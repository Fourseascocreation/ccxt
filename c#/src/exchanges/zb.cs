using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class zb : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "zb" },
            { "name", "ZB" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 6 },
            { "version", "v1" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", null },
                { "option", null },
                { "addMargin", true },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createMarketOrder", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "5d", "5d" },
                { "1w", "1w" },
            } },
            { "hostname", "zb.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "v1", new Dictionary<string, object>() {
                            { "public", "https://api.{hostname}/data" },
                            { "private", "https://trade.{hostname}/api" },
                        } },
                    } },
                    { "contract", new Dictionary<string, object>() {
                        { "v1", new Dictionary<string, object>() {
                            { "public", "https://fapi.{hostname}/api/public" },
                        } },
                        { "v2", new Dictionary<string, object>() {
                            { "public", "https://fapi.{hostname}/Server/api" },
                            { "private", "https://fapi.{hostname}/Server/api" },
                        } },
                    } },
                } },
                { "www", "https://www.zb.com" },
                { "doc", "https://www.zb.com/i/developer" },
                { "fees", "https://www.zb.com/i/rate" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.zb.com/en/register?ref=4301lera" },
                    { "discount", 0.16 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "markets", 16.667 },
                                { "ticker", 16.667 },
                                { "allTicker", 16.667 },
                                { "depth", 16.667 },
                                { "trades", 16.667 },
                                { "kline", 166.667 },
                                { "getGroupMarkets", 16.667 },
                                { "getFeeInfo", 16.667 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "order", 1 },
                                { "orderMoreV2", 1 },
                                { "cancelOrder", 1 },
                                { "cancelAllOrdersAfter", 1 },
                                { "getOrder", 1 },
                                { "getOrders", 1 },
                                { "getOrdersNew", 16.667 },
                                { "getOrdersIgnoreTradeType", 1 },
                                { "getUnfinishedOrdersIgnoreTradeType", 1 },
                                { "getFinishedAndPartialOrders", 1 },
                                { "getAccountInfo", 16.667 },
                                { "getUserAddress", 16.667 },
                                { "getPayinAddress", 16.667 },
                                { "getWithdrawAddress", 16.667 },
                                { "getWithdrawRecord", 16.667 },
                                { "getChargeRecord", 16.667 },
                                { "getCnyWithdrawRecord", 16.667 },
                                { "getCnyChargeRecord", 16.667 },
                                { "withdraw", 16.667 },
                                { "addSubUser", 16.667 },
                                { "getSubUserList", 16.667 },
                                { "doTransferFunds", 16.667 },
                                { "createSubUserKey", 16.667 },
                                { "getLeverAssetsInfo", 16.667 },
                                { "getLeverBills", 16.667 },
                                { "transferInLever", 16.667 },
                                { "transferOutLever", 16.667 },
                                { "loan", 16.667 },
                                { "cancelLoan", 16.667 },
                                { "getLoans", 16.667 },
                                { "getLoanRecords", 16.667 },
                                { "borrow", 16.667 },
                                { "autoBorrow", 16.667 },
                                { "repay", 16.667 },
                                { "doAllRepay", 16.667 },
                                { "getRepayments", 16.667 },
                                { "getFinanceRecords", 16.667 },
                                { "changeInvestMark", 16.667 },
                                { "changeLoop", 16.667 },
                                { "getCrossAssets", 16.667 },
                                { "getCrossBills", 16.667 },
                                { "transferInCross", 16.667 },
                                { "transferOutCross", 16.667 },
                                { "doCrossLoan", 16.667 },
                                { "doCrossRepay", 16.667 },
                                { "getCrossRepayRecords", 16.667 },
                            } },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "depth", 16.667 },
                                { "fundingRate", 16.667 },
                                { "indexKline", 16.667 },
                                { "indexPrice", 16.667 },
                                { "kline", 16.667 },
                                { "markKline", 16.667 },
                                { "markPrice", 16.667 },
                                { "ticker", 16.667 },
                                { "trade", 16.667 },
                            } },
                        } },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "allForceOrders", 3.334 },
                                { "config/marketList", 3.334 },
                                { "topLongShortAccountRatio", 3.334 },
                                { "topLongShortPositionRatio", 3.334 },
                                { "fundingRate", 3.334 },
                                { "premiumIndex", 3.334 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "Fund/balance", 3.334 },
                                { "Fund/getAccount", 3.334 },
                                { "Fund/getBill", 3.334 },
                                { "Fund/getBillTypeList", 3.334 },
                                { "Fund/marginHistory", 3.334 },
                                { "Positions/getPositions", 3.334 },
                                { "Positions/getNominalValue", 3.334 },
                                { "Positions/marginInfo", 3.334 },
                                { "setting/get", 3.334 },
                                { "trade/getAllOrders", 3.334 },
                                { "trade/getOrder", 3.334 },
                                { "trade/getOrderAlgos", 3.334 },
                                { "trade/getTradeList", 3.334 },
                                { "trade/getUndoneOrders", 3.334 },
                                { "trade/tradeHistory", 3.334 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "activity/buyTicket", 3.334 },
                                { "Fund/transferFund", 3.334 },
                                { "Positions/setMarginCoins", 3.334 },
                                { "Positions/updateAppendUSDValue", 3.334 },
                                { "Positions/updateMargin", 3.334 },
                                { "setting/setLeverage", 3.334 },
                                { "setting/setPositionsMode", 3.334 },
                                { "trade/batchOrder", 3.334 },
                                { "trade/batchCancelOrder", 3.334 },
                                { "trade/cancelAlgos", 3.334 },
                                { "trade/cancelAllOrders", 3.334 },
                                { "trade/cancelOrder", 3.334 },
                                { "trade/order", 3.334 },
                                { "trade/orderAlgo", 3.334 },
                                { "trade/updateOrderAlgo", 3.334 },
                            } },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {} },
                } },
                { "trading", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "ANG", "Anagram" },
                { "ENT", "ENTCash" },
                { "BCHABC", "BCHABC" },
                { "BCHSV", "BCHSV" },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "3m", "3min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "1hour" },
                        { "2h", "2hour" },
                        { "4h", "4hour" },
                        { "6h", "6hour" },
                        { "12h", "12hour" },
                        { "1d", "1day" },
                        { "3d", "3day" },
                        { "1w", "1week" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "1M" },
                        { "5m", "5M" },
                        { "15m", "15M" },
                        { "30m", "30M" },
                        { "1h", "1H" },
                        { "6h", "6H" },
                        { "1d", "1D" },
                        { "5d", "5D" },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "1001", typeof(ExchangeError) },
                    { "1002", typeof(ExchangeError) },
                    { "1003", typeof(AuthenticationError) },
                    { "1004", typeof(AuthenticationError) },
                    { "1005", typeof(AuthenticationError) },
                    { "1006", typeof(PermissionDenied) },
                    { "1007", typeof(ExchangeError) },
                    { "1009", typeof(OnMaintenance) },
                    { "1010", typeof(ExchangeNotAvailable) },
                    { "1012", typeof(PermissionDenied) },
                    { "1013", typeof(ExchangeError) },
                    { "1014", typeof(ExchangeError) },
                    { "2001", typeof(InsufficientFunds) },
                    { "2002", typeof(InsufficientFunds) },
                    { "2003", typeof(InsufficientFunds) },
                    { "2005", typeof(InsufficientFunds) },
                    { "2006", typeof(InsufficientFunds) },
                    { "2007", typeof(InsufficientFunds) },
                    { "2008", typeof(InsufficientFunds) },
                    { "2009", typeof(InsufficientFunds) },
                    { "3001", typeof(OrderNotFound) },
                    { "3002", typeof(InvalidOrder) },
                    { "3003", typeof(InvalidOrder) },
                    { "3004", typeof(AuthenticationError) },
                    { "3005", typeof(BadRequest) },
                    { "3006", typeof(PermissionDenied) },
                    { "3007", typeof(RequestTimeout) },
                    { "3008", typeof(ExchangeError) },
                    { "3009", typeof(InvalidOrder) },
                    { "3010", typeof(PermissionDenied) },
                    { "3011", typeof(InvalidOrder) },
                    { "3012", typeof(InvalidOrder) },
                    { "4001", typeof(AccountSuspended) },
                    { "4002", typeof(RateLimitExceeded) },
                } },
                { "exact", new Dictionary<string, object>() {
                    { "10001", typeof(ExchangeError) },
                    { "10002", typeof(PermissionDenied) },
                    { "10003", typeof(BadResponse) },
                    { "10004", typeof(BadResponse) },
                    { "10005", typeof(PermissionDenied) },
                    { "10006", typeof(BadRequest) },
                    { "10007", typeof(ExchangeError) },
                    { "10008", typeof(ExchangeError) },
                    { "10009", typeof(ExchangeError) },
                    { "1001", typeof(ExchangeError) },
                    { "10010", typeof(AuthenticationError) },
                    { "10011", typeof(AuthenticationError) },
                    { "10012", typeof(AccountSuspended) },
                    { "10013", typeof(AuthenticationError) },
                    { "10014", typeof(AuthenticationError) },
                    { "10015", typeof(AuthenticationError) },
                    { "10016", typeof(AuthenticationError) },
                    { "10017", typeof(PermissionDenied) },
                    { "10018", typeof(AccountSuspended) },
                    { "10019", typeof(RequestTimeout) },
                    { "1002", typeof(ExchangeError) },
                    { "10020", typeof(BadRequest) },
                    { "10021", typeof(BadRequest) },
                    { "10022", typeof(BadRequest) },
                    { "10023", typeof(RateLimitExceeded) },
                    { "10024", typeof(AuthenticationError) },
                    { "10025", typeof(ExchangeError) },
                    { "10026", typeof(NetworkError) },
                    { "10027", typeof(RequestTimeout) },
                    { "10028", typeof(ExchangeNotAvailable) },
                    { "10029", typeof(DDoSProtection) },
                    { "1003", typeof(AuthenticationError) },
                    { "10030", typeof(BadRequest) },
                    { "10031", typeof(BadRequest) },
                    { "10032", typeof(BadRequest) },
                    { "10033", typeof(BadRequest) },
                    { "10034", typeof(BadRequest) },
                    { "10035", typeof(BadRequest) },
                    { "10036", typeof(BadRequest) },
                    { "10037", typeof(ArgumentsRequired) },
                    { "10038", typeof(BadRequest) },
                    { "10039", typeof(BadResponse) },
                    { "1004", typeof(AuthenticationError) },
                    { "10040", typeof(BadResponse) },
                    { "10041", typeof(BadResponse) },
                    { "10042", typeof(ExchangeError) },
                    { "10043", typeof(ExchangeError) },
                    { "10044", typeof(ExchangeError) },
                    { "10045", typeof(ExchangeError) },
                    { "10046", typeof(ExchangeError) },
                    { "10047", typeof(ExchangeError) },
                    { "10048", typeof(ExchangeError) },
                    { "10049", typeof(NetworkError) },
                    { "1005", typeof(AuthenticationError) },
                    { "1006", typeof(AuthenticationError) },
                    { "1009", typeof(ExchangeNotAvailable) },
                    { "1010", typeof(ExchangeNotAvailable) },
                    { "10100", typeof(OnMaintenance) },
                    { "1012", typeof(PermissionDenied) },
                    { "1013", typeof(ExchangeError) },
                    { "1014", typeof(ExchangeError) },
                    { "11000", typeof(ExchangeError) },
                    { "11001", typeof(ExchangeError) },
                    { "110011", typeof(ExchangeError) },
                    { "11002", typeof(ExchangeError) },
                    { "11003", typeof(ExchangeError) },
                    { "11004", typeof(InsufficientFunds) },
                    { "11005", typeof(InvalidOrder) },
                    { "11006", typeof(InsufficientFunds) },
                    { "11007", typeof(OrderNotFound) },
                    { "11008", typeof(ExchangeError) },
                    { "11009", typeof(ExchangeError) },
                    { "110110", typeof(ExchangeError) },
                    { "11012", typeof(InsufficientFunds) },
                    { "11013", typeof(ExchangeError) },
                    { "11014", typeof(ExchangeError) },
                    { "11015", typeof(AuthenticationError) },
                    { "11016", typeof(AuthenticationError) },
                    { "11017", typeof(ExchangeError) },
                    { "11018", typeof(InsufficientFunds) },
                    { "11019", typeof(ExchangeError) },
                    { "11021", typeof(InsufficientFunds) },
                    { "11023", typeof(ExchangeError) },
                    { "11030", typeof(PermissionDenied) },
                    { "11031", typeof(ExchangeError) },
                    { "11032", typeof(ExchangeError) },
                    { "11033", typeof(ArgumentsRequired) },
                    { "11034", typeof(ExchangeError) },
                    { "12000", typeof(InvalidOrder) },
                    { "12001", typeof(InvalidOrder) },
                    { "12002", typeof(InvalidOrder) },
                    { "12003", typeof(InvalidOrder) },
                    { "12004", typeof(InvalidOrder) },
                    { "12005", typeof(InvalidOrder) },
                    { "12006", typeof(InvalidOrder) },
                    { "12007", typeof(InvalidOrder) },
                    { "12008", typeof(InvalidOrder) },
                    { "12009", typeof(InvalidOrder) },
                    { "12010", typeof(InvalidOrder) },
                    { "12011", typeof(InvalidOrder) },
                    { "12012", typeof(OrderNotFound) },
                    { "12013", typeof(InvalidOrder) },
                    { "12014", typeof(InvalidOrder) },
                    { "12015", typeof(InvalidOrder) },
                    { "12016", typeof(InvalidOrder) },
                    { "12017", typeof(InvalidOrder) },
                    { "12018", typeof(InvalidOrder) },
                    { "12019", typeof(ArgumentsRequired) },
                    { "12020", typeof(ExchangeError) },
                    { "12021", typeof(InvalidOrder) },
                    { "12022", typeof(InvalidOrder) },
                    { "12023", typeof(OrderNotFound) },
                    { "12024", typeof(InvalidOrder) },
                    { "12025", typeof(InvalidOrder) },
                    { "12026", typeof(DuplicateOrderId) },
                    { "12027", typeof(ExchangeNotAvailable) },
                    { "12028", typeof(InvalidOrder) },
                    { "12029", typeof(InvalidOrder) },
                    { "12201", typeof(InvalidOrder) },
                    { "12202", typeof(InvalidOrder) },
                    { "12203", typeof(InvalidOrder) },
                    { "12204", typeof(InvalidOrder) },
                    { "12205", typeof(InvalidOrder) },
                    { "12206", typeof(InvalidOrder) },
                    { "12207", typeof(RateLimitExceeded) },
                    { "13001", typeof(AuthenticationError) },
                    { "13002", typeof(PermissionDenied) },
                    { "13003", typeof(InvalidOrder) },
                    { "13004", typeof(InvalidOrder) },
                    { "13005", typeof(RateLimitExceeded) },
                    { "13006", typeof(ExchangeError) },
                    { "13007", typeof(ExchangeError) },
                    { "13008", typeof(ExchangeError) },
                    { "13009", typeof(ExchangeError) },
                    { "14000", typeof(ExchangeError) },
                    { "14001", typeof(AuthenticationError) },
                    { "14002", typeof(AuthenticationError) },
                    { "14003", typeof(ExchangeError) },
                    { "14100", typeof(ExchangeError) },
                    { "14101", typeof(RateLimitExceeded) },
                    { "14200", typeof(ArgumentsRequired) },
                    { "14300", typeof(ExchangeError) },
                    { "14301", typeof(ExchangeError) },
                    { "14302", typeof(ExchangeError) },
                    { "14303", typeof(ExchangeError) },
                    { "14305", typeof(ExchangeError) },
                    { "14306", typeof(ExchangeError) },
                    { "14307", typeof(InvalidOrder) },
                    { "14308", typeof(InvalidOrder) },
                    { "14309", typeof(ExchangeError) },
                    { "14310", typeof(NotSupported) },
                    { "14311", typeof(NotSupported) },
                    { "14312", typeof(ExchangeError) },
                    { "14313", typeof(PermissionDenied) },
                    { "14314", typeof(ExchangeError) },
                    { "2001", typeof(InsufficientFunds) },
                    { "2002", typeof(InsufficientFunds) },
                    { "2003", typeof(InsufficientFunds) },
                    { "2005", typeof(InsufficientFunds) },
                    { "2006", typeof(InsufficientFunds) },
                    { "2007", typeof(InsufficientFunds) },
                    { "2008", typeof(InsufficientFunds) },
                    { "2009", typeof(InsufficientFunds) },
                    { "3001", typeof(OrderNotFound) },
                    { "3002", typeof(InvalidOrder) },
                    { "3003", typeof(InvalidOrder) },
                    { "3004", typeof(AuthenticationError) },
                    { "3005", typeof(BadRequest) },
                    { "3006", typeof(AuthenticationError) },
                    { "3007", typeof(AuthenticationError) },
                    { "3008", typeof(OrderNotFound) },
                    { "3009", typeof(InvalidOrder) },
                    { "3010", typeof(PermissionDenied) },
                    { "3011", typeof(InvalidOrder) },
                    { "3012", typeof(InvalidOrder) },
                    { "4001", typeof(ExchangeNotAvailable) },
                    { "4002", typeof(RateLimitExceeded) },
                    { "9999", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "提币地址有误, 请先添加提币地址。", typeof(InvalidAddress) },
                    { "资金不足,无法划账", typeof(InsufficientFunds) },
                    { "响应超时", typeof(RequestTimeout) },
                } },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchMarkets
        * @description retrieves data on all markets for zb
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        //
        //     {
        //         "zb_qc":{
        //             "amountScale":2,
        //             "minAmount":0.01,
        //             "minSize":5,
        //             "priceScale":4,
        //         },
        //     }
        //
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object> {this.spotV1PublicGetMarkets(parameters), this.contractV2PublicGetConfigMarketList(parameters)};
        promises = await promiseAll(promises);
        object markets = getValue(promises, 0);
        object contracts = getValue(promises, 1);
        //
        //     {
        //         BTC_USDT: {
        //             symbol: 'BTC_USDT',
        //             buyerCurrencyId: '6',
        //             contractType: '1',
        //             defaultMarginMode: '1',
        //             marketType: '2',
        //             historyDBName: 'trade_history_readonly.dbc',
        //             defaultLeverage: '20',
        //             id: '100',
        //             canCancelOrder: true,
        //             area: '1',
        //             mixMarginCoinName: 'usdt',
        //             fundingRateRatio: '0.25',
        //             marginCurrencyName: 'usdt',
        //             minTradeMoney: '0.0001',
        //             enableTime: '1638954000000',
        //             maxTradeMoney: '10000000',
        //             canTrade: true,
        //             maxLeverage: '125',
        //             defaultPositionsMode: '2',
        //             onlyWhitelistVisible: false,
        //             riskWarnRatio: '0.8',
        //             marginDecimal: '8',
        //             spot: false,
        //             status: '1',
        //             amountDecimal: '3',
        //             leverage: false,
        //             minAmount: '0.001',
        //             canOrder: true,
        //             duration: '1',
        //             feeDecimal: '8',
        //             sellerCurrencyId: '1',
        //             maxAmount: '1000',
        //             canOpenPosition: true,
        //             isSupportMixMargin: false,
        //             markPriceLimitRate: '0.05',
        //             marginCurrencyId: '6',
        //             stopFundingFee: false,
        //             priceDecimal: '2',
        //             lightenUpFeeRate: '0',
        //             futures: true,
        //             sellerCurrencyName: 'btc',
        //             marketPriceLimitRate: '0.05',
        //             canRebate: true,
        //             marketName: 'BTC_USDT',
        //             depth: [ 0.01, 0.1, 1 ],
        //             createTime: '1607590430094',
        //             mixMarginCoinIds: [ 6 ],
        //             buyerCurrencyName: 'usdt',
        //             stopService: false
        //         },
        //     }
        //
        object contractsData = this.safeValue(contracts, "data", new List<object>() {});
        object contractsById = this.indexBy(contractsData, "marketName");
        object dataById = this.deepExtend(contractsById, markets);
        object keys = new List<string>(((Dictionary<string,object>)dataById).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object id = getValue(keys, i);
            object market = getValue(dataById, id);
            var baseIdquoteIdVariable = ((string)id).Split((string)"_").ToList<object>();
            var baseId = ((List<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((List<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = this.safeValue(market, "marginCurrencyName");
            object settle = this.safeCurrencyCode(settleId);
            object spot = isEqual(settle, null);
            object swap = this.safeValue(market, "futures", false);
            object linear = ((bool) isTrue(swap)) ? true : null;
            object active = true;
            object symbol = add(add(bs, "/"), quote);
            if (isTrue(swap))
            {
                object status = this.safeString(market, "status");
                active = (isEqual(status, "1"));
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            }
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", ((bool) isTrue(swap)) ? "swap" : "spot" },
                { "spot", spot },
                { "margin", false },
                { "swap", swap },
                { "future", false },
                { "option", false },
                { "active", active },
                { "contract", swap },
                { "linear", linear },
                { "inverse", ((bool) isTrue(swap)) ? !isTrue(linear) : null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString2(market, "amountScale", "amountDecimal"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString2(market, "priceScale", "priceDecimal"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", this.safeNumber(market, "maxLeverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minAmount") },
                        { "max", this.safeNumber(market, "maxAmount") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber2(market, "minSize", "minTradeMoney") },
                        { "max", this.safeNumber(market, "maxTradeMoney") },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.spotV1PublicGetGetFeeInfo(parameters);
        //
        //     {
        //         "code":1000,
        //         "message":"success",
        //         "result":{
        //             "USDT":[
        //                 {
        //                     "chainName":"TRC20",
        //                     "canWithdraw":true,
        //                     "fee":1.0,
        //                     "mainChainName":"TRX",
        //                     "canDeposit":true
        //                 },
        //                 {
        //                     "chainName":"OMNI",
        //                     "canWithdraw":true,
        //                     "fee":5.0,
        //                     "mainChainName":"BTC",
        //                     "canDeposit":true
        //                 },
        //                 {
        //                     "chainName":"ERC20",
        //                     "canWithdraw":true,
        //                     "fee":15.0,
        //                     "mainChainName":"ETH",
        //                     "canDeposit":true
        //                 }
        //             ],
        //         }
        //     }
        //
        object currencies = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ids = new List<string>(((Dictionary<string,object>)currencies).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object currency = getValue(currencies, id);
            object code = this.safeCurrencyCode(id);
            object isWithdrawEnabled = true;
            object isDepositEnabled = true;
            object fees = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(currency)); postFixIncrement(ref j))
            {
                object networkItem = getValue(currency, j);
                object network = this.safeString(networkItem, "chainName");
                // const name = this.safeString (networkItem, 'name');
                object withdrawFee = this.safeNumber(networkItem, "fee");
                object depositEnable = this.safeValue(networkItem, "canDeposit");
                object withdrawEnable = this.safeValue(networkItem, "canWithdraw");
                isDepositEnabled = isTrue(isDepositEnabled) || isTrue(depositEnable);
                isWithdrawEnabled = isTrue(isWithdrawEnabled) || isTrue(withdrawEnable);
                ((Dictionary<string, object>)fees)[(string)network] = withdrawFee;
            }
            object active = (isTrue(isWithdrawEnabled) && isTrue(isDepositEnabled));
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", null },
                { "code", code },
                { "precision", null },
                { "info", currency },
                { "active", active },
                { "deposit", isDepositEnabled },
                { "withdraw", isWithdrawEnabled },
                { "fee", null },
                { "fees", fees },
                { "limits", this.limits },
            };
        }
        return result;
    }

    public virtual object parseBalance(object response)
    {
        object balances = this.safeValue(getValue(response, "result"), "coins");
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            //     {        enName: "BTC",
            //               freez: "0.00000000",
            //         unitDecimal:  8, // always 8
            //              cnName: "BTC",
            //       isCanRecharge:  true, // TODO: should use this
            //             unitTag: "฿",
            //       isCanWithdraw:  true,  // TODO: should use this
            //           available: "0.00000000",
            //                 key: "btc"         }
            object account = this.account();
            object currencyId = this.safeString(balance, "key");
            object code = this.safeCurrencyCode(currencyId);
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "available");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "freez");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseSwapBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            //
            //     {
            //         "userId": "6896693805014120448",
            //         "currencyId": "6",
            //         "currencyName": "usdt",
            //         "amount": "30.56585118",
            //         "freezeAmount": "0",
            //         "contractType": 1,
            //         "id": "6899113714763638819",
            //         "createTime": "1644876888934",
            //         "modifyTime": "1645787446037",
            //         "accountBalance": "30.56585118",
            //         "allMargin": "0",
            //         "allowTransferOutAmount": "30.56585118"
            //     },
            //
            object code = this.safeCurrencyCode(this.safeString(balance, "currencyName"));
            object account = this.account();
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "accountBalance");
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "allowTransferOutAmount");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "freezeAmount");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseMarginBalance(object response, object marginMode)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object levers = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            object message = this.safeValue(response, "message", new Dictionary<string, object>() {});
            object data = this.safeValue(message, "datas", new Dictionary<string, object>() {});
            levers = this.safeValue(data, "levers", new List<object>() {});
        } else
        {
            object crossResponse = this.safeValue(response, "result", new Dictionary<string, object>() {});
            levers = this.safeValue(crossResponse, "list", new List<object>() {});
        }
        for (object i = 0; isLessThan(i, getArrayLength(levers)); postFixIncrement(ref i))
        {
            object balance = getValue(levers, i);
            //
            // Isolated Margin
            //
            //     {
            //         "cNetUSD": "0.00",
            //         "repayLeverShow": "-",
            //         "cCanLoanIn": "0.002115400000000",
            //         "fNetCNY": "147.76081161",
            //         "fLoanIn": "0.00",
            //         "repayLevel": 0,
            //         "level": 1,
            //         "netConvertCNY": "147.760811613032",
            //         "cFreeze": "0.00",
            //         "cUnitTag": "BTC",
            //         "version": 1646783178609,
            //         "cAvailableUSD": "0.00",
            //         "cNetCNY": "0.00",
            //         "riskRate": "-",
            //         "fAvailableUSD": "20.49273433",
            //         "fNetUSD": "20.49273432",
            //         "cShowName": "BTC",
            //         "leverMultiple": "5.00",
            //         "couldTransferOutFiat": "20.49273433",
            //         "noticeLine": "1.13",
            //         "fFreeze": "0.00",
            //         "cUnitDecimal": 8,
            //         "fCanLoanIn": "81.970937320000000",
            //         "cAvailable": "0.00",
            //         "repayLock": false,
            //         "status": 1,
            //         "forbidType": 0,
            //         "totalConvertCNY": "147.760811613032",
            //         "cAvailableCNY": "0.00",
            //         "unwindPrice": "0.00",
            //         "fOverdraft": "0.00",
            //         "fShowName": "USDT",
            //         "statusShow": "%E6%AD%A3%E5%B8%B8",
            //         "cOverdraft": "0.00",
            //         "netConvertUSD": "20.49273433",
            //         "cNetBtc": "0.00",
            //         "loanInConvertCNY": "0.00",
            //         "fAvailableCNY": "147.760811613032",
            //         "key": "btcusdt",
            //         "fNetBtc": "0.0005291",
            //         "fUnitDecimal": 8,
            //         "loanInConvertUSD": "0.00",
            //         "showName": "BTC/USDT",
            //         "startLine": "1.25",
            //         "totalConvertUSD": "20.49273433",
            //         "couldTransferOutCoin": "0.00",
            //         "cEnName": "BTC",
            //         "leverMultipleInterest": "3.00",
            //         "fAvailable": "20.49273433",
            //         "fEnName": "USDT",
            //         "forceRepayLine": "1.08",
            //         "cLoanIn": "0.00"
            //     }
            //
            // Cross Margin
            //
            //     [
            //         {
            //             "fundType": 2,
            //             "loanIn": 0,
            //             "amount": 0,
            //             "freeze": 0,
            //             "overdraft": 0,
            //             "key": "BTC",
            //             "canTransferOut": 0
            //         },
            //     ],
            //
            object account = this.account();
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                object code = this.safeCurrencyCode(this.safeString(balance, "fShowName"));
                ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "fAvailableUSD"); // total amount in USD
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "couldTransferOutFiat");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "fFreeze");
                ((Dictionary<string, object>)result)[(string)code] = account;
            } else
            {
                object code = this.safeCurrencyCode(this.safeString(balance, "key"));
                ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "amount");
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "canTransferOut");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "freeze");
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the zb api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypemarketTypeQueryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((List<object>) marketTypemarketTypeQueryVariable)[0];
        var marketTypeQuery = ((List<object>) marketTypemarketTypeQueryVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", marketTypeQuery);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object swap = (isEqual(marketType, "swap"));
        object marginMethod = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "spotV1PrivateGetGetCrossAssets" : "spotV1PrivateGetGetLeverAssetsInfo";
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetGetAccountInfo" },
            { "swap", "contractV2PrivateGetFundBalance" },
            { "margin", marginMethod },
        });
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            method = "spotV1PrivateGetGetLeverAssetsInfo";
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            method = "spotV1PrivateGetGetCrossAssets";
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(swap))
        {
            ((Dictionary<string, object>)request)["futuresAccountType"] = 1;
        }
        object response = await this.callAsync(method, this.extend(request, query));
        //
        // Spot
        //
        //     {
        //         "result": {
        //             "coins": [
        //                 {
        //                     "isCanWithdraw": "true",
        //                     "canLoan": false,
        //                     "fundstype": 51,
        //                     "showName": "ZB",
        //                     "isCanRecharge": "true",
        //                     "cnName": "ZB",
        //                     "enName": "ZB",
        //                     "available": "0",
        //                     "freez": "0",
        //                     "unitTag": "ZB",
        //                     "key": "zb",
        //                     "unitDecimal": 8
        //                 },
        //             ],
        //             "version": 1645856691340,
        //             "base": {
        //                 "auth_google_enabled": true,
        //                 "auth_mobile_enabled": false,
        //                 "trade_password_enabled": true,
        //                 "username": "blank@gmail.com"
        //             }
        //         },
        //         "leverPerm": true,
        //         "otcPerm": false,
        //         "assetPerm": true,
        //         "moneyPerm": true,
        //         "subUserPerm": true,
        //         "entrustPerm": true
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "userId": "6896693805014120448",
        //                 "currencyId": "6",
        //                 "currencyName": "usdt",
        //                 "amount": "30.56585118",
        //                 "freezeAmount": "0",
        //                 "contractType": 1,
        //                 "id": "6899113714763638819",
        //                 "createTime": "1644876888934",
        //                 "modifyTime": "1645787446037",
        //                 "accountBalance": "30.56585118",
        //                 "allMargin": "0",
        //                 "allowTransferOutAmount": "30.56585118"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        // Isolated Margin
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "leverPerm": true,
        //                 "levers": [
        //                     {
        //                         "cNetUSD": "0.00",
        //                         "repayLeverShow": "-",
        //                         "cCanLoanIn": "0.002115400000000",
        //                         "fNetCNY": "147.76081161",
        //                         "fLoanIn": "0.00",
        //                         "repayLevel": 0,
        //                         "level": 1,
        //                         "netConvertCNY": "147.760811613032",
        //                         "cFreeze": "0.00",
        //                         "cUnitTag": "BTC",
        //                         "version": 1646783178609,
        //                         "cAvailableUSD": "0.00",
        //                         "cNetCNY": "0.00",
        //                         "riskRate": "-",
        //                         "fAvailableUSD": "20.49273433",
        //                         "fNetUSD": "20.49273432",
        //                         "cShowName": "BTC",
        //                         "leverMultiple": "5.00",
        //                         "couldTransferOutFiat": "20.49273433",
        //                         "noticeLine": "1.13",
        //                         "fFreeze": "0.00",
        //                         "cUnitDecimal": 8,
        //                         "fCanLoanIn": "81.970937320000000",
        //                         "cAvailable": "0.00",
        //                         "repayLock": false,
        //                         "status": 1,
        //                         "forbidType": 0,
        //                         "totalConvertCNY": "147.760811613032",
        //                         "cAvailableCNY": "0.00",
        //                         "unwindPrice": "0.00",
        //                         "fOverdraft": "0.00",
        //                         "fShowName": "USDT",
        //                         "statusShow": "%E6%AD%A3%E5%B8%B8",
        //                         "cOverdraft": "0.00",
        //                         "netConvertUSD": "20.49273433",
        //                         "cNetBtc": "0.00",
        //                         "loanInConvertCNY": "0.00",
        //                         "fAvailableCNY": "147.760811613032",
        //                         "key": "btcusdt",
        //                         "fNetBtc": "0.0005291",
        //                         "fUnitDecimal": 8,
        //                         "loanInConvertUSD": "0.00",
        //                         "showName": "BTC/USDT",
        //                         "startLine": "1.25",
        //                         "totalConvertUSD": "20.49273433",
        //                         "couldTransferOutCoin": "0.00",
        //                         "cEnName": "BTC",
        //                         "leverMultipleInterest": "3.00",
        //                         "fAvailable": "20.49273433",
        //                         "fEnName": "USDT",
        //                         "forceRepayLine": "1.08",
        //                         "cLoanIn": "0.00"
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        //
        // Cross Margin
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功",
        //         "result": {
        //             "loanIn": 0,
        //             "total": 71.167,
        //             "riskRate": "-",
        //             "list" :[
        //                 {
        //                     "fundType": 2,
        //                     "loanIn": 0,
        //                     "amount": 0,
        //                     "freeze": 0,
        //                     "overdraft": 0,
        //                     "key": "BTC",
        //                     "canTransferOut": 0
        //                 },
        //             ],
        //             "net": 71.167
        //         }
        //     }
        //
        // todo: use this somehow
        // let permissions = response['result']['base'];
        if (isTrue(swap))
        {
            return this.parseSwapBalance(response);
        } else if (isTrue(!isEqual(marginMode, null)))
        {
            return this.parseMarginBalance(response, marginMode);
        } else
        {
            return this.parseBalance(response);
        }
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        // fetchDepositAddress
        //
        //     {
        //         "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //     }
        //
        // fetchDepositAddresses
        //
        //     {
        //         "blockChain": "btc",
        //         "isUseMemo": false,
        //         "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //         "canWithdraw": true,
        //         "canDeposit": true
        //     }
        //     {
        //         "blockChain": "bts",
        //         "isUseMemo": true,
        //         "account": "btstest",
        //         "memo": "123",
        //         "canWithdraw": true,
        //         "canDeposit": true
        //     }
        //
        object address = this.safeString2(depositAddress, "key", "address");
        object tag = null;
        object memo = this.safeString(depositAddress, "memo");
        if (isTrue(!isEqual(memo, null)))
        {
            tag = memo;
        } else if (isTrue(isGreaterThanOrEqual(getIndexOf(address, "_"), 0)))
        {
            object parts = ((string)address).Split((string)"_").ToList<object>();
            address = getValue(parts, 0); // WARNING: MAY BE tag_address INSTEAD OF address_tag FOR SOME CURRENCIES!!
            tag = getValue(parts, 1);
        }
        this.checkAddress(address);
        object currencyId = this.safeString(depositAddress, "blockChain");
        object code = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotV1PrivateGetGetPayinAddress(parameters);
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": [
        //                 {
        //                     "blockChain": "btc",
        //                     "isUseMemo": false,
        //                     "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //                     "canWithdraw": true,
        //                     "canDeposit": true
        //                 },
        //                 {
        //                     "blockChain": "bts",
        //                     "isUseMemo": true,
        //                     "account": "btstest",
        //                     "memo": "123",
        //                     "canWithdraw": true,
        //                     "canDeposit": true
        //                 },
        //             ]
        //         }
        //     }
        //
        object message = this.safeValue(response, "message", new Dictionary<string, object>() {});
        object datas = this.safeValue(message, "datas", new List<object>() {});
        return this.parseDepositAddresses(datas, codes);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.spotV1PrivateGetGetUserAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //             }
        //         }
        //     }
        //
        object message = this.safeValue(response, "message", new Dictionary<string, object>() {});
        object datas = this.safeValue(message, "datas", new Dictionary<string, object>() {});
        return this.parseDepositAddress(datas, currency);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object marketIdField = ((bool) isTrue(getValue(market, "swap"))) ? "symbol" : "market";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PublicGetDepth" },
            { "swap", "contractV1PublicGetDepth" },
        });
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     {
        //         "asks":[
        //             [35000.0,0.2741],
        //             [34949.0,0.0173],
        //             [34900.0,0.5004],
        //         ],
        //         "bids":[
        //             [34119.32,0.0030],
        //             [34107.83,0.1500],
        //             [34104.42,0.1500],
        //         ],
        //         "timestamp":1624536510
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "asks": [
        //                 [43416.6,0.02],
        //                 [43418.25,0.04],
        //                 [43425.82,0.02]
        //             ],
        //             "bids": [
        //                 [43414.61,0.1],
        //                 [43414.18,0.04],
        //                 [43413.03,0.05]
        //             ],
        //             "time": 1645087743071
        //         }
        //     }
        //
        object result = null;
        object timestamp = null;
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            result = this.safeValue(response, "data");
            timestamp = this.safeInteger(result, "time");
        } else
        {
            result = response;
            timestamp = this.safeTimestamp(response, "timestamp");
        }
        return this.parseOrderBook(result, symbol, timestamp);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.spotV1PublicGetAllTicker(parameters);
        object result = new Dictionary<string, object>() {};
        object marketsByIdWithoutUnderscore = new Dictionary<string, object>() {};
        object marketIds = this.ids;
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object tickerId = ((string)marketId).Replace((string)"_", (string)"");
            ((Dictionary<string, object>)marketsByIdWithoutUnderscore)[(string)tickerId] = marketId;
        }
        object ids = new List<string>(((Dictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object marketId = this.safeValue(marketsByIdWithoutUnderscore, getValue(ids, i));
            object market = this.safeMarket(marketId, null, "_");
            if (isTrue(!isEqual(market, null)))
            {
                object symbol = getValue(market, "symbol");
                object ticker = this.safeValue(response, getValue(ids, i));
                if (isTrue(!isEqual(ticker, null)))
                {
                    ((Dictionary<string, object>)result)[(string)symbol] = this.parseTicker(ticker, market);
                }
            }
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object marketIdField = ((bool) isTrue(getValue(market, "swap"))) ? "symbol" : "market";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PublicGetTicker" },
            { "swap", "contractV1PublicGetTicker" },
        });
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587",
        //         "ticker":{
        //             "high":"33298.38",
        //             "vol":"56152.9012",
        //             "last":"32578.55",
        //             "low":"28808.19",
        //             "buy":"32572.68",
        //             "sell":"32615.37",
        //             "turnover":"1764201303.6100",
        //             "open":"31664.85",
        //             "riseRate":"2.89"
        //         }
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "BTC_USDT": [44053.47,44357.77,42911.54,43297.79,53471.264,-1.72,1645093002,302201.255084]
        //         }
        //     }
        //
        object ticker = null;
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            ticker = new Dictionary<string, object>() {};
            object data = this.safeValue(response, "data");
            object values = this.safeValue(data, getValue(market, "id"), new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(values)); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)ticker)["open"] = this.safeValue(values, 0);
                ((Dictionary<string, object>)ticker)["high"] = this.safeValue(values, 1);
                ((Dictionary<string, object>)ticker)["low"] = this.safeValue(values, 2);
                ((Dictionary<string, object>)ticker)["last"] = this.safeValue(values, 3);
                ((Dictionary<string, object>)ticker)["vol"] = this.safeValue(values, 4);
                ((Dictionary<string, object>)ticker)["riseRate"] = this.safeValue(values, 5);
            }
        } else
        {
            ticker = this.safeValue(response, "ticker", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)ticker)["date"] = this.safeValue(response, "date");
        }
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587", // injected from outside
        //         "high":"33298.38",
        //         "vol":"56152.9012",
        //         "last":"32578.55",
        //         "low":"28808.19",
        //         "buy":"32572.68",
        //         "sell":"32615.37",
        //         "turnover":"1764201303.6100",
        //         "open":"31664.85",
        //         "riseRate":"2.89"
        //     }
        //
        // Swap
        //
        //     {
        //         open: 44083.82,
        //         high: 44357.77,
        //         low: 42911.54,
        //         last: 43097.87,
        //         vol: 53451.641,
        //         riseRate: -2.24
        //     }
        //
        object timestamp = this.safeInteger(ticker, "date", this.milliseconds());
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "buy") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "sell") },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "vol") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        if (isTrue(getValue(market, "swap")))
        {
            object ohlcvLength = getArrayLength(ohlcv);
            if (isTrue(isGreaterThan(ohlcvLength, 5)))
            {
                return new List<object> {this.safeTimestamp(ohlcv, 5), this.safeNumber(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4)};
            } else
            {
                return new List<object> {this.safeTimestamp(ohlcv, 4), this.safeNumber(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), null};
            }
        } else
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        }
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object spot = getValue(market, "spot");
        object options = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(options, getValue(market, "type"), new Dictionary<string, object>() {});
        object timeframeValue = this.safeString(timeframes, timeframe);
        if (isTrue(isEqual(timeframeValue, null)))
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " fetchOHLCV() does not support "), timeframe), " timeframe for "), getValue(market, "type")), " markets")) ;
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 1000;
        }
        object request = new Dictionary<string, object>() {
            { "size", limit },
        };
        object marketIdField = ((bool) isTrue(swap)) ? "symbol" : "market";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object periodField = ((bool) isTrue(swap)) ? "period" : "type";
        ((Dictionary<string, object>)request)[(string)periodField] = timeframeValue;
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PublicGetKline" },
            { "swap", "contractV1PublicGetKline" },
        });
        if (isTrue(swap))
        {
            if (isTrue(isEqual(price, "mark")))
            {
                method = "contractV1PublicGetMarkKline";
            } else if (isTrue(isEqual(price, "index")))
            {
                method = "contractV1PublicGetIndexKline";
            }
        } else if (isTrue(spot))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["since"] = since;
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     {
        //         "symbol": "BTC",
        //         "data": [
        //             [1645091400000,43183.24,43187.49,43145.92,43182.28,0.9110],
        //             [1645091460000,43182.18,43183.15,43182.06,43183.15,1.4393],
        //             [1645091520000,43182.11,43240.1,43182.11,43240.1,0.3802]
        //         ],
        //         "moneyType": "USDT"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41433.44,41433.44,41405.88,41408.75,21.368,1646366460],
        //             [41409.25,41423.74,41408.8,41423.42,9.828,1646366520],
        //             [41423.96,41429.39,41369.98,41370.31,123.104,1646366580]
        //         ]
        //     }
        //
        // Mark
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41603.39,41603.39,41591.59,41600.81,1646381760],
        //             [41600.36,41605.75,41587.69,41601.97,1646381820],
        //             [41601.97,41601.97,41562.62,41593.96,1646381880]
        //         ]
        //     }
        //
        // Index
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41697.53,41722.29,41689.16,41689.16,1646381640],
        //             [41690.1,41691.73,41611.61,41611.61,1646381700],
        //             [41611.61,41619.49,41594.87,41594.87,1646381760]
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // Spot
        //
        //     {
        //         "date":1624537391,
        //         "amount":"0.0142",
        //         "price":"33936.42",
        //         "trade_type":"ask",
        //         "type":"sell",
        //         "tid":1718869018
        //     }
        //
        // Swap
        //
        //     {
        //         "amount": "0.002",
        //         "createTime": "1645787446034",
        //         "feeAmount": "-0.05762699",
        //         "feeCurrency": "USDT",
        //         "id": "6902932868050395136",
        //         "maker": false,
        //         "orderId": "6902932868042006528",
        //         "price": "38417.99",
        //         "relizedPnl": "0.30402",
        //         "side": 4,
        //         "userId": "6896693805014120448"
        //     },
        //
        object sideField = ((bool) isTrue(getValue(market, "swap"))) ? "side" : "trade_type";
        object side = this.safeString(trade, sideField);
        object takerOrMaker = null;
        object maker = this.safeValue(trade, "maker");
        if (isTrue(!isEqual(maker, null)))
        {
            takerOrMaker = ((bool) isTrue(maker)) ? "maker" : "taker";
        }
        if (isTrue(getValue(market, "spot")))
        {
            side = ((bool) isTrue((isEqual(side, "bid")))) ? "buy" : "sell";
        } else
        {
            if (isTrue(isEqual(side, "3")))
            {
                side = "sell"; // close long
            } else if (isTrue(isEqual(side, "4")))
            {
                side = "buy"; // close short
            } else if (isTrue(isEqual(side, "1")))
            {
                side = "buy"; // open long
            } else if (isTrue(isEqual(side, "2")))
            {
                side = "sell"; // open short
            }
        }
        object timestamp = null;
        if (isTrue(getValue(market, "swap")))
        {
            timestamp = this.safeInteger(trade, "createTime");
        } else
        {
            timestamp = this.safeTimestamp(trade, "date");
        }
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "amount");
        object fee = null;
        object feeCostString = this.safeString(trade, "feeAmount");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCurrency");
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            };
        }
        market = this.safeMarket(null, market);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "side", side },
            { "order", this.safeString(trade, "orderId") },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object marketIdField = ((bool) isTrue(swap)) ? "symbol" : "market";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        if (isTrue(isTrue(swap) && isTrue(isEqual(getValue(parameters, "pageNum"), null))))
        {
            ((Dictionary<string, object>)request)["pageNum"] = 1;
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PublicGetTrades" },
            { "swap", "contractV2PrivateGetTradeTradeHistory" },
        });
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     [
        //         {"date":1624537391,"amount":"0.0142","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869018},
        //         {"date":1624537391,"amount":"0.0010","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869020},
        //         {"date":1624537391,"amount":"0.0133","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869021},
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "amount": "0.002",
        //                     "createTime": "1645787446034",
        //                     "feeAmount": "-0.05762699",
        //                     "feeCurrency": "USDT",
        //                     "id": "6902932868050395136",
        //                     "maker": false,
        //                     "orderId": "6902932868042006528",
        //                     "price": "38417.99",
        //                     "relizedPnl": "0.30402",
        //                     "side": 4,
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        if (isTrue(swap))
        {
            object data = this.safeValue(response, "data");
            response = this.safeValue(data, "list");
        }
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type must be 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the zb api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marginModequeryVariable = this.handleMarginModeAndParams("createOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object swap = getValue(market, "swap");
        object spot = getValue(market, "spot");
        object timeInForce = this.safeString(parameters, "timeInForce");
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        object isTriggerOrder = !isEqual(triggerPrice, null);
        if (isTrue(this.sum(isStopLoss, isTakeProfit, isTriggerOrder)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() stopLossPrice and takeProfitPrice cannot both be defined")) ;
        }
        object isStopOrder = isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)) || isTrue(isTriggerOrder);
        if (isTrue(isTrue(isStopOrder) && isTrue(spot)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() it is not possible to make a stop order on spot markets")) ;
        }
        if (isTrue(isEqual(type, "market")))
        {
            throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() on "), getValue(market, "type")), " markets does not allow market orders")) ;
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetOrder" },
            { "margin", "spotV1PrivateGetOrder" },
            { "swap", "contractV2PrivatePostTradeOrder" },
        });
        object request = new Dictionary<string, object>() {
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(spot))
        {
            object exchangeSpecificParam = isEqual(this.safeInteger(parameters, "orderType", type), 1);
            object postOnly = this.isPostOnly(false, exchangeSpecificParam, parameters);
            ((Dictionary<string, object>)request)["tradeType"] = ((bool) isTrue((isEqual(side, "buy")))) ? 1 : 0;
            ((Dictionary<string, object>)request)["currency"] = getValue(market, "id");
            if (isTrue(postOnly))
            {
                ((Dictionary<string, object>)request)["orderType"] = 1;
            } else if (isTrue(isEqual(timeInForce, "IOC")))
            {
                ((Dictionary<string, object>)request)["orderType"] = 2;
            }
            if (isTrue(!isEqual(price, null)))
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    ((Dictionary<string, object>)request)["acctType"] = 1;
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    ((Dictionary<string, object>)request)["acctType"] = 2;
                }
            }
        } else if (isTrue(swap))
        {
            object exchangeSpecificParam = isEqual(this.safeInteger(parameters, "action", type), 4);
            object postOnly = this.isPostOnly(false, exchangeSpecificParam, parameters);
            // the default mode on zb is one way mode
            // currently ccxt does not support hedge mode natively
            if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                reduceOnly = true;
            }
            if (isTrue(reduceOnly))
            {
                ((Dictionary<string, object>)request)["side"] = 0;
            } else
            {
                ((Dictionary<string, object>)request)["side"] = ((bool) isTrue((isEqual(side, "buy")))) ? 5 : 6;
            }
            if (isTrue(isStopOrder))
            {
                method = "contractV2PrivatePostTradeOrderAlgo";
                if (isTrue(isStopLoss))
                {
                    ((Dictionary<string, object>)request)["orderType"] = 2;
                    ((Dictionary<string, object>)request)["bizType"] = 2;
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                } else if (isTrue(isTakeProfit))
                {
                    ((Dictionary<string, object>)request)["orderType"] = 2;
                    ((Dictionary<string, object>)request)["bizType"] = 1;
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                } else if (isTrue(isTriggerOrder))
                {
                    ((Dictionary<string, object>)request)["orderType"] = 1;
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                }
                ((Dictionary<string, object>)request)["algoPrice"] = this.priceToPrecision(symbol, price);
                ((Dictionary<string, object>)request)["pricetype"] = 2;
            } else
            {
                if (isTrue(isEqual(timeInForce, "IOC")))
                {
                    ((Dictionary<string, object>)request)["action"] = 3;
                } else if (isTrue(postOnly))
                {
                    ((Dictionary<string, object>)request)["action"] = 4;
                } else if (isTrue(isEqual(timeInForce, "FOK")))
                {
                    ((Dictionary<string, object>)request)["action"] = 5;
                } else if (isTrue(isEqual(type, "limit")))
                {
                    ((Dictionary<string, object>)request)["action"] = 1;
                } else
                {
                    ((Dictionary<string, object>)request)["action"] = type;
                }
            }
            if (isTrue(!isEqual(price, null)))
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            object clientOrderId = this.safeString(parameters, "clientOrderId"); // OPTIONAL '^[a-zA-Z0-9-_]{1,36}$', // The user-defined order number
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["clientOrderId"] = clientOrderId;
            }
            // using extend as const name causes issues in python
            object extendOrderAlgos = this.safeValue(parameters, "extend", null); // OPTIONAL {"orderAlgos":[{"bizType":1,"priceType":1,"triggerPrice":"70000"},{"bizType":2,"priceType":1,"triggerPrice":"40000"}]}
            if (isTrue(!isEqual(extendOrderAlgos, null)))
            {
                ((Dictionary<string, object>)request)["extend"] = extendOrderAlgos;
            }
        }
        parameters = this.omit(query, new List<object>() {"takeProfitPrice", "stopLossPrice", "stopPrice", "reduceOnly", "orderType", "triggerPrice", "priceType", "clientOrderId", "extend"});
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot and Margin
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功",
        //         "id": "202202224851151555"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "orderId": "6901786759944937472",
        //             "orderCode": null
        //         }
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": "6919884551305242624",
        //         "desc": "操作成功"
        //     }
        //
        object result = response;
        if (isTrue(isTrue(swap) && !isTrue(isStopOrder)))
        {
            result = this.safeValue(response, "data");
        }
        return this.parseOrder(result, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {};
        object marketIdField = ((bool) isTrue(swap)) ? "symbol" : "currency";
        ((Dictionary<string, object>)request)[(string)marketIdField] = this.marketId(symbol);
        object orderIdField = ((bool) isTrue(swap)) ? "orderId" : "id";
        ((Dictionary<string, object>)request)[(string)orderIdField] = ((object)id).ToString();
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetCancelOrder" },
            { "swap", "contractV2PrivatePostTradeCancelOrder" },
        });
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     {
        //         "code": 1000,
        //         "message": "Success。"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10007,
        //         "desc": "orderId与clientOrderId选填1个"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#cancelAllOrders
        * @description cancel all open orders in a market
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() is not supported on "), getValue(market, "type")), " markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "contractV2PrivatePostTradeCancelAllOrders";
        if (isTrue(stop))
        {
            method = "contractV2PrivatePostTradeCancelAlgos";
        }
        object query = this.omit(parameters, "stop");
        return await this.callAsync(method, this.extend(request, query));
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderType = this.safeInteger(parameters, "orderType");
        if (isTrue(!isEqual(orderType, null)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchOrder() it is not possible to fetch a single conditional order, use fetchOrders() instead")) ;
        }
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {};
        object marketIdField = ((bool) isTrue(swap)) ? "symbol" : "currency";
        ((Dictionary<string, object>)request)[(string)marketIdField] = this.marketId(symbol);
        object orderIdField = ((bool) isTrue(swap)) ? "orderId" : "id";
        ((Dictionary<string, object>)request)[(string)orderIdField] = ((object)id).ToString();
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetGetOrder" },
            { "swap", "contractV2PrivateGetTradeGetOrder" },
        });
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     {
        //         'total_amount': 0.01,
        //         'id': '20180910244276459',
        //         'price': 180.0,
        //         'trade_date': 1536576744960,
        //         'status': 2,
        //         'trade_money': '1.96742',
        //         'trade_amount': 0.01,
        //         'type': 0,
        //         'currency': 'eth_usdt'
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "action": 1,
        //             "amount": "0.002",
        //             "availableAmount": "0.002",
        //             "availableValue": "60",
        //             "avgPrice": "0",
        //             "canCancel": true,
        //             "cancelStatus": 20,
        //             "createTime": "1646185684379",
        //             "entrustType": 1,
        //             "id": "6904603200733782016",
        //             "leverage": 2,
        //             "margin": "30",
        //             "marketId": "100",
        //             "modifyTime": "1646185684416",
        //             "price": "30000",
        //             "priority": 0,
        //             "showStatus": 1,
        //             "side": 1,
        //             "sourceType": 4,
        //             "status": 12,
        //             "tradeAmount": "0",
        //             "tradeValue": "0",
        //             "type": 1,
        //             "userId": "6896693805014120448",
        //             "value": "60"
        //         },
        //         "desc":"操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        object result = response;
        if (isTrue(swap))
        {
            result = this.safeValue(response, "data");
        }
        return this.parseOrder(result, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderType = this.safeInteger(parameters, "orderType");
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "pageSize", limit },
        };
        object marketIdField = ((bool) isTrue(getValue(market, "swap"))) ? "symbol" : "currency";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object pageNumField = ((bool) isTrue(getValue(market, "swap"))) ? "pageNum" : "pageIndex";
        ((Dictionary<string, object>)request)[(string)pageNumField] = 1;
        if (isTrue(swap))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetGetOrdersIgnoreTradeType" },
            { "swap", "contractV2PrivateGetTradeGetAllOrders" },
        });
        // tradeType 交易类型1/0[buy/sell]
        if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("tradeType"))))
        {
            method = "spotV1PrivateGetGetOrdersNew";
        }
        if (isTrue(!isEqual(orderType, null)))
        {
            method = "contractV2PrivateGetTradeGetOrderAlgos";
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0,
        //             "id": "202202234857482656",
        //             "price": 30000.0,
        //             "status": 3,
        //             "total_amount": 0.0006,
        //             "trade_amount": 0.0000,
        //             "trade_date": 1645610254524,
        //             "trade_money": 0.000000,
        //             "type": 1,
        //             "useZbFee": false,
        //             "webId": 0
        //         }
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "amount": "0.004",
        //                     "availableAmount": "0.004",
        //                     "availableValue": "120",
        //                     "avgPrice": "0",
        //                     "canCancel": true,
        //                     "cancelStatus": 20,
        //                     "createTime": "1645609643885",
        //                     "entrustType": 1,
        //                     "id": "6902187111785635850",
        //                     "leverage": 5,
        //                     "margin": "24",
        //                     "marketId": "100",
        //                     "marketName": "BTC_USDT",
        //                     "modifyTime": "1645609643889",
        //                     "price": "30000",
        //                     "showStatus": 1,
        //                     "side": 1,
        //                     "sourceType": 1,
        //                     "status": 12,
        //                     "tradeAmount": "0",
        //                     "tradeValue": "0",
        //                     "type": 1,
        //                     "userId": "6896693805014120448",
        //                     "value": "120"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        object result = response;
        if (isTrue(swap))
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            result = this.safeValue(data, "list", new List<object>() {});
        }
        return this.parseOrders(result, market, since, limit);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since timestamp in ms of the earliest order, default is undefined
        * @param {int|undefined} limit max number of orders to return, default is undefined
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        limit ??= 10;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object stop = this.safeValue(parameters, "stop");
        object request = new Dictionary<string, object>() {
            { "pageSize", limit },
        };
        object marketIdField = ((bool) isTrue(getValue(market, "spot"))) ? "currency" : "symbol";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object pageNumField = ((bool) isTrue(getValue(market, "spot"))) ? "pageIndex" : "pageNum";
        ((Dictionary<string, object>)request)[(string)pageNumField] = 1;
        object method = "spotV1PrivateGetGetOrdersIgnoreTradeType";
        if (isTrue(stop))
        {
            method = "contractV2PrivateGetTradeGetOrderAlgos";
            object orderType = this.safeInteger(parameters, "orderType");
            if (isTrue(isEqual(orderType, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledOrders() requires an orderType parameter for stop orders")) ;
            }
            object side = this.safeValue(parameters, "side");
            object bizType = this.safeInteger(parameters, "bizType");
            if (isTrue(isTrue(isEqual(side, "sell")) && isTrue(reduceOnly)))
            {
                ((Dictionary<string, object>)request)["side"] = 3; // close long
            } else if (isTrue(isTrue(isEqual(side, "buy")) && isTrue(reduceOnly)))
            {
                ((Dictionary<string, object>)request)["side"] = 4; // close short
            } else if (isTrue(isEqual(side, "buy")))
            {
                ((Dictionary<string, object>)request)["side"] = 1; // open long
            } else if (isTrue(isEqual(side, "sell")))
            {
                ((Dictionary<string, object>)request)["side"] = 2; // open short
            } else if (isTrue(isEqual(side, 5)))
            {
                ((Dictionary<string, object>)request)["side"] = 5; // one way position buy
            } else if (isTrue(isEqual(side, 6)))
            {
                ((Dictionary<string, object>)request)["side"] = 6; // one way position sell
            } else if (isTrue(isEqual(side, 0)))
            {
                ((Dictionary<string, object>)request)["side"] = 0; // one way position close only
            }
            if (isTrue(isEqual(orderType, 1)))
            {
                ((Dictionary<string, object>)request)["orderType"] = 1;
            } else if (isTrue(isTrue(isEqual(orderType, 2)) || isTrue(bizType)))
            {
                ((Dictionary<string, object>)request)["orderType"] = 2;
                ((Dictionary<string, object>)request)["bizType"] = bizType;
            }
            ((Dictionary<string, object>)request)["status"] = 2;
        }
        // tradeType 交易类型1/0[buy/sell]
        if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("tradeType"))))
        {
            method = "spotV1PrivateGetGetOrdersNew";
        }
        object response = null;
        try
        {
            response = await this.callAsync(method, this.extend(request, parameters));
        } catch(Exception e)
        {
            if (isTrue(e is OrderNotFound))
            {
                return new List<object>() {};
            }
            throw e;
        }
        object query = this.omit(parameters, new List<object>() {"reduceOnly", "stop", "side", "orderType", "bizType"});
        response = await this.callAsync(method, this.extend(request, query));
        //
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0,
        //             "id": "202202234857482656",
        //             "price": 30000.0,
        //             "status": 1,
        //             "total_amount": 0.0006,
        //             "trade_amount": 0.0000,
        //             "trade_date": 1645610254524,
        //             "trade_money": 0.000000,
        //             "type": 1,
        //             "useZbFee": false,
        //             "webId": 0
        //         }
        //     ]
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 2,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        if (isTrue(stop))
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            response = this.safeValue(data, "list", new List<object>() {});
        }
        object result = new List<object>() {};
        if (isTrue(isEqual(getValue(market, "type"), "spot")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object entry = getValue(response, i);
                object status = this.safeString(entry, "status");
                if (isTrue(isEqual(status, "1")))
                {
                    ((List<object>)result).Add(entry);
                }
            }
            response = result;
        }
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        limit ??= 10;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object orderType = this.safeInteger(parameters, "orderType");
        object request = new Dictionary<string, object>() {
            { "pageSize", limit },
        };
        object marketIdField = ((bool) isTrue(getValue(market, "spot"))) ? "currency" : "symbol";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object pageNumField = ((bool) isTrue(getValue(market, "spot"))) ? "pageIndex" : "pageNum";
        ((Dictionary<string, object>)request)[(string)pageNumField] = 1;
        if (isTrue(isTrue(swap) && isTrue((!isEqual(since, null)))))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetGetFinishedAndPartialOrders" },
            { "swap", "contractV2PrivateGetTradeGetOrderAlgos" },
        });
        if (isTrue(isTrue(swap) && isTrue((isEqual(orderType, null)))))
        {
            throw new ExchangeError ((string)add(this.id, " fetchClosedOrders() can not fetch swap orders, use fetchOrders instead")) ;
        }
        if (isTrue(swap))
        {
            // a status of 2 would mean canceled and could also be valid
            ((Dictionary<string, object>)request)["status"] = 5; // complete
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0.00823354,
        //             "id": "202204145086706337",
        //             "price": 41167.7,
        //             "status": 2,
        //             "total_amount": 0.0001,
        //             "trade_amount": 0.0001,
        //             "trade_date": 1649917867370,
        //             "trade_money": 4.116770,
        //             "type": 0,
        //             "useZbFee": false,
        //             "webId": 0
        //         },
        //     ]
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        object result = response;
        if (isTrue(swap))
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            result = this.safeValue(data, "list", new List<object>() {});
        }
        return this.parseOrders(result, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderType = this.safeInteger(parameters, "orderType");
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit; // default pageSize is 10 for spot, 30 for swap
        }
        object marketIdField = ((bool) isTrue(getValue(market, "swap"))) ? "symbol" : "currency";
        ((Dictionary<string, object>)request)[(string)marketIdField] = getValue(market, "id");
        object pageNumField = ((bool) isTrue(getValue(market, "swap"))) ? "pageNum" : "pageIndex";
        ((Dictionary<string, object>)request)[(string)pageNumField] = 1;
        if (isTrue(isTrue(swap) && isTrue((!isEqual(since, null)))))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType" },
            { "swap", "contractV2PrivateGetTradeGetUndoneOrders" },
        });
        if (isTrue(!isEqual(orderType, null)))
        {
            method = "contractV2PrivateGetTradeGetOrderAlgos";
            // value 3 would mean triggered but still open orders
            ((Dictionary<string, object>)request)["status"] = 1; // untriggered
        }
        // tradeType 交易类型1/0[buy/sell]
        if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("tradeType"))))
        {
            method = "spotV1PrivateGetGetOrdersNew";
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Spot
        //
        //     [
        //         {
        //             "currency": "btc_usdt",
        //             "id": "20150928158614292",
        //             "price": 1560,
        //             "status": 3,
        //             "total_amount": 0.1,
        //             "trade_amount": 0,
        //             "trade_date": 1443410396717,
        //             "trade_money": 0,
        //             "type": 0,
        //             "fees": "0.03",
        //             "useZbFee": true
        //         },
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "amount": "0.003",
        //                     "availableAmount": "0.003",
        //                     "availableValue": "90",
        //                     "avgPrice": "0",
        //                     "canCancel": true,
        //                     "cancelStatus": 20,
        //                     "createTime": "1645694610880",
        //                     "entrustType": 1,
        //                     "id": "6902543489192632320",
        //                     "leverage": 5,
        //                     "margin": "18",
        //                     "marketId": "100",
        //                     "modifyTime": "1645694610883",
        //                     "price": "30000",
        //                     "priority": 0,
        //                     "showStatus": 1,
        //                     "side": 1,
        //                     "sourceType": 1,
        //                     "status": 12,
        //                     "tradeAmount": "0",
        //                     "tradeValue": "0",
        //                     "type": 1,
        //                     "userId": "6896693805014120448",
        //                     "value": "90"
        //                 }
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 30
        //         },
        //         "desc": "操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        object result = response;
        if (isTrue(swap))
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            result = this.safeValue(data, "list", new List<object>() {});
        }
        return this.parseOrders(result, market, since, limit);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Spot fetchOrder, fetchClosedOrders
        //
        //     {
        //         acctType: 0,
        //         currency: 'btc_usdt',
        //         fees: 3.6e-7,
        //         id: '202102282829772463',
        //         price: 45177.5,
        //         status: 2,
        //         total_amount: 0.0002,
        //         trade_amount: 0.0002,
        //         trade_date: 1614515104998,
        //         trade_money: 8.983712,
        //         type: 1,
        //         useZbFee: false
        //     },
        //
        // Swap fetchOrder
        //
        //     {
        //         "action": 1,
        //         "amount": "0.002",
        //         "availableAmount": "0.002",
        //         "availableValue": "60",
        //         "avgPrice": "0",
        //         "canCancel": true,
        //         "cancelStatus": 20,
        //         "createTime": "1646185684379",
        //         "entrustType": 1,
        //         "id": "6904603200733782016",
        //         "leverage": 2,
        //         "margin": "30",
        //         "marketId": "100",
        //         "modifyTime": "1646185684416",
        //         "price": "30000",
        //         "priority": 0,
        //         "showStatus": 1,
        //         "side": 1,
        //         "sourceType": 4,
        //         "status": 12,
        //         "tradeAmount": "0",
        //         "tradeValue": "0",
        //         "type": 1,
        //         "userId": "6896693805014120448",
        //         "value": "60"
        //     },
        //
        // Algo fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "action": 1,
        //         "algoPrice": "30000",
        //         "amount": "0.003",
        //         "bizType": 0,
        //         "canCancel": true,
        //         "createTime": "1649913941109",
        //         "errorCode": 0,
        //         "id": "6920240642849449984",
        //         "isLong": false,
        //         "leverage": 10,
        //         "marketId": "100",
        //         "modifyTime": "1649913941109",
        //         "orderType": 1,
        //         "priceType": 2,
        //         "side": 5,
        //         "sourceType": 4,
        //         "status": 1,
        //         "submitPrice": "41270.53",
        //         "symbol": "BTC_USDT",
        //         "tradedAmount": "0",
        //         "triggerCondition": "<=",
        //         "triggerPrice": "31000",
        //         "triggerTime": "0",
        //         "userId": "6896693805014120448"
        //     },
        //
        // Spot createOrder
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         id: '202202224851151555',
        //         type: '1',
        //         total_amount: 0.0002,
        //         price: 30000
        //     }
        //
        // Swap createOrder
        //
        //     {
        //         orderId: '6901786759944937472',
        //         orderCode: null,
        //         timeInForce: 'IOC',
        //         total_amount: 0.0002,
        //         price: 30000
        //     }
        //
        // Algo createOrder
        //
        //     {
        //         "code": 10000,
        //         "data": "6919884551305242624",
        //         "desc": "操作成功"
        //     }
        //
        object orderId = ((bool) isTrue(getValue(market, "swap"))) ? this.safeString2(order, "orderId", "data") : this.safeString(order, "id");
        if (isTrue(isEqual(orderId, null)))
        {
            orderId = this.safeValue(order, "id");
        }
        object rawSide = this.safeInteger2(order, "type", "side");
        object side = null;
        if (isTrue(!isEqual(rawSide, null)))
        {
            if (isTrue(getValue(market, "spot")))
            {
                side = ((bool) isTrue((isEqual(rawSide, 1)))) ? "buy" : "sell";
            } else if (isTrue(getValue(market, "swap")))
            {
                if (isTrue(isEqual(rawSide, 0)))
                {
                    side = null;
                } else if (isTrue(isTrue(isTrue((isEqual(rawSide, 1))) || isTrue((isEqual(rawSide, 4)))) || isTrue((isEqual(rawSide, 5)))))
                {
                    side = "buy";
                } else if (isTrue(isTrue(isTrue((isEqual(rawSide, 2))) || isTrue((isEqual(rawSide, 3)))) || isTrue((isEqual(rawSide, 6)))))
                {
                    side = "sell";
                }
            }
        }
        object timestamp = this.safeInteger(order, "trade_date");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(order, "createTime");
        }
        object marketId = this.safeString(order, "currency");
        market = this.safeMarket(marketId, market, "_");
        object price = this.safeString2(order, "price", "algoPrice");
        object filled = ((bool) isTrue(getValue(market, "swap"))) ? this.safeString(order, "tradeAmount") : this.safeString(order, "trade_amount");
        object amount = this.safeString(order, "total_amount");
        if (isTrue(isEqual(amount, null)))
        {
            amount = this.safeString(order, "amount");
        }
        object cost = this.safeString(order, "trade_money");
        object status = this.parseOrderStatus(this.safeString(order, "status"), market);
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = (isEqual(timeInForce, "PO"));
        object feeCost = this.safeNumber(order, "fees");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrency = null;
            object zbFees = this.safeValue(order, "useZbFee");
            if (isTrue(isEqual(zbFees, true)))
            {
                feeCurrency = "ZB";
            } else
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", orderId },
            { "clientOrderId", this.safeString(order, "userId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", "limit" },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", this.safeNumber(order, "triggerPrice") },
            { "triggerPrice", this.safeNumber(order, "triggerPrice") },
            { "average", this.safeString(order, "avgPrice") },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status, object market = null)
    {
        object statuses = new Dictionary<string, object>() {};
        if (isTrue(isEqual(getValue(market, "type"), "spot")))
        {
            statuses = new Dictionary<string, object>() {
                { "0", "open" },
                { "1", "canceled" },
                { "2", "closed" },
                { "3", "open" },
            };
        } else
        {
            statuses = new Dictionary<string, object>() {
                { "1", "open" },
                { "2", "canceled" },
                { "3", "open" },
                { "4", "rejected" },
                { "5", "closed" },
            };
        }
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "failed" },
            { "2", "ok" },
            { "3", "canceled" },
            { "5", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "id": "withdrawalId"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount": 0.01,
        //         "fees": 0.001,
        //         "id": 2016042556231,
        //         "manageTime": 1461579340000,
        //         "status": 3,
        //         "submitTime": 1461579288000,
        //         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //         "amount": "1.00000000",
        //         "confirmTimes": 1,
        //         "currency": "BTC",
        //         "description": "Successfully Confirm",
        //         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //         "id": 558,
        //         "itransfer": 1,
        //         "status": 2,
        //         "submit_time": "2016-12-07 18:51:57",
        //     }
        //
        object id = this.safeString(transaction, "id");
        object txid = this.safeString(transaction, "hash");
        object amount = this.safeNumber(transaction, "amount");
        object timestamp = this.parse8601(this.safeString(transaction, "submit_time"));
        timestamp = this.safeInteger(transaction, "submitTime", timestamp);
        object address = this.safeString2(transaction, "toAddress", "address");
        object tag = null;
        if (isTrue(!isEqual(address, null)))
        {
            object parts = ((string)address).Split((string)"_").ToList<object>();
            address = this.safeString(parts, 0);
            tag = this.safeString(parts, 1);
        }
        object confirmTimes = this.safeInteger(transaction, "confirmTimes");
        object updated = this.safeInteger(transaction, "manageTime");
        object type = null;
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        if (isTrue(!isEqual(address, null)))
        {
            type = ((bool) isTrue((isEqual(confirmTimes, null)))) ? "withdrawal" : "deposit";
        }
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object fee = null;
        object feeCost = this.safeNumber(transaction, "fees");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", null },
            { "address", address },
            { "addressTo", address },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", fee },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 125")) ;
        }
        object market = this.market(symbol);
        object accountType = null;
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        } else
        {
            accountType = 1;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
            { "futuresAccountType", accountType },
        };
        return await this.contractV2PrivatePostSettingSetLeverage(this.extend(request, parameters));
    }

    public async virtual Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the zb api endpoint
        * @param {int|undefined} params.until timestamp in ms of the latest funding rate to fetch
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object until = this.safeInteger2(parameters, "until", "till");
        parameters = this.omit(parameters, new List<object>() {"endTime", "till", "until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["endTime"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.contractV2PublicGetFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "fundingRate": "0.0001",
        //                 "fundingTime": "1645171200000"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() does not supports contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.contractV1PublicGetFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "fundingRate": "0.0001",
        //             "nextCalculateTime": "2022-02-19 00:00:00"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // fetchFundingRate
        //
        //     {
        //         "fundingRate": "0.0001",
        //         "nextCalculateTime": "2022-02-19 00:00:00"
        //     }
        //
        // fetchFundingRates
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "markPrice": "43254.42",
        //         "indexPrice": "43278.61",
        //         "lastFundingRate": "0.0001",
        //         "nextFundingTime": "1646121600000"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object fundingRate = this.safeNumber2(contract, "fundingRate", "lastFundingRate");
        object nextFundingTimestamp = this.parse8601(this.safeString(contract, "nextCalculateTime"));
        object fundingTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", this.safeString(contract, "markPrice") },
            { "indexPrice", this.safeString(contract, "indexPrice") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.contractV2PublicGetPremiumIndex(parameters);
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "markPrice": "43254.42",
        //                 "indexPrice": "43278.61",
        //                 "lastFundingRate": "0.0001",
        //                 "nextFundingTime": "1646121600000"
        //             },
        //         ],
        //         "desc":"操作成功"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = this.parseFundingRates(data);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
                var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        object password = this.safeString(parameters, "safePwd", this.password);
        if (isTrue(isEqual(password, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires exchange.password or a safePwd parameter")) ;
        }
        object fees = this.safeNumber(parameters, "fees");
        if (isTrue(isEqual(fees, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a fees parameter")) ;
        }
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(!isEqual(tag, null)))
        {
            address = add(address, add("_", tag));
        }
        object request = new Dictionary<string, object>() {
            { "amount", this.currencyToPrecision(code, amount) },
            { "currency", getValue(currency, "id") },
            { "fees", this.currencyToPrecision(code, fees) },
            { "method", "withdraw" },
            { "receiveAddr", address },
            { "safePwd", password },
        };
        object response = await this.spotV1PrivateGetWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "id": "withdrawalId"
        //     }
        //
        object transaction = this.parseTransaction(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "type", "withdrawal" },
            { "address", address },
            { "addressTo", address },
            { "amount", amount },
        });
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.spotV1PrivateGetGetWithdrawRecord(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "list": [
        //                     {
        //                         "amount": 0.01,
        //                         "fees": 0.001,
        //                         "id": 2016042556231,
        //                         "manageTime": 1461579340000,
        //                         "status": 3,
        //                         "submitTime": 1461579288000,
        //                         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //                     },
        //                 ],
        //                 "pageIndex": 1,
        //                 "pageSize": 10,
        //                 "totalCount": 4,
        //                 "totalPage": 1
        //             }
        //         }
        //     }
        //
        object message = this.safeValue(response, "message", new Dictionary<string, object>() {});
        object datas = this.safeValue(message, "datas", new Dictionary<string, object>() {});
        object withdrawals = this.safeValue(datas, "list", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.spotV1PrivateGetGetChargeRecord(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "list": [
        //                     {
        //                         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //                         "amount": "1.00000000",
        //                         "confirmTimes": 1,
        //                         "currency": "BTC",
        //                         "description": "Successfully Confirm",
        //                         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //                         "id": 558,
        //                         "itransfer": 1,
        //                         "status": 2,
        //                         "submit_time": "2016-12-07 18:51:57",
        //                     },
        //                 ],
        //                 "pageIndex": 1,
        //                 "pageSize": 10,
        //                 "total": 8
        //             }
        //         }
        //     }
        //
        object message = this.safeValue(response, "message", new Dictionary<string, object>() {});
        object datas = this.safeValue(message, "datas", new Dictionary<string, object>() {});
        object deposits = this.safeValue(datas, "list", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchPosition
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "futuresAccountType", 1 },
        };
        object response = await this.contractV2PrivateGetPositionsGetPositions(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "amount": "0.002",
        //                 "appendAmount": "0",
        //                 "autoLightenRatio": "0",
        //                 "avgPrice": "38570",
        //                 "bankruptcyPrice": "46288.41",
        //                 "contractType": 1,
        //                 "createTime": "1645784751867",
        //                 "freezeAmount": "0",
        //                 "freezeList": [
        //                     {
        //                         "amount": "15.436832",
        //                         "currencyId": "6",
        //                         "currencyName": "usdt",
        //                         "modifyTime": "1645784751867"
        //                     }
        //                 ],
        //                 "id": "6902921567894972486",
        //                 "lastAppendAmount": "0",
        //                 "leverage": 5,
        //                 "liquidateLevel": 1,
        //                 "liquidatePrice": "46104",
        //                 "maintainMargin": "0.30912384",
        //                 "margin": "15.436832",
        //                 "marginAppendCount": 0,
        //                 "marginBalance": "15.295872",
        //                 "marginMode": 1,
        //                 "marginRate": "0.020209",
        //                 "marketId": "100",
        //                 "marketName": "BTC_USDT",
        //                 "modifyTime": "1645784751867",
        //                 "nominalValue": "77.14736",
        //                 "originAppendAmount": "0",
        //                 "originId": "6902921567894972591",
        //                 "refreshType": "Timer",
        //                 "returnRate": "-0.0091",
        //                 "side": 0,
        //                 "status": 1,
        //                 "unrealizedPnl": "-0.14096",
        //                 "userId": "6896693805014120448"
        //             }
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object firstPosition = this.safeValue(data, 0);
        return this.parsePosition(firstPosition, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "futuresAccountType", 1 },
        };
        object response = await this.contractV2PrivateGetPositionsGetPositions(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "amount": "0.002",
        //                 "appendAmount": "0",
        //                 "autoLightenRatio": "0",
        //                 "avgPrice": "38570",
        //                 "bankruptcyPrice": "46288.41",
        //                 "contractType": 1,
        //                 "createTime": "1645784751867",
        //                 "freezeAmount": "0",
        //                 "freezeList": [
        //                     {
        //                         "amount": "15.436832",
        //                         "currencyId": "6",
        //                         "currencyName": "usdt",
        //                         "modifyTime": "1645784751867"
        //                     }
        //                 ],
        //                 "id": "6902921567894972486",
        //                 "lastAppendAmount": "0",
        //                 "leverage": 5,
        //                 "liquidateLevel": 1,
        //                 "liquidatePrice": "46104",
        //                 "maintainMargin": "0.30912384",
        //                 "margin": "15.436832",
        //                 "marginAppendCount": 0,
        //                 "marginBalance": "15.295872",
        //                 "marginMode": 1,
        //                 "marginRate": "0.020209",
        //                 "marketId": "100",
        //                 "marketName": "BTC_USDT",
        //                 "modifyTime": "1645784751867",
        //                 "nominalValue": "77.14736",
        //                 "originAppendAmount": "0",
        //                 "originId": "6902921567894972591",
        //                 "refreshType": "Timer",
        //                 "returnRate": "-0.0091",
        //                 "side": 0,
        //                 "status": 1,
        //                 "unrealizedPnl": "-0.14096",
        //                 "userId": "6896693805014120448"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "amount": "0.002",
        //         "appendAmount": "0",
        //         "autoLightenRatio": "0",
        //         "avgPrice": "38570",
        //         "bankruptcyPrice": "46288.41",
        //         "contractType": 1,
        //         "createTime": "1645784751867",
        //         "freezeAmount": "0",
        //         "freezeList": [
        //             {
        //                 "amount": "15.436832",
        //                 "currencyId": "6",
        //                 "currencyName": "usdt",
        //                 "modifyTime": "1645784751867"
        //             }
        //         ],
        //         "id": "6902921567894972486",
        //         "lastAppendAmount": "0",
        //         "leverage": 5,
        //         "liquidateLevel": 1,
        //         "liquidatePrice": "46104",
        //         "maintainMargin": "0.30912384",
        //         "margin": "15.436832",
        //         "marginAppendCount": 0,
        //         "marginBalance": "15.295872",
        //         "marginMode": 1,
        //         "marginRate": "0.020209",
        //         "marketId": "100",
        //         "marketName": "BTC_USDT",
        //         "modifyTime": "1645784751867",
        //         "nominalValue": "77.14736",
        //         "originAppendAmount": "0",
        //         "originId": "6902921567894972591",
        //         "refreshType": "Timer",
        //         "returnRate": "-0.0091",
        //         "side": 0,
        //         "status": 1,
        //         "unrealizedPnl": "-0.14096",
        //         "userId": "6896693805014120448"
        //     }
        //
        object marketId = this.safeString(position, "marketName");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object contracts = this.safeString(position, "amount");
        object entryPrice = this.safeNumber(position, "avgPrice");
        object initialMargin = this.safeString(position, "margin");
        object rawSide = this.safeString(position, "side");
        object side = ((bool) isTrue((isEqual(rawSide, "1")))) ? "long" : "short";
        object openType = this.safeString(position, "marginMode");
        object marginMode = ((bool) isTrue((isEqual(openType, "1")))) ? "isolated" : "cross";
        object leverage = this.safeString(position, "leverage");
        object liquidationPrice = this.safeNumber(position, "liquidatePrice");
        object unrealizedProfit = this.safeNumber(position, "unrealizedPnl");
        object maintenanceMargin = this.safeNumber(position, "maintainMargin");
        object marginRatio = this.safeNumber(position, "marginRate");
        object notional = this.safeNumber(position, "nominalValue");
        object percentage = Precise.stringMul(this.safeString(position, "returnRate"), "100");
        object timestamp = this.safeNumber(position, "createTime");
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", null },
            { "entryPrice", entryPrice },
            { "collateral", null },
            { "side", side },
            { "unrealizedProfit", unrealizedProfit },
            { "leverage", this.parseNumber(leverage) },
            { "percentage", percentage },
            { "marginMode", marginMode },
            { "notional", notional },
            { "markPrice", null },
            { "liquidationPrice", liquidationPrice },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", null },
            { "marginRatio", marginRatio },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "realized pnl" },
            { "2", "commission" },
            { "3", "funding fee subtract" },
            { "4", "funding fee addition" },
            { "5", "insurance clear" },
            { "6", "transfer in" },
            { "7", "transfer out" },
            { "8", "margin addition" },
            { "9", "margin subtraction" },
            { "10", "commission addition" },
            { "11", "bill type freeze" },
            { "12", "bill type unfreeze" },
            { "13", "system take over margin" },
            { "14", "transfer" },
            { "15", "realized pnl collection" },
            { "16", "funding fee collection" },
            { "17", "recommender return commission" },
            { "18", "by level subtract positions" },
            { "19", "system add" },
            { "20", "system subtract" },
            { "23", "trading competition take over fund" },
            { "24", "trading contest tickets" },
            { "25", "return of trading contest tickets" },
            { "26", "experience expired recall" },
            { "50", "test register gift" },
            { "51", "register gift" },
            { "52", "deposit gift" },
            { "53", "trading volume gift" },
            { "54", "awards gift" },
            { "55", "trading volume gift" },
            { "56", "awards gift expire" },
            { "201", "open positions" },
            { "202", "close positions" },
            { "203", "take over positions" },
            { "204", "trading competition take over positions" },
            { "205", "one way open long" },
            { "206", "one way open short" },
            { "207", "one way close long" },
            { "208", "one way close short" },
            { "301", "coupon deduction service charge" },
            { "302", "experience deduction" },
            { "303", "experience expired" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     [
        //         {
        //             "type": 3,
        //             "changeAmount": "0.00434664",
        //             "isIn": 0,
        //             "beforeAmount": "30.53353135",
        //             "beforeFreezeAmount": "21.547",
        //             "createTime": "1646121604997",
        //             "available": "30.52918471",
        //             "unit": "usdt",
        //             "symbol": "BTC_USDT"
        //         },
        //     ],
        //
        object timestamp = this.safeInteger(item, "createTime");
        object direction = null;
        object changeDirection = this.safeNumber(item, "isIn");
        if (isTrue(isEqual(changeDirection, 1)))
        {
            direction = "increase";
        } else
        {
            direction = "reduce";
        }
        object fee = null;
        object feeCost = this.safeNumber(item, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", this.safeCurrencyCode(this.safeString(item, "unit")) },
            };
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", this.safeString(item, "userId") },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeInteger(item, "type")) },
            { "currency", this.safeCurrencyCode(this.safeString(item, "unit")) },
            { "amount", this.safeNumber(item, "changeAmount") },
            { "before", this.safeNumber(item, "beforeAmount") },
            { "after", this.safeNumber(item, "available") },
            { "status", null },
            { "fee", fee },
        };
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLedger() requires a code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "futuresAccountType", 1 },
        };
        if (isTrue(!isEqual(code, null)))
        {
            ((Dictionary<string, object>)request)["currencyName"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.contractV2PrivateGetFundGetBill(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "type": 3,
        //                     "changeAmount": "0.00434664",
        //                     "isIn": 0,
        //                     "beforeAmount": "30.53353135",
        //                     "beforeFreezeAmount": "21.547",
        //                     "createTime": "1646121604997",
        //                     "available": "30.52918471",
        //                     "unit": "usdt",
        //                     "symbol": "BTC_USDT"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object list = this.safeValue(data, "list", new List<object>() {});
        return this.parseLedger(list, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name zb#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the zb api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypemarketTypeQueryVariable = this.handleMarketTypeAndParams("transfer", null, parameters);
        var marketType = ((List<object>) marketTypemarketTypeQueryVariable)[0];
        var marketTypeQuery = ((List<object>) marketTypemarketTypeQueryVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("transfer", marketTypeQuery);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object currency = this.currency(code);
        object swap = (isEqual(marketType, "swap"));
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
        };
        object method = null;
        object side = null;
        if (isTrue(swap))
        {
            method = "contractV2PrivatePostFundTransferFund";
            if (isTrue(isTrue(isEqual(fromAccount, "spot")) || isTrue(isEqual(toAccount, "future"))))
            {
                side = 1;
            } else
            {
                side = 0;
            }
            ((Dictionary<string, object>)request)["currencyName"] = getValue(currency, "id");
            ((Dictionary<string, object>)request)["clientId"] = this.safeString(parameters, "clientId");
            ((Dictionary<string, object>)request)["side"] = side;
        } else
        {
            if (isTrue(isTrue(isTrue((isEqual(marginMode, "isolated"))) || isTrue((isEqual(toAccount, "isolated")))) || isTrue((isEqual(fromAccount, "isolated")))))
            {
                if (isTrue(isTrue(isEqual(fromAccount, "spot")) || isTrue(isEqual(toAccount, "isolated"))))
                {
                    method = "spotV1PrivateGetTransferInLever";
                } else
                {
                    method = "spotV1PrivateGetTransferOutLever";
                }
                object symbol = this.safeString2(parameters, "marketName", "symbol");
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " transfer() requires a symbol argument for isolated margin")) ;
                }
                object marketInner = this.market(symbol);
                ((Dictionary<string, object>)request)["marketName"] = this.safeSymbol(getValue(marketInner, "id"), marketInner, "_");
            } else if (isTrue(isTrue(isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(toAccount, "cross")))) || isTrue((isEqual(fromAccount, "cross")))))
            {
                if (isTrue(isTrue(isEqual(fromAccount, "spot")) || isTrue(isEqual(toAccount, "cross"))))
                {
                    method = "spotV1PrivateGetTransferInCross";
                } else
                {
                    method = "spotV1PrivateGetTransferOutCross";
                }
            }
            ((Dictionary<string, object>)request)["coin"] = getValue(currency, "id");
        }
        object response = await this.callAsync(method, this.extend(request, query));
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": "2sdfsdfsdf232342",
        //         "desc": "Success"
        //     }
        //
        // Margin
        //
        //     {
        //         "code": 1000,
        //         "message": "Success"
        //     }
        //
        return this.extend(this.parseTransfer(response, currency), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        // response samples in 'transfer'
        object timestamp = this.milliseconds();
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "data") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(null, "currency") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(getValue(parameters, "positionsId"), null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " modifyMarginHelper() requires a positionsId argument in the params")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        amount = this.amountToPrecision(symbol, amount);
        object position = this.safeString(parameters, "positionsId");
        object request = new Dictionary<string, object>() {
            { "positionsId", position },
            { "amount", amount },
            { "type", type },
            { "futuresAccountType", 1 },
        };
        object response = await this.contractV2PrivatePostPositionsUpdateMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "amount": "0.002",
        //             "appendAmount": "0",
        //             "avgPrice": "43927.23",
        //             "bankruptcyPrice": "41730.86",
        //             "createTime": "1646208695609",
        //             "freezeAmount": "0",
        //             "id": "6900781818669377576",
        //             "keyMark": "6896693805014120448-100-1-",
        //             "lastAppendAmount": "0",
        //             "lastTime": "1646209235505",
        //             "leverage": 20,
        //             "liquidateLevel": 1,
        //             "liquidatePrice": "41898.46",
        //             "maintainMargin": "0",
        //             "margin": "4.392723",
        //             "marginAppendCount": 0,
        //             "marginBalance": "0",
        //             "marginMode": 1,
        //             "marginRate": "0",
        //             "marketId": "100",
        //             "marketName": "BTC_USDT",
        //             "modifyTime": "1646209235505",
        //             "nominalValue": "87.88828",
        //             "originAppendAmount": "0",
        //             "originId": "6904699716827818029",
        //             "positionsMode": 2,
        //             "sellerCurrencyId": "1",
        //             "side": 1,
        //             "status": 1,
        //             "unrealizedPnl": "0.03382",
        //             "usable": true,
        //             "userId": "6896693805014120448"
        //         },
        //         "desc":"操作成功"
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
        });
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        object innerData = this.safeValue(data, "data", new Dictionary<string, object>() {});
        object sideRaw = this.safeInteger(innerData, "side");
        object side = ((bool) isTrue((isEqual(sideRaw, 1)))) ? "add" : "reduce";
        object statusCode = this.safeInteger(innerData, "status");
        object status = ((bool) isTrue((isEqual(statusCode, 1)))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", side },
            { "amount", null },
            { "code", getValue(market, "quote") },
            { "symbol", getValue(market, "symbol") },
            { "status", status },
        };
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name zb#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(getValue(parameters, "positionsId"), null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " addMargin() requires a positionsId argument in the params")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, 1, parameters);
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name zb#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(getValue(parameters, "positionsId"), null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " reduceMargin() requires a positionsId argument in the params")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, 0, parameters);
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object response = await this.spotV1PrivateGetGetLoans(this.extend(request, parameters));
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         result: [
        //             {
        //                 interestRateOfDay: '0.0005',
        //                 repaymentDay: '30',
        //                 amount: '148804.4841',
        //                 balance: '148804.4841',
        //                 rateOfDayShow: '0.05 %',
        //                 coinName: 'USDT',
        //                 lowestAmount: '0.01'
        //             },
        //         ]
        //     }
        //
        object timestamp = this.milliseconds();
        object data = this.safeValue(response, "result", new List<object>() {});
        object rate = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(this.safeString(rate, "coinName")) },
            { "rate", this.safeNumber(rate, "interestRateOfDay") },
            { "period", this.safeNumber(rate, "repaymentDay") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", rate },
        };
    }

    public async override Task<object> fetchBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name zb#fetchBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(getValue(parameters, "coin"), null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowRates() requires a coin argument in the params")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(this.safeString(parameters, "coin"));
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object response = await this.spotV1PrivateGetGetLoans(this.extend(request, parameters));
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         result: [
        //             {
        //                 interestRateOfDay: '0.0005',
        //                 repaymentDay: '30',
        //                 amount: '148804.4841',
        //                 balance: '148804.4841',
        //                 rateOfDayShow: '0.05 %',
        //                 coinName: 'USDT',
        //                 lowestAmount: '0.01'
        //             },
        //         ]
        //     }
        //
        object timestamp = this.milliseconds();
        object data = this.safeValue(response, "result", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(entry, "coinName")) },
                { "rate", this.safeNumber(entry, "interestRateOfDay") },
                { "period", this.safeNumber(entry, "repaymentDay") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "info", entry },
            });
        }
        return rates;
    }

    public async virtual Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the zb api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setPositionMode() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object accountType = null;
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setPositionMode() supports swap contracts only")) ;
        } else
        {
            accountType = 1;
        }
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
            { "positionMode", ((bool) isTrue(hedged)) ? 2 : 1 },
            { "futuresAccountType", accountType },
        };
        object response = await this.contractV2PrivatePostSettingSetPositionsMode(this.extend(request, parameters));
        //
        //     {
        //         "code": 10000,
        //         "desc": "success",
        //         "data": {
        //             "userId": 111,
        //             "marketId": 100,
        //             "leverage": 20,
        //             "marginMode": 1,
        //             "positionsMode": 2,
        //             "enableAutoAppend": 1,
        //             "maxAppendAmount": "11212",
        //             "marginCoins": "qc,usdt,eth",
        //             "id": 6737268451833817088,
        //             "createTime": 1606289971312,
        //             "modifyTime": 0,
        //             "extend": null
        //         }
        //     }
        //
        return response;
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zb#borrowMargin
        * @description create a loan to borrow margin
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the zb api endpoint
        * @param {string} params.safePwd transaction password, extra parameter required for cross margin
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("borrowMargin", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                marginMode = "isolated"; // default to isolated if the symbol is defined
            } else
            {
                marginMode = "cross"; // default to cross
            }
        }
        object password = this.safeString(parameters, "safePwd", this.password);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "safePwd", password },
        };
        object method = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " borrowMargin() requires a symbol argument for isolated margin")) ;
            }
            object marketInner = this.market(symbol);
            ((Dictionary<string, object>)request)["marketName"] = this.safeSymbol(getValue(marketInner, "id"), marketInner, "_");
            method = "spotV1PrivateGetBorrow";
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            method = "spotV1PrivateGetDoCrossLoan";
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功"
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功"
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        var sectionversionaccessVariable = api;
        var section = ((List<object>) sectionversionaccessVariable)[0];
        var version = ((List<object>) sectionversionaccessVariable)[1];
        var access = ((List<object>) sectionversionaccessVariable)[2];
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), section), version), access));
        if (isTrue(isEqual(access, "public")))
        {
            if (isTrue(isEqual(path, "getFeeInfo")))
            {
                url = add(add(this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), section), version), "private")), "/"), path);
            } else
            {
                url = add(url, add(add(add("/", version), "/"), path));
            }
            if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else if (isTrue(isEqual(section, "contract")))
        {
            object timestamp = this.milliseconds();
            object iso8601 = this.iso8601(timestamp);
            object signedString = add(add(add(add(add(iso8601, method), "/Server/api/"), version), "/"), path);
            parameters = this.keysort(parameters);
            headers = new Dictionary<string, object>() {
                { "ZB-APIKEY", this.apiKey },
                { "ZB-TIMESTAMP", iso8601 },
            };
            url = add(url, add(add(add("/", version), "/"), path));
            if (isTrue(isEqual(method, "POST")))
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
                body = this.json(parameters);
                signedString = add(signedString, this.urlencode(parameters));
            } else
            {
                if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
                {
                    object query = this.urlencode(parameters);
                    url = add(url, add("?", query));
                    signedString = add(signedString, query);
                }
            }
            object secret = this.hash(this.encode(this.secret), sha1);
            object signature = this.hmac(this.encode(signedString), this.encode(secret), sha256, "base64");
            ((Dictionary<string, object>)headers)["ZB-SIGN"] = signature;
        } else
        {
            object query = this.keysort(this.extend(new Dictionary<string, object>() {
                { "method", path },
                { "accesskey", this.apiKey },
            }, parameters));
            object nonce = this.nonce();
            query = this.keysort(query);
            object auth = this.rawencode(query);
            object secret = this.hash(this.encode(this.secret), sha1);
            object signature = this.hmac(this.encode(auth), this.encode(secret), md5);
            object suffix = add(add(add("sign=", signature), "&reqTime="), ((object)nonce).ToString());
            url = add(url, add(add(add(add(add("/", path), "?"), auth), "&"), suffix));
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(isEqual(getValue(body, 0), "{")))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            if (isTrue(((Dictionary<string,object>)response).ContainsKey(toStringOrNull("code"))))
            {
                object code = this.safeString(response, "code");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                if (isTrue(isTrue((!isEqual(code, "1000"))) && isTrue((!isEqual(code, "10000")))))
                {
                    throw new ExchangeError ((string)feedback) ;
                }
            }
            // special case for {"result":false,"message":"服务端忙碌"} (a "Busy Server" reply)
            object result = this.safeValue(response, "result");
            if (isTrue(!isEqual(result, null)))
            {
                if (!isTrue(result))
                {
                    object message = this.safeString(response, "message");
                    if (isTrue(isEqual(message, "服务端忙碌")))
                    {
                        throw new ExchangeNotAvailable ((string)feedback) ;
                    } else
                    {
                        throw new ExchangeError ((string)feedback) ;
                    }
                }
            }
        }
        return null;
    }
}
