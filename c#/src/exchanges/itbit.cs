using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class itbit : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "itbit" },
            { "name", "itBit" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 2000 },
            { "version", "v1" },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "createMarketOrder", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.itbit.com" },
                } },
                { "www", "https://www.itbit.com" },
                { "doc", new List<object>() {"https://api.itbit.com/docs", "https://www.itbit.com/api"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"markets/{symbol}/ticker", "markets/{symbol}/order_book", "markets/{symbol}/trades"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"wallets", "wallets/{walletId}", "wallets/{walletId}/balances/{currencyCode}", "wallets/{walletId}/funding_history", "wallets/{walletId}/trades", "wallets/{walletId}/orders", "wallets/{walletId}/orders/{id}"} },
                    { "post", new List<object>() {"wallet_transfers", "wallets", "wallets/{walletId}/cryptocurrency_deposits", "wallets/{walletId}/cryptocurrency_withdrawals", "wallets/{walletId}/orders", "wire_withdrawal"} },
                    { "delete", new List<object>() {"wallets/{walletId}/orders/{id}"} },
                } },
            } },
            { "markets", new Dictionary<string, object>() {
                { "BTC/USD", new Dictionary<string, object>() {
                    { "id", "XBTUSD" },
                    { "symbol", "BTC/USD" },
                    { "base", "BTC" },
                    { "quote", "USD" },
                    { "baseId", "XBT" },
                    { "quoteId", "USD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "BTC/SGD", new Dictionary<string, object>() {
                    { "id", "XBTSGD" },
                    { "symbol", "BTC/SGD" },
                    { "base", "BTC" },
                    { "quote", "SGD" },
                    { "baseId", "XBT" },
                    { "quoteId", "SGD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "BTC/EUR", new Dictionary<string, object>() {
                    { "id", "XBTEUR" },
                    { "symbol", "BTC/EUR" },
                    { "base", "BTC" },
                    { "quote", "EUR" },
                    { "baseId", "XBT" },
                    { "quoteId", "EUR" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "ETH/USD", new Dictionary<string, object>() {
                    { "id", "ETHUSD" },
                    { "symbol", "ETH/USD" },
                    { "base", "ETH" },
                    { "quote", "USD" },
                    { "baseId", "ETH" },
                    { "quoteId", "USD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "ETH/EUR", new Dictionary<string, object>() {
                    { "id", "ETHEUR" },
                    { "symbol", "ETH/EUR" },
                    { "base", "ETH" },
                    { "quote", "EUR" },
                    { "baseId", "ETH" },
                    { "quoteId", "EUR" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "ETH/SGD", new Dictionary<string, object>() {
                    { "id", "ETHSGD" },
                    { "symbol", "ETH/SGD" },
                    { "base", "ETH" },
                    { "quote", "SGD" },
                    { "baseId", "ETH" },
                    { "quoteId", "SGD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "PAXGUSD", new Dictionary<string, object>() {
                    { "id", "PAXGUSD" },
                    { "symbol", "PAXG/USD" },
                    { "base", "PAXG" },
                    { "quote", "USD" },
                    { "baseId", "PAXG" },
                    { "quoteId", "USD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "BCHUSD", new Dictionary<string, object>() {
                    { "id", "BCHUSD" },
                    { "symbol", "BCH/USD" },
                    { "base", "BCH" },
                    { "quote", "USD" },
                    { "baseId", "BCH" },
                    { "quoteId", "USD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
                { "LTCUSD", new Dictionary<string, object>() {
                    { "id", "LTCUSD" },
                    { "symbol", "LTC/USD" },
                    { "base", "LTC" },
                    { "quote", "USD" },
                    { "baseId", "LTC" },
                    { "quoteId", "USD" },
                    { "type", "spot" },
                    { "spot", true },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("-0.0003") },
                    { "taker", this.parseNumber("0.0035") },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "XBT", "BTC" },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object orderbook = await this.publicGetMarketsSymbolOrderBook(this.extend(request, parameters));
        return this.parseOrderBook(orderbook, getValue(market, "symbol"));
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // {
        //     "pair":"XBTUSD",
        //     "bid":"36734.50",
        //     "bidAmt":"0.01000000",
        //     "ask":"36734.75",
        //     "askAmt":"0.30750480",
        //     "lastPrice":"36721.75",
        //     "lastAmt":"0.00070461",
        //     "volume24h":"275.50596346",
        //     "volumeToday":"118.19025141",
        //     "high24h":"37510.50",
        //     "low24h":"35542.75",
        //     "highToday":"37510.50",
        //     "lowToday":"36176.50",
        //     "openToday":"37156.50",
        //     "vwapToday":"37008.22463903",
        //     "vwap24h":"36580.27146808",
        //     "serverTimeUTC":"2022-01-28T14:46:32.4472864Z"
        // }
        //
        object symbol = this.safeSymbol(null, market);
        object serverTimeUTC = this.safeString(ticker, "serverTimeUTC");
        if (!isTrue(serverTimeUTC))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchTicker() returned a bad response: "), this.json(ticker))) ;
        }
        object timestamp = this.parse8601(serverTimeUTC);
        object vwap = this.safeString(ticker, "vwap24h");
        object baseVolume = this.safeString(ticker, "volume24h");
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object last = this.safeString(ticker, "lastPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low24h") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", this.safeString(ticker, "openToday") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object ticker = await this.publicGetMarketsSymbolTicker(this.extend(request, parameters));
        //
        // {
        //     "pair":"XBTUSD",
        //     "bid":"36734.50",
        //     "bidAmt":"0.01000000",
        //     "ask":"36734.75",
        //     "askAmt":"0.30750480",
        //     "lastPrice":"36721.75",
        //     "lastAmt":"0.00070461",
        //     "volume24h":"275.50596346",
        //     "volumeToday":"118.19025141",
        //     "high24h":"37510.50",
        //     "low24h":"35542.75",
        //     "highToday":"37510.50",
        //     "lowToday":"36176.50",
        //     "openToday":"37156.50",
        //     "vwapToday":"37008.22463903",
        //     "vwap24h":"36580.27146808",
        //     "serverTimeUTC":"2022-01-28T14:46:32.4472864Z"
        // }
        //
        return this.parseTicker(ticker, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         timestamp: "2015-05-22T17:45:34.7570000Z",
        //         matchNumber: "5CR1JEUBBM8J",
        //         price: "351.45000000",
        //         amount: "0.00010000"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "orderId": "248ffda4-83a0-4033-a5bb-8929d523f59f",
        //         "timestamp": "2015-05-11T14:48:01.9870000Z",
        //         "instrument": "XBTUSD",
        //         "direction": "buy",                      // buy or sell
        //         "currency1": "XBT",                      // base currency
        //         "currency1Amount": "0.00010000",         // order amount in base currency
        //         "currency2": "USD",                      // quote currency
        //         "currency2Amount": "0.0250530000000000", // order cost in quote currency
        //         "rate": "250.53000000",
        //         "commissionPaid": "0.00000000",   // net trade fee paid after using any available rebate balance
        //         "commissionCurrency": "USD",
        //         "rebatesApplied": "-0.000125265", // negative values represent amount of rebate balance used for trades removing liquidity from order book; positive values represent amount of rebate balance earned from trades adding liquidity to order book
        //         "rebateCurrency": "USD",
        //         "executionId": "23132"
        //     }
        //
        object id = this.safeString2(trade, "executionId", "matchNumber");
        object timestamp = this.parse8601(this.safeString(trade, "timestamp"));
        object side = this.safeString(trade, "direction");
        object orderId = this.safeString(trade, "orderId");
        object feeCost = this.safeNumber(trade, "commissionPaid");
        object feeCurrencyId = this.safeString(trade, "commissionCurrency");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        object rebatesApplied = this.safeNumber(trade, "rebatesApplied");
        if (isTrue(!isEqual(rebatesApplied, null)))
        {
            rebatesApplied = prefixUnaryNeg(ref rebatesApplied);
        }
        object rebateCurrencyId = this.safeString(trade, "rebateCurrency");
        object rebateCurrency = this.safeCurrencyCode(rebateCurrencyId);
        object priceString = this.safeString2(trade, "price", "rate");
        object amountString = this.safeString2(trade, "currency1Amount", "amount");
        object price = this.parseNumber(priceString);
        object amount = this.parseNumber(amountString);
        object cost = this.parseNumber(Precise.stringMul(priceString, amountString));
        object symbol = null;
        object marketId = this.safeString(trade, "instrument");
        if (isTrue(!isEqual(marketId, null)))
        {
            object baseId = this.safeString(trade, "currency1");
            object quoteId = this.safeString(trade, "currency2");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            symbol = add(add(bs, "/"), quote);
        }
        object result = ((object)new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", null },
        });
        if (isTrue(!isEqual(feeCost, null)))
        {
            if (isTrue(!isEqual(rebatesApplied, null)))
            {
                if (isTrue(isEqual(feeCurrency, rebateCurrency)))
                {
                    feeCost = this.sum(feeCost, rebatesApplied);
                    ((Dictionary<string, object>)result)["fee"] = new Dictionary<string, object>() {
                        { "cost", feeCost },
                        { "currency", feeCurrency },
                    };
                } else
                {
                    ((Dictionary<string, object>)result)["fees"] = new List<object>() {new Dictionary<string, object>() {
    { "cost", feeCost },
    { "currency", feeCurrency },
}, new Dictionary<string, object>() {
    { "cost", rebatesApplied },
    { "currency", rebateCurrency },
}};
                }
            } else
            {
                ((Dictionary<string, object>)result)["fee"] = new Dictionary<string, object>() {
                    { "cost", feeCost },
                    { "currency", feeCurrency },
                };
            }
        }
        if (!isTrue((((Dictionary<string,object>)result).ContainsKey(toStringOrNull("fee")))))
        {
            if (!isTrue((((Dictionary<string,object>)result).ContainsKey(toStringOrNull("fees")))))
            {
                ((Dictionary<string, object>)result)["fee"] = null;
            }
        }
        return result;
    }

    public async override Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchTransactions
        * @description fetch history of deposits and withdrawals
        * @param {string|undefined} code not used by itbit fetchTransactions ()
        * @param {int|undefined} since not used by itbit fetchTransactions ()
        * @param {int|undefined} limit max number of transactions to return, default is undefined
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object walletId = this.safeString(parameters, "walletId");
        if (isTrue(isEqual(walletId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransactions() requires a walletId parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "walletId", walletId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["perPage"] = limit; // default 50, max 50
        }
        object response = await this.privateGetWalletsWalletIdFundingHistory(this.extend(request, parameters));
        //     { bankName: 'USBC (usd)',
        //         withdrawalId: 94740,
        //         holdingPeriodCompletionDate: '2018-04-16T07:57:05.9606869',
        //         time: '2018-04-16T07:57:05.9600000',
        //         currency: 'USD',
        //         transactionType: 'Withdrawal',
        //         amount: '2186.72000000',
        //         walletName: 'Wallet',
        //         status: 'completed' },
        //
        //     { "time": "2018-01-02T19:52:22.4176503",
        //     "amount": "0.50000000",
        //     "status": "completed",
        //     "txnHash": "1b6fff67ed83cb9e9a38ca4976981fc047322bc088430508fe764a127d3ace95",
        //     "currency": "XBT",
        //     "walletName": "Wallet",
        //     "transactionType": "Deposit",
        //     "destinationAddress": "3AAWTH9et4e8o51YKp9qPpmujrNXKwHWNX"}
        object items = getValue(response, "fundingHistory");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
        {
            object item = getValue(items, i);
            object time = this.safeString(item, "time");
            object timestamp = this.parse8601(time);
            object currency = this.safeString(item, "currency");
            object destinationAddress = this.safeString(item, "destinationAddress");
            object txnHash = this.safeString(item, "txnHash");
            object transactionType = this.safeStringLower(item, "transactionType");
            object transactionStatus = this.safeString(item, "status");
            object status = this.parseTransferStatus(transactionStatus);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(item, "withdrawalId") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "currency", this.safeCurrencyCode(currency) },
                { "address", destinationAddress },
                { "tag", null },
                { "txid", txnHash },
                { "type", transactionType },
                { "status", status },
                { "amount", this.safeNumber(item, "amount") },
                { "fee", null },
                { "info", item },
            });
        }
        return result;
    }

    public virtual object parseTransferStatus(object status)
    {
        object options = new Dictionary<string, object>() {
            { "cancelled", "canceled" },
            { "completed", "ok" },
        };
        return this.safeString(options, status, "pending");
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object walletId = this.safeString(parameters, "walletId");
        if (isTrue(isEqual(walletId, null)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchMyTrades() requires a walletId parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "walletId", walletId },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["rangeStart"] = this.ymdhms(since, "T");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["perPage"] = limit; // default 50, max 50
        }
        object response = await this.privateGetWalletsWalletIdTrades(this.extend(request, parameters));
        //
        //     {
        //         "totalNumberOfRecords": "2",
        //         "currentPageNumber": "1",
        //         "latestExecutionId": "332", // most recent execution at time of response
        //         "recordsPerPage": "50",
        //         "tradingHistory": [
        //             {
        //                 "orderId": "248ffda4-83a0-4033-a5bb-8929d523f59f",
        //                 "timestamp": "2015-05-11T14:48:01.9870000Z",
        //                 "instrument": "XBTUSD",
        //                 "direction": "buy",                      // buy or sell
        //                 "currency1": "XBT",                      // base currency
        //                 "currency1Amount": "0.00010000",         // order amount in base currency
        //                 "currency2": "USD",                      // quote currency
        //                 "currency2Amount": "0.0250530000000000", // order cost in quote currency
        //                 "rate": "250.53000000",
        //                 "commissionPaid": "0.00000000",   // net trade fee paid after using any available rebate balance
        //                 "commissionCurrency": "USD",
        //                 "rebatesApplied": "-0.000125265", // negative values represent amount of rebate balance used for trades removing liquidity from order book; positive values represent amount of rebate balance earned from trades adding liquidity to order book
        //                 "rebateCurrency": "USD",
        //                 "executionId": "23132"
        //             },
        //         ],
        //     }
        //
        object trades = this.safeValue(response, "tradingHistory", new List<object>() {});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsSymbolTrades(this.extend(request, parameters));
        //
        //     {
        //         count: 3,
        //         recentTrades: [
        //             {
        //                 timestamp: "2015-05-22T17:45:34.7570000Z",
        //                 matchNumber: "5CR1JEUBBM8J",
        //                 price: "351.45000000",
        //                 amount: "0.00010000"
        //             },
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "recentTrades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseBalance(object response)
    {
        object balances = getValue(getValue(response, 0), "balances");
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "totalBalance");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.fetchWallets(parameters);
        return this.parseBalance(response);
    }

    public async virtual Task<object> fetchWallets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (!isTrue(this.uid))
        {
            throw new AuthenticationError ((string)add(this.id, " fetchWallets() requires uid API credential")) ;
        }
        object request = new Dictionary<string, object>() {
            { "userId", this.uid },
        };
        return await this.privateGetWallets(this.extend(request, parameters));
    }

    public async virtual Task<object> fetchWallet(object walletId, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "walletId", walletId },
        };
        return await this.privateGetWalletsWalletId(this.extend(request, parameters));
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "open" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "filled" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object walletIdInParams = (((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("walletId")));
        if (!isTrue(walletIdInParams))
        {
            throw new ExchangeError ((string)add(this.id, " fetchOrders() requires a walletId parameter")) ;
        }
        object walletId = getValue(parameters, "walletId");
        object request = new Dictionary<string, object>() {
            { "walletId", walletId },
        };
        object response = await this.privateGetWalletsWalletIdOrders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "submitted", "open" },
            { "open", "open" },
            { "filled", "closed" },
            { "cancelled", "canceled" },
            { "rejected", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "id": "13d6af57-8b0b-41e5-af30-becf0bcc574d",
        //         "walletId": "7e037345-1288-4c39-12fe-d0f99a475a98",
        //         "side": "buy",
        //         "instrument": "XBTUSD",
        //         "type": "limit",
        //         "currency": "XBT",
        //         "amount": "2.50000000",
        //         "displayAmount": "2.50000000",
        //         "price": "650.00000000",
        //         "volumeWeightedAveragePrice": "0.00000000",
        //         "amountFilled": "0.00000000",
        //         "createdTime": "2014-02-11T17:05:15Z",
        //         "status": "submitted",
        //         "funds": null,
        //         "metadata": {},
        //         "clientOrderIdentifier": null,
        //         "postOnly": "False"
        //     }
        //
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "type");
        object marketId = this.safeString(order, "instrument");
        object symbol = this.safeSymbol(marketId, market);
        object datetime = this.safeString(order, "createdTime");
        object timestamp = this.parse8601(datetime);
        object amount = this.safeString(order, "amount");
        object filled = this.safeString(order, "amountFilled");
        object fee = null;
        object price = this.safeString(order, "price");
        object average = this.safeString(order, "volumeWeightedAveragePrice");
        object clientOrderId = this.safeString(order, "clientOrderIdentifier");
        object id = this.safeString(order, "id");
        object postOnlyString = this.safeString(order, "postOnly");
        object postOnly = (isEqual(postOnlyString, "True"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseOrderStatus(this.safeString(order, "status")) },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "cost", null },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#createOrder
        * @description create a trade order
        * @see https://api.itbit.com/docs#trading-new-order-post
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type must be 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(type, "market")))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() allows limit orders only")) ;
        }
        object walletIdInParams = (((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("walletId")));
        if (!isTrue(walletIdInParams))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() requires a walletId parameter")) ;
        }
        amount = ((object)amount).ToString();
        price = ((object)price).ToString();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "side", side },
            { "type", type },
            { "currency", ((string)getValue(market, "id")).Replace((string)getValue(market, "quote"), (string)"") },
            { "amount", amount },
            { "display", amount },
            { "price", price },
            { "instrument", getValue(market, "id") },
        };
        object response = await this.privatePostWalletsWalletIdOrders(this.extend(request, parameters));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", getValue(response, "id") },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol not used by itbit fetchOrder
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object walletIdInParams = (((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("walletId")));
        if (!isTrue(walletIdInParams))
        {
            throw new ExchangeError ((string)add(this.id, " fetchOrder() requires a walletId parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetWalletsWalletIdOrdersId(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name itbit#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the itbit api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object walletIdInParams = (((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("walletId")));
        if (!isTrue(walletIdInParams))
        {
            throw new ExchangeError ((string)add(this.id, " cancelOrder() requires a walletId parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        return await this.privateDeleteWalletsWalletIdOrdersId(this.extend(request, parameters));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), "rest"), "/"), this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isTrue(isEqual(method, "GET")) && isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys)))))
        {
            url = add(url, add("?", this.urlencode(query)));
        }
        if (isTrue(isTrue(isEqual(method, "POST")) && isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys)))))
        {
            body = this.json(query);
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object timestamp = nonce;
            object authBody = ((bool) isTrue((isEqual(method, "POST")))) ? body : "";
            object auth = new List<object>() {method, url, authBody, nonce, timestamp};
            object message = add(nonce, this.json(auth)); // .replace ('\\/', '/');
            object hash = this.hash(this.encode(message), sha256, "binary");
            object binaryUrl = this.encode(url);
            object binhash = this.binaryConcat(binaryUrl, hash);
            object signature = this.hmac(binhash, this.encode(this.secret), sha512, "base64");
            headers = new Dictionary<string, object>() {
                { "Authorization", add(add(this.apiKey, ":"), signature) },
                { "Content-Type", "application/json" },
                { "X-Auth-Timestamp", timestamp },
                { "X-Auth-Nonce", nonce },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object code = this.safeString(response, "code");
        if (isTrue(!isEqual(code, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), this.json(response))) ;
        }
        return null;
    }
}
