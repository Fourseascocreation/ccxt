using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bitrue : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitrue" },
            { "name", "Bitrue" },
            { "countries", new List<object>() {"SG"} },
            { "rateLimit", 1000 },
            { "certified", false },
            { "version", "v1" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", null },
                { "future", null },
                { "option", false },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchPositionMode", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "1d", "1D" },
                { "1w", "1W" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/139516488-243a830d-05dd-446b-91c6-c1f18fe30c63.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "v1", "https://www.bitrue.com/api/v1" },
                    { "v2", "https://www.bitrue.com/api/v2" },
                    { "kline", "https://www.bitrue.com/kline-api" },
                } },
                { "www", "https://www.bitrue.com" },
                { "referral", "https://www.bitrue.com/activity/task/task-landing?inviteCode=EZWETQE&cn=900000" },
                { "doc", new List<object>() {"https://github.com/Bitrue-exchange/bitrue-official-api-docs"} },
                { "fees", "https://bitrue.zendesk.com/hc/en-001/articles/4405479952537" },
            } },
            { "api", new Dictionary<string, object>() {
                { "kline", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "public.json", 1 },
                            { "public{currency}.json", 1 },
                        } },
                    } },
                } },
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "ping", 1 },
                            { "time", 1 },
                            { "exchangeInfo", 1 },
                            { "depth", new Dictionary<string, object>() {
                                { "cost", 1 },
                                { "byLimit", new List<object>() {new List<object>() {100, 1}, new List<object>() {500, 5}, new List<object>() {1000, 10}} },
                            } },
                            { "trades", 1 },
                            { "historicalTrades", 5 },
                            { "aggTrades", 1 },
                            { "ticker/24hr", new Dictionary<string, object>() {
                                { "cost", 1 },
                                { "noSymbol", 40 },
                            } },
                            { "ticker/price", new Dictionary<string, object>() {
                                { "cost", 1 },
                                { "noSymbol", 2 },
                            } },
                            { "ticker/bookTicker", new Dictionary<string, object>() {
                                { "cost", 1 },
                                { "noSymbol", 2 },
                            } },
                            { "market/kline", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "openOrders", 1 },
                            { "allOrders", 5 },
                            { "account", 5 },
                            { "myTrades", new Dictionary<string, object>() {
                                { "cost", 5 },
                                { "noSymbol", 40 },
                            } },
                            { "etf/net-value/{symbol}", 1 },
                            { "withdraw/history", 1 },
                            { "deposit/history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 4 },
                            { "withdraw/commit", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "myTrades", 5 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.00098") },
                    { "maker", this.parseNumber("0.00098") },
                } },
                { "future", new Dictionary<string, object>() {
                    { "trading", new Dictionary<string, object>() {
                        { "feeSide", "quote" },
                        { "tierBased", true },
                        { "percentage", true },
                        { "taker", this.parseNumber("0.000400") },
                        { "maker", this.parseNumber("0.000200") },
                        { "tiers", new Dictionary<string, object>() {
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000350")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000320")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000300")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000270")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000250")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000220")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000200")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0.000170")}} },
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000200")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000160")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000140")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000120")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000100")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000080")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000060")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000040")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000020")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0")}} },
                        } },
                    } },
                } },
                { "delivery", new Dictionary<string, object>() {
                    { "trading", new Dictionary<string, object>() {
                        { "feeSide", "base" },
                        { "tierBased", true },
                        { "percentage", true },
                        { "taker", this.parseNumber("0.000500") },
                        { "maker", this.parseNumber("0.000100") },
                        { "tiers", new Dictionary<string, object>() {
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000500")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000450")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000300")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000250")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0.000240")}} },
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000100")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000080")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000050")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.0000030")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0")}, new List<object> {this.parseNumber("50000"), this.parseNumber("-0.000050")}, new List<object> {this.parseNumber("100000"), this.parseNumber("-0.000060")}, new List<object> {this.parseNumber("200000"), this.parseNumber("-0.000070")}, new List<object> {this.parseNumber("400000"), this.parseNumber("-0.000080")}, new List<object> {this.parseNumber("750000"), this.parseNumber("-0.000090")}} },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchMyTradesMethod", "v2PrivateGetMyTrades" },
                { "hasAlreadyAuthenticatedSuccessfully", false },
                { "recvWindow", multiply(5, 1000) },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "parseOrderToPrecision", false },
                { "newOrderRespType", new Dictionary<string, object>() {
                    { "market", "FULL" },
                    { "limit", "FULL" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "TRC20", "TRX" },
                    { "TRON", "TRX" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "MIM", "MIM Swarm" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "System is under maintenance.", typeof(OnMaintenance) },
                    { "System abnormality", typeof(ExchangeError) },
                    { "You are not authorized to execute this request.", typeof(PermissionDenied) },
                    { "API key does not exist", typeof(AuthenticationError) },
                    { "Order would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Stop price would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Order would immediately match and take.", typeof(OrderImmediatelyFillable) },
                    { "Account has insufficient balance for requested action.", typeof(InsufficientFunds) },
                    { "Rest API trading is not enabled.", typeof(ExchangeNotAvailable) },
                    { "You don\'t have permission.", typeof(PermissionDenied) },
                    { "Market is closed.", typeof(ExchangeNotAvailable) },
                    { "Too many requests. Please try again later.", typeof(DDoSProtection) },
                    { "-1000", typeof(ExchangeNotAvailable) },
                    { "-1001", typeof(ExchangeNotAvailable) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1013", typeof(InvalidOrder) },
                    { "-1015", typeof(RateLimitExceeded) },
                    { "-1016", typeof(ExchangeNotAvailable) },
                    { "-1020", typeof(BadRequest) },
                    { "-1021", typeof(InvalidNonce) },
                    { "-1022", typeof(AuthenticationError) },
                    { "-1100", typeof(BadRequest) },
                    { "-1101", typeof(BadRequest) },
                    { "-1102", typeof(BadRequest) },
                    { "-1103", typeof(BadRequest) },
                    { "-1104", typeof(BadRequest) },
                    { "-1105", typeof(BadRequest) },
                    { "-1106", typeof(BadRequest) },
                    { "-1111", typeof(BadRequest) },
                    { "-1112", typeof(InvalidOrder) },
                    { "-1114", typeof(BadRequest) },
                    { "-1115", typeof(BadRequest) },
                    { "-1116", typeof(BadRequest) },
                    { "-1117", typeof(BadRequest) },
                    { "-1118", typeof(BadRequest) },
                    { "-1119", typeof(BadRequest) },
                    { "-1120", typeof(BadRequest) },
                    { "-1121", typeof(BadSymbol) },
                    { "-1125", typeof(AuthenticationError) },
                    { "-1127", typeof(BadRequest) },
                    { "-1128", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1131", typeof(BadRequest) },
                    { "-2008", typeof(AuthenticationError) },
                    { "-2010", typeof(ExchangeError) },
                    { "-2011", typeof(OrderNotFound) },
                    { "-2013", typeof(OrderNotFound) },
                    { "-2014", typeof(AuthenticationError) },
                    { "-2015", typeof(AuthenticationError) },
                    { "-2019", typeof(InsufficientFunds) },
                    { "-3005", typeof(InsufficientFunds) },
                    { "-3006", typeof(InsufficientFunds) },
                    { "-3008", typeof(InsufficientFunds) },
                    { "-3010", typeof(ExchangeError) },
                    { "-3015", typeof(ExchangeError) },
                    { "-3022", typeof(AccountSuspended) },
                    { "-4028", typeof(BadRequest) },
                    { "-3020", typeof(InsufficientFunds) },
                    { "-3041", typeof(InsufficientFunds) },
                    { "-5013", typeof(InsufficientFunds) },
                    { "-11008", typeof(InsufficientFunds) },
                    { "-4051", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "has no operation privilege", typeof(PermissionDenied) },
                    { "MAX_POSITION", typeof(InvalidOrder) },
                } },
            } },
        });
    }

    public override object costToPrecision(object symbol, object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "quote"), this.precisionMode, this.paddingMode);
    }

    public override object currencyToPrecision(object code, object fee, object networkCode = null)
    {
        // info is available in currencies only if the user has configured his api keys
        if (isTrue(!isEqual(this.safeValue(getValue(this.currencies, code), "precision"), null)))
        {
            return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(this.currencies, code), "precision"), this.precisionMode, this.paddingMode);
        } else
        {
            return this.numberToString(fee);
        }
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetPing(parameters);
        //
        // empty means working status.
        //
        //     {}
        //
        object keys = new List<string>(((Dictionary<string,object>)response).Keys);
        object keysLength = getArrayLength(keys);
        object formattedStatus = ((bool) isTrue(keysLength)) ? "maintenance" : "ok";
        return new Dictionary<string, object>() {
            { "status", formattedStatus },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetTime(parameters);
        //
        //     {
        //         "serverTime":1635467280514
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    public virtual object safeNetwork(object networkId)
    {
        object uppercaseNetworkId = ((string)networkId).ToUpper();
        object networksById = new Dictionary<string, object>() {
            { "Aeternity", "Aeternity" },
            { "AION", "AION" },
            { "Algorand", "Algorand" },
            { "ASK", "ASK" },
            { "ATOM", "ATOM" },
            { "AVAX C-Chain", "AVAX C-Chain" },
            { "bch", "bch" },
            { "BCH", "BCH" },
            { "BEP2", "BEP2" },
            { "BEP20", "BEP20" },
            { "Bitcoin", "Bitcoin" },
            { "BRP20", "BRP20" },
            { "Cardano", "ADA" },
            { "CasinoCoin", "CasinoCoin" },
            { "CasinoCoin XRPL", "CasinoCoin XRPL" },
            { "Contentos", "Contentos" },
            { "Dash", "Dash" },
            { "Decoin", "Decoin" },
            { "DeFiChain", "DeFiChain" },
            { "DGB", "DGB" },
            { "Divi", "Divi" },
            { "dogecoin", "DOGE" },
            { "EOS", "EOS" },
            { "ERC20", "ERC20" },
            { "ETC", "ETC" },
            { "Filecoin", "Filecoin" },
            { "FREETON", "FREETON" },
            { "HBAR", "HBAR" },
            { "Hedera Hashgraph", "Hedera Hashgraph" },
            { "HRC20", "HRC20" },
            { "ICON", "ICON" },
            { "ICP", "ICP" },
            { "Ignis", "Ignis" },
            { "Internet Computer", "Internet Computer" },
            { "IOTA", "IOTA" },
            { "KAVA", "KAVA" },
            { "KSM", "KSM" },
            { "LiteCoin", "LiteCoin" },
            { "Luna", "Luna" },
            { "MATIC", "MATIC" },
            { "Mobile Coin", "Mobile Coin" },
            { "MonaCoin", "MonaCoin" },
            { "Monero", "Monero" },
            { "NEM", "NEM" },
            { "NEP5", "NEP5" },
            { "OMNI", "OMNI" },
            { "PAC", "PAC" },
            { "Polkadot", "Polkadot" },
            { "Ravencoin", "Ravencoin" },
            { "Safex", "Safex" },
            { "SOLANA", "SOL" },
            { "Songbird", "Songbird" },
            { "Stellar Lumens", "Stellar Lumens" },
            { "Symbol", "Symbol" },
            { "Tezos", "XTZ" },
            { "theta", "theta" },
            { "THETA", "THETA" },
            { "TRC20", "TRC20" },
            { "VeChain", "VeChain" },
            { "VECHAIN", "VECHAIN" },
            { "Wanchain", "Wanchain" },
            { "XinFin Network", "XinFin Network" },
            { "XRP", "XRP" },
            { "XRPL", "XRPL" },
            { "ZIL", "ZIL" },
        };
        return this.safeString2(networksById, networkId, uppercaseNetworkId, networkId);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetExchangeInfo(parameters);
        //
        //     {
        //         "timezone":"CTT",
        //         "serverTime":1635464889117,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUESTS_WEIGHT","interval":"MINUTES","limit":6000},
        //             {"rateLimitType":"ORDERS","interval":"SECONDS","limit":150},
        //             {"rateLimitType":"ORDERS","interval":"DAYS","limit":288000},
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"SHABTC",
        //                 "status":"TRADING",
        //                 "baseAsset":"sha",
        //                 "baseAssetPrecision":0,
        //                 "quoteAsset":"btc",
        //                 "quotePrecision":10,
        //                 "orderTypes":["MARKET","LIMIT"],
        //                 "icebergAllowed":false,
        //                 "filters":[
        //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000001349","maxPrice":"0.00000017537","priceScale":10},
        //                     {"filterType":"LOT_SIZE","minQty":"1.0","minVal":"0.00020","maxQty":"1000000000","volumeScale":0},
        //                 ],
        //                 "defaultPrice":"0.0000006100",
        //             },
        //         ],
        //         "coins":[
        //           {
        //               coin: "near",
        //               coinFulName: "NEAR Protocol",
        //               chains: [ "BEP20", ],
        //               chainDetail: [
        //                 {
        //                     chain: "BEP20",
        //                     enableWithdraw: true,
        //                     enableDeposit: true,
        //                     withdrawFee: "0.2000",
        //                     minWithdraw: "5.0000",
        //                     maxWithdraw: "1000000000000000.0000",
        //                 },
        //               ],
        //           },
        //         ],
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object coins = this.safeValue(response, "coins", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(coins)); postFixIncrement(ref i))
        {
            object currency = getValue(coins, i);
            object id = this.safeString(currency, "coin");
            object name = this.safeString(currency, "coinFulName");
            object code = this.safeCurrencyCode(id);
            object enableDeposit = this.safeValue(currency, "enableDeposit");
            object enableWithdraw = this.safeValue(currency, "enableWithdraw");
            object networkIds = this.safeValue(currency, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networkIds)); postFixIncrement(ref j))
            {
                object networkId = getValue(networkIds, j);
                object network = this.safeNetwork(networkId);
                ((Dictionary<string, object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", networkId },
                    { "id", networkId },
                    { "network", network },
                    { "active", null },
                    { "fee", null },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            object active = (isTrue(enableWithdraw) && isTrue(enableDeposit));
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", null },
                { "info", currency },
                { "active", active },
                { "deposit", enableDeposit },
                { "withdraw", enableWithdraw },
                { "networks", networks },
                { "fee", this.safeNumber(currency, "withdrawFee") },
                { "limits", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minWithdraw") },
                        { "max", this.safeNumber(currency, "maxWithdraw") },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchMarkets
        * @description retrieves data on all markets for bitrue
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetExchangeInfo(parameters);
        //
        //     {
        //         "timezone":"CTT",
        //         "serverTime":1635464889117,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUESTS_WEIGHT","interval":"MINUTES","limit":6000},
        //             {"rateLimitType":"ORDERS","interval":"SECONDS","limit":150},
        //             {"rateLimitType":"ORDERS","interval":"DAYS","limit":288000},
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"SHABTC",
        //                 "status":"TRADING",
        //                 "baseAsset":"sha",
        //                 "baseAssetPrecision":0,
        //                 "quoteAsset":"btc",
        //                 "quotePrecision":10,
        //                 "orderTypes":["MARKET","LIMIT"],
        //                 "icebergAllowed":false,
        //                 "filters":[
        //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000001349","maxPrice":"0.00000017537","priceScale":10},
        //                     {"filterType":"LOT_SIZE","minQty":"1.0","minVal":"0.00020","maxQty":"1000000000","volumeScale":0},
        //                 ],
        //                 "defaultPrice":"0.0000006100",
        //             },
        //         ],
        //         "coins":[
        //             {
        //                 "coin":"sbr",
        //                 "coinFulName":"Saber",
        //                 "enableWithdraw":true,
        //                 "enableDeposit":true,
        //                 "chains":["SOLANA"],
        //                 "withdrawFee":"2.0",
        //                 "minWithdraw":"5.0",
        //                 "maxWithdraw":"1000000000000000",
        //             },
        //         ],
        //     }
        //
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object markets = this.safeValue(response, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "symbol");
            object lowercaseId = this.safeStringLower(market, "symbol");
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object filters = this.safeValue(market, "filters", new List<object>() {});
            object filtersByType = this.indexBy(filters, "filterType");
            object status = this.safeString(market, "status");
            object priceFilter = this.safeValue(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
            object amountFilter = this.safeValue(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
            object defaultPricePrecision = this.safeString(market, "pricePrecision");
            object defaultAmountPrecision = this.safeString(market, "quantityPrecision");
            object pricePrecision = this.safeString(priceFilter, "priceScale", defaultPricePrecision);
            object amountPrecision = this.safeString(amountFilter, "volumeScale", defaultAmountPrecision);
            object entry = new Dictionary<string, object>() {
                { "id", id },
                { "lowercaseId", lowercaseId },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(status, "TRADING")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(amountPrecision)) },
                    { "price", this.parseNumber(this.parsePrecision(pricePrecision)) },
                    { "base", this.parseNumber(this.parsePrecision(this.safeString(market, "baseAssetPrecision"))) },
                    { "quote", this.parseNumber(this.parsePrecision(this.safeString(market, "quotePrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(amountFilter, "minQty") },
                        { "max", this.safeNumber(amountFilter, "maxQty") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(priceFilter, "minPrice") },
                        { "max", this.safeNumber(priceFilter, "maxPrice") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(amountFilter, "minVal") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            };
            ((List<object>)result).Add(entry);
        }
        return result;
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object timestamp = this.safeInteger(response, "updateTime");
        object balances = this.safeValue(response, "balances", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "free");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "locked");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        ((Dictionary<string, object>)result)["timestamp"] = timestamp;
        ((Dictionary<string, object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetAccount(parameters);
        //
        //     {
        //         "makerCommission":0,
        //         "takerCommission":0,
        //         "buyerCommission":0,
        //         "sellerCommission":0,
        //         "updateTime":null,
        //         "balances":[
        //             {"asset":"sbr","free":"0","locked":"0"},
        //             {"asset":"ksm","free":"0","locked":"0"},
        //             {"asset":"neo3s","free":"0","locked":"0"},
        //         ],
        //         "canTrade":false,
        //         "canWithdraw":false,
        //         "canDeposit":false
        //     }
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 1000, see https://github.com/Bitrue-exchange/bitrue-official-api-docs#order-book
        }
        object response = await this.v1PublicGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "lastUpdateId":1635474910177,
        //         "bids":[
        //             ["61436.84","0.05",[]],
        //             ["61435.77","0.0124",[]],
        //             ["61434.88","0.012",[]],
        //         ],
        //         "asks":[
        //             ["61452.46","0.0001",[]],
        //             ["61452.47","0.0597",[]],
        //             ["61452.76","0.0713",[]],
        //         ]
        //     }
        //
        object orderbook = this.parseOrderBook(response, symbol);
        ((Dictionary<string, object>)orderbook)["nonce"] = this.safeInteger(response, "lastUpdateId");
        return orderbook;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "id":397945892,
        //         "last":"1.143411",
        //         "lowestAsk":"1.144223",
        //         "highestBid":"1.141696",
        //         "percentChange":"-0.001432",
        //         "baseVolume":"338287",
        //         "quoteVolume":"415013.244366",
        //         "isFrozen":"0",
        //         "high24hr":"1.370087",
        //         "low24hr":"1.370087",
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high24hr") },
            { "low", this.safeString(ticker, "low24hr") },
            { "bid", this.safeString(ticker, "highestBid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "lowestAsk") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(ticker, "percentChange") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "baseVolume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseBaseId = this.safeStringUpper(market, "baseId");
        object uppercaseQuoteId = this.safeStringUpper(market, "quoteId");
        object request = new Dictionary<string, object>() {
            { "currency", uppercaseQuoteId },
            { "command", "returnTicker" },
        };
        object response = await this.klinePublicGetPublicCurrencyJson(this.extend(request, parameters));
        //
        //     {
        //         "code":"200",
        //         "msg":"success",
        //         "data":{
        //             "DODO3S_USDT":{
        //                 "id":397945892,
        //                 "last":"1.143411",
        //                 "lowestAsk":"1.144223",
        //                 "highestBid":"1.141696",
        //                 "percentChange":"-0.001432",
        //                 "baseVolume":"338287",
        //                 "quoteVolume":"415013.244366",
        //                 "isFrozen":"0",
        //                 "high24hr":"1.370087",
        //                 "low24hr":"1.370087"
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object id = add(add(uppercaseBaseId, "_"), uppercaseQuoteId);
        object ticker = this.safeValue(data, id);
        if (isTrue(isEqual(ticker, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchTicker() could not find the ticker for "), getValue(market, "symbol"))) ;
        }
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "scale", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetMarketKline(this.extend(request, parameters));
        //
        //       {
        //           "symbol":"BTCUSDT",
        //           "scale":"KLINE_1MIN",
        //           "data":[
        //                {
        //                   "i":"1660825020",
        //                   "a":"93458.778",
        //                   "v":"3.9774",
        //                   "c":"23494.99",
        //                   "h":"23509.63",
        //                   "l":"23491.93",
        //                   "o":"23508.34"
        //                }
        //           ]
        //       }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //      {
        //         "i":"1660825020",
        //         "a":"93458.778",
        //         "v":"3.9774",
        //         "c":"23494.99",
        //         "h":"23509.63",
        //         "l":"23491.93",
        //         "o":"23508.34"
        //      }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "i"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchBidsAsks
        * @description fetches the bid and ask price and volume for multiple markets
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultType = this.safeString2(this.options, "fetchBidsAsks", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object query = this.omit(parameters, "type");
        object method = null;
        if (isTrue(isEqual(type, "future")))
        {
            method = "fapiPublicGetTickerBookTicker";
        } else if (isTrue(isEqual(type, "delivery")))
        {
            method = "dapiPublicGetTickerBookTicker";
        } else
        {
            method = "publicGetTickerBookTicker";
        }
        object response = await this.callAsync(method, query);
        return this.parseTickers(response, symbols);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "command", "returnTicker" },
        };
        object response = await this.klinePublicGetPublicJson(this.extend(request, parameters));
        //
        //     {
        //         "code":"200",
        //         "msg":"success",
        //         "data":{
        //             "DODO3S_USDT":{
        //                 "id":397945892,
        //                 "last":"1.143411",
        //                 "lowestAsk":"1.144223",
        //                 "highestBid":"1.141696",
        //                 "percentChange":"-0.001432",
        //                 "baseVolume":"338287",
        //                 "quoteVolume":"415013.244366",
        //                 "isFrozen":"0",
        //                 "high24hr":"1.370087",
        //                 "low24hr":"1.370087"
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        // the exchange returns market ids with an underscore from the tickers endpoint
        // the market ids do not have an underscore, so it has to be removed
        // https://github.com/ccxt/ccxt/issues/13856
        object tickers = new Dictionary<string, object>() {};
        object marketIds = new List<string>(((Dictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = ((string)getValue(marketIds, i)).Replace((string)"_", (string)"");
            ((Dictionary<string, object>)tickers)[(string)marketId] = getValue(data, getValue(marketIds, i));
        }
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // aggregate trades
        //
        //     {
        //         "a": 26129,         // Aggregate tradeId
        //         "p": "0.01633102",  // Price
        //         "q": "4.70443515",  // Quantity
        //         "f": 27781,         // First tradeId
        //         "l": 27781,         // Last tradeId
        //         "T": 1498793709153, // Timestamp
        //         "m": true,          // Was the buyer the maker?
        //         "M": true           // Was the trade the best price match?
        //     }
        //
        // recent public trades and old public trades
        //
        //     {
        //         "id": 28457,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "time": 1499865549590,
        //         "isBuyerMaker": true,
        //         "isBestMatch": true
        //     }
        //
        // private trades
        //
        //     {
        //         "symbol":"USDCUSDT",
        //         "id":20725156,
        //         "orderId":2880918576,
        //         "origClientOrderId":null,
        //         "price":"0.9996000000000000",
        //         "qty":"100.0000000000000000",
        //         "commission":null,
        //         "commissionAssert":null,
        //         "time":1635558511000,
        //         "isBuyer":false,
        //         "isMaker":false,
        //         "isBestMatch":true
        //     }
        //
        object timestamp = this.safeInteger2(trade, "T", "time");
        object priceString = this.safeString2(trade, "p", "price");
        object amountString = this.safeString2(trade, "q", "qty");
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object id = this.safeString2(trade, "t", "a");
        id = this.safeString2(trade, "id", "tradeId", id);
        object side = null;
        object orderId = this.safeString(trade, "orderId");
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("m"))))
        {
            side = ((bool) isTrue(getValue(trade, "m"))) ? "sell" : "buy"; // this is reversed intentionally
        } else if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isBuyerMaker"))))
        {
            side = ((bool) isTrue(getValue(trade, "isBuyerMaker"))) ? "sell" : "buy";
        } else if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("side"))))
        {
            side = this.safeStringLower(trade, "side");
        } else
        {
            if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isBuyer"))))
            {
                side = ((bool) isTrue(getValue(trade, "isBuyer"))) ? "buy" : "sell"; // this is a true side
            }
        }
        object fee = null;
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("commission"))))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "commission") },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "commissionAssert")) },
            };
        }
        object takerOrMaker = null;
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isMaker"))))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "isMaker"))) ? "maker" : "taker";
        }
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("maker"))))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "maker"))) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.safeString(this.options, "fetchTradesMethod", "v1PublicGetAggTrades");
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 1000
        }
        //
        // Caveats:
        // - default limit (500) applies only if no other parameters set, trades up
        //   to the maximum limit may be returned to satisfy other parameters
        // - if both limit and time window is set and time window contains more
        //   trades than the limit then the last trades from the window are returned
        // - 'tradeId' accepted and returned by this method is "aggregate" trade id
        //   which is different from actual trade id
        // - setting both fromId and time window results in error
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // aggregate trades
        //
        //     [
        //         {
        //             "a": 26129,         // Aggregate tradeId
        //             "p": "0.01633102",  // Price
        //             "q": "4.70443515",  // Quantity
        //             "f": 27781,         // First tradeId
        //             "l": 27781,         // Last tradeId
        //             "T": 1498793709153, // Timestamp
        //             "m": true,          // Was the buyer the maker?
        //             "M": true           // Was the trade the best price match?
        //         }
        //     ]
        //
        // recent public trades and historical public trades
        //
        //     [
        //         {
        //             "id": 28457,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "time": 1499865549590,
        //             "isBuyerMaker": true,
        //             "isBestMatch": true
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "PENDING_CANCEL", "canceling" },
            { "REJECTED", "rejected" },
            { "EXPIRED", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "symbol":"USDCUSDT",
        //         "orderId":2878854881,
        //         "clientOrderId":"",
        //         "transactTime":1635551031276
        //     }
        //
        // fetchOpenOrders
        //
        //     {
        //         "symbol":"USDCUSDT",
        //         "orderId":"2878854881",
        //         "clientOrderId":"",
        //         "price":"1.1000000000000000",
        //         "origQty":"100.0000000000000000",
        //         "executedQty":"0.0000000000000000",
        //         "cummulativeQuoteQty":"0.0000000000000000",
        //         "status":"NEW",
        //         "timeInForce":"",
        //         "type":"LIMIT",
        //         "side":"SELL",
        //         "stopPrice":"",
        //         "icebergQty":"",
        //         "time":1635551031000,
        //         "updateTime":1635551031000,
        //         "isWorking":false
        //     }
        //
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object filled = this.safeString(order, "executedQty");
        object timestamp = null;
        object lastTradeTimestamp = null;
        if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("time"))))
        {
            timestamp = this.safeInteger(order, "time");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("transactTime"))))
        {
            timestamp = this.safeInteger(order, "transactTime");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("updateTime"))))
        {
            if (isTrue(isEqual(status, "open")))
            {
                if (isTrue(Precise.stringGt(filled, "0")))
                {
                    lastTradeTimestamp = this.safeInteger(order, "updateTime");
                } else
                {
                    timestamp = this.safeInteger(order, "updateTime");
                }
            }
        }
        object average = this.safeString(order, "avgPrice");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "origQty");
        // - Spot/Margin market: cummulativeQuoteQty
        // - Futures market: cumQuote.
        //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
        object cost = this.safeString2(order, "cummulativeQuoteQty", "cumQuote");
        object id = this.safeString(order, "orderId");
        object type = this.safeStringLower(order, "type");
        object side = this.safeStringLower(order, "side");
        object fills = this.safeValue(order, "fills", new List<object>() {});
        object clientOrderId = this.safeString(order, "clientOrderId");
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(timeInForce, "GTX")));
        if (isTrue(isEqual(type, "limit_maker")))
        {
            type = "limit";
        }
        object stopPriceString = this.safeString(order, "stopPrice");
        object stopPrice = this.parseNumber(this.omitZero(stopPriceString));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", fills },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseType = ((string)type).ToUpper();
        object validOrderTypes = this.safeValue(getValue(market, "info"), "orderTypes");
        if (!isTrue(this.inArray(uppercaseType, validOrderTypes)))
        {
            throw new InvalidOrder ((string)add(add(add(add(this.id, " "), type), " is not a valid order type in market "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "type", uppercaseType },
            { "quantity", this.amountToPrecision(symbol, amount) },
        };
        object clientOrderId = this.safeString2(parameters, "newClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"newClientOrderId", "clientOrderId"});
            ((Dictionary<string, object>)request)["newClientOrderId"] = clientOrderId;
        }
        if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() requires a price argument")) ;
            }
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object stopPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
            ((Dictionary<string, object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
        }
        object response = await this.v1PrivatePostOrder(this.extend(request, parameters));
        //
        //     {
        //         "symbol":"USDCUSDT",
        //         "orderId":2878854881,
        //         "clientOrderId":"",
        //         "transactTime":1635551031276
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        object query = this.omit(parameters, new List<object>() {"type", "clientOrderId", "origClientOrderId"});
        object response = await this.v1PrivateGetOrder(this.extend(request, query));
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 1000
        }
        object response = await this.v1PrivateGetAllOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol": "LTCBTC",
        //             "orderId": 1,
        //             "clientOrderId": "myOrder1",
        //             "price": "0.1",
        //             "origQty": "1.0",
        //             "executedQty": "0.0",
        //             "cummulativeQuoteQty": "0.0",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "stopPrice": "0.0",
        //             "icebergQty": "0.0",
        //             "time": 1499827319559,
        //             "updateTime": 1499827319559,
        //             "isWorking": true
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetOpenOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol":"USDCUSDT",
        //             "orderId":"2878854881",
        //             "clientOrderId":"",
        //             "price":"1.1000000000000000",
        //             "origQty":"100.0000000000000000",
        //             "executedQty":"0.0000000000000000",
        //             "cummulativeQuoteQty":"0.0000000000000000",
        //             "status":"NEW",
        //             "timeInForce":"",
        //             "type":"LIMIT",
        //             "side":"SELL",
        //             "stopPrice":"",
        //             "icebergQty":"",
        //             "time":1635551031000,
        //             "updateTime":1635551031000,
        //             "isWorking":false
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object origClientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isEqual(origClientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        } else
        {
            ((Dictionary<string, object>)request)["origClientOrderId"] = origClientOrderId;
        }
        object query = this.omit(parameters, new List<object>() {"type", "origClientOrderId", "clientOrderId"});
        object response = await this.v1PrivateDeleteOrder(this.extend(request, query));
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "origClientOrderId": "myOrder1",
        //         "orderId": 1,
        //         "clientOrderId": "cancelMyOrder1"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchMyTradesMethod", "v2PrivateGetMyTrades");
        if (isTrue(isTrue((isEqual(symbol, null))) && isTrue((isEqual(method, "v2PrivateGetMyTrades")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " v2PrivateGetMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol":"USDCUSDT",
        //             "id":20725156,
        //             "orderId":2880918576,
        //             "origClientOrderId":null,
        //             "price":"0.9996000000000000",
        //             "qty":"100.0000000000000000",
        //             "commission":null,
        //             "commissionAssert":null,
        //             "time":1635558511000,
        //             "isBuyer":false,
        //             "isMaker":false,
        //             "isBestMatch":true
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "status", 1 },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "msg":"succ",
        //         "data":[
        //             {
        //                 "id":2659137,
        //                 "symbol":"USDC",
        //                 "amount":"200.0000000000000000",
        //                 "fee":"0.0E-15",
        //                 "createdAt":1635503169000,
        //                 "updatedAt":1635503202000,
        //                 "addressFrom":"0x2faf487a4414fe77e2327f0bf4ae2a264a776ad2",
        //                 "addressTo":"0x190ceccb1f8bfbec1749180f0ba8922b488d865b",
        //                 "txid":"0x9970aec41099ac385568859517308707bc7d716df8dabae7b52f5b17351c3ed0",
        //                 "confirmations":5,
        //                 "status":0,
        //                 "tagType":null,
        //             },
        //             {
        //                 "id":2659137,
        //                 "symbol": "XRP",
        //                 "amount": "20.0000000000000000",
        //                 "fee": "0.0E-15",
        //                 "createdAt": 1544669393000,
        //                 "updatedAt": 1544669413000,
        //                 "addressFrom": "",
        //                 "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
        //                 "txid": "515B23E1F9864D3AF7F5B4C4FCBED784BAE861854FAB95F4031922B6AAEFC7AC",
        //                 "confirmations": 7,
        //                 "status": 1,
        //                 "tagType": "Tag"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires a code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "status", 5 },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetWithdrawHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "msg": "succ",
        //         "data": {
        //             "msg": null,
        //             "amount": 1000,
        //             "fee": 1,
        //             "ctime": null,
        //             "coin": "usdt_erc20",
        //             "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransactions(data, currency);
    }

    public virtual object parseTransactionStatusByType(object status, object type = null)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "deposit", new Dictionary<string, object>() {
                { "0", "pending" },
                { "1", "ok" },
            } },
            { "withdrawal", new Dictionary<string, object>() {
                { "0", "pending" },
                { "5", "ok" },
                { "6", "canceled" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "symbol": "XRP",
        //         "amount": "261.3361000000000000",
        //         "fee": "0.0E-15",
        //         "createdAt": 1548816979000,
        //         "updatedAt": 1548816999000,
        //         "addressFrom": "",
        //         "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
        //         "txid": "86D6EB68A7A28938BCE06BD348F8C07DEF500C5F7FE92069EF8C0551CE0F2C7D",
        //         "confirmations": 8,
        //         "status": 1,
        //         "tagType": "Tag"
        //     },
        //     {
        //         "symbol": "XRP",
        //         "amount": "20.0000000000000000",
        //         "fee": "0.0E-15",
        //         "createdAt": 1544669393000,
        //         "updatedAt": 1544669413000,
        //         "addressFrom": "",
        //         "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
        //         "txid": "515B23E1F9864D3AF7F5B4C4FCBED784BAE861854FAB95F4031922B6AAEFC7AC",
        //         "confirmations": 7,
        //         "status": 1,
        //         "tagType": "Tag"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": 183745,
        //         "symbol": "usdt_erc20",
        //         "amount": "8.4000000000000000",
        //         "fee": "1.6000000000000000",
        //         "payAmount": "0.0000000000000000",
        //         "createdAt": 1595336441000,
        //         "updatedAt": 1595336576000,
        //         "addressFrom": "",
        //         "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83",
        //         "txid": "",
        //         "confirmations": 0,
        //         "status": 6,
        //         "tagType": null
        //     }
        //
        // withdraw
        //
        //     {
        //         "msg": null,
        //         "amount": 1000,
        //         "fee": 1,
        //         "ctime": null,
        //         "coin": "usdt_erc20",
        //         "withdrawId": 1156423,
        //         "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83"
        //     }
        //
        object id = this.safeString2(transaction, "id", "withdrawId");
        object tagType = this.safeString(transaction, "tagType");
        object addressTo = this.safeString(transaction, "addressTo");
        object addressFrom = this.safeString(transaction, "addressFrom");
        object tagTo = null;
        object tagFrom = null;
        if (isTrue(!isEqual(tagType, null)))
        {
            if (isTrue(!isEqual(addressTo, null)))
            {
                object parts = ((string)addressTo).Split((string)"_").ToList<object>();
                addressTo = this.safeString(parts, 0);
                tagTo = this.safeString(parts, 1);
            }
            if (isTrue(!isEqual(addressFrom, null)))
            {
                object parts = ((string)addressFrom).Split((string)"_").ToList<object>();
                addressFrom = this.safeString(parts, 0);
                tagFrom = this.safeString(parts, 1);
            }
        }
        object txid = this.safeString(transaction, "txid");
        object timestamp = this.safeInteger(transaction, "createdAt");
        object updated = this.safeInteger(transaction, "updatedAt");
        object payAmount = (((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("payAmount")));
        object ctime = (((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("ctime")));
        object type = ((bool) isTrue((isTrue(payAmount) || isTrue(ctime)))) ? "withdrawal" : "deposit";
        object status = this.parseTransactionStatusByType(this.safeString(transaction, "status"), type);
        object amount = this.safeNumber(transaction, "amount");
        object network = null;
        object currencyId = this.safeString2(transaction, "symbol", "coin");
        if (isTrue(!isEqual(currencyId, null)))
        {
            object parts = ((string)currencyId).Split((string)"_").ToList<object>();
            currencyId = this.safeString(parts, 0);
            object networkId = this.safeString(parts, 1);
            if (isTrue(!isEqual(networkId, null)))
            {
                network = ((string)networkId).ToUpper();
            }
        }
        object code = this.safeCurrencyCode(currencyId, currency);
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", addressTo },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", tagTo },
            { "tagTo", tagTo },
            { "tagFrom", tagFrom },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "internal", false },
            { "fee", fee },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object chainName = this.safeString(parameters, "chainName");
        if (isTrue(isEqual(chainName, null)))
        {
            object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
            object optionsNetworks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(optionsNetworks, network, network);
            object networkEntry = this.safeValue(networks, network, new Dictionary<string, object>() {});
            chainName = this.safeString(networkEntry, "id"); // handle ERC20>ETH alias
            if (isTrue(isEqual(chainName, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a network parameter or a chainName parameter")) ;
            }
            parameters = this.omit(parameters, "network");
        }
        object request = new Dictionary<string, object>() {
            { "coin", ((string)getValue(currency, "id")).ToUpper() },
            { "amount", amount },
            { "addressTo", address },
            { "chainName", chainName },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["tag"] = tag;
        }
        object response = await this.v1PrivatePostWithdrawCommit(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "msg": "succ",
        //         "data": {
        //             "msg": null,
        //             "amount": 1000,
        //             "fee": 1,
        //             "ctime": null,
        //             "coin": "usdt_erc20",
        //             "withdrawId": 1156423,
        //             "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTransaction(data, currency);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //   {
        //       coin: 'adx',
        //       coinFulName: 'Ambire AdEx',
        //       chains: [ 'BSC' ],
        //       chainDetail: [ [Object] ]
        //   }
        //
        object chainDetails = this.safeValue(fee, "chainDetail", new List<object>() {});
        object chainDetailLength = getArrayLength(chainDetails);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(chainDetailLength, 0)))
        {
            for (object i = 0; isLessThan(i, chainDetailLength); postFixIncrement(ref i))
            {
                object chainDetail = getValue(chainDetails, i);
                object networkId = this.safeString(chainDetail, "chain");
                object currencyCode = this.safeString(currency, "code");
                object networkCode = this.networkIdToCode(networkId, currencyCode);
                ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.safeNumber(chainDetail, "withdrawFee") },
                        { "percentage", false },
                    } },
                };
                if (isTrue(isEqual(chainDetailLength, 1)))
                {
                    ((Dictionary<string, object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(chainDetail, "withdrawFee");
                    ((Dictionary<string, object>)getValue(result, "withdraw"))["percentage"] = false;
                }
            }
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitrue#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#exchangeInfo_endpoint
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the bitrue api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/en/latest/manual.html#fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PublicGetExchangeInfo(parameters);
        object coins = this.safeValue(response, "coins");
        return this.parseDepositWithdrawFees(coins, codes, "coin");
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        var versionaccessVariable = api;
        var version = ((List<object>) versionaccessVariable)[0];
        var access = ((List<object>) versionaccessVariable)[1];
        object url = add(add(getValue(getValue(this.urls, "api"), version), "/"), this.implodeParams(path, parameters));
        parameters = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(access, "private")))
        {
            this.checkRequiredCredentials();
            object recvWindow = this.safeInteger(this.options, "recvWindow", 5000);
            object query = this.urlencode(this.extend(new Dictionary<string, object>() {
                { "timestamp", this.nonce() },
                { "recvWindow", recvWindow },
            }, parameters));
            object signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
            query = add(query, add(add("&", "signature="), signature));
            headers = new Dictionary<string, object>() {
                { "X-MBX-APIKEY", this.apiKey },
            };
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                url = add(url, add("?", query));
            } else
            {
                body = query;
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isTrue((isEqual(code, 418))) || isTrue((isEqual(code, 429)))))
        {
            throw new DDoSProtection ((string)add(add(add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason), " "), body)) ;
        }
        // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
        // following block cointains legacy checks against message patterns in "msg" property
        // will switch "code" checks eventually, when we know all of them
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Price * QTY is zero or less"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order cost = amount * price is zero or less "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "LOT_SIZE"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order amount should be evenly divisible by lot size "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "PRICE_FILTER"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "), body)) ;
            }
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        // check success value for wapi endpoints
        // response in format {'msg': 'The coin does not exist.', 'success': true/false}
        object success = this.safeValue(response, "success", true);
        if (!isTrue(success))
        {
            object messageInner = this.safeString(response, "msg");
            object parsedMessage = null;
            if (isTrue(!isEqual(messageInner, null)))
            {
                try
                {
                    parsedMessage = parseJson(messageInner);
                } catch(Exception e)
                {
                    // do nothing
                    parsedMessage = null;
                }
                if (isTrue(!isEqual(parsedMessage, null)))
                {
                    response = parsedMessage;
                }
            }
        }
        object message = this.safeString(response, "msg");
        if (isTrue(!isEqual(message, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, add(add(this.id, " "), message));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, add(add(this.id, " "), message));
        }
        // checks against error codes
        object error = this.safeString(response, "code");
        if (isTrue(!isEqual(error, null)))
        {
            // https://github.com/ccxt/ccxt/issues/6501
            // https://github.com/ccxt/ccxt/issues/7742
            if (isTrue(isTrue((isEqual(error, "200"))) || isTrue(Precise.stringEquals(error, "0"))))
            {
                return null;
            }
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            // despite that their message is very confusing, it is raised by Binance
            // on a temporary ban, the API key is valid, but disabled for a while
            if (isTrue(isTrue((isEqual(error, "-2015"))) && isTrue(getValue(this.options, "hasAlreadyAuthenticatedSuccessfully"))))
            {
                throw new DDoSProtection ((string)add(add(this.id, " temporary banned: "), body)) ;
            }
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        if (!isTrue(success))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null, object context = null)
    {
        config ??= new Dictionary<string, object>();
        context ??= new Dictionary<string, object>();
        if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("noSymbol")))) && !isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("symbol"))))))
        {
            return getValue(config, "noSymbol");
        } else if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("byLimit")))) && isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("limit"))))))
        {
            object limit = getValue(parameters, "limit");
            object byLimit = ((object)getValue(config, "byLimit"));
            for (object i = 0; isLessThan(i, getArrayLength(byLimit)); postFixIncrement(ref i))
            {
                object entry = getValue(byLimit, i);
                if (isTrue(isLessThanOrEqual(limit, getValue(entry, 0))))
                {
                    return getValue(entry, 1);
                }
            }
        }
        return this.safeValue(config, "cost", 1);
    }
}
