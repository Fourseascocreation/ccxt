using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class kucoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kucoin" },
            { "name", "KuCoin" },
            { "countries", new List<object>() {"SC"} },
            { "rateLimit", 50 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "comment", "Platform 2.0" },
            { "quoteJsonNumbers", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", null },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", true },
                { "fetchBorrowRates", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchL3OrderBook", true },
                { "fetchLedger", true },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrdersByStatus", true },
                { "fetchOrderTrades", true },
                { "fetchPositionMode", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchWithdrawals", true },
                { "repayMargin", true },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg" },
                { "referral", "https://www.kucoin.com/ucenter/signup?rcode=E5wkqe" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kucoin.com" },
                    { "private", "https://api.kucoin.com" },
                    { "futuresPrivate", "https://api-futures.kucoin.com" },
                    { "futuresPublic", "https://api-futures.kucoin.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://openapi-sandbox.kucoin.com" },
                    { "private", "https://openapi-sandbox.kucoin.com" },
                    { "futuresPrivate", "https://api-sandbox-futures.kucoin.com" },
                    { "futuresPublic", "https://api-sandbox-futures.kucoin.com" },
                } },
                { "www", "https://www.kucoin.com" },
                { "doc", new List<object>() {"https://docs.kucoin.com"} },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "timestamp", 1 },
                        { "status", 1 },
                        { "symbols", 1 },
                        { "markets", 1 },
                        { "market/allTickers", 1 },
                        { "market/orderbook/level{level}_{limit}", 1 },
                        { "market/orderbook/level2_20", 1 },
                        { "market/orderbook/level2_100", 1 },
                        { "market/histories", 1 },
                        { "market/candles", 1 },
                        { "market/stats", 1 },
                        { "currencies", 1 },
                        { "currencies/{currency}", 1 },
                        { "prices", 1 },
                        { "mark-price/{symbol}/current", 1 },
                        { "margin/config", 1 },
                        { "margin/trade/last", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/orderbook/level{level}", 1 },
                        { "market/orderbook/level2", new Dictionary<string, object>() {
                            { "v3", 2 },
                        } },
                        { "market/orderbook/level3", 1 },
                        { "accounts", 1 },
                        { "accounts/{accountId}", 1 },
                        { "accounts/ledgers", 3.333 },
                        { "accounts/{accountId}/holds", 1 },
                        { "accounts/transferable", 1 },
                        { "base-fee", 1 },
                        { "sub/user", 1 },
                        { "user-info", 1 },
                        { "sub/api-key", 1 },
                        { "sub-accounts", 1 },
                        { "sub-accounts/{subUserId}", 1 },
                        { "deposit-addresses", 1 },
                        { "deposits", 10 },
                        { "hist-deposits", 10 },
                        { "hist-withdrawals", 10 },
                        { "withdrawals", 10 },
                        { "withdrawals/quotas", 1 },
                        { "orders", 2 },
                        { "order/client-order/{clientOid}", 1 },
                        { "orders/{orderId}", 1 },
                        { "limit/orders", 1 },
                        { "fills", 6.66667 },
                        { "limit/fills", 1 },
                        { "isolated/accounts", 2 },
                        { "isolated/account/{symbol}", 2 },
                        { "isolated/borrow/outstanding", 2 },
                        { "isolated/borrow/repaid", 2 },
                        { "isolated/symbols", 2 },
                        { "margin/account", 1 },
                        { "margin/borrow", 1 },
                        { "margin/borrow/outstanding", 1 },
                        { "margin/borrow/repaid", 1 },
                        { "margin/lend/active", 1 },
                        { "margin/lend/done", 1 },
                        { "margin/lend/trade/unsettled", 1 },
                        { "margin/lend/trade/settled", 1 },
                        { "margin/lend/assets", 1 },
                        { "margin/market", 1 },
                        { "stop-order/{orderId}", 1 },
                        { "stop-order", 1 },
                        { "stop-order/queryOrderByClientOid", 1 },
                        { "trade-fees", 1.3333 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "accounts", 1 },
                        { "accounts/inner-transfer", new Dictionary<string, object>() {
                            { "v2", 1 },
                        } },
                        { "accounts/sub-transfer", new Dictionary<string, object>() {
                            { "v2", 25 },
                        } },
                        { "deposit-addresses", 1 },
                        { "withdrawals", 1 },
                        { "orders", 4 },
                        { "orders/multi", 20 },
                        { "isolated/borrow", 2 },
                        { "isolated/repay/all", 2 },
                        { "isolated/repay/single", 2 },
                        { "margin/borrow", 1 },
                        { "margin/order", 1 },
                        { "margin/repay/all", 1 },
                        { "margin/repay/single", 1 },
                        { "margin/lend", 1 },
                        { "margin/toggle-auto-lend", 1 },
                        { "bullet-private", 1 },
                        { "stop-order", 1 },
                        { "sub/user", 1 },
                        { "sub/api-key", 1 },
                        { "sub/api-key/update", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "withdrawals/{withdrawalId}", 1 },
                        { "orders", 20 },
                        { "order/client-order/{clientOid}", 1 },
                        { "orders/{orderId}", 1 },
                        { "margin/lend/{orderId}", 1 },
                        { "stop-order/cancelOrderByClientOid", 1 },
                        { "stop-order/{orderId}", 1 },
                        { "stop-order/cancel", 1 },
                        { "sub/api-key", 1 },
                    } },
                } },
                { "futuresPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "contracts/active", 1.3953 },
                        { "contracts/{symbol}", 1.3953 },
                        { "ticker", 1.3953 },
                        { "level2/snapshot", 2 },
                        { "level2/depth20", 1.3953 },
                        { "level2/depth100", 1.3953 },
                        { "level2/message/query", 1.3953 },
                        { "level3/message/query", 1.3953 },
                        { "level3/snapshot", 1.3953 },
                        { "trade/history", 1.3953 },
                        { "interest/query", 1.3953 },
                        { "index/query", 1.3953 },
                        { "mark-price/{symbol}/current", 1.3953 },
                        { "premium/query", 1.3953 },
                        { "funding-rate/{symbol}/current", 1.3953 },
                        { "timestamp", 1.3953 },
                        { "status", 1.3953 },
                        { "kline/query", 1.3953 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 1.3953 },
                    } },
                } },
                { "futuresPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account-overview", 2 },
                        { "transaction-history", 6.666 },
                        { "deposit-address", 1.3953 },
                        { "deposit-list", 1.3953 },
                        { "withdrawals/quotas", 1.3953 },
                        { "withdrawal-list", 1.3953 },
                        { "transfer-list", 1.3953 },
                        { "orders", 1.3953 },
                        { "stopOrders", 1.3953 },
                        { "recentDoneOrders", 1.3953 },
                        { "orders/{orderId}", 1.3953 },
                        { "orders/byClientOid", 1.3953 },
                        { "fills", 6.666 },
                        { "recentFills", 6.666 },
                        { "openOrderStatistics", 1.3953 },
                        { "position", 1.3953 },
                        { "positions", 6.666 },
                        { "funding-history", 6.666 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "withdrawals", 1.3953 },
                        { "transfer-out", 1.3953 },
                        { "orders", 1.3953 },
                        { "position/margin/auto-deposit-status", 1.3953 },
                        { "position/margin/deposit-margin", 1.3953 },
                        { "bullet-private", 1.3953 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "withdrawals/{withdrawalId}", 1.3953 },
                        { "cancel/transfer-out", 1.3953 },
                        { "orders/{orderId}", 1.3953 },
                        { "orders", 6.666 },
                        { "stopOrders", 1.3953 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "8h", "8hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "1w", "1week" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "order not exist", typeof(OrderNotFound) },
                    { "order not exist.", typeof(OrderNotFound) },
                    { "order_not_exist", typeof(OrderNotFound) },
                    { "order_not_exist_or_not_allow_to_cancel", typeof(InvalidOrder) },
                    { "Order size below the minimum requirement.", typeof(InvalidOrder) },
                    { "The withdrawal amount is below the minimum requirement.", typeof(ExchangeError) },
                    { "Unsuccessful! Exceeded the max. funds out-transfer limit", typeof(InsufficientFunds) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(NotSupported) },
                    { "404", typeof(NotSupported) },
                    { "405", typeof(NotSupported) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "503", typeof(ExchangeNotAvailable) },
                    { "101030", typeof(PermissionDenied) },
                    { "103000", typeof(InvalidOrder) },
                    { "200004", typeof(InsufficientFunds) },
                    { "210014", typeof(InvalidOrder) },
                    { "210021", typeof(InsufficientFunds) },
                    { "230003", typeof(InsufficientFunds) },
                    { "260000", typeof(InvalidAddress) },
                    { "260100", typeof(InsufficientFunds) },
                    { "300000", typeof(InvalidOrder) },
                    { "400000", typeof(BadSymbol) },
                    { "400001", typeof(AuthenticationError) },
                    { "400002", typeof(InvalidNonce) },
                    { "400003", typeof(AuthenticationError) },
                    { "400004", typeof(AuthenticationError) },
                    { "400005", typeof(AuthenticationError) },
                    { "400006", typeof(AuthenticationError) },
                    { "400007", typeof(AuthenticationError) },
                    { "400008", typeof(NotSupported) },
                    { "400100", typeof(BadRequest) },
                    { "400200", typeof(InvalidOrder) },
                    { "400350", typeof(InvalidOrder) },
                    { "400370", typeof(InvalidOrder) },
                    { "400500", typeof(InvalidOrder) },
                    { "400600", typeof(BadSymbol) },
                    { "400760", typeof(InvalidOrder) },
                    { "401000", typeof(BadRequest) },
                    { "411100", typeof(AccountSuspended) },
                    { "415000", typeof(BadRequest) },
                    { "500000", typeof(ExchangeNotAvailable) },
                    { "260220", typeof(InvalidAddress) },
                    { "900014", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Exceeded the access frequency", typeof(RateLimitExceeded) },
                    { "require more permission", typeof(PermissionDenied) },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0.001") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("15000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00035")}, new List<object> {this.parseNumber("60000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("80000"), this.parseNumber("0.00025")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0")}, new List<object> {this.parseNumber("15000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("40000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("60000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("80000"), this.parseNumber("-0.00005")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BIFI", "BIFIF" },
                { "EDGE", "DADI" },
                { "HOT", "HOTNOW" },
                { "TRY", "Trias" },
                { "VAI", "VAIOT" },
                { "WAX", "WAXP" },
            } },
            { "options", new Dictionary<string, object>() {
                { "version", "v1" },
                { "symbolSeparator", "-" },
                { "fetchMyTradesMethod", "private_get_fills" },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "fetchTickersFees", true },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
                { "versions", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "currencies/{currency}", "v2" },
                            { "status", "v1" },
                            { "market/orderbook/level2_20", "v1" },
                            { "market/orderbook/level2_100", "v1" },
                            { "market/orderbook/level{level}_{limit}", "v1" },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "market/orderbook/level2", "v3" },
                            { "market/orderbook/level3", "v3" },
                            { "market/orderbook/level{level}", "v3" },
                            { "deposit-addresses", "v1" },
                        } },
                        { "POST", new Dictionary<string, object>() {
                            { "accounts/inner-transfer", "v2" },
                            { "accounts/sub-transfer", "v2" },
                            { "accounts", "v1" },
                        } },
                    } },
                    { "futuresPrivate", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "account-overview", "v1" },
                            { "positions", "v1" },
                        } },
                        { "POST", new Dictionary<string, object>() {
                            { "transfer-out", "v2" },
                        } },
                    } },
                    { "futuresPublic", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "level3/snapshot", "v2" },
                        } },
                    } },
                } },
                { "partner", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "id", "ccxt" },
                        { "key", "9e58cc35-5b5e-4133-92ec-166e3f077cb8" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "id", "ccxtfutures" },
                        { "key", "1b327198-f30c-4f14-a0ac-918871282f15" },
                    } },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "trade" },
                    { "margin", "margin" },
                    { "cross", "margin" },
                    { "isolated", "isolated" },
                    { "main", "main" },
                    { "funding", "main" },
                    { "future", "contract" },
                    { "swap", "contract" },
                    { "mining", "pool" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "Native", "bech32" },
                    { "BTC-Segwit", "btc" },
                    { "ERC20", "eth" },
                    { "BEP20", "bsc" },
                    { "TRC20", "trx" },
                    { "TERRA", "luna" },
                    { "BNB", "bsc" },
                    { "HRC20", "heco" },
                    { "HT", "heco" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "BEP20", "BSC" },
                } },
                { "marginModes", new Dictionary<string, object>() {
                    { "cross", "MARGIN_TRADE" },
                    { "isolated", "MARGIN_ISOLATED_TRADE" },
                    { "spot", "TRADE" },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTimestamp(parameters);
        //
        //     {
        //         "code":"200000",
        //         "msg":"success",
        //         "data":1546837113087
        //     }
        //
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetStatus(parameters);
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "status":"open", //open, close, cancelonly
        //             "msg":"upgrade match engine" //remark for operation
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString(data, "status");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(status, "open")))) ? "ok" : "maintenance" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchMarkets
        * @description retrieves data on all markets for kucoin
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSymbols(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "symbol": "XLM-USDT",
        //                 "name": "XLM-USDT",
        //                 "baseCurrency": "XLM",
        //                 "quoteCurrency": "USDT",
        //                 "feeCurrency": "USDT",
        //                 "market": "USDS",
        //                 "baseMinSize": "0.1",
        //                 "quoteMinSize": "0.01",
        //                 "baseMaxSize": "10000000000",
        //                 "quoteMaxSize": "99999999",
        //                 "baseIncrement": "0.0001",
        //                 "quoteIncrement": "0.000001",
        //                 "priceIncrement": "0.000001",
        //                 "priceLimitRate": "0.1",
        //                 "isMarginEnabled": true,
        //                 "enableTrading": true
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        object options = this.safeValue(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object fetchTickersFees = this.safeValue(options, "fetchTickersFees", true);
        object tickersResponse = new Dictionary<string, object>() {};
        if (isTrue(fetchTickersFees))
        {
            tickersResponse = await this.publicGetMarketAllTickers(parameters);
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        object tickersData = this.safeValue(tickersResponse, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(tickersData, "ticker", new List<object>() {});
        object tickersByMarketId = this.indexBy(tickers, "symbol");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object id = this.safeString(market, "symbol");
            var baseIdquoteIdVariable = ((string)id).Split((string)"-").ToList<object>();
            var baseId = ((List<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((List<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
            object ticker = this.safeValue(tickersByMarketId, id, new Dictionary<string, object>() {});
            object makerFeeRate = this.safeString(ticker, "makerFeeRate");
            object takerFeeRate = this.safeString(ticker, "takerFeeRate");
            object makerCoefficient = this.safeString(ticker, "makerCoefficient");
            object takerCoefficient = this.safeString(ticker, "takerCoefficient");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", this.safeValue(market, "isMarginEnabled") },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeValue(market, "enableTrading") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringMul(takerFeeRate, takerCoefficient)) },
                { "maker", this.parseNumber(Precise.stringMul(makerFeeRate, makerCoefficient)) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "baseIncrement") },
                    { "price", this.safeNumber(market, "priceIncrement") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "baseMinSize") },
                        { "max", this.safeNumber(market, "baseMaxSize") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "quoteMinSize") },
                        { "max", this.safeNumber(market, "quoteMaxSize") },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     {
        //         "currency": "OMG",
        //         "name": "OMG",
        //         "fullName": "OmiseGO",
        //         "precision": 8,
        //         "confirms": 12,
        //         "withdrawalMinSize": "4",
        //         "withdrawalMinFee": "1.25",
        //         "isWithdrawEnabled": false,
        //         "isDepositEnabled": false,
        //         "isMarginEnabled": false,
        //         "isDebitEnabled": false
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "currency");
            object name = this.safeString(entry, "fullName");
            object code = this.safeCurrencyCode(id);
            object isWithdrawEnabled = this.safeValue(entry, "isWithdrawEnabled", false);
            object isDepositEnabled = this.safeValue(entry, "isDepositEnabled", false);
            object fee = this.safeNumber(entry, "withdrawalMinFee");
            object active = (isTrue(isWithdrawEnabled) && isTrue(isDepositEnabled));
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(entry, "precision"))) },
                { "info", entry },
                { "active", active },
                { "deposit", isDepositEnabled },
                { "withdraw", isWithdrawEnabled },
                { "fee", fee },
                { "limits", this.limits },
            };
        }
        return result;
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccounts(parameters);
        //
        //     {
        //         code: "200000",
        //         data: [
        //             {
        //                 balance: "0.00009788",
        //                 available: "0.00009788",
        //                 holds: "0",
        //                 currency: "BTC",
        //                 id: "5c6a4fd399a1d81c4f9cc4d0",
        //                 type: "trade"
        //             },
        //             {
        //                 balance: "0.00000001",
        //                 available: "0.00000001",
        //                 holds: "0",
        //                 currency: "ETH",
        //                 id: "5c6a49ec99a1d819392e8e9f",
        //                 type: "trade"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object accountId = this.safeString(account, "id");
            object currencyId = this.safeString(account, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object type = this.safeString(account, "type"); // main or trade
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", type },
                { "currency", code },
                { "info", account },
            });
        }
        return result;
    }

    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTransactionFee
        * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
        * @see https://docs.kucoin.com/#get-withdrawal-quotas
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper2(parameters, "network", "chain");
        network = this.safeStringLower(networks, network, network);
        if (isTrue(!isEqual(network, null)))
        {
            network = ((string)network).ToLower();
            ((Dictionary<string, object>)request)["chain"] = ((string)network).ToLower();
            parameters = this.omit(parameters, new List<object>() {"network", "chain"});
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        object data = getValue(response, "data");
        object withdrawFees = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdrawMinFee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositWithdrawFee
        * @description fetch the fee for deposits and withdrawals
        * @see https://docs.kucoin.com/#get-withdrawal-quotas
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {string|undefined} params.network The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency; you can query the chain through the response of the GET /api/v2/currencies/{currency} interface
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = this.safeStringUpper(parameters, "network");
        object network = this.networkCodeToId(networkCode, code);
        if (isTrue(!isEqual(network, null)))
        {
            ((Dictionary<string, object>)request)["chain"] = network;
            parameters = this.omit(parameters, new List<object>() {"network"});
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "currency": "USDT",
        //            "limitBTCAmount": "1.00000000",
        //            "usedBTCAmount": "0.00000000",
        //            "remainAmount": "16548.072149",
        //            "availableAmount": "0",
        //            "withdrawMinFee": "25",
        //            "innerWithdrawMinFee": "0",
        //            "withdrawMinSize": "50",
        //            "isWithdrawEnabled": true,
        //            "precision": 6,
        //            "chain": "ERC20"
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFee(data, currency);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "currency": "USDT",
        //        "limitBTCAmount": "1.00000000",
        //        "usedBTCAmount": "0.00000000",
        //        "remainAmount": "16548.072149",
        //        "availableAmount": "0",
        //        "withdrawMinFee": "25",
        //        "innerWithdrawMinFee": "0",
        //        "withdrawMinSize": "50",
        //        "isWithdrawEnabled": true,
        //        "precision": 6,
        //        "chain": "ERC20"
        //    }
        //
        object result = this.depositWithdrawFee(fee);
        object isWithdrawEnabled = this.safeValue(fee, "isWithdrawEnabled");
        if (isTrue(isWithdrawEnabled))
        {
            object networkId = this.safeString(fee, "chain");
            object networkCode = this.networkIdToCode(networkId, this.safeString(currency, "code"));
            ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(fee, "withdrawMinFee") },
                    { "percentage", null },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return this.assignDefaultDepositWithdrawFees(result);
    }

    public virtual object isFuturesMethod(object methodName, object parameters)
    {
        //
        // Helper
        // @methodName (string): The name of the method
        // @params (dict): The parameters passed into {methodName}
        // @return: true if the method used is meant for futures trading, false otherwise
        //
        object defaultType = this.safeString2(this.options, methodName, "defaultType", "trade");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeValue(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType);
        if (isTrue(isEqual(type, null)))
        {
            object keys = new List<string>(((Dictionary<string,object>)accountsByType).Keys);
            throw new ExchangeError ((string)add(add(this.id, " isFuturesMethod() type must be one of "), String.Join(", ", keys))) ;
        }
        parameters = this.omit(parameters, "type");
        return isTrue(isTrue((isEqual(type, "contract"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "futures")));  // * (type === 'futures') deprecated, use (type === 'future')
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",   // symbol
        //         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //         "buy": "11328.9",   // bestAsk
        //         "sell": "11329",    // bestBid
        //         "changeRate": "-0.0055",    // 24h change rate
        //         "changePrice": "-63.6", // 24h change price
        //         "high": "11610",    // 24h highest price
        //         "low": "11200", // 24h lowest price
        //         "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //         "last": "11328.9",  // last price
        //         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //         "takerFeeRate": "0.001",    // Basic Taker Fee
        //         "makerFeeRate": "0.001",    // Basic Maker Fee
        //         "takerCoefficient": "1",    // Taker Fee Coefficient
        //         "makerCoefficient": "1" // Maker Fee Coefficient
        //     }
        //
        //     {
        //         "trading": true,
        //         "symbol": "KCS-BTC",
        //         "buy": 0.00011,
        //         "sell": 0.00012,
        //         "sort": 100,
        //         "volValue": 3.13851792584,   //total
        //         "baseCurrency": "KCS",
        //         "market": "BTC",
        //         "quoteCurrency": "BTC",
        //         "symbolCode": "KCS-BTC",
        //         "datetime": 1548388122031,
        //         "high": 0.00013,
        //         "vol": 27514.34842,
        //         "low": 0.0001,
        //         "changePrice": -1.0e-5,
        //         "changeRate": -0.0769,
        //         "lastTradedPrice": 0.00012,
        //         "board": 0,
        //         "mark": 0
        //     }
        //
        // market/ticker ws subscription
        //
        //     {
        //         bestAsk: '62258.9',
        //         bestAskSize: '0.38579986',
        //         bestBid: '62258.8',
        //         bestBidSize: '0.0078381',
        //         price: '62260.7',
        //         sequence: '1621383297064',
        //         size: '0.00002841',
        //         time: 1634641777363
        //     }
        //
        object percentage = this.safeString(ticker, "changeRate");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(percentage, "100");
        }
        object last = this.safeString2(ticker, "last", "lastTradedPrice");
        last = this.safeString(ticker, "price", last);
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object baseVolume = this.safeString(ticker, "vol");
        object quoteVolume = this.safeString(ticker, "volValue");
        object timestamp = this.safeInteger2(ticker, "time", "datetime");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString2(ticker, "buy", "bestBid") },
            { "bidVolume", this.safeString(ticker, "bestBidSize") },
            { "ask", this.safeString2(ticker, "sell", "bestAsk") },
            { "askVolume", this.safeString(ticker, "bestAskSize") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "changePrice") },
            { "percentage", percentage },
            { "average", this.safeString(ticker, "averagePrice") },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarketAllTickers(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "ticker", new List<object>() {});
        object time = this.safeInteger(data, "time");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(tickers, i))["time"] = time;
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = this.safeString(ticker, "symbol");
            if (isTrue(!isEqual(symbol, null)))
            {
                ((Dictionary<string, object>)result)[(string)symbol] = ticker;
            }
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketStats(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time": 1602832092060,  // time
        //             "symbol": "BTC-USDT",   // symbol
        //             "buy": "11328.9",   // bestAsk
        //             "sell": "11329",    // bestBid
        //             "changeRate": "-0.0055",    // 24h change rate
        //             "changePrice": "-63.6", // 24h change price
        //             "high": "11610",    // 24h highest price
        //             "low": "11200", // 24h lowest price
        //             "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //             "last": "11328.9",  // last price
        //             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //             "takerFeeRate": "0.001",    // Basic Taker Fee
        //             "makerFeeRate": "0.001",    // Basic Maker Fee
        //             "takerCoefficient": "1",    // Taker Fee Coefficient
        //             "makerCoefficient": "1" // Maker Fee Coefficient
        //         }
        //     }
        //
        return this.parseTicker(getValue(response, "data"), market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1545904980",             // Start time of the candle cycle
        //         "0.058",                  // opening price
        //         "0.049",                  // closing price
        //         "0.058",                  // highest price
        //         "0.049",                  // lowest price
        //         "0.018",                  // base volume
        //         "0.000945",               // quote volume
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object endAt = this.milliseconds(); // required param
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
            if (isTrue(isEqual(limit, null)))
            {
                // https://docs.kucoin.com/#get-klines
                // https://docs.kucoin.com/#details
                // For each query, the system would return at most 1500 pieces of data.
                // To obtain more data, please page the data by time.
                limit = this.safeInteger(this.options, "fetchOHLCVLimit", 1500);
            }
            endAt = this.sum(since, multiply(limit, duration));
        } else if (isTrue(!isEqual(limit, null)))
        {
            since = subtract(endAt, multiply(limit, duration));
            ((Dictionary<string, object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
        }
        ((Dictionary<string, object>)request)["endAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(endAt, 1000)).ToString()))));
        object response = await this.publicGetMarketCandles(this.extend(request, parameters));
        //
        //     {
        //         "code":"200000",
        //         "data":[
        //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
        //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
        //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createDepositAddress
        * @see https://docs.kucoin.com/#create-deposit-address
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {string|undefined} params.network the blockchain network name
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper2(parameters, "chain", "network");
        network = this.safeStringLower(networks, network, network);
        if (isTrue(!isEqual(network, null)))
        {
            network = ((string)network).ToLower();
            ((Dictionary<string, object>)request)["chain"] = network;
            parameters = this.omit(parameters, new List<object>() {"chain", "network"});
        }
        object response = await this.privatePostDepositAddresses(this.extend(request, parameters));
        // {"code":"260000","msg":"Deposit address already exists."}
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object address = this.safeString(data, "address");
        // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
        if (isTrue(!isEqual(address, null)))
        {
            address = ((string)address).Replace((string)"bitcoincash:", (string)"");
        }
        object tag = this.safeString(data, "memo");
        if (isTrue(!isEqual(code, "NIM")))
        {
            // contains spaces
            this.checkAddress(address);
        }
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", code },
            { "network", this.safeString(data, "chain") },
            { "address", address },
            { "tag", tag },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {string|undefined} params.network the blockchain network name
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        // same as for withdraw
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper2(parameters, "chain", "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeStringLower(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            network = ((string)network).ToLower();
            ((Dictionary<string, object>)request)["chain"] = network;
            parameters = this.omit(parameters, new List<object>() {"chain", "network"});
        }
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((Dictionary<string, object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v1";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        ((Dictionary<string, object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object address = this.safeString(depositAddress, "address");
        object code = getValue(currency, "id");
        if (isTrue(!isEqual(code, "NIM")))
        {
            // contains spaces
            this.checkAddress(address);
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
            { "network", this.safeString(depositAddress, "chain") },
        };
    }

    public async virtual Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositAddressesByNetwork
        * @see https://docs.kucoin.com/#get-deposit-addresses-v2
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} an array of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((Dictionary<string, object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v2";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
        //                 "memo": "",
        //                 "chain": "BTC-Segwit",
        //                 "contractAddress": ""
        //             },
        //             {"address":"37icNMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn","memo":"","chain":"BTC","contractAddress":""},
        //             {"address":"Deposit temporarily blocked","memo":"","chain":"TRC20","contractAddress":""}
        //         ]
        //     }
        //
        ((Dictionary<string, object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseDepositAddressesByNetwork(data, currency);
    }

    public virtual object parseDepositAddressesByNetwork(object depositAddresses, object currency = null)
    {
        //
        //     [
        //         {
        //             "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
        //             "memo": "",
        //             "chain": "BTC-Segwit",
        //             "contractAddress": ""
        //         },
        //         ...
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(depositAddresses)); postFixIncrement(ref i))
        {
            object entry = getValue(depositAddresses, i);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "currency", this.safeCurrencyCode(getValue(currency, "id"), currency) },
                { "network", this.safeString(entry, "chain") },
                { "address", this.safeString(entry, "address") },
                { "tag", this.safeString(entry, "memo") },
            });
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object level = this.safeInteger(parameters, "level", 2);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "publicGetMarketOrderbookLevelLevelLimit";
        object isAuthenticated = this.checkRequiredCredentials(false);
        object response = null;
        if (isTrue(!isTrue(isAuthenticated) || isTrue(!isEqual(limit, null))))
        {
            if (isTrue(isEqual(level, 2)))
            {
                ((Dictionary<string, object>)request)["level"] = level;
                if (isTrue(!isEqual(limit, null)))
                {
                    if (isTrue(isTrue((isEqual(limit, 20))) || isTrue((isEqual(limit, 100)))))
                    {
                        ((Dictionary<string, object>)request)["limit"] = limit;
                    } else
                    {
                        throw new ExchangeError ((string)add(this.id, " fetchOrderBook() limit argument must be 20 or 100")) ;
                    }
                }
                ((Dictionary<string, object>)request)["limit"] = ((bool) isTrue(limit)) ? limit : 100;
            }
        } else
        {
            method = "privateGetMarketOrderbookLevel2"; // recommended (v3)
        }
        response = await this.callAsync(method, this.extend(request, parameters));
        //
        // public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        // private (v3) market/orderbook/level2
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "time");
        object orderbook = this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "bids", "asks", subtract(level, 2), subtract(level, 1));
        ((Dictionary<string, object>)orderbook)["nonce"] = this.safeInteger(data, "sequence");
        return orderbook;
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createOrder
        * @description Create an order on the exchange
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} type 'limit' or 'market'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount the amount of currency to trade
        * @param {float} price *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
        * @param {object} params  Extra parameters specific to the exchange API endpoint
        * @param {string} params.clientOid client order id, defaults to uuid if not passed
        * @param {string} params.remark remark for the order, length cannot exceed 100 utf8 characters
        * @param {string} params.tradeType 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
        * limit orders ---------------------------------------------------
        * @param {string} params.timeInForce GTC, GTT, IOC, or FOK, default is GTC, limit orders only
        * @param {float} params.cancelAfter long, // cancel after n seconds, requires timeInForce to be GTT
        * @param {string} params.postOnly Post only flag, invalid when timeInForce is IOC or FOK
        * @param {bool} params.hidden false, // Order will not be displayed in the order book
        * @param {bool} params.iceberg false, // Only a portion of the order is displayed in the order book
        * @param {string} params.visibleSize this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
        * market orders --------------------------------------------------
        * @param {string} params.funds // Amount of quote currency to use
        * stop orders ----------------------------------------------------
        * @param {string} params.stop  Either loss or entry, the default is loss. Requires stopPrice to be defined
        * @param {float} params.stopPrice The price at which a trigger order is triggered at
        * margin orders --------------------------------------------------
        * @param {float} params.leverage Leverage size of the order
        * @param {string} params.stp '', // self trade prevention, CN, CO, CB or DC
        * @param {string} params.marginMode 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
        * @param {bool} params.autoBorrow false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // required param, cannot be used twice
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId", this.uuid());
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId"});
        object request = new Dictionary<string, object>() {
            { "clientOid", clientOrderId },
            { "side", side },
            { "symbol", getValue(market, "id") },
            { "type", type },
        };
        object quoteAmount = this.safeNumber2(parameters, "cost", "funds");
        object amountString = null;
        object costString = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(!isEqual(quoteAmount, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"cost", "funds"});
                // kucoin uses base precision even for quote values
                costString = this.amountToPrecision(symbol, quoteAmount);
                ((Dictionary<string, object>)request)["funds"] = costString;
            } else
            {
                amountString = this.amountToPrecision(symbol, amount);
                ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            amountString = this.amountToPrecision(symbol, amount);
            ((Dictionary<string, object>)request)["size"] = amountString;
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        // default is take profit
        object takeProfitPrice = this.safeValue2(parameters, "takeProfitPrice", "stopPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        if (isTrue(isTrue(isStopLoss) && isTrue(isTakeProfit)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() stopLossPrice and takeProfitPrice cannot both be defined")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice", "stopPrice"});
        object tradeType = this.safeString(parameters, "tradeType"); // keep it for backward compatibility
        object method = "privatePostOrders";
        if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            ((Dictionary<string, object>)request)["stop"] = ((bool) isTrue(isStopLoss)) ? "entry" : "loss";
            object triggerPrice = ((bool) isTrue(isStopLoss)) ? stopLossPrice : takeProfitPrice;
            ((Dictionary<string, object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            method = "privatePostStopOrder";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                throw new BadRequest ((string)add(this.id, " createOrder does not support isolated margin for stop orders")) ;
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                ((Dictionary<string, object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            }
        } else if (isTrue(isTrue(isEqual(tradeType, "MARGIN_TRADE")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "privatePostMarginOrder";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["marginModel"] = "isolated";
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "orderId": "5bd6e9286d99522a52e458de"
        //         }
        //    }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {bool} params.stop True if cancelling a stop order
        * @returns Response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object stop = this.safeValue(parameters, "stop");
        object method = "privateDeleteOrdersOrderId";
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["clientOid"] = clientOrderId;
            if (isTrue(stop))
            {
                method = "privateDeleteStopOrderCancelOrderByClientOid";
            } else
            {
                method = "privateDeleteOrderClientOrderClientOid";
            }
        } else
        {
            if (isTrue(stop))
            {
                method = "privateDeleteStopOrderOrderId";
            }
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId", "stop"});
        return await this.callAsync(method, this.extend(request, parameters));
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {bool} params.stop *invalid for isolated margin* true if cancelling all stop orders
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @param {string} params.orderIds *stop orders only* Comma seperated order IDs
        * @returns Response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object stop = this.safeValue(parameters, "stop");
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            ((Dictionary<string, object>)request)["symbol"] = this.marketId(symbol);
        }
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((Dictionary<string, object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            if (isTrue(isTrue(isEqual(marginMode, "isolated")) && isTrue(stop)))
            {
                throw new BadRequest ((string)add(this.id, " cancelAllOrders does not support isolated margin for stop orders")) ;
            }
        }
        object method = ((bool) isTrue(stop)) ? "privateDeleteStopOrderCancel" : "privateDeleteOrders";
        return await this.callAsync(method, this.extend(request, query));
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrdersByStatus
        * @description fetch a list of orders
        * @param {string} status *not used for stop orders* 'open' or 'closed'
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since timestamp in ms of the earliest order
        * @param {int|undefined} limit max number of orders to return
        * @param {object} params exchange specific params
        * @param {int|undefined} params.until end time in ms
        * @param {bool|undefined} params.stop true if fetching stop orders
        * @param {string|undefined} params.side buy or sell
        * @param {string|undefined} params.type limit, market, limit_stop or market_stop
        * @param {string|undefined} params.tradeType TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @param {int|undefined} params.currentPage *stop orders only* current page
        * @param {string|undefined} params.orderIds *stop orders only* comma seperated order ID list
        * @returns An [array of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object lowercaseStatus = ((string)status).ToLower();
        object until = this.safeInteger2(parameters, "until", "till");
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "till", "until"});
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(lowercaseStatus, "open")))
        {
            lowercaseStatus = "active";
        } else if (isTrue(isEqual(lowercaseStatus, "closed")))
        {
            lowercaseStatus = "done";
        }
        object request = new Dictionary<string, object>() {
            { "status", lowercaseStatus },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startAt"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        if (isTrue(until))
        {
            ((Dictionary<string, object>)request)["endAt"] = until;
        }
        object method = "privateGetOrders";
        if (isTrue(stop))
        {
            method = "privateGetStopOrder";
        }
        ((Dictionary<string, object>)request)["tradeType"] = this.safeString(getValue(this.options, "marginModes"), marginMode, "TRADE");
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 1,
        //             "totalNum": 153408,
        //             "totalPage": 153408,
        //             "items": [
        //                 {
        //                     "id": "5c35c02703aa673ceec2a168",   //orderid
        //                     "symbol": "BTC-USDT",   //symbol
        //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
        //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
        //                     "side": "buy",         // transaction direction,include buy and sell
        //                     "price": "10",         // order price
        //                     "size": "2",           // order quantity
        //                     "funds": "0",          // order funds
        //                     "dealFunds": "0.166",  // deal funds
        //                     "dealSize": "2",       // deal quantity
        //                     "fee": "0",            // fee
        //                     "feeCurrency": "USDT", // charge fee currency
        //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
        //                     "stop": "",            // stop type
        //                     "stopTriggered": false,  // stop order is triggered
        //                     "stopPrice": "0",      // stop price
        //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
        //                     "postOnly": false,     // postOnly
        //                     "hidden": false,       // hidden order
        //                     "iceberg": false,      // iceberg order
        //                     "visibleSize": "0",    // display quantity for iceberg order
        //                     "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
        //                     "channel": "IOS",      // order source
        //                     "clientOid": "",       // user-entered order unique mark
        //                     "remark": "",          // remark
        //                     "tags": "",            // tag order source
        //                     "isActive": false,     // status before unfilled or uncancelled
        //                     "cancelExist": false,   // order cancellation transaction record
        //                     "createdAt": 1547026471000  // time
        //                 },
        //             ]
        //         }
        //    }
        object responseData = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeValue(responseData, "items", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {int|undefined} params.till end time in ms
        * @param {string|undefined} params.side buy or sell
        * @param {string|undefined} params.type limit, market, limit_stop or market_stop
        * @param {string|undefined} params.tradeType TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("done", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {int} params.till end time in ms
        * @param {bool} params.stop true if fetching stop orders
        * @param {string} params.side buy or sell
        * @param {string} params.type limit, market, limit_stop or market_stop
        * @param {string} params.tradeType TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @param {int} params.currentPage *stop orders only* current page
        * @param {string} params.orderIds *stop orders only* comma seperated order ID list
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("active", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrder
        * @description fetch an order
        * @param {string} id Order id
        * @param {string} symbol not sent to exchange except for stop orders with clientOid, but used internally by CCXT to filter
        * @param {object} params exchange specific parameters
        * @param {bool} params.stop true if fetching a stop order
        * @param {bool} params.clientOid unique order id created by users to identify their orders
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object stop = this.safeValue(parameters, "stop");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        parameters = this.omit(parameters, "stop");
        object method = "privateGetOrdersOrderId";
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["clientOid"] = clientOrderId;
            if (isTrue(stop))
            {
                method = "privateGetStopOrderQueryOrderByClientOid";
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
                }
            } else
            {
                method = "privateGetOrderClientOrderClientOid";
            }
        } else
        {
            // a special case for undefined ids
            // otherwise a wrong endpoint for all orders will be triggered
            // https://github.com/ccxt/ccxt/issues/7234
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " fetchOrder() requires an order id")) ;
            }
            if (isTrue(stop))
            {
                method = "privateGetStopOrderOrderId";
            }
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId"});
        object response = await this.callAsync(method, this.extend(request, parameters));
        object responseData = this.safeValue(response, "data");
        if (isTrue(isEqual(method, "privateGetStopOrderQueryOrderByClientOid")))
        {
            responseData = this.safeValue(responseData, 0);
        }
        return this.parseOrder(responseData, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //    {
        //        "orderId": "63c97e47d686c5000159a656"
        //    }
        //
        // cancelOrder
        //
        //    {
        //        "cancelledOrderIds": [ "63c97e47d686c5000159a656" ]
        //    }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //    {
        //        "id": "63c97ce8d686c500015793bb",
        //        "symbol": "USDC-USDT",
        //        "opType": "DEAL",
        //        "type": "limit",
        //        "side": "sell",
        //        "price": "1.05",
        //        "size": "1",
        //        "funds": "0",
        //        "dealFunds": "0",
        //        "dealSize": "0",
        //        "fee": "0",
        //        "feeCurrency": "USDT",
        //        "stp": "",
        //        "stop": "",
        //        "stopTriggered": false,
        //        "stopPrice": "0",
        //        "timeInForce": "GTC",
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": "0",
        //        "cancelAfter": 0,
        //        "channel": "API",
        //        "clientOid": "d602d73f-5424-4751-bef0-8debce8f0a82",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "isActive": true,
        //        "cancelExist": false,
        //        "createdAt": 1674149096927,
        //        "tradeType": "TRADE"
        //    }
        //
        // stop orders (fetchOpenOrders, fetchClosedOrders)
        //
        //    {
        //        "id": "vs9f6ou9e864rgq8000t4qnm",
        //        "symbol": "USDC-USDT",
        //        "userId": "613a896885d8660006151f01",
        //        "status": "NEW",
        //        "type": "market",
        //        "side": "sell",
        //        "price": null,
        //        "size": "1.00000000000000000000",
        //        "funds": null,
        //        "stp": null,
        //        "timeInForce": "GTC",
        //        "cancelAfter": -1,
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": null,
        //        "channel": "API",
        //        "clientOid": "5d3fd727-6456-438d-9550-40d9d85eee0b",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "relatedNo": null,
        //        "orderTime": 1674146316994000028,
        //        "domainId": "kucoin",
        //        "tradeSource": "USER",
        //        "tradeType": "MARGIN_TRADE",
        //        "feeCurrency": "USDT",
        //        "takerFeeRate": "0.00100000000000000000",
        //        "makerFeeRate": "0.00100000000000000000",
        //        "createdAt": 1674146316994,
        //        "stop": "loss",
        //        "stopTriggerTime": null,
        //        "stopPrice": "0.97000000000000000000"
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        object timestamp = this.safeInteger(order, "createdAt");
        object feeCurrencyId = this.safeString(order, "feeCurrency");
        object cancelExist = this.safeValue(order, "cancelExist", false);
        object responseStop = this.safeString(order, "stop");
        object stop = !isEqual(responseStop, null);
        object stopTriggered = this.safeValue(order, "stopTriggered", false);
        object isActive = this.safeValue(order, "isActive");
        object status = null;
        if (isTrue(isEqual(isActive, true)))
        {
            status = "open";
        }
        if (isTrue(stop))
        {
            object responseStatus = this.safeString(order, "status");
            if (isTrue(isEqual(responseStatus, "NEW")))
            {
                status = "open";
            } else if (isTrue(!isTrue(isActive) && !isTrue(stopTriggered)))
            {
                status = "cancelled";
            }
        }
        if (isTrue(cancelExist))
        {
            status = "canceled";
        }
        if (isTrue(isEqual(status, null)))
        {
            status = "closed";
        }
        object stopPrice = this.safeNumber(order, "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "id", "orderId") },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "symbol", this.safeSymbol(marketId, market, "-") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", this.safeValue(order, "postOnly") },
            { "side", this.safeString(order, "side") },
            { "amount", this.safeString(order, "size") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", this.safeString(order, "dealFunds") },
            { "filled", this.safeString(order, "dealSize") },
            { "remaining", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "status", status },
            { "lastTradeTimestamp", null },
            { "average", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object method = getValue(this.options, "fetchMyTradesMethod");
        object parseResponseData = false;
        if (isTrue(isEqual(method, "private_get_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            if (isTrue(!isEqual(since, null)))
            {
                // only returns trades up to one week after the since param
                ((Dictionary<string, object>)request)["startAt"] = since;
            }
        } else if (isTrue(isEqual(method, "private_get_limit_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            // takes no params
            // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
            parseResponseData = true;
        } else if (isTrue(isEqual(method, "private_get_hist_orders")))
        {
            // despite that this endpoint is called `HistOrders`
            // it returns historical trades instead of orders
            // returns trades earlier than 2019-02-18T00:00:00Z only
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
            }
        } else
        {
            throw new ExchangeError ((string)add(this.id, " fetchMyTradesMethod() invalid method")) ;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "currentPage": 1,
        //         "pageSize": 50,
        //         "totalNum": 1,
        //         "totalPage": 1,
        //         "items": [
        //             {
        //                 "symbol":"BTC-USDT",       // symbol
        //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
        //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
        //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
        //                 "side":"buy",              // transaction direction,include buy and sell
        //                 "liquidity":"taker",       // include taker and maker
        //                 "forceTaker":true,         // forced to become taker
        //                 "price":"0.083",           // order price
        //                 "size":"0.8424304",        // order quantity
        //                 "funds":"0.0699217232",    // order funds
        //                 "fee":"0",                 // fee
        //                 "feeRate":"0",             // fee rate
        //                 "feeCurrency":"USDT",      // charge fee currency
        //                 "stop":"",                 // stop type
        //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
        //                 "createdAt":1547026472000  // time
        //             },
        //             //------------------------------------------------------
        //             // v1 (historical) trade response structure
        //             {
        //                 "symbol": "SNOV-ETH",
        //                 "dealPrice": "0.0000246",
        //                 "dealValue": "0.018942",
        //                 "amount": "770",
        //                 "fee": "0.00001137",
        //                 "side": "sell",
        //                 "createdAt": 1540080199
        //                 "id":"5c4d389e4c8c60413f78e2e5",
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = null;
        if (isTrue(parseResponseData))
        {
            trades = data;
        } else
        {
            trades = this.safeValue(data, "items", new List<object>() {});
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        // pagination is not supported on the exchange side anymore
        // if (since !== undefined) {
        //     request['startAt'] = Math.floor (since / 1000);
        // }
        // if (limit !== undefined) {
        //     request['pageSize'] = limit;
        // }
        object response = await this.publicGetMarketHistories(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "sequence": "1548764654235",
        //                 "side": "sell",
        //                 "size":"0.6841354",
        //                 "price":"0.03202",
        //                 "time":1548848575203567174
        //             }
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "sequence": "1548764654235",
        //         "side": "sell",
        //         "size":"0.6841354",
        //         "price":"0.03202",
        //         "time":1548848575203567174
        //     }
        //
        //     {
        //         sequence: '1568787654360',
        //         symbol: 'BTC-USDT',
        //         side: 'buy',
        //         size: '0.00536577',
        //         price: '9345',
        //         takerOrderId: '5e356c4a9f1a790008f8d921',
        //         time: '1580559434436443257',
        //         type: 'match',
        //         makerOrderId: '5e356bffedf0010008fa5d7f',
        //         tradeId: '5e356c4aeefabd62c62a1ece'
        //     }
        //
        // fetchMyTrades (private) v2
        //
        //     {
        //         "symbol":"BTC-USDT",
        //         "tradeId":"5c35c02709e4f67d5266954e",
        //         "orderId":"5c35c02703aa673ceec2a168",
        //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
        //         "side":"buy",
        //         "liquidity":"taker",
        //         "forceTaker":true,
        //         "price":"0.083",
        //         "size":"0.8424304",
        //         "funds":"0.0699217232",
        //         "fee":"0",
        //         "feeRate":"0",
        //         "feeCurrency":"USDT",
        //         "stop":"",
        //         "type":"limit",
        //         "createdAt":1547026472000
        //     }
        //
        // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
        //
        //     {
        //         symbol: "OPEN-BTC",
        //         forceTaker:  false,
        //         orderId: "5ce36420054b4663b1fff2c9",
        //         fee: "0",
        //         feeCurrency: "",
        //         type: "",
        //         feeRate: "0",
        //         createdAt: 1558417615000,
        //         size: "12.8206",
        //         stop: "",
        //         price: "0",
        //         funds: "0",
        //         tradeId: "5ce390cf6e0db23b861c6e80"
        //     }
        //
        // fetchMyTrades (private) v1 (historical)
        //
        //     {
        //         "symbol": "SNOV-ETH",
        //         "dealPrice": "0.0000246",
        //         "dealValue": "0.018942",
        //         "amount": "770",
        //         "fee": "0.00001137",
        //         "side": "sell",
        //         "createdAt": 1540080199
        //         "id":"5c4d389e4c8c60413f78e2e5",
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object id = this.safeString2(trade, "tradeId", "id");
        object orderId = this.safeString(trade, "orderId");
        object takerOrMaker = this.safeString(trade, "liquidity");
        object timestamp = this.safeInteger(trade, "time");
        if (isTrue(!isEqual(timestamp, null)))
        {
            timestamp = this.parseToInt(divide(timestamp, 1000000));
        } else
        {
            timestamp = this.safeInteger(trade, "createdAt");
            // if it's a historical v1 trade, the exchange returns timestamp in seconds
            if (isTrue(isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("dealValue")))) && isTrue((!isEqual(timestamp, null)))))
            {
                timestamp = multiply(timestamp, 1000);
            }
        }
        object priceString = this.safeString2(trade, "price", "dealPrice");
        object amountString = this.safeString2(trade, "size", "amount");
        object side = this.safeString(trade, "side");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCurrency");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrency, null)))
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrency },
                { "rate", this.safeString(trade, "feeRate") },
            };
        }
        object type = this.safeString(trade, "type");
        if (isTrue(isEqual(type, "match")))
        {
            type = null;
        }
        object costString = this.safeString2(trade, "funds", "dealValue");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
        };
        object response = await this.privateGetTradeFees(this.extend(request, parameters));
        //
        //     {
        //         code: '200000',
        //         data: [
        //           {
        //             symbol: 'BTC-USDT',
        //             takerFeeRate: '0.001',
        //             makerFeeRate: '0.001'
        //           }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0);
        object marketId = this.safeString(first, "symbol");
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(first, "makerFeeRate") },
            { "taker", this.safeNumber(first, "takerFeeRate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["memo"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeStringLower(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            network = ((string)network).ToLower();
            ((Dictionary<string, object>)request)["chain"] = network;
            parameters = this.omit(parameters, "network");
        }
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        object includeFee = this.safeValue(withdrawOptions, "includeFee", false);
        if (isTrue(includeFee))
        {
            ((Dictionary<string, object>)request)["feeDeductType"] = "INTERNAL";
        }
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        // https://github.com/ccxt/ccxt/issues/5558
        //
        //     {
        //         "code":  200000,
        //         "data": {
        //             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
            { "PROCESSING", "pending" },
            { "WALLET_PROCESSING", "pending" },
            { "FAILURE", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //         "memo": "5c247c8a03aa677cea2a251d",
        //         "amount": 1,
        //         "fee": 0.0001,
        //         "currency": "KCS",
        //         "chain": "",
        //         "isInner": false,
        //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //         "status": "SUCCESS",
        //         "createdAt": 1544178843000,
        //         "updatedAt": 1544178891000
        //         "remark":"foobar"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "5c2dc64e03aa675aa263f1ac",
        //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //         "memo": "",
        //         "currency": "ETH",
        //         "chain": "",
        //         "amount": 1.0000000,
        //         "fee": 0.0100000,
        //         "walletTxId": "3e2414d82acce78d38be7fe9",
        //         "isInner": false,
        //         "status": "FAILURE",
        //         "createdAt": 1546503758000,
        //         "updatedAt": 1546504603000
        //         "remark":"foobar"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //     }
        //
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "address");
        object amount = this.safeString(transaction, "amount");
        object txid = this.safeString(transaction, "walletTxId");
        if (isTrue(!isEqual(txid, null)))
        {
            object txidParts = ((string)txid).Split((string)"@").ToList<object>();
            object numTxidParts = getArrayLength(txidParts);
            if (isTrue(isGreaterThan(numTxidParts, 1)))
            {
                if (isTrue(isEqual(address, null)))
                {
                    if (isTrue(isGreaterThan(((string)getValue(txidParts, 1)).Length, 1)))
                    {
                        address = getValue(txidParts, 1);
                    }
                }
            }
            txid = getValue(txidParts, 0);
        }
        object type = ((bool) isTrue((isEqual(txid, null)))) ? "withdrawal" : "deposit";
        object rawStatus = this.safeString(transaction, "status");
        object fee = null;
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object rate = null;
            if (isTrue(!isEqual(amount, null)))
            {
                rate = Precise.stringDiv(feeCost, amount);
            }
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "rate", this.parseNumber(rate) },
                { "currency", code },
            };
        }
        object timestamp = this.safeInteger2(transaction, "createdAt", "createAt");
        object updated = this.safeInteger(transaction, "updatedAt");
        object isV1 = !isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("createdAt"))));
        // if it's a v1 structure
        if (isTrue(isV1))
        {
            type = ((bool) isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("address"))))) ? "withdrawal" : "deposit";
            if (isTrue(!isEqual(timestamp, null)))
            {
                timestamp = multiply(timestamp, 1000);
            }
            if (isTrue(!isEqual(updated, null)))
            {
                updated = multiply(updated, 1000);
            }
        }
        object tag = this.safeString(transaction, "memo");
        object network = this.safeString(transaction, "chain");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdrawalId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "txid", txid },
            { "type", type },
            { "status", this.parseTransactionStatus(rawStatus) },
            { "comment", this.safeString(transaction, "remark") },
            { "fee", fee },
            { "updated", updated },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object method = "privateGetDeposits";
        if (isTrue(!isEqual(since, null)))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            if (isTrue(isLessThan(since, 1550448000000)))
            {
                ((Dictionary<string, object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
                method = "privateGetHistDeposits";
            } else
            {
                ((Dictionary<string, object>)request)["startAt"] = since;
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 deposit response structure
        //                 {
        //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //                     "memo": "5c247c8a03aa677cea2a251d",
        //                     "amount": 1,
        //                     "fee": 0.0001,
        //                     "currency": "KCS",
        //                     "isInner": false,
        //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //                     "status": "SUCCESS",
        //                     "createdAt": 1544178843000,
        //                     "updatedAt": 1544178891000
        //                     "remark":"foobar"
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) deposit response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1528536998,
        //                     "amount": "0.03266638",
        //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
        //                     "isInner": false,
        //                     "status": "SUCCESS",
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseData = getValue(getValue(response, "data"), "items");
        return this.parseTransactions(responseData, currency, since, limit, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object method = "privateGetWithdrawals";
        if (isTrue(!isEqual(since, null)))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            if (isTrue(isLessThan(since, 1550448000000)))
            {
                ((Dictionary<string, object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
                method = "privateGetHistWithdrawals";
            } else
            {
                ((Dictionary<string, object>)request)["startAt"] = since;
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 withdrawal response structure
        //                 {
        //                     "id": "5c2dc64e03aa675aa263f1ac",
        //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //                     "memo": "",
        //                     "currency": "ETH",
        //                     "amount": 1.0000000,
        //                     "fee": 0.0100000,
        //                     "walletTxId": "3e2414d82acce78d38be7fe9",
        //                     "isInner": false,
        //                     "status": "FAILURE",
        //                     "createdAt": 1546503758000,
        //                     "updatedAt": 1546504603000
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) withdrawal response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1526723468,
        //                     "amount": "0.534",
        //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
        //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
        //                     "isInner": false,
        //                     "status": "SUCCESS"
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseData = getValue(getValue(response, "data"), "items");
        return this.parseTransactions(responseData, currency, since, limit, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((Dictionary<string, object>)account)["used"] = this.safeString(entry, "holdBalance");
        ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "availableBalance");
        ((Dictionary<string, object>)account)["total"] = this.safeString(entry, "totalBalance");
        object debt = this.safeString(entry, "liability");
        object interest = this.safeString(entry, "interest");
        ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.kucoin.com/#list-accounts
        * @see https://docs.kucoin.com/#query-isolated-margin-account-info
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {object} params.marginMode 'cross' or 'isolated', margin type for fetching margin balance
        * @param {object} params.type extra parameters specific to the kucoin api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object code = this.safeString(parameters, "code");
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeValue(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType, requestedType);
        parameters = this.omit(parameters, "type");
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object method = "privateGetAccounts";
        object request = new Dictionary<string, object>() {};
        object isolated = isTrue((isEqual(marginMode, "isolated"))) || isTrue((isEqual(type, "isolated")));
        object cross = isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(type, "cross")));
        if (isTrue(isolated))
        {
            method = "privateGetIsolatedAccounts";
            if (isTrue(!isEqual(currency, null)))
            {
                ((Dictionary<string, object>)request)["balanceCurrency"] = getValue(currency, "id");
            }
        } else if (isTrue(cross))
        {
            method = "privateGetMarginAccount";
        } else
        {
            if (isTrue(!isEqual(currency, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
            }
            ((Dictionary<string, object>)request)["type"] = type;
        }
        object response = await this.callAsync(method, this.extend(request, query));
        //
        // Spot and Cross
        //
        //    {
        //        "code": "200000",
        //        "data": [
        //            {
        //                "balance": "0.00009788",
        //                "available": "0.00009788",
        //                "holds": "0",
        //                "currency": "BTC",
        //                "id": "5c6a4fd399a1d81c4f9cc4d0",
        //                "type": "trade",
        //            },
        //        ]
        //    }
        //
        // Isolated
        //
        //    {
        //        code: '200000',
        //        data: {
        //            totalConversionBalance: '0',
        //            liabilityConversionBalance: '0',
        //            assets: [
        //                {
        //                    symbol: 'MANA-USDT',
        //                    status: 'CLEAR',
        //                    debtRatio: '0',
        //                    baseAsset: {
        //                        currency: 'MANA',
        //                        totalBalance: '0',
        //                        holdBalance: '0',
        //                        availableBalance: '0',
        //                        liability: '0',
        //                        interest: '0',
        //                        borrowableAmount: '0'
        //                    },
        //                    quoteAsset: {
        //                        currency: 'USDT',
        //                        totalBalance: '0',
        //                        holdBalance: '0',
        //                        availableBalance: '0',
        //                        liability: '0',
        //                        interest: '0',
        //                        borrowableAmount: '0'
        //                    }
        //                },
        //                ...
        //            ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        if (isTrue(isolated))
        {
            object assets = this.safeValue(data, "assets", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
            {
                object entry = getValue(assets, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeValue(entry, "baseAsset", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quoteAsset", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((Dictionary<string, object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((Dictionary<string, object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((Dictionary<string, object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
        } else if (isTrue(cross))
        {
            object accounts = this.safeValue(data, "accounts", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
            {
                object balance = getValue(accounts, i);
                object currencyId = this.safeString(balance, "currency");
                object codeInner = this.safeCurrencyCode(currencyId);
                ((Dictionary<string, object>)result)[(string)codeInner] = this.parseBalanceHelper(balance);
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object balance = getValue(data, i);
                object balanceType = this.safeString(balance, "type");
                if (isTrue(isEqual(balanceType, type)))
                {
                    object currencyId = this.safeString(balance, "currency");
                    object codeInner2 = this.safeCurrencyCode(currencyId);
                    object account = this.account();
                    ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "balance");
                    ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "available");
                    ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "holds");
                    ((Dictionary<string, object>)result)[(string)codeInner2] = account;
                }
            }
        }
        return ((bool) isTrue(isolated)) ? result : this.safeBalance(result);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://docs.kucoin.com/#inner-transfer
        * @see https://docs.kucoin.com/futures/#transfer-funds-to-kucoin-main-account-2
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object requestedAmount = this.currencyToPrecision(code, amount);
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        object fromIsolated = this.inArray(fromId, this.ids);
        object toIsolated = this.inArray(toId, this.ids);
        if (isTrue(isEqual(fromId, "contract")))
        {
            if (isTrue(!isEqual(toId, "main")))
            {
                throw new ExchangeError ((string)add(this.id, " transfer() only supports transferring from futures account to main account")) ;
            }
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "amount", requestedAmount },
            };
            if (!isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("bizNo")))))
            {
                // it doesn't like more than 24 characters
                ((Dictionary<string, object>)request)["bizNo"] = this.uuid22();
            }
            object response = await this.futuresPrivatePostTransferOut(this.extend(request, parameters));
            //
            //     {
            //         'code': '200000',
            //         'data': {
            //             'applyId': '605a87217dff1500063d485d',
            //             'bizNo': 'bcd6e5e1291f4905af84dc',
            //             'payAccountType': 'CONTRACT',
            //             'payTag': 'DEFAULT',
            //             'remark': '',
            //             'recAccountType': 'MAIN',
            //             'recTag': 'DEFAULT',
            //             'recRemark': '',
            //             'recSystem': 'KUCOIN',
            //             'status': 'PROCESSING',
            //             'currency': 'XBT',
            //             'amount': '0.00001',
            //             'fee': '0',
            //             'sn': '573688685663948',
            //             'reason': '',
            //             'createdAt': 1616545569000,
            //             'updatedAt': 1616545569000
            //         }
            //     }
            //
            object data = this.safeValue(response, "data");
            return this.parseTransfer(data, currency);
        } else
        {
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "amount", requestedAmount },
            };
            if (isTrue(isTrue(fromIsolated) || isTrue(toIsolated)))
            {
                if (isTrue(this.inArray(fromId, this.ids)))
                {
                    ((Dictionary<string, object>)request)["fromTag"] = fromId;
                    fromId = "isolated";
                }
                if (isTrue(this.inArray(toId, this.ids)))
                {
                    ((Dictionary<string, object>)request)["toTag"] = toId;
                    toId = "isolated";
                }
            }
            ((Dictionary<string, object>)request)["from"] = fromId;
            ((Dictionary<string, object>)request)["to"] = toId;
            if (!isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("clientOid")))))
            {
                ((Dictionary<string, object>)request)["clientOid"] = this.uuid();
            }
            object response = await this.privatePostAccountsInnerTransfer(this.extend(request, parameters));
            //
            //     {
            //         'code': '200000',
            //         'data': {
            //              'orderId': '605a6211e657f00006ad0ad6'
            //         }
            //     }
            //
            object data = this.safeValue(response, "data");
            return this.parseTransfer(data, currency);
        }
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer (spot)
        //
        //    {
        //        'orderId': '605a6211e657f00006ad0ad6'
        //    }
        //
        //    {
        //        "code": "200000",
        //        "msg": "Failed to transfer out. The amount exceeds the upper limit"
        //    }
        //
        // transfer (futures)
        //
        //     {
        //         'applyId': '605a87217dff1500063d485d',
        //         'bizNo': 'bcd6e5e1291f4905af84dc',
        //         'payAccountType': 'CONTRACT',
        //         'payTag': 'DEFAULT',
        //         'remark': '',
        //         'recAccountType': 'MAIN',
        //         'recTag': 'DEFAULT',
        //         'recRemark': '',
        //         'recSystem': 'KUCOIN',
        //         'status': 'PROCESSING',
        //         'currency': 'XBT',
        //         'amount': '0.00001',
        //         'fee': '0',
        //         'sn': '573688685663948',
        //         'reason': '',
        //         'createdAt': 1616545569000,
        //         'updatedAt': 1616545569000
        //     }
        //
        object timestamp = this.safeInteger(transfer, "createdAt");
        object currencyId = this.safeString(transfer, "currency");
        object rawStatus = this.safeString(transfer, "status");
        object accountFromRaw = this.safeStringLower(transfer, "payAccountType");
        object accountToRaw = this.safeStringLower(transfer, "recAccountType");
        object accountsByType = this.safeValue(this.options, "accountsByType");
        object accountFrom = this.safeString(accountsByType, accountFromRaw, accountFromRaw);
        object accountTo = this.safeString(accountsByType, accountToRaw, accountToRaw);
        return new Dictionary<string, object>() {
            { "id", this.safeString2(transfer, "applyId", "orderId") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", accountFrom },
            { "toAccount", accountTo },
            { "status", this.parseTransferStatus(rawStatus) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSING", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Assets Transferred in After Upgrading", "transfer" },
            { "Deposit", "transaction" },
            { "Withdrawal", "transaction" },
            { "Transfer", "transfer" },
            { "Trade_Exchange", "trade" },
            { "KuCoin Bonus", "bonus" },
            { "Referral Bonus", "referral" },
            { "Rewards", "bonus" },
            { "Airdrop/Fork", "airdrop" },
            { "Other rewards", "bonus" },
            { "Fee Rebate", "rebate" },
            { "Buy Crypto", "trade" },
            { "Sell Crypto", "sell" },
            { "Public Offering Purchase", "trade" },
            { "Refunded Fees", "fee" },
            { "KCS Pay Fees", "fee" },
            { "Margin Trade", "trade" },
            { "Loans", "Loans" },
            { "Instant Exchange", "trade" },
            { "Sub-account transfer", "transfer" },
            { "Liquidation Fees", "fee" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
        //         "currency": "USDT", //Currency
        //         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
        //         "fee": "0", //Deposit or withdrawal fee
        //         "balance": "0", //Total assets of a currency remaining funds after transaction
        //         "accountType": "MAIN", //Account Type
        //         "bizType": "Loans Repaid", //business type
        //         "direction": "in", //side, in or out
        //         "createdAt": 1629101692950, //Creation time
        //         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
        //     }
        //
        object id = this.safeString(item, "id");
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(item, "amount");
        object balanceAfter = null;
        // const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
        object bizType = this.safeString(item, "bizType");
        object type = this.parseLedgerEntryType(bizType);
        object direction = this.safeString(item, "direction");
        object timestamp = this.safeInteger(item, "createdAt");
        object datetime = this.iso8601(timestamp);
        object account = this.safeString(item, "accountType"); // MAIN, TRADE, MARGIN, or CONTRACT
        object context = this.safeString(item, "context"); // contains other information about the ledger entry
        //
        // withdrawal transaction
        //
        //     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
        //
        // deposit to MAIN, trade via MAIN
        //
        //     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
        //
        // sell trade
        //
        //     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
        //
        object referenceId = null;
        if (isTrue(isTrue(!isEqual(context, null)) && isTrue(!isEqual(context, ""))))
        {
            try
            {
                object parsed = parseJson(context);
                object orderId = this.safeString(parsed, "orderId");
                object tradeId = this.safeString(parsed, "tradeId");
                // transactions only have an orderId but for trades we wish to use tradeId
                if (isTrue(!isEqual(tradeId, null)))
                {
                    referenceId = tradeId;
                } else
                {
                    referenceId = orderId;
                }
            } catch(Exception exc)
            {
                referenceId = context;
            }
        }
        object fee = null;
        object feeCost = this.safeNumber(item, "fee");
        object feeCurrency = null;
        if (isTrue(!isEqual(feeCost, 0)))
        {
            feeCurrency = code;
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        return new Dictionary<string, object>() {
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", account },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "before", null },
            { "after", balanceAfter },
            { "status", null },
            { "fee", fee },
            { "info", item },
        };
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startAt"] = since;
        }
        // atm only single currency retrieval is supported
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetAccountsLedgers(this.extend(request, parameters));
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "currentPage":1,
        //             "pageSize":50,
        //             "totalNum":1,
        //             "totalPage":1,
        //             "items":[
        //                 {
        //                     "id":"617cc528729f5f0001c03ceb",
        //                     "currency":"GAS",
        //                     "amount":"0.00000339",
        //                     "fee":"0",
        //                     "balance":"0",
        //                     "accountType":"MAIN",
        //                     "bizType":"Distribution",
        //                     "direction":"in",
        //                     "createdAt":1635566888183,
        //                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
        //                 }
        //                 {
        //                     "id": "611a1e7c6a053300067a88d9",//unique key
        //                     "currency": "USDT", //Currency
        //                     "amount": "10.00059547", //Change amount of the funds
        //                     "fee": "0", //Deposit or withdrawal fee
        //                     "balance": "0", //Total assets of a currency
        //                     "accountType": "MAIN", //Account Type
        //                     "bizType": "Loans Repaid", //business type
        //                     "direction": "in", //side, in or out
        //                     "createdAt": 1629101692950, //Creation time
        //                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        object items = this.safeValue(data, "items");
        return this.parseLedger(items, currency, since, limit);
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null, object context = null)
    {
        config ??= new Dictionary<string, object>();
        context ??= new Dictionary<string, object>();
        object versions = this.safeValue(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeValue(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeValue(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        if (isTrue(isTrue(isEqual(version, "v3")) && isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("v3"))))))
        {
            return getValue(config, "v3");
        } else if (isTrue(isTrue(isEqual(version, "v2")) && isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("v2"))))))
        {
            return getValue(config, "v2");
        } else if (isTrue(isTrue(isEqual(version, "v1")) && isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("v1"))))))
        {
            return getValue(config, "v1");
        }
        return this.safeValue(config, "cost", 1);
    }

    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBorrowRateHistory
        * @description retrieves a history of a currencies borrow interest rate at specific time slots
        * @see https://docs.kucoin.com/#margin-trade-data
        * @param {string} code unified currency code
        * @param {int|undefined} since timestamp for the earliest borrow rate
        * @param {int|undefined} limit the maximum number of [borrow rate structures]
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @returns {[object]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.publicGetMarginTradeLast(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "tradeId": "62db2dcaff219600012b56cd",
        //                 "currency": "USDT",
        //                 "size": "10",
        //                 "dailyIntRate": "0.00003",
        //                 "term": 7,
        //                 "timestamp": 1658531274508488480
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseBorrowRateHistory(data, code, since, limit);
    }

    public virtual object parseBorrowRateHistory(object response, object code, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object borrowRate = this.parseBorrowRate(item);
            ((List<object>)result).Add(borrowRate);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterByCurrencySinceLimit(sorted, code, since, limit);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "tradeId": "62db2dcaff219600012b56cd",
        //         "currency": "USDT",
        //         "size": "10",
        //         "dailyIntRate": "0.00003",
        //         "term": 7,
        //         "timestamp": 1658531274508488480
        //     },
        //
        object timestampId = this.safeString(info, "timestamp");
        object timestamp = Precise.stringMul(timestampId, "0.000001");
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber(info, "dailyIntRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://docs.kucoin.com/#get-repay-record
        * @see https://docs.kucoin.com/#query-isolated-margin-account-info
        * @param {string|undefined} code unified currency code
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {int|undefined} since the earliest time in ms to fetch borrrow interest for
        * @param {int|undefined} limit the maximum number of structures to retrieve
        * @param {object} params extra parameters specific to the kucoin api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' default is 'cross'
        * @returns {[object]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = "cross"; // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {};
        object method = "privateGetMarginBorrowOutstanding";
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(!isEqual(code, null)))
            {
                object currency = this.currency(code);
                ((Dictionary<string, object>)request)["balanceCurrency"] = getValue(currency, "id");
            }
            method = "privateGetIsolatedAccounts";
        } else
        {
            if (isTrue(!isEqual(code, null)))
            {
                object currency = this.currency(code);
                ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 10,
        //             "totalNum": 1,
        //             "totalPage": 1,
        //             "items": [
        //                 {
        //                     "tradeId": "62e1e320ff219600013b44e2",
        //                     "currency": "USDT",
        //                     "principal": "100",
        //                     "accruedInterest": "0.00016667",
        //                     "liability": "100.00016667",
        //                     "repaidSize": "0",
        //                     "dailyIntRate": "0.00004",
        //                     "term": 7,
        //                     "createdAt": 1658970912000,
        //                     "maturityTime": 1659575713000
        //                 }
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalConversionBalance": "0.02138647",
        //             "liabilityConversionBalance": "0.01480001",
        //             "assets": [
        //                 {
        //                     "symbol": "NKN-USDT",
        //                     "status": "CLEAR",
        //                     "debtRatio": "0",
        //                     "baseAsset": {
        //                         "currency": "NKN",
        //                         "totalBalance": "0",
        //                         "holdBalance": "0",
        //                         "availableBalance": "0",
        //                         "liability": "0",
        //                         "interest": "0",
        //                         "borrowableAmount": "0"
        //                     },
        //                     "quoteAsset": {
        //                         "currency": "USDT",
        //                         "totalBalance": "0",
        //                         "holdBalance": "0",
        //                         "availableBalance": "0",
        //                         "liability": "0",
        //                         "interest": "0",
        //                         "borrowableAmount": "0"
        //                     }
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object assets = ((bool) isTrue((isEqual(marginMode, "isolated")))) ? this.safeValue(data, "assets", new List<object>() {}) : this.safeValue(data, "items", new List<object>() {});
        return this.parseBorrowInterests(assets, null);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        // Cross
        //
        //     {
        //         "tradeId": "62e1e320ff219600013b44e2",
        //         "currency": "USDT",
        //         "principal": "100",
        //         "accruedInterest": "0.00016667",
        //         "liability": "100.00016667",
        //         "repaidSize": "0",
        //         "dailyIntRate": "0.00004",
        //         "term": 7,
        //         "createdAt": 1658970912000,
        //         "maturityTime": 1659575713000
        //     },
        //
        // Isolated
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "status": "CLEAR",
        //         "debtRatio": "0",
        //         "baseAsset": {
        //             "currency": "BTC",
        //             "totalBalance": "0",
        //             "holdBalance": "0",
        //             "availableBalance": "0",
        //             "liability": "0",
        //             "interest": "0",
        //             "borrowableAmount": "0.0592"
        //         },
        //         "quoteAsset": {
        //             "currency": "USDT",
        //             "totalBalance": "149.99991731",
        //             "holdBalance": "0",
        //             "availableBalance": "149.99991731",
        //             "liability": "0",
        //             "interest": "0",
        //             "borrowableAmount": "1349"
        //         }
        //     },
        //
        object marketId = this.safeString(info, "symbol");
        object marginMode = ((bool) isTrue((isEqual(marketId, null)))) ? "cross" : "isolated";
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(info, "createdAt");
        object isolatedBase = this.safeValue(info, "baseAsset", new Dictionary<string, object>() {});
        object amountBorrowed = null;
        object interest = null;
        object currencyId = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            amountBorrowed = this.safeNumber(isolatedBase, "liability");
            interest = this.safeNumber(isolatedBase, "interest");
            currencyId = this.safeString(isolatedBase, "currency");
        } else
        {
            amountBorrowed = this.safeNumber(info, "principal");
            interest = this.safeNumber(info, "accruedInterest");
            currencyId = this.safeString(info, "currency");
        }
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "marginMode", marginMode },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "interest", interest },
            { "interestRate", this.safeNumber(info, "dailyIntRate") },
            { "amountBorrowed", amountBorrowed },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#borrowMargin
        * @description create a loan to borrow margin
        * @see https://docs.kucoin.com/#post-borrow-order
        * @see https://docs.kucoin.com/#isolated-margin-borrowing
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the kucoin api endpoints
        * @param {string} params.timeInForce either IOC or FOK
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' default is 'cross'
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = this.safeString(parameters, "marginMode"); // cross or isolated
        parameters = this.omit(parameters, "marginMode");
        this.checkRequiredMarginArgument("borrowMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
        };
        object method = null;
        object timeInForce = this.safeStringN(parameters, new List<object>() {"timeInForce", "type", "borrowStrategy"}, "IOC");
        object timeInForceRequest = null;
        if (isTrue(isEqual(symbol, null)))
        {
            method = "privatePostMarginBorrow";
            timeInForceRequest = "type";
        } else
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            timeInForceRequest = "borrowStrategy";
            method = "privatePostIsolatedBorrow";
        }
        ((Dictionary<string, object>)request)[(string)timeInForceRequest] = timeInForce;
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "type", "borrowStrategy"});
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "62df422ccde938000115290a",
        //             "currency": "USDT"
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "62df44a1c65f300001bc32a8",
        //             "currency": "USDT",
        //             "actualSize": "100"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#repayMargin
        * @description repay borrowed margin and interest
        * @see https://docs.kucoin.com/#one-click-repayment
        * @see https://docs.kucoin.com/#quick-repayment
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol unified market symbol
        * @param {object} params extra parameters specific to the kucoin api endpoints
        * @param {string|undefined} params.sequence cross margin repay sequence, either 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST' default is 'RECENTLY_EXPIRE_FIRST'
        * @param {string|undefined} params.seqStrategy isolated margin repay sequence, either 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST' default is 'RECENTLY_EXPIRE_FIRST'
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' default is 'cross'
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = this.safeString(parameters, "marginMode"); // cross or isolated
        parameters = this.omit(parameters, "marginMode");
        this.checkRequiredMarginArgument("repayMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
        };
        object method = null;
        object sequence = this.safeString2(parameters, "sequence", "seqStrategy", "RECENTLY_EXPIRE_FIRST");
        object sequenceRequest = null;
        if (isTrue(isEqual(symbol, null)))
        {
            method = "privatePostMarginRepayAll";
            sequenceRequest = "sequence";
        } else
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            sequenceRequest = "seqStrategy";
            method = "privatePostIsolatedRepayAll";
        }
        ((Dictionary<string, object>)request)[(string)sequenceRequest] = sequence;
        parameters = this.omit(parameters, new List<object>() {"sequence", "seqStrategy"});
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": null
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin cross
        //
        //     {
        //         "orderId": "62df422ccde938000115290a",
        //         "currency": "USDT"
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "orderId": "62df44a1c65f300001bc32a8",
        //         "currency": "USDT",
        //         "actualSize": "100"
        //     }
        //
        // repayMargin
        //
        //     {
        //         "code": "200000",
        //         "data": null
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "id", this.safeString(info, "orderId") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "actualSize") },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        //
        // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
        //                                ↑                 ↑
        //                                ↑                 ↑
        //
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object versions = this.safeValue(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeValue(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeValue(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        parameters = this.omit(parameters, "version");
        object endpoint = add(add(add("/api/", version), "/"), this.implodeParams(path, parameters));
        if (isTrue(isEqual(api, "webFront")))
        {
            endpoint = add("/", this.implodeParams(path, parameters));
        }
        object query = this.omit(parameters, this.extractParams(path));
        object endpart = "";
        headers = ((bool) isTrue((!isEqual(headers, null)))) ? headers : new Dictionary<string, object>() {};
        object url = getValue(getValue(this.urls, "api"), api);
        object isSandbox = isGreaterThanOrEqual(getIndexOf(url, "sandbox"), 0);
        if (isTrue(isTrue(isEqual(path, "symbols")) && !isTrue(isSandbox)))
        {
            endpoint = add("/api/v2/", this.implodeParams(path, parameters));
        }
        if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)query).Keys))))
        {
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                endpoint = add(endpoint, add("?", this.rawencode(query)));
            } else
            {
                body = this.json(query);
                endpart = body;
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
            }
        }
        url = add(url, endpoint);
        object isFuturePrivate = (isEqual(api, "futuresPrivate"));
        object isPrivate = (isEqual(api, "private"));
        if (isTrue(isTrue(isPrivate) || isTrue(isFuturePrivate)))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            headers = this.extend(new Dictionary<string, object>() {
                { "KC-API-KEY-VERSION", "2" },
                { "KC-API-KEY", this.apiKey },
                { "KC-API-TIMESTAMP", timestamp },
            }, headers);
            object apiKeyVersion = this.safeString(headers, "KC-API-KEY-VERSION");
            if (isTrue(isEqual(apiKeyVersion, "2")))
            {
                object passphrase = this.hmac(this.encode(this.password), this.encode(this.secret), sha256, "base64");
                ((Dictionary<string, object>)headers)["KC-API-PASSPHRASE"] = passphrase;
            } else
            {
                ((Dictionary<string, object>)headers)["KC-API-PASSPHRASE"] = this.password;
            }
            object payload = add(add(add(timestamp, method), endpoint), endpart);
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            ((Dictionary<string, object>)headers)["KC-API-SIGN"] = signature;
            object partner = this.safeValue(this.options, "partner", new Dictionary<string, object>() {});
            partner = ((bool) isTrue(isFuturePrivate)) ? this.safeValue(partner, "future", partner) : this.safeValue(partner, "spot", partner);
            object partnerId = this.safeString(partner, "id");
            object partnerSecret = this.safeString2(partner, "secret", "key");
            if (isTrue(isTrue((!isEqual(partnerId, null))) && isTrue((!isEqual(partnerSecret, null)))))
            {
                object partnerPayload = add(add(timestamp, partnerId), this.apiKey);
                object partnerSignature = this.hmac(this.encode(partnerPayload), this.encode(partnerSecret), sha256, "base64");
                ((Dictionary<string, object>)headers)["KC-API-PARTNER-SIGN"] = partnerSignature;
                ((Dictionary<string, object>)headers)["KC-API-PARTNER"] = partnerId;
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, body);
            return null;
        }
        //
        // bad
        //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
        // good
        //     { code: '200000', data: { ... }}
        //
        object errorCode = this.safeString(response, "code");
        object message = this.safeString(response, "msg", "");
        object feedback = add(add(this.id, " "), message);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
        return null;
    }
}
