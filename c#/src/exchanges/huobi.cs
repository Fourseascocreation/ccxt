using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class huobi : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "huobi" },
            { "name", "Huobi" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 100 },
            { "userAgent", getValue(this.userAgents, "chrome100") },
            { "certified", true },
            { "version", "v1" },
            { "hostname", "api.huobi.pro" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "addMargin", null },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", null },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", null },
                { "fetchBorrowRateHistories", null },
                { "fetchBorrowRateHistory", null },
                { "fetchBorrowRates", true },
                { "fetchBorrowRatesPerSymbol", true },
                { "fetchCanceledOrders", null },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", null },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", null },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchL3OrderBook", null },
                { "fetchLedger", true },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", null },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", true },
                { "fetchSettlementHistory", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", true },
                { "fetchTransactionFee", null },
                { "fetchTransactionFees", null },
                { "fetchTransactions", null },
                { "fetchTransfers", null },
                { "fetchWithdrawAddresses", true },
                { "fetchWithdrawal", null },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", null },
                { "reduceMargin", null },
                { "repayMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", null },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "60min" },
                { "4h", "4hour" },
                { "1d", "1day" },
                { "1w", "1week" },
                { "1M", "1mon" },
                { "1y", "1year" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg" },
                { "hostnames", new Dictionary<string, object>() {
                    { "contract", "api.hbdm.com" },
                    { "spot", "api.huobi.pro" },
                    { "status", new Dictionary<string, object>() {
                        { "spot", "status.huobigroup.com" },
                        { "future", new Dictionary<string, object>() {
                            { "inverse", "status-dm.huobigroup.com" },
                            { "linear", "status-linear-swap.huobigroup.com" },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "inverse", "status-swap.huobigroup.com" },
                            { "linear", "status-linear-swap.huobigroup.com" },
                        } },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "status", "https://{hostname}" },
                    { "contract", "https://{hostname}" },
                    { "spot", "https://{hostname}" },
                    { "public", "https://{hostname}" },
                    { "private", "https://{hostname}" },
                    { "v2Public", "https://{hostname}" },
                    { "v2Private", "https://{hostname}" },
                } },
                { "www", "https://www.huobi.com" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223" },
                    { "discount", 0.15 },
                } },
                { "doc", new List<object>() {"https://huobiapi.github.io/docs/spot/v1/en/", "https://huobiapi.github.io/docs/dm/v1/en/", "https://huobiapi.github.io/docs/coin_margined_swap/v1/en/", "https://huobiapi.github.io/docs/usdt_swap/v1/en/"} },
                { "fees", "https://www.huobi.com/about/fee/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v2Public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "reference/currencies", 1 },
                        { "market-status", 1 },
                    } },
                } },
                { "v2Private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/ledger", 1 },
                        { "account/withdraw/quota", 1 },
                        { "account/withdraw/address", 1 },
                        { "account/deposit/address", 1 },
                        { "account/repayment", 5 },
                        { "reference/transact-fee-rate", 1 },
                        { "account/asset-valuation", 0.2 },
                        { "point/account", 5 },
                        { "sub-user/user-list", 1 },
                        { "sub-user/user-state", 1 },
                        { "sub-user/account-list", 1 },
                        { "sub-user/deposit-address", 1 },
                        { "sub-user/query-deposit", 1 },
                        { "user/api-key", 1 },
                        { "user/uid", 1 },
                        { "algo-orders/opening", 1 },
                        { "algo-orders/history", 1 },
                        { "algo-orders/specific", 1 },
                        { "c2c/offers", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/transactions", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/account", 1 },
                        { "etp/reference", 1 },
                        { "etp/transactions", 5 },
                        { "etp/transaction", 5 },
                        { "etp/rebalance", 1 },
                        { "etp/limit", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "account/repayment", 5 },
                        { "point/transfer", 5 },
                        { "sub-user/management", 1 },
                        { "sub-user/creation", 1 },
                        { "sub-user/tradable-market", 1 },
                        { "sub-user/transferability", 1 },
                        { "sub-user/api-key-generation", 1 },
                        { "sub-user/api-key-modification", 1 },
                        { "sub-user/api-key-deletion", 1 },
                        { "sub-user/deduct-mode", 1 },
                        { "algo-orders", 1 },
                        { "algo-orders/cancel-all-after", 1 },
                        { "algo-orders/cancellation", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/cancellation", 1 },
                        { "c2c/cancel-all", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/transfer", 1 },
                        { "etp/creation", 5 },
                        { "etp/redemption", 5 },
                        { "etp/{transactId}/cancel", 10 },
                        { "etp/batch-cancel", 50 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "common/symbols", 1 },
                        { "common/currencys", 1 },
                        { "common/timestamp", 1 },
                        { "common/exchange", 1 },
                        { "settings/currencys", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/accounts", 0.2 },
                        { "account/accounts/{id}/balance", 0.2 },
                        { "account/accounts/{sub-uid}", 1 },
                        { "account/history", 4 },
                        { "cross-margin/loan-info", 1 },
                        { "margin/loan-info", 1 },
                        { "fee/fee-rate/get", 1 },
                        { "order/openOrders", 0.4 },
                        { "order/orders", 0.4 },
                        { "order/orders/{id}", 0.4 },
                        { "order/orders/{id}/matchresults", 0.4 },
                        { "order/orders/getClientOrder", 0.4 },
                        { "order/history", 1 },
                        { "order/matchresults", 1 },
                        { "query/deposit-withdraw", 1 },
                        { "margin/loan-orders", 0.2 },
                        { "margin/accounts/balance", 0.2 },
                        { "cross-margin/loan-orders", 1 },
                        { "cross-margin/accounts/balance", 1 },
                        { "points/actions", 1 },
                        { "points/orders", 1 },
                        { "subuser/aggregate-balance", 10 },
                        { "stable-coin/exchange_rate", 1 },
                        { "stable-coin/quote", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "futures/transfer", 1 },
                        { "order/batch-orders", 0.4 },
                        { "order/orders/place", 0.2 },
                        { "order/orders/submitCancelClientOrder", 0.2 },
                        { "order/orders/batchCancelOpenOrders", 0.4 },
                        { "order/orders/{id}/submitcancel", 0.2 },
                        { "order/orders/batchcancel", 0.4 },
                        { "dw/withdraw/api/create", 1 },
                        { "dw/withdraw-virtual/{id}/cancel", 1 },
                        { "dw/transfer-in/margin", 10 },
                        { "dw/transfer-out/margin", 10 },
                        { "margin/orders", 10 },
                        { "margin/orders/{id}/repay", 10 },
                        { "cross-margin/transfer-in", 1 },
                        { "cross-margin/transfer-out", 1 },
                        { "cross-margin/orders", 1 },
                        { "cross-margin/orders/{id}/repay", 1 },
                        { "stable-coin/exchange", 1 },
                        { "subuser/transfer", 10 },
                    } },
                } },
                { "status", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "spot", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "api/v2/summary.json", 1 },
                            } },
                        } },
                        { "future", new Dictionary<string, object>() {
                            { "inverse", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                            { "linear", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "inverse", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                            { "linear", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                        } },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/market-status", 1 },
                            { "v1/common/symbols", 1 },
                            { "v1/common/currencys", 1 },
                            { "v2/settings/common/currencies", 1 },
                            { "v2/reference/currencies", 1 },
                            { "v1/common/timestamp", 1 },
                            { "v1/common/exchange", 1 },
                            { "v1/settings/common/chains", 1 },
                            { "v1/settings/common/currencys", 1 },
                            { "v1/settings/common/symbols", 1 },
                            { "v2/settings/common/symbols", 1 },
                            { "v1/settings/common/market-symbols", 1 },
                            { "market/history/candles", 1 },
                            { "market/history/kline", 1 },
                            { "market/detail/merged", 1 },
                            { "market/tickers", 1 },
                            { "market/detail", 1 },
                            { "market/depth", 1 },
                            { "market/trade", 1 },
                            { "market/history/trade", 1 },
                            { "market/etp", 1 },
                            { "v2/etp/reference", 1 },
                            { "v2/etp/rebalance", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v1/account/accounts", 0.2 },
                            { "v1/account/accounts/{account-id}/balance", 0.2 },
                            { "v2/account/valuation", 1 },
                            { "v2/account/asset-valuation", 0.2 },
                            { "v1/account/history", 4 },
                            { "v2/account/ledger", 1 },
                            { "v2/point/account", 5 },
                            { "v2/account/deposit/address", 1 },
                            { "v2/account/withdraw/quota", 1 },
                            { "v2/account/withdraw/address", 1 },
                            { "v2/reference/currencies", 1 },
                            { "v1/query/deposit-withdraw", 1 },
                            { "v1/query/withdraw/client-order-id", 1 },
                            { "v2/user/api-key", 1 },
                            { "v2/user/uid", 1 },
                            { "v2/sub-user/user-list", 1 },
                            { "v2/sub-user/user-state", 1 },
                            { "v2/sub-user/account-list", 1 },
                            { "v2/sub-user/deposit-address", 1 },
                            { "v2/sub-user/query-deposit", 1 },
                            { "v1/subuser/aggregate-balance", 10 },
                            { "v1/account/accounts/{sub-uid}", 1 },
                            { "v1/order/openOrders", 0.4 },
                            { "v1/order/orders/{order-id}", 0.4 },
                            { "v1/order/orders/getClientOrder", 0.4 },
                            { "v1/order/orders/{order-id}/matchresult", 0.4 },
                            { "v1/order/orders/{order-id}/matchresults", 0.4 },
                            { "v1/order/orders", 0.4 },
                            { "v1/order/history", 1 },
                            { "v1/order/matchresults", 1 },
                            { "v2/reference/transact-fee-rate", 1 },
                            { "v2/algo-orders/opening", 1 },
                            { "v2/algo-orders/history", 1 },
                            { "v2/algo-orders/specific", 1 },
                            { "v1/margin/loan-info", 1 },
                            { "v1/margin/loan-orders", 0.2 },
                            { "v1/margin/accounts/balance", 0.2 },
                            { "v1/cross-margin/loan-info", 1 },
                            { "v1/cross-margin/loan-orders", 1 },
                            { "v1/cross-margin/accounts/balance", 1 },
                            { "v2/account/repayment", 5 },
                            { "v1/stable-coin/quote", 1 },
                            { "v1/stable_coin/exchange_rate", 1 },
                            { "v2/etp/transactions", 5 },
                            { "v2/etp/transaction", 5 },
                            { "v2/etp/limit", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v1/account/transfer", 1 },
                            { "v1/futures/transfer", 1 },
                            { "v2/point/transfer", 5 },
                            { "v2/account/transfer", 1 },
                            { "v1/dw/withdraw/api/create", 1 },
                            { "v1/dw/withdraw-virtual/{withdraw-id}/cancel", 1 },
                            { "v2/sub-user/deduct-mode", 1 },
                            { "v2/sub-user/creation", 1 },
                            { "v2/sub-user/management", 1 },
                            { "v2/sub-user/tradable-market", 1 },
                            { "v2/sub-user/transferability", 1 },
                            { "v2/sub-user/api-key-generation", 1 },
                            { "v2/sub-user/api-key-modification", 1 },
                            { "v2/sub-user/api-key-deletion", 1 },
                            { "v1/subuser/transfer", 10 },
                            { "v1/order/orders/place", 0.2 },
                            { "v1/order/batch-orders", 0.4 },
                            { "v1/order/orders/{order-id}/submitcancel", 0.2 },
                            { "v1/order/orders/submitCancelClientOrder", 0.2 },
                            { "v1/order/orders/batchCancelOpenOrders", 0.4 },
                            { "v1/order/orders/batchcancel", 0.4 },
                            { "v2/algo-orders/cancel-all-after", 1 },
                            { "v2/algo-orders", 1 },
                            { "v2/algo-orders/cancellation", 1 },
                            { "v2/account/repayment", 5 },
                            { "v1/dw/transfer-in/margin", 10 },
                            { "v1/dw/transfer-out/margin", 10 },
                            { "v1/margin/orders", 10 },
                            { "v1/margin/orders/{order-id}/repay", 10 },
                            { "v1/cross-margin/transfer-in", 1 },
                            { "v1/cross-margin/transfer-out", 1 },
                            { "v1/cross-margin/orders", 1 },
                            { "v1/cross-margin/orders/{order-id}/repay", 1 },
                            { "v1/stable-coin/exchange", 1 },
                            { "v2/etp/creation", 5 },
                            { "v2/etp/redemption", 5 },
                            { "v2/etp/{transactId}/cancel", 10 },
                            { "v2/etp/batch-cancel", 50 },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "api/v1/timestamp", 1 },
                            { "heartbeat/", 1 },
                            { "api/v1/contract_contract_info", 1 },
                            { "api/v1/contract_index", 1 },
                            { "api/v1/contract_price_limit", 1 },
                            { "api/v1/contract_open_interest", 1 },
                            { "api/v1/contract_delivery_price", 1 },
                            { "market/depth", 1 },
                            { "market/bbo", 1 },
                            { "market/history/kline", 1 },
                            { "index/market/history/mark_price_kline", 1 },
                            { "market/detail/merged", 1 },
                            { "market/detail/batch_merged", 1 },
                            { "v2/market/detail/batch_merged", 1 },
                            { "market/trade", 1 },
                            { "market/history/trade", 1 },
                            { "api/v1/contract_risk_info", 1 },
                            { "api/v1/contract_insurance_fund", 1 },
                            { "api/v1/contract_adjustfactor", 1 },
                            { "api/v1/contract_his_open_interest", 1 },
                            { "api/v1/contract_ladder_margin", 1 },
                            { "api/v1/contract_api_state", 1 },
                            { "api/v1/contract_elite_account_ratio", 1 },
                            { "api/v1/contract_elite_position_ratio", 1 },
                            { "api/v1/contract_liquidation_orders", 1 },
                            { "api/v1/contract_settlement_records", 1 },
                            { "index/market/history/index", 1 },
                            { "index/market/history/basis", 1 },
                            { "api/v1/contract_estimated_settlement_price", 1 },
                            { "api/v3/contract_liquidation_orders", 1 },
                            { "swap-api/v1/swap_contract_info", 1 },
                            { "swap-api/v1/swap_index", 1 },
                            { "swap-api/v1/swap_price_limit", 1 },
                            { "swap-api/v1/swap_open_interest", 1 },
                            { "swap-ex/market/depth", 1 },
                            { "swap-ex/market/bbo", 1 },
                            { "swap-ex/market/history/kline", 1 },
                            { "index/market/history/swap_mark_price_kline", 1 },
                            { "swap-ex/market/detail/merged", 1 },
                            { "v2/swap-ex/market/detail/batch_merged", 1 },
                            { "index/market/history/swap_premium_index_kline", 1 },
                            { "swap-ex/market/detail/batch_merged", 1 },
                            { "swap-ex/market/trade", 1 },
                            { "swap-ex/market/history/trade", 1 },
                            { "swap-api/v1/swap_risk_info", 1 },
                            { "swap-api/v1/swap_insurance_fund", 1 },
                            { "swap-api/v1/swap_adjustfactor", 1 },
                            { "swap-api/v1/swap_his_open_interest", 1 },
                            { "swap-api/v1/swap_ladder_margin", 1 },
                            { "swap-api/v1/swap_api_state", 1 },
                            { "swap-api/v1/swap_elite_account_ratio", 1 },
                            { "swap-api/v1/swap_elite_position_ratio", 1 },
                            { "swap-api/v1/swap_estimated_settlement_price", 1 },
                            { "swap-api/v1/swap_liquidation_orders", 1 },
                            { "swap-api/v1/swap_settlement_records", 1 },
                            { "swap-api/v1/swap_funding_rate", 1 },
                            { "swap-api/v1/swap_batch_funding_rate", 1 },
                            { "swap-api/v1/swap_historical_funding_rate", 1 },
                            { "swap-api/v3/swap_liquidation_orders", 1 },
                            { "index/market/history/swap_estimated_rate_kline", 1 },
                            { "index/market/history/swap_basis", 1 },
                            { "linear-swap-api/v1/swap_contract_info", 1 },
                            { "linear-swap-api/v1/swap_index", 1 },
                            { "linear-swap-api/v1/swap_price_limit", 1 },
                            { "linear-swap-api/v1/swap_open_interest", 1 },
                            { "linear-swap-ex/market/depth", 1 },
                            { "linear-swap-ex/market/bbo", 1 },
                            { "linear-swap-ex/market/history/kline", 1 },
                            { "index/market/history/linear_swap_mark_price_kline", 1 },
                            { "linear-swap-ex/market/detail/merged", 1 },
                            { "linear-swap-ex/market/detail/batch_merged", 1 },
                            { "v2/linear-swap-ex/market/detail/batch_merged", 1 },
                            { "linear-swap-ex/market/trade", 1 },
                            { "linear-swap-ex/market/history/trade", 1 },
                            { "linear-swap-api/v1/swap_risk_info", 1 },
                            { "swap-api/v1/linear-swap-api/v1/swap_insurance_fund", 1 },
                            { "linear-swap-api/v1/swap_adjustfactor", 1 },
                            { "linear-swap-api/v1/swap_cross_adjustfactor", 1 },
                            { "linear-swap-api/v1/swap_his_open_interest", 1 },
                            { "linear-swap-api/v1/swap_ladder_margin", 1 },
                            { "linear-swap-api/v1/swap_cross_ladder_margin", 1 },
                            { "linear-swap-api/v1/swap_api_state", 1 },
                            { "linear-swap-api/v1/swap_cross_transfer_state", 1 },
                            { "linear-swap-api/v1/swap_cross_trade_state", 1 },
                            { "linear-swap-api/v1/swap_elite_account_ratio", 1 },
                            { "linear-swap-api/v1/swap_elite_position_ratio", 1 },
                            { "linear-swap-api/v1/swap_liquidation_orders", 1 },
                            { "linear-swap-api/v1/swap_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_funding_rate", 1 },
                            { "linear-swap-api/v1/swap_batch_funding_rate", 1 },
                            { "linear-swap-api/v1/swap_historical_funding_rate", 1 },
                            { "linear-swap-api/v3/swap_liquidation_orders", 1 },
                            { "index/market/history/linear_swap_premium_index_kline", 1 },
                            { "index/market/history/linear_swap_estimated_rate_kline", 1 },
                            { "index/market/history/linear_swap_basis", 1 },
                            { "linear-swap-api/v1/swap_estimated_settlement_price", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "api/v1/contract_api_trading_status", 1 },
                            { "swap-api/v1/swap_api_trading_status", 1 },
                            { "linear-swap-api/v1/swap_api_trading_status", 1 },
                            { "linear-swap-api/v3/unified_account_info", 1 },
                            { "linear-swap-api/v3/swap_unified_account_type", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "api/v1/contract_balance_valuation", 1 },
                            { "api/v1/contract_account_info", 1 },
                            { "api/v1/contract_position_info", 1 },
                            { "api/v1/contract_sub_auth", 1 },
                            { "api/v1/contract_sub_account_list", 1 },
                            { "api/v1/contract_sub_account_info_list", 1 },
                            { "api/v1/contract_sub_account_info", 1 },
                            { "api/v1/contract_sub_position_info", 1 },
                            { "api/v1/contract_financial_record", 1 },
                            { "api/v1/contract_financial_record_exact", 1 },
                            { "api/v1/contract_user_settlement_records", 1 },
                            { "api/v1/contract_order_limit", 1 },
                            { "api/v1/contract_fee", 1 },
                            { "api/v1/contract_transfer_limit", 1 },
                            { "api/v1/contract_position_limit", 1 },
                            { "api/v1/contract_account_position_info", 1 },
                            { "api/v1/contract_master_sub_transfer", 1 },
                            { "api/v1/contract_master_sub_transfer_record", 1 },
                            { "api/v1/contract_available_level_rate", 1 },
                            { "api/v3/contract_financial_record", 1 },
                            { "api/v3/contract_financial_record_exact", 1 },
                            { "api/v1/contract_order", 1 },
                            { "v1/contract_batchorder", 1 },
                            { "api/v1/contract_cancel", 1 },
                            { "api/v1/contract_cancelall", 1 },
                            { "api/v1/contract_switch_lever_rate", 1 },
                            { "api/v1/lightning_close_position", 1 },
                            { "api/v1/contract_order_info", 1 },
                            { "api/v1/contract_order_detail", 1 },
                            { "api/v1/contract_openorders", 1 },
                            { "api/v1/contract_hisorders", 1 },
                            { "api/v1/contract_hisorders_exact", 1 },
                            { "api/v1/contract_matchresults", 1 },
                            { "api/v1/contract_matchresults_exact", 1 },
                            { "api/v3/contract_hisorders", 1 },
                            { "api/v3/contract_hisorders_exact", 1 },
                            { "api/v3/contract_matchresults", 1 },
                            { "api/v3/contract_matchresults_exact", 1 },
                            { "api/v1/contract_trigger_order", 1 },
                            { "api/v1/contract_trigger_cancel", 1 },
                            { "api/v1/contract_trigger_cancelall", 1 },
                            { "api/v1/contract_trigger_openorders", 1 },
                            { "api/v1/contract_trigger_hisorders", 1 },
                            { "api/v1/contract_tpsl_order", 1 },
                            { "api/v1/contract_tpsl_cancel", 1 },
                            { "api/v1/contract_tpsl_cancelall", 1 },
                            { "api/v1/contract_tpsl_openorders", 1 },
                            { "api/v1/contract_tpsl_hisorders", 1 },
                            { "api/v1/contract_relation_tpsl_order", 1 },
                            { "api/v1/contract_track_order", 1 },
                            { "api/v1/contract_track_cancel", 1 },
                            { "api/v1/contract_track_cancelall", 1 },
                            { "api/v1/contract_track_openorders", 1 },
                            { "api/v1/contract_track_hisorders", 1 },
                            { "swap-api/v1/swap_balance_valuation", 1 },
                            { "swap-api/v1/swap_account_info", 1 },
                            { "swap-api/v1/swap_position_info", 1 },
                            { "swap-api/v1/swap_account_position_info", 1 },
                            { "swap-api/v1/swap_sub_auth", 1 },
                            { "swap-api/v1/swap_sub_account_list", 1 },
                            { "swap-api/v1/swap_sub_account_info_list", 1 },
                            { "swap-api/v1/swap_sub_account_info", 1 },
                            { "swap-api/v1/swap_sub_position_info", 1 },
                            { "swap-api/v1/swap_financial_record", 1 },
                            { "swap-api/v1/swap_financial_record_exact", 1 },
                            { "swap-api/v1/swap_user_settlement_records", 1 },
                            { "swap-api/v1/swap_available_level_rate", 1 },
                            { "swap-api/v1/swap_order_limit", 1 },
                            { "swap-api/v1/swap_fee", 1 },
                            { "swap-api/v1/swap_transfer_limit", 1 },
                            { "swap-api/v1/swap_position_limit", 1 },
                            { "swap-api/v1/swap_master_sub_transfer", 1 },
                            { "swap-api/v1/swap_master_sub_transfer_record", 1 },
                            { "swap-api/v3/swap_financial_record", 1 },
                            { "swap-api/v3/swap_financial_record_exact", 1 },
                            { "swap-api/v1/swap_order", 1 },
                            { "swap-api/v1/swap_batchorder", 1 },
                            { "swap-api/v1/swap_cancel", 1 },
                            { "swap-api/v1/swap_cancelall", 1 },
                            { "swap-api/v1/swap_lightning_close_position", 1 },
                            { "swap-api/v1/swap_switch_lever_rate", 1 },
                            { "swap-api/v1/swap_order_info", 1 },
                            { "swap-api/v1/swap_order_detail", 1 },
                            { "swap-api/v1/swap_openorders", 1 },
                            { "swap-api/v1/swap_hisorders", 1 },
                            { "swap-api/v1/swap_hisorders_exact", 1 },
                            { "swap-api/v1/swap_matchresults", 1 },
                            { "swap-api/v1/swap_matchresults_exact", 1 },
                            { "swap-api/v3/swap_matchresults", 1 },
                            { "swap-api/v3/swap_matchresults_exact", 1 },
                            { "swap-api/v3/swap_hisorders", 1 },
                            { "swap-api/v3/swap_hisorders_exact", 1 },
                            { "swap-api/v1/swap_trigger_order", 1 },
                            { "swap-api/v1/swap_trigger_cancel", 1 },
                            { "swap-api/v1/swap_trigger_cancelall", 1 },
                            { "swap-api/v1/swap_trigger_openorders", 1 },
                            { "swap-api/v1/swap_trigger_hisorders", 1 },
                            { "swap-api/v1/swap_tpsl_order", 1 },
                            { "swap-api/v1/swap_tpsl_cancel", 1 },
                            { "swap-api/v1/swap_tpsl_cancelall", 1 },
                            { "swap-api/v1/swap_tpsl_openorders", 1 },
                            { "swap-api/v1/swap_tpsl_hisorders", 1 },
                            { "swap-api/v1/swap_relation_tpsl_order", 1 },
                            { "swap-api/v1/swap_track_order", 1 },
                            { "swap-api/v1/swap_track_cancel", 1 },
                            { "swap-api/v1/swap_track_cancelall", 1 },
                            { "swap-api/v1/swap_track_openorders", 1 },
                            { "swap-api/v1/swap_track_hisorders", 1 },
                            { "linear-swap-api/v1/swap_lever_position_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_lever_position_limit", 1 },
                            { "linear-swap-api/v1/swap_balance_valuation", 1 },
                            { "linear-swap-api/v1/swap_account_info", 1 },
                            { "linear-swap-api/v1/swap_cross_account_info", 1 },
                            { "linear-swap-api/v1/swap_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_position_info", 1 },
                            { "linear-swap-api/v1/swap_account_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_account_position_info", 1 },
                            { "linear-swap-api/v1/swap_sub_auth", 1 },
                            { "linear-swap-api/v1/swap_sub_account_list", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_list", 1 },
                            { "linear-swap-api/v1/swap_sub_account_info_list", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_info_list", 1 },
                            { "linear-swap-api/v1/swap_sub_account_info", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_info", 1 },
                            { "linear-swap-api/v1/swap_sub_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_position_info", 1 },
                            { "linear-swap-api/v1/swap_financial_record", 1 },
                            { "linear-swap-api/v1/swap_financial_record_exact", 1 },
                            { "linear-swap-api/v1/swap_user_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_cross_user_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_available_level_rate", 1 },
                            { "linear-swap-api/v1/swap_cross_available_level_rate", 1 },
                            { "linear-swap-api/v1/swap_order_limit", 1 },
                            { "linear-swap-api/v1/swap_fee", 1 },
                            { "linear-swap-api/v1/swap_transfer_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_transfer_limit", 1 },
                            { "linear-swap-api/v1/swap_position_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_position_limit", 1 },
                            { "linear-swap-api/v1/swap_master_sub_transfer", 1 },
                            { "linear-swap-api/v1/swap_master_sub_transfer_record", 1 },
                            { "linear-swap-api/v1/swap_transfer_inner", 1 },
                            { "linear-swap-api/v3/swap_financial_record", 1 },
                            { "linear-swap-api/v3/swap_financial_record_exact", 1 },
                            { "linear-swap-api/v1/swap_order", 1 },
                            { "linear-swap-api/v1/swap_cross_order", 1 },
                            { "linear-swap-api/v1/swap_batchorder", 1 },
                            { "linear-swap-api/v1/swap_cross_batchorder", 1 },
                            { "linear-swap-api/v1/swap_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_cancel", 1 },
                            { "linear-swap-api/v1/swap_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_cancelall", 1 },
                            { "linear-swap-api/v1/swap_switch_lever_rate", 1 },
                            { "linear-swap-api/v1/swap_cross_switch_lever_rate", 1 },
                            { "linear-swap-api/v1/swap_lightning_close_position", 1 },
                            { "linear-swap-api/v1/swap_cross_lightning_close_position", 1 },
                            { "linear-swap-api/v1/swap_order_info", 1 },
                            { "linear-swap-api/v1/swap_cross_order_info", 1 },
                            { "linear-swap-api/v1/swap_order_detail", 1 },
                            { "linear-swap-api/v1/swap_cross_order_detail", 1 },
                            { "linear-swap-api/v1/swap_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_openorders", 1 },
                            { "linear-swap-api/v1/swap_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_hisorders", 1 },
                            { "linear-swap-api/v1/swap_hisorders_exact", 1 },
                            { "linear-swap-api/v1/swap_cross_hisorders_exact", 1 },
                            { "linear-swap-api/v1/swap_matchresults", 1 },
                            { "linear-swap-api/v1/swap_cross_matchresults", 1 },
                            { "linear-swap-api/v1/swap_matchresults_exact", 1 },
                            { "linear-swap-api/v1/swap_cross_matchresults_exact", 1 },
                            { "linear-swap-api/v1/swap_switch_position_mode", 1 },
                            { "linear-swap-api/v1/swap_cross_switch_position_mode", 1 },
                            { "linear-swap-api/v3/swap_matchresults", 1 },
                            { "linear-swap-api/v3/swap_cross_matchresults", 1 },
                            { "linear-swap-api/v3/swap_matchresults_exact", 1 },
                            { "linear-swap-api/v3/swap_cross_matchresults_exact", 1 },
                            { "linear-swap-api/v3/swap_hisorders", 1 },
                            { "linear-swap-api/v3/swap_cross_hisorders", 1 },
                            { "linear-swap-api/v3/swap_hisorders_exact", 1 },
                            { "linear-swap-api/v3/swap_cross_hisorders_exact", 1 },
                            { "linear-swap-api/v3/swap_switch_account_type", 1 },
                            { "linear-swap-api/v1/swap_trigger_order", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_order", 1 },
                            { "linear-swap-api/v1/swap_trigger_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_cancel", 1 },
                            { "linear-swap-api/v1/swap_trigger_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_cancelall", 1 },
                            { "linear-swap-api/v1/swap_trigger_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_openorders", 1 },
                            { "linear-swap-api/v1/swap_trigger_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_hisorders", 1 },
                            { "linear-swap-api/v1/swap_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_tpsl_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_cancel", 1 },
                            { "linear-swap-api/v1/swap_tpsl_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_cancelall", 1 },
                            { "linear-swap-api/v1/swap_tpsl_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_openorders", 1 },
                            { "linear-swap-api/v1/swap_tpsl_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_hisorders", 1 },
                            { "linear-swap-api/v1/swap_relation_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_cross_relation_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_track_order", 1 },
                            { "linear-swap-api/v1/swap_cross_track_order", 1 },
                            { "linear-swap-api/v1/swap_track_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_track_cancel", 1 },
                            { "linear-swap-api/v1/swap_track_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_track_cancelall", 1 },
                            { "linear-swap-api/v1/swap_track_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_track_openorders", 1 },
                            { "linear-swap-api/v1/swap_track_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_track_hisorders", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "broad", new Dictionary<string, object>() {
                    { "contract is restricted of closing positions on API.  Please contact customer service", typeof(OnMaintenance) },
                    { "maintain", typeof(OnMaintenance) },
                } },
                { "exact", new Dictionary<string, object>() {
                    { "403", typeof(AuthenticationError) },
                    { "1010", typeof(AccountNotEnabled) },
                    { "1003", typeof(AuthenticationError) },
                    { "1013", typeof(BadSymbol) },
                    { "1017", typeof(OrderNotFound) },
                    { "1034", typeof(InvalidOrder) },
                    { "1036", typeof(InvalidOrder) },
                    { "1039", typeof(InvalidOrder) },
                    { "1041", typeof(InvalidOrder) },
                    { "1047", typeof(InsufficientFunds) },
                    { "1048", typeof(InsufficientFunds) },
                    { "1051", typeof(InvalidOrder) },
                    { "1066", typeof(BadSymbol) },
                    { "1067", typeof(InvalidOrder) },
                    { "1094", typeof(InvalidOrder) },
                    { "1220", typeof(AccountNotEnabled) },
                    { "1303", typeof(BadRequest) },
                    { "1461", typeof(InvalidOrder) },
                    { "bad-request", typeof(BadRequest) },
                    { "validation-format-error", typeof(BadRequest) },
                    { "validation-constraints-required", typeof(BadRequest) },
                    { "base-date-limit-error", typeof(BadRequest) },
                    { "api-not-support-temp-addr", typeof(PermissionDenied) },
                    { "timeout", typeof(RequestTimeout) },
                    { "gateway-internal-error", typeof(ExchangeNotAvailable) },
                    { "account-frozen-balance-insufficient-error", typeof(InsufficientFunds) },
                    { "invalid-amount", typeof(InvalidOrder) },
                    { "order-limitorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-amount-max-error", typeof(InvalidOrder) },
                    { "order-marketorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-max-error", typeof(InvalidOrder) },
                    { "order-stop-order-hit-trigger", typeof(InvalidOrder) },
                    { "order-value-min-error", typeof(InvalidOrder) },
                    { "order-invalid-price", typeof(InvalidOrder) },
                    { "order-holding-limit-failed", typeof(InvalidOrder) },
                    { "order-orderprice-precision-error", typeof(InvalidOrder) },
                    { "order-etp-nav-price-max-error", typeof(InvalidOrder) },
                    { "order-orderstate-error", typeof(OrderNotFound) },
                    { "order-queryorder-invalid", typeof(OrderNotFound) },
                    { "order-update-error", typeof(ExchangeNotAvailable) },
                    { "api-signature-check-failed", typeof(AuthenticationError) },
                    { "api-signature-not-valid", typeof(AuthenticationError) },
                    { "base-record-invalid", typeof(OrderNotFound) },
                    { "base-symbol-trade-disabled", typeof(BadSymbol) },
                    { "base-symbol-error", typeof(BadSymbol) },
                    { "system-maintenance", typeof(OnMaintenance) },
                    { "base-request-exceed-frequency-limit", typeof(RateLimitExceeded) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "symbol trade not open now", typeof(BadSymbol) },
                    { "require-symbol", typeof(BadSymbol) },
                    { "invalid-address", typeof(BadRequest) },
                    { "base-currency-chain-error", typeof(BadRequest) },
                    { "dw-insufficient-balance", typeof(InsufficientFunds) },
                    { "base-withdraw-fee-error", typeof(BadRequest) },
                    { "dw-withdraw-min-limit", typeof(BadRequest) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new Dictionary<string, object>() {
                        { "spot", true },
                        { "future", new Dictionary<string, object>() {
                            { "linear", true },
                            { "inverse", true },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "linear", true },
                            { "inverse", true },
                        } },
                    } },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "BTC", "BTC" },
                    { "USDT", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ALGO", "ALGO" },
                    { "ALGORAND", "ALGO" },
                    { "BEP20", "BEP20" },
                    { "BSC", "BEP20" },
                    { "ERC20", "ERC20" },
                    { "ETH", "ERC20" },
                    { "AVALANCHE", "AVAXCCHAIN" },
                    { "AVAX", "AVAXCCHAIN" },
                    { "HRC20", "HECO" },
                    { "HECO", "HECO" },
                    { "TRC20", "TRC20" },
                    { "TRX", "TRC20" },
                    { "BTC", "BTC" },
                    { "BITCOIN", "BTC" },
                    { "ARBITRUM", "ARB" },
                    { "ARB", "ARB" },
                    { "SOLANA", "SOL" },
                    { "SOL", "SOL" },
                    { "SPL", "SOL" },
                    { "PRC20", "PRC20" },
                    { "POLYGON", "PRC20" },
                    { "MATIC", "PRC20" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ALGO", "ALGO" },
                    { "BEP20", "BEP20" },
                    { "ERC20", "ERC20" },
                    { "AVAXCCHAIN", "AVALANCHE" },
                    { "HECO", "HRC20" },
                    { "TRC20", "TRC20" },
                    { "BTC", "BTC" },
                    { "ARB", "ARBITRUM" },
                    { "SOL", "SOLANA" },
                    { "PRC20", "POLYGON" },
                } },
                { "fetchOrdersByStatesMethod", "spot_private_get_v1_order_orders" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "language", "en-US" },
                { "broker", new Dictionary<string, object>() {
                    { "id", "AA03022abc" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "pro" },
                    { "funding", "pro" },
                    { "future", "futures" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "margin", "margin" },
                    { "otc", "otc" },
                    { "point", "point" },
                    { "super-margin", "super-margin" },
                    { "investment", "investment" },
                    { "borrow", "borrow" },
                    { "grid-trading", "grid-trading" },
                    { "deposit-earning", "deposit-earning" },
                    { "otc-options", "otc-options" },
                } },
                { "marginAccounts", new Dictionary<string, object>() {
                    { "cross", "super-margin" },
                    { "isolated", "margin" },
                } },
                { "typesByAccount", new Dictionary<string, object>() {
                    { "pro", "spot" },
                    { "futures", "future" },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "stopOrderTypes", new Dictionary<string, object>() {
                        { "stop-limit", true },
                        { "buy-stop-limit", true },
                        { "sell-stop-limit", true },
                        { "stop-limit-fok", true },
                        { "buy-stop-limit-fok", true },
                        { "sell-stop-limit-fok", true },
                    } },
                    { "limitOrderTypes", new Dictionary<string, object>() {
                        { "limit", true },
                        { "buy-limit", true },
                        { "sell-limit", true },
                        { "ioc", true },
                        { "buy-ioc", true },
                        { "sell-ioc", true },
                        { "limit-maker", true },
                        { "buy-limit-maker", true },
                        { "sell-limit-maker", true },
                        { "stop-limit", true },
                        { "buy-stop-limit", true },
                        { "sell-stop-limit", true },
                        { "limit-fok", true },
                        { "buy-limit-fok", true },
                        { "sell-limit-fok", true },
                        { "stop-limit-fok", true },
                        { "buy-stop-limit-fok", true },
                        { "sell-stop-limit-fok", true },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "GET", "Themis" },
                { "GTC", "Game.com" },
                { "HIT", "HitChain" },
                { "HOT", "Hydro Protocol" },
                { "PNT", "Penta" },
                { "SBTC", "Super Bitcoin" },
                { "SOUL", "Soulsaver" },
                { "BIFI", "Bitcoin File" },
            } },
        });
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = "statusPublicSpotGetApiV2SummaryJson";
        if (isTrue(!isEqual(marketType, "spot")))
        {
            object subType = this.safeString(parameters, "subType", getValue(this.options, "defaultSubType"));
            if (isTrue(isEqual(marketType, "swap")))
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    method = "statusPublicSwapLinearGetApiV2SummaryJson";
                } else if (isTrue(isEqual(subType, "inverse")))
                {
                    method = "statusPublicSwapInverseGetApiV2SummaryJson";
                }
            } else if (isTrue(isEqual(marketType, "future")))
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    method = "statusPublicFutureLinearGetApiV2SummaryJson";
                } else if (isTrue(isEqual(subType, "inverse")))
                {
                    method = "statusPublicFutureInverseGetApiV2SummaryJson";
                }
            } else if (isTrue(isEqual(marketType, "contract")))
            {
                method = "contractPublicGetHeartbeat";
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] {  }));
        //
        // statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
        //
        //      {
        //          "page": {
        //              "id":"mn7l2lw8pz4p",
        //              "name":"Huobi Futures-USDT-margined Swaps",
        //              "url":"https://status-linear-swap.huobigroup.com",
        //              "time_zone":"Asia/Singapore",
        //              "updated_at":"2022-04-29T12:47:21.319+08:00"},
        //              "components": [
        //                  {
        //                      "id":"lrv093qk3yp5",
        //                      "name":"market data",
        //                      "status":"operational",
        //                      "created_at":"2020-10-29T14:08:59.427+08:00",
        //                      "updated_at":"2020-10-29T14:08:59.427+08:00",
        //                      "position":1,"description":null,
        //                      "showcase":false,
        //                      "start_date":null,
        //                      "group_id":null,
        //                      "page_id":"mn7l2lw8pz4p",
        //                      "group":true,
        //                      "only_show_if_degraded":false,
        //                      "components": [
        //                          "82k5jxg7ltxd" // list of related components
        //                      ]
        //                  },
        //              ],
        //              "incidents": [ // empty array if there are no issues
        //                  {
        //                      "id": "rclfxz2g21ly",  // incident id
        //                      "name": "Market data is delayed",  // incident name
        //                      "status": "investigating",  // incident status
        //                      "created_at": "2020-02-11T03:15:01.913Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:15:02.003Z",   // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "minor",  // incident impact
        //                      "shortlink": "http://stspg.io/pkvbwp8jppf9",
        //                      "started_at": "2020-02-11T03:15:01.906Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "dwfsk5ttyvtb",
        //                              "status": "investigating",
        //                              "body": "Market data is delayed",
        //                              "incident_id": "rclfxz2g21ly",
        //                              "created_at": "2020-02-11T03:15:02.000Z",
        //                              "updated_at": "2020-02-11T03:15:02.000Z",
        //                              "display_at": "2020-02-11T03:15:02.000Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "nctwm9tghxh6",
        //                                      "name": "Market data",
        //                                      "old_status": "operational",
        //                                      "new_status": "degraded_performance"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "nctwm9tghxh6",
        //                              "name": "Market data",
        //                              "status": "degraded_performance",
        //                              "created_at": "2020-01-13T09:34:48.284Z",
        //                              "updated_at": "2020-02-11T03:15:01.951Z",
        //                              "position": 8,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": null,
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ]
        //                  }, ...
        //              ],
        //              "scheduled_maintenances":[ // empty array if there are no scheduled maintenances
        //                  {
        //                      "id": "k7g299zl765l", // incident id
        //                      "name": "Schedule maintenance", // incident name
        //                      "status": "scheduled", // incident status
        //                      "created_at": "2020-02-11T03:16:31.481Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:16:31.530Z",  // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "maintenance",  // incident impact
        //                      "shortlink": "http://stspg.io/md4t4ym7nytd",
        //                      "started_at": "2020-02-11T03:16:31.474Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "8whgr3rlbld8",
        //                              "status": "scheduled",
        //                              "body": "We will be undergoing scheduled maintenance during this time.",
        //                              "incident_id": "k7g299zl765l",
        //                              "created_at": "2020-02-11T03:16:31.527Z",
        //                              "updated_at": "2020-02-11T03:16:31.527Z",
        //                              "display_at": "2020-02-11T03:16:31.527Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "h028tnzw1n5l",
        //                                      "name": "Deposit And Withdraw - Deposit",
        //                                      "old_status": "operational",
        //                                      "new_status": "operational"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "h028tnzw1n5l",
        //                              "name": "Deposit",
        //                              "status": "operational",
        //                              "created_at": "2019-12-05T02:07:12.372Z",
        //                              "updated_at": "2020-02-10T12:34:52.970Z",
        //                              "position": 1,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": "gtd0nyr3pf0k",
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ],
        //                      "scheduled_for": "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
        //                      "scheduled_until": "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
        //                  }
        //              ],
        //              "status": {
        //                  "indicator":"none", // none, minor, major, critical, maintenance
        //                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
        //              }
        //          }
        //
        //
        // contractPublicGetHeartbeat
        //
        //      {
        //          "status": "ok", // 'ok', 'error'
        //          "data": {
        //              "heartbeat": 1, // future 1: available, 0: maintenance with service suspended
        //              "estimated_recovery_time": null, // estimated recovery time in milliseconds
        //              "swap_heartbeat": 1,
        //              "swap_estimated_recovery_time": null,
        //              "option_heartbeat": 1,
        //              "option_estimated_recovery_time": null,
        //              "linear_swap_heartbeat": 1,
        //              "linear_swap_estimated_recovery_time": null
        //          },
        //          "ts": 1557714418033
        //      }
        //
        object status = null;
        object updated = null;
        object url = null;
        if (isTrue(isEqual(method, "contractPublicGetHeartbeat")))
        {
            object statusRaw = this.safeString(response, "status");
            status = ((bool) isTrue((isEqual(statusRaw, "ok")))) ? "ok" : "maintenance"; // 'ok', 'error'
            updated = this.safeString(response, "ts");
        } else
        {
            object statusData = this.safeValue(response, "status", new Dictionary<string, object>() {});
            object statusRaw = this.safeString(statusData, "indicator");
            status = ((bool) isTrue((isEqual(statusRaw, "none")))) ? "ok" : "maintenance"; // none, minor, major, critical, maintenance
            object pageData = this.safeValue(response, "page", new Dictionary<string, object>() {});
            object datetime = this.safeString(pageData, "updated_at");
            updated = this.parse8601(datetime);
            url = this.safeString(pageData, "url");
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", updated },
            { "eta", null },
            { "url", url },
            { "info", response },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchTime", new Dictionary<string, object>() {});
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        object type = this.safeString(options, "type", defaultType);
        type = this.safeString(parameters, "type", type);
        object method = "spotPublicGetV1CommonTimestamp";
        if (isTrue(isTrue((isEqual(type, "future"))) || isTrue((isEqual(type, "swap")))))
        {
            method = "contractPublicGetApiV1Timestamp";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        //
        // spot
        //
        //     {"status":"ok","data":1637504261099}
        //
        // future, swap
        //
        //     {"status":"ok","ts":1637504164707}
        //
        return this.safeInteger2(response, "data", "ts");
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol":"btcusdt",
        //         "actualMakerRate":"0.002",
        //         "actualTakerRate":"0.002",
        //         "takerFeeRate":"0.002",
        //         "makerFeeRate":"0.002"
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(fee, "actualMakerRate") },
            { "taker", this.safeNumber(fee, "actualTakerRate") },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
        };
        object response = await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "data":[
        //             {
        //                 "symbol":"btcusdt",
        //                 "actualMakerRate":"0.002",
        //                 "actualTakerRate":"0.002",
        //                 "takerFeeRate":"0.002",
        //                 "makerFeeRate":"0.002"
        //             }
        //         ],
        //         "success":true
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first, market);
    }

    public async override Task<object> fetchTradingLimits(object symbols = null, object parameters = null)
    {
        // this method should not be called directly, use loadTradingLimits () instead
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = this.symbols;
        }
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((Dictionary<string, object>)result)[(string)symbol] = await this.fetchTradingLimitsById(this.marketId(symbol), parameters);
        }
        return result;
    }

    public async virtual Task<object> fetchTradingLimitsById(object id, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "symbol", id },
        };
        object response = await this.spotPublicGetV1CommonExchange(this.extend(request, parameters));
        //
        //     { status:   "ok",
        //         data: {                                  symbol: "aidocbtc",
        //                              'buy-limit-must-less-than':  1.1,
        //                          'sell-limit-must-greater-than':  0.9,
        //                         'limit-order-must-greater-than':  1,
        //                            'limit-order-must-less-than':  5000000,
        //                    'market-buy-order-must-greater-than':  0.0001,
        //                       'market-buy-order-must-less-than':  100,
        //                   'market-sell-order-must-greater-than':  1,
        //                      'market-sell-order-must-less-than':  500000,
        //                       'circuit-break-when-greater-than':  10000,
        //                          'circuit-break-when-less-than':  10,
        //                 'market-sell-order-rate-must-less-than':  0.1,
        //                  'market-buy-order-rate-must-less-than':  0.1        } }
        //
        return this.parseTradingLimits(this.safeValue(response, "data", new Dictionary<string, object>() {}));
    }

    public virtual object parseTradingLimits(object limits, object symbol = null, object parameters = null)
    {
        //
        //   {                                  symbol: "aidocbtc",
        //                  'buy-limit-must-less-than':  1.1,
        //              'sell-limit-must-greater-than':  0.9,
        //             'limit-order-must-greater-than':  1,
        //                'limit-order-must-less-than':  5000000,
        //        'market-buy-order-must-greater-than':  0.0001,
        //           'market-buy-order-must-less-than':  100,
        //       'market-sell-order-must-greater-than':  1,
        //          'market-sell-order-must-less-than':  500000,
        //           'circuit-break-when-greater-than':  10000,
        //              'circuit-break-when-less-than':  10,
        //     'market-sell-order-rate-must-less-than':  0.1,
        //      'market-buy-order-rate-must-less-than':  0.1        }
        //
        parameters ??= new Dictionary<string, object>();
        return new Dictionary<string, object>() {
            { "info", limits },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(limits, "limit-order-must-greater-than") },
                    { "max", this.safeNumber(limits, "limit-order-must-less-than") },
                } },
            } },
        };
    }

    public override object costToPrecision(object symbol, object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "cost"), this.precisionMode);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchMarkets
        * @description retrieves data on all markets for huobi
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object types = this.safeValue(options, "types", new Dictionary<string, object>() {});
        object allMarkets = new List<object>() {};
        object promises = new List<object>() {};
        object keys = new List<object>(((Dictionary<string,object>)types).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object type = getValue(keys, i);
            object value = this.safeValue(types, type);
            if (isTrue(isEqual(value, true)))
            {
                ((List<object>)promises).Add(this.fetchMarketsByTypeAndSubType(type, null, parameters));
            } else if (isTrue(!isEqual(value, null)))
            {
                object subKeys = new List<object>(((Dictionary<string,object>)value).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(subKeys)); postFixIncrement(ref j))
                {
                    object subType = getValue(subKeys, j);
                    object subValue = this.safeValue(value, subType);
                    if (isTrue(subValue))
                    {
                        ((List<object>)promises).Add(this.fetchMarketsByTypeAndSubType(type, subType, parameters));
                    }
                }
            }
        }
        promises = await promiseAll(promises);
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            allMarkets = this.arrayConcat(allMarkets, getValue(promises, i));
        }
        return allMarkets;
    }

    public async virtual Task<object> fetchMarketsByTypeAndSubType(object type, object subType, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = "spotPublicGetV1CommonSymbols";
        object query = this.omit(parameters, new List<object>() {"type", "subType"});
        object spot = (isEqual(type, "spot"));
        object contract = (!isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object linear = null;
        object inverse = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(contract))
        {
            linear = (isEqual(subType, "linear"));
            inverse = (isEqual(subType, "inverse"));
            if (isTrue(linear))
            {
                method = "contractPublicGetLinearSwapApiV1SwapContractInfo";
                if (isTrue(future))
                {
                    ((Dictionary<string, object>)request)["business_type"] = "futures";
                }
            } else if (isTrue(inverse))
            {
                if (isTrue(future))
                {
                    method = "contractPublicGetApiV1ContractContractInfo";
                } else if (isTrue(swap))
                {
                    method = "contractPublicGetSwapApiV1SwapContractInfo";
                }
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "base-currency":"xrp3s",
        //                 "quote-currency":"usdt",
        //                 "price-precision":4,
        //                 "amount-precision":4,
        //                 "symbol-partition":"innovation",
        //                 "symbol":"xrp3susdt",
        //                 "state":"online",
        //                 "value-precision":8,
        //                 "min-order-amt":0.01,
        //                 "max-order-amt":1616.4353,
        //                 "min-order-value":5,
        //                 "limit-order-min-order-amt":0.01,
        //                 "limit-order-max-order-amt":1616.4353,
        //                 "limit-order-max-buy-amt":1616.4353,
        //                 "limit-order-max-sell-amt":1616.4353,
        //                 "sell-market-min-order-amt":0.01,
        //                 "sell-market-max-order-amt":1616.4353,
        //                 "buy-market-max-order-value":2500,
        //                 "max-order-value":2500,
        //                 "underlying":"xrpusdt",
        //                 "mgmt-fee-rate":0.035000000000000000,
        //                 "charge-time":"23:55:00",
        //                 "rebal-time":"00:00:00",
        //                 "rebal-threshold":-5,
        //                 "init-nav":10.000000000000000000,
        //                 "api-trading":"enabled",
        //                 "tags":"etp,nav,holdinglimit"
        //             },
        //         ]
        //     }
        //
        // inverse future
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC211126",
        //                 "contract_type":"this_week",
        //                 "contract_size":100.000000000000000000,
        //                 "price_tick":0.010000000000000000,
        //                 "delivery_date":"20211126",
        //                 "delivery_time":"1637913600000",
        //                 "create_date":"20211112",
        //                 "contract_status":1,
        //                 "settlement_time":"1637481600000"
        //             },
        //         ],
        //         "ts":1637474595140
        //     }
        //
        // linear futures
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT-211231",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_date":"20211231",
        //                 "delivery_time":"1640937600000",
        //                 "create_date":"20211228",
        //                 "contract_status":1,
        //                 "settlement_date":"1640764800000",
        //                 "support_margin_mode":"cross",
        //                 "business_type":"futures",
        //                 "pair":"BTC-USDT",
        //                 "contract_type":"this_week" // next_week, quarter
        //             },
        //         ],
        //         "ts":1640736207263
        //     }
        //
        // swaps
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_time":"",
        //                 "create_date":"20201021",
        //                 "contract_status":1,
        //                 "settlement_date":"1637481600000",
        //                 "support_margin_mode":"all", // isolated
        //             },
        //         ],
        //         "ts":1637474774467
        //     }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        object numMarkets = getArrayLength(markets);
        if (isTrue(isLessThan(numMarkets, 1)))
        {
            throw new NetworkError ((string)add(add(this.id, " fetchMarkets() returned an empty response: "), this.json(markets))) ;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object baseId = null;
            object quoteId = null;
            object settleId = null;
            object id = null;
            object lowercaseId = null;
            object lowercaseBaseId = null;
            if (isTrue(contract))
            {
                id = this.safeString(market, "contract_code");
                lowercaseId = ((string)id).ToLower();
                if (isTrue(swap))
                {
                    object parts = ((string)id).Split((string)"-").ToList<object>();
                    baseId = this.safeString(market, "symbol");
                    lowercaseBaseId = ((string)baseId).ToLower();
                    quoteId = this.safeStringLower(parts, 1);
                    settleId = ((bool) isTrue(inverse)) ? baseId : quoteId;
                } else if (isTrue(future))
                {
                    baseId = this.safeString(market, "symbol");
                    lowercaseBaseId = ((string)baseId).ToLower();
                    if (isTrue(inverse))
                    {
                        quoteId = "USD";
                        settleId = baseId;
                    } else
                    {
                        object pair = this.safeString(market, "pair");
                        object parts = ((string)pair).Split((string)"-").ToList<object>();
                        quoteId = this.safeString(parts, 1);
                        settleId = quoteId;
                    }
                }
            } else
            {
                baseId = this.safeString(market, "base-currency");
                lowercaseBaseId = ((string)baseId).ToLower();
                quoteId = this.safeString(market, "quote-currency");
                id = add(baseId, quoteId);
                lowercaseId = ((string)id).ToLower();
            }
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(bs, "/"), quote);
            object expiry = null;
            if (isTrue(contract))
            {
                if (isTrue(inverse))
                {
                    symbol = add(symbol, add(":", bs));
                } else if (isTrue(linear))
                {
                    symbol = add(symbol, add(":", quote));
                }
                if (isTrue(future))
                {
                    expiry = this.safeInteger(market, "delivery_time");
                    symbol = add(symbol, add("-", this.yymmdd(expiry)));
                }
            }
            object contractSize = this.safeNumber(market, "contract_size");
            object minCost = this.safeNumber(market, "min-order-value");
            object maxAmount = this.safeNumber(market, "max-order-amt");
            object minAmount = this.safeNumber(market, "min-order-amt");
            if (isTrue(contract))
            {
                if (isTrue(linear))
                {
                    minAmount = contractSize;
                } else if (isTrue(inverse))
                {
                    minCost = contractSize;
                }
            }
            object pricePrecision = null;
            object amountPrecision = null;
            object costPrecision = null;
            if (isTrue(spot))
            {
                pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "price-precision")));
                amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "amount-precision")));
                costPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "value-precision")));
            } else
            {
                pricePrecision = this.safeNumber(market, "price_tick");
                amountPrecision = this.parseNumber("1"); // other markets have step size of 1 contract
            }
            object maker = null;
            object taker = null;
            if (isTrue(spot))
            {
                maker = ((bool) isTrue((isEqual(bs, "OMG")))) ? this.parseNumber("0") : this.parseNumber("0.002");
                taker = ((bool) isTrue((isEqual(bs, "OMG")))) ? this.parseNumber("0") : this.parseNumber("0.002");
            }
            object active = null;
            if (isTrue(spot))
            {
                object state = this.safeString(market, "state");
                active = (isEqual(state, "online"));
            } else if (isTrue(contract))
            {
                object contractStatus = this.safeInteger(market, "contract_status");
                active = (isEqual(contractStatus, 1));
            }
            object leverageRatio = this.safeString(market, "leverage-ratio", "1");
            object superLeverageRatio = this.safeString(market, "super-margin-leverage-ratio", "1");
            object hasLeverage = isTrue(Precise.stringGt(leverageRatio, "1")) || isTrue(Precise.stringGt(superLeverageRatio, "1"));
            // 0 Delisting
            // 1 Listing
            // 2 Pending Listing
            // 3 Suspension
            // 4 Suspending of Listing
            // 5 In Settlement
            // 6 Delivering
            // 7 Settlement Completed
            // 8 Delivered
            // 9 Suspending of Trade
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "lowercaseId", lowercaseId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "lowercaseBaseId", lowercaseBaseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", (isTrue(spot) && isTrue(hasLeverage)) },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "active", active },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", pricePrecision },
                    { "cost", costPrecision },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.parseNumber(leverageRatio) },
                        { "superMax", this.parseNumber(superLeverageRatio) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", minAmount },
                        { "max", maxAmount },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", minCost },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "amount": 26228.672978342216,
        //         "open": 9078.95,
        //         "close": 9146.86,
        //         "high": 9155.41,
        //         "id": 209988544334,
        //         "count": 265846,
        //         "low": 8988.0,
        //         "version": 209988544334,
        //         "ask": [ 9146.87, 0.156134 ],
        //         "vol": 2.3822168242201668E8,
        //         "bid": [ 9146.86, 0.080758 ],
        //     }
        //
        // fetchTickers
        //
        //     {
        //         symbol: "bhdht",
        //         open:  2.3938,
        //         high:  2.4151,
        //         low:  2.3323,
        //         close:  2.3909,
        //         amount:  628.992,
        //         vol:  1493.71841095,
        //         count:  2088,
        //         bid:  2.3643,
        //         bidSize:  0.7136,
        //         ask:  2.4061,
        //         askSize:  0.4156
        //     }
        //
        // watchTikcer - bbo
        //     {
        //         seqId: 161499562790,
        //         ask: 16829.51,
        //         askSize: 0.707776,
        //         bid: 16829.5,
        //         bidSize: 1.685945,
        //         quoteTime: 1671941599612,
        //         symbol: 'btcusdt'
        //     }
        //
        object marketId = this.safeString2(ticker, "symbol", "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger2(ticker, "ts", "quoteTime");
        object bid = null;
        object bidVolume = null;
        object ask = null;
        object askVolume = null;
        if (isTrue(((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("bid"))))
        {
            if (isTrue((getValue(ticker, "bid").GetType().IsGenericType && getValue(ticker, "bid").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                bid = this.safeString(getValue(ticker, "bid"), 0);
                bidVolume = this.safeString(getValue(ticker, "bid"), 1);
            } else
            {
                bid = this.safeString(ticker, "bid");
                bidVolume = this.safeString(ticker, "bidSize");
            }
        }
        if (isTrue(((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("ask"))))
        {
            if (isTrue((getValue(ticker, "ask").GetType().IsGenericType && getValue(ticker, "ask").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                ask = this.safeString(getValue(ticker, "ask"), 0);
                askVolume = this.safeString(getValue(ticker, "ask"), 1);
            } else
            {
                ask = this.safeString(ticker, "ask");
                askVolume = this.safeString(ticker, "askSize");
            }
        }
        object open = this.safeString(ticker, "open");
        object close = this.safeString(ticker, "close");
        object baseVolume = this.safeString(ticker, "amount");
        object quoteVolume = this.safeString(ticker, "vol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object fieldName = "symbol";
        object method = "spotPublicGetMarketDetailMerged";
        if (isTrue(getValue(market, "linear")))
        {
            method = "contractPublicGetLinearSwapExMarketDetailMerged";
            fieldName = "contract_code";
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "future")))
            {
                method = "contractPublicGetMarketDetailMerged";
            } else if (isTrue(getValue(market, "swap")))
            {
                method = "contractPublicGetSwapExMarketDetailMerged";
                fieldName = "contract_code";
            }
        }
        ((Dictionary<string, object>)request)[(string)fieldName] = getValue(market, "id");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.detail.merged",
        //         "ts": 1583494336669,
        //         "tick": {
        //             "amount": 26228.672978342216,
        //             "open": 9078.95,
        //             "close": 9146.86,
        //             "high": 9155.41,
        //             "id": 209988544334,
        //             "count": 265846,
        //             "low": 8988.0,
        //             "version": 209988544334,
        //             "ask": [ 9146.87, 0.156134 ],
        //             "vol": 2.3822168242201668E8,
        //             "bid": [ 9146.86, 0.080758 ],
        //         }
        //     }
        //
        // future, swap
        //
        //     {
        //         "ch":"market.BTC211126.detail.merged",
        //         "status":"ok",
        //         "tick":{
        //             "amount":"669.3385682049668320322569544150680718474",
        //             "ask":[59117.44,48],
        //             "bid":[59082,48],
        //             "close":"59087.97",
        //             "count":5947,
        //             "high":"59892.62",
        //             "id":1637502670,
        //             "low":"57402.87",
        //             "open":"57638",
        //             "ts":1637502670059,
        //             "vol":"394598"
        //         },
        //         "ts":1637502670059
        //     }
        //
        object tick = this.safeValue(response, "tick", new Dictionary<string, object>() {});
        object ticker = this.parseTicker(tick, market);
        object timestamp = this.safeInteger(response, "ts");
        ((Dictionary<string, object>)ticker)["timestamp"] = timestamp;
        ((Dictionary<string, object>)ticker)["datetime"] = this.iso8601(timestamp);
        return ticker;
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-tickers-for-all-pairs
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-a-batch-of-market-data-overview
        * @see https://huobiapi.github.io/docs/dm/v1/en/#get-a-batch-of-market-data-overview
        * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-a-batch-of-market-data-overview-v2
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        object type = null;
        object subType = null;
        object method = "spotPublicGetMarketTickers";
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object linear = (isEqual(subType, "linear"));
        object inverse = (isEqual(subType, "inverse"));
        if (isTrue(isTrue(future) || isTrue(swap)))
        {
            if (isTrue(linear))
            {
                method = "contractPublicGetLinearSwapExMarketDetailBatchMerged";
                if (isTrue(future))
                {
                    ((Dictionary<string, object>)request)["business_type"] = "futures";
                }
            } else if (isTrue(inverse))
            {
                if (isTrue(future))
                {
                    method = "contractPublicGetMarketDetailBatchMerged";
                } else if (isTrue(swap))
                {
                    method = "contractPublicGetSwapExMarketDetailBatchMerged";
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"type", "subType"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "data":[
        //             {
        //                 "symbol":"hbcbtc",
        //                 "open":5.313E-5,
        //                 "high":5.34E-5,
        //                 "low":5.112E-5,
        //                 "close":5.175E-5,
        //                 "amount":1183.87,
        //                 "vol":0.0618599229,
        //                 "count":205,
        //                 "bid":5.126E-5,
        //                 "bidSize":5.25,
        //                 "ask":5.214E-5,
        //                 "askSize":150.0
        //             },
        //         ],
        //         "status":"ok",
        //         "ts":1639547261293
        //     }
        //
        // inverse swaps, linear swaps, inverse futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1637504679,
        //                 "ts":1637504679372,
        //                 "ask":[0.10644,100],
        //                 "bid":[0.10624,26],
        //                 "symbol":"TRX_CW",
        //                 "open":"0.10233",
        //                 "close":"0.10644",
        //                 "low":"0.1017",
        //                 "high":"0.10725",
        //                 "amount":"2340267.415144052378486261756692535687481566",
        //                 "count":882,
        //                 "vol":"24706"
        //             }
        //         ],
        //         "ts":1637504679376
        //     }
        //
        // linear futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1640745627,
        //                 "ts":1640745627957,
        //                 "ask":[48079.1,20],
        //                 "bid":[47713.8,125],
        //                 "business_type":"futures",
        //                 "contract_code":"BTC-USDT-CW",
        //                 "open":"49011.8",
        //                 "close":"47934",
        //                 "low":"47292.3",
        //                 "high":"49011.8",
        //                 "amount":"17.398",
        //                 "count":1515,
        //                 "vol":"17398",
        //                 "trade_turnover":"840726.5048"
        //             }
        //         ],
        //         "ts":1640745627988
        //     }
        //
        object tickers = this.safeValue2(response, "data", "ticks", new List<object>() {});
        object timestamp = this.safeInteger(response, "ts");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            // the market ids for linear futures are non-standard and differ from all the other endpoints
            // we are doing a linear-matching here
            if (isTrue(isTrue(future) && isTrue(linear)))
            {
                for (object j = 0; isLessThan(j, getArrayLength(this.symbols)); postFixIncrement(ref j))
                {
                    object symbolInner = getValue(this.symbols, j);
                    object marketInner = this.market(symbolInner);
                    object contractType = this.safeString(getValue(marketInner, "info"), "contract_type");
                    if (isTrue(isTrue((isEqual(contractType, "this_week"))) && isTrue((isEqual(getValue(ticker, "symbol"), (add(add(add(getValue(marketInner, "baseId"), "-"), getValue(marketInner, "quoteId")), "-CW")))))))
                    {
                        ((Dictionary<string, object>)ticker)["symbol"] = getValue(marketInner, "symbol");
                        break;
                    } else if (isTrue(isTrue((isEqual(contractType, "next_week"))) && isTrue((isEqual(getValue(ticker, "symbol"), (add(add(add(getValue(marketInner, "baseId"), "-"), getValue(marketInner, "quoteId")), "-NW")))))))
                    {
                        ((Dictionary<string, object>)ticker)["symbol"] = getValue(marketInner, "symbol");
                        break;
                    } else if (isTrue(isTrue((isEqual(contractType, "this_quarter"))) && isTrue((isEqual(getValue(ticker, "symbol"), (add(add(add(getValue(marketInner, "baseId"), "-"), getValue(marketInner, "quoteId")), "-CQ")))))))
                    {
                        ((Dictionary<string, object>)ticker)["symbol"] = getValue(marketInner, "symbol");
                        break;
                    } else if (isTrue(isTrue((isEqual(contractType, "next_quarter"))) && isTrue((isEqual(getValue(ticker, "symbol"), (add(add(add(getValue(marketInner, "baseId"), "-"), getValue(marketInner, "quoteId")), "-NQ")))))))
                    {
                        ((Dictionary<string, object>)ticker)["symbol"] = getValue(marketInner, "symbol");
                        break;
                    }
                }
            }
            object symbol = getValue(ticker, "symbol");
            ((Dictionary<string, object>)ticker)["timestamp"] = timestamp;
            ((Dictionary<string, object>)ticker)["datetime"] = this.iso8601(timestamp);
            ((Dictionary<string, object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "step0" },
        };
        object fieldName = "symbol";
        object method = "spotPublicGetMarketDepth";
        if (isTrue(getValue(market, "linear")))
        {
            method = "contractPublicGetLinearSwapExMarketDepth";
            fieldName = "contract_code";
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "future")))
            {
                method = "contractPublicGetMarketDepth";
            } else if (isTrue(getValue(market, "swap")))
            {
                method = "contractPublicGetSwapExMarketDepth";
                fieldName = "contract_code";
            }
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                // Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
                if (isTrue(isTrue(isTrue(isTrue((!isEqual(limit, 5))) && isTrue((!isEqual(limit, 10)))) && isTrue((!isEqual(limit, 20)))) && isTrue((!isEqual(limit, 150)))))
                {
                    throw new BadRequest ((string)add(this.id, " fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150")) ;
                }
                // only set the depth if it is not 150
                // 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
                // it is not accepted by the exchange if you set it explicitly
                if (isTrue(!isEqual(limit, 150)))
                {
                    ((Dictionary<string, object>)request)["depth"] = limit;
                }
            }
        }
        ((Dictionary<string, object>)request)[(string)fieldName] = getValue(market, "id");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot, future, swap
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.depth.step0",
        //         "ts": 1583474832790,
        //         "tick": {
        //             "bids": [
        //                 [ 9100.290000000000000000, 0.200000000000000000 ],
        //                 [ 9099.820000000000000000, 0.200000000000000000 ],
        //                 [ 9099.610000000000000000, 0.205000000000000000 ],
        //             ],
        //             "asks": [
        //                 [ 9100.640000000000000000, 0.005904000000000000 ],
        //                 [ 9101.010000000000000000, 0.287311000000000000 ],
        //                 [ 9101.030000000000000000, 0.012121000000000000 ],
        //             ],
        //             "ch":"market.BTC-USD.depth.step0",
        //             "ts":1583474832008,
        //             "id":1637554816,
        //             "mrid":121654491624,
        //             "version":104999698781
        //         }
        //     }
        //
        if (isTrue(((Dictionary<string,object>)response).ContainsKey(toStringOrNull("tick"))))
        {
            if (!isTrue(getValue(response, "tick")))
            {
                throw new BadSymbol ((string)add(add(this.id, " fetchOrderBook() returned empty response: "), this.json(response))) ;
            }
            object tick = this.safeValue(response, "tick");
            object timestamp = this.safeInteger(tick, "ts", this.safeInteger(response, "ts"));
            object result = this.parseOrderBook(tick, symbol, timestamp);
            ((Dictionary<string, object>)result)["nonce"] = this.safeInteger(tick, "version");
            return result;
        }
        throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() returned unrecognized response: "), this.json(response))) ;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot fetchTrades (public)
        //
        //     {
        //         "amount": 0.010411000000000000,
        //         "trade-id": 102090736910,
        //         "ts": 1583497692182,
        //         "id": 10500517034273194594947,
        //         "price": 9096.050000000000000000,
        //         "direction": "sell"
        //     }
        //
        // spot fetchMyTrades (private)
        //
        //     {
        //          'symbol': 'swftcbtc',
        //          'fee-currency': 'swftc',
        //          'filled-fees': '0',
        //          'source': 'spot-api',
        //          'id': 83789509854000,
        //          'type': 'buy-limit',
        //          'order-id': 83711103204909,
        //          'filled-points': '0.005826843283532154',
        //          'fee-deduct-currency': 'ht',
        //          'filled-amount': '45941.53',
        //          'price': '0.0000001401',
        //          'created-at': 1597933260729,
        //          'match-id': 100087455560,
        //          'role': 'maker',
        //          'trade-id': 100050305348
        //     }
        //
        // linear swap isolated margin fetchOrder details
        //
        //     {
        //         "trade_id": 131560927,
        //         "trade_price": 13059.800000000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_fee": -0.005223920000000000,
        //         "created_at": 1603703614715,
        //         "role": "taker",
        //         "fee_asset": "USDT",
        //         "profit": 0,
        //         "real_profit": 0,
        //         "id": "131560927-770334322963152896-1"
        //     }
        //
        // inverse swap cross margin fetchMyTrades
        //
        //     {
        //         "contract_type":"swap",
        //         "pair":"O3-USDT",
        //         "business_type":"swap",
        //         "query_id":652123190,
        //         "match_id":28306009409,
        //         "order_id":941137865226903553,
        //         "symbol":"O3",
        //         "contract_code":"O3-USDT",
        //         "direction":"sell",
        //         "offset":"open",
        //         "trade_volume":100.000000000000000000,
        //         "trade_price":0.398500000000000000,
        //         "trade_turnover":39.850000000000000000,
        //         "trade_fee":-0.007970000000000000,
        //         "offset_profitloss":0E-18,
        //         "create_date":1644426352999,
        //         "role":"Maker",
        //         "order_source":"api",
        //         "order_id_str":"941137865226903553",
        //         "id":"28306009409-941137865226903553-1",
        //         "fee_asset":"USDT",
        //         "margin_mode":"cross",
        //         "margin_account":"USDT",
        //         "real_profit":0E-18,
        //         "trade_partition":"USDT"
        //     }
        //
        object marketId = this.safeString2(trade, "contract_code", "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(trade, "ts", "created-at");
        timestamp = this.safeInteger2(trade, "created_at", "create_date", timestamp);
        object order = this.safeString2(trade, "order-id", "order_id");
        object side = this.safeString(trade, "direction");
        object type = this.safeString(trade, "type");
        if (isTrue(!isEqual(type, null)))
        {
            object typeParts = ((string)type).Split((string)"-").ToList<object>();
            side = getValue(typeParts, 0);
            type = getValue(typeParts, 1);
        }
        object takerOrMaker = this.safeStringLower(trade, "role");
        object priceString = this.safeString2(trade, "price", "trade_price");
        object amountString = this.safeString2(trade, "filled-amount", "amount");
        amountString = this.safeString(trade, "trade_volume", amountString);
        object costString = this.safeString(trade, "trade_turnover");
        object fee = null;
        object feeCost = this.safeString2(trade, "filled-fees", "trade_fee");
        object feeCurrencyId = this.safeString2(trade, "fee-currency", "fee_asset");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        object filledPoints = this.safeString(trade, "filled-points");
        if (isTrue(!isEqual(filledPoints, null)))
        {
            if (isTrue(isTrue((isEqual(feeCost, null))) || isTrue(Precise.stringEquals(feeCost, "0"))))
            {
                object feeDeductCurrency = this.safeString(trade, "fee-deduct-currency");
                if (isTrue(!isEqual(feeDeductCurrency, null)))
                {
                    feeCost = filledPoints;
                    feeCurrency = this.safeCurrencyCode(feeDeductCurrency);
                }
            }
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object tradeId = this.safeString2(trade, "trade-id", "tradeId");
        object id = this.safeString2(trade, "trade_id", "id", tradeId);
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "order", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrderTrades", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "fetchSpotOrderTrades" },
        });
        return await ((Task<object>)callDynamically(this, method, new object[] { id, symbol, since, limit, parameters }));
    }

    public async virtual Task<object> fetchSpotOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order-id", id },
        };
        object response = await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "data"), null, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["size"] = limit; // default 100, max 500
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start-time"] = since; // a date within 120 days from today
            }
            method = "spotPrivateGetV1OrderMatchresults";
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchMyTrades() requires a symbol for "), marketType), " orders")) ;
            }
            ((Dictionary<string, object>)request)["contract"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["trade_type"] = 0; // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_time"] = since; // a date within 120 days from today
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["page_size"] = limit; // default 100, max 500
            }
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV3SwapMatchresultsExact";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact";
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(marketType, "future")))
                {
                    method = "contractPrivatePostApiV3ContractMatchresultsExact";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
                } else if (isTrue(isEqual(marketType, "swap")))
                {
                    method = "contractPrivatePostSwapApiV3SwapMatchresultsExact";
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), marketType), " markets")) ;
                }
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "polyusdt",
        //                 "fee-currency": "poly",
        //                 "source": "spot-web",
        //                 "price": "0.338",
        //                 "created-at": 1629443051839,
        //                 "role": "taker",
        //                 "order-id": 345487249132375,
        //                 "match-id": 5014,
        //                 "trade-id": 1085,
        //                 "filled-amount": "147.928994082840236",
        //                 "filled-fees": "0",
        //                 "filled-points": "0.1",
        //                 "fee-deduct-currency": "hbpoint",
        //                 "fee-deduct-state": "done",
        //                 "id": 313288753120940,
        //                 "type": "buy-market"
        //             }
        //         ]
        //     }
        //
        // contracts
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "trades": [
        //                 {
        //                     "query_id": 2424420723,
        //                     "match_id": 113891764710,
        //                     "order_id": 773135295142658048,
        //                     "symbol": "ADA",
        //                     "contract_type": "quarter", // swap
        //                     "business_type": "futures", // swap
        //                     "contract_code": "ADA201225",
        //                     "direction": "buy",
        //                     "offset": "open",
        //                     "trade_volume": 1,
        //                     "trade_price": 0.092,
        //                     "trade_turnover": 10,
        //                     "trade_fee": -0.021739130434782608,
        //                     "offset_profitloss": 0,
        //                     "create_date": 1604371703183,
        //                     "role": "Maker",
        //                     "order_source": "web",
        //                     "order_id_str": "773135295142658048",
        //                     "fee_asset": "ADA",
        //                     "margin_mode": "isolated", // cross
        //                     "margin_account": "BTC-USDT",
        //                     "real_profit": 0,
        //                     "id": "113891764710-773135295142658048-1",
        //                     "trade_partition":"USDT",
        //                 }
        //             ],
        //             "remain_size": 15,
        //             "next_id": 2424413094
        //         },
        //         "ts": 1604372202243
        //     }
        //
        object trades = this.safeValue(response, "data");
        if (!isTrue((trades.GetType().IsGenericType && trades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            trades = this.safeValue(trades, "trades");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        limit ??= 1000;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object fieldName = "symbol";
        object method = "spotPublicGetMarketHistoryTrade";
        if (isTrue(getValue(market, "future")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                method = "contractPublicGetMarketHistoryTrade";
            } else if (isTrue(getValue(market, "linear")))
            {
                method = "contractPublicGetLinearSwapExMarketHistoryTrade";
                fieldName = "contract_code";
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                method = "contractPublicGetSwapExMarketHistoryTrade";
            } else if (isTrue(getValue(market, "linear")))
            {
                method = "contractPublicGetLinearSwapExMarketHistoryTrade";
            }
            fieldName = "contract_code";
        }
        ((Dictionary<string, object>)request)[(string)fieldName] = getValue(market, "id");
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // max 2000
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.trade.detail",
        //         "ts": 1583497692365,
        //         "data": [
        //             {
        //                 "id": 105005170342,
        //                 "ts": 1583497692182,
        //                 "data": [
        //                     {
        //                         "amount": 0.010411000000000000,
        //                         "trade-id": 102090736910,
        //                         "ts": 1583497692182,
        //                         "id": 10500517034273194594947,
        //                         "price": 9096.050000000000000000,
        //                         "direction": "sell"
        //                     }
        //                 ]
        //             },
        //             // ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trades = this.safeValue(getValue(data, i), "data", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
            {
                object trade = this.parseTrade(getValue(trades, j), market);
                ((List<object>)result).Add(trade);
            }
        }
        result = this.sortBy(result, "timestamp");
        return ((object)this.filterBySymbolSinceLimit(result, getValue(market, "symbol"), since, limit));
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "id"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "amount")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object fieldName = "symbol";
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object method = "spotPublicGetMarketHistoryCandles";
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["size"] = limit; // max 2000
            }
        } else if (isTrue(getValue(market, "future")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(price, "mark")))
                {
                    method = "contractPublicGetIndexMarketHistoryMarkPriceKline";
                } else if (isTrue(isEqual(price, "index")))
                {
                    method = "contractPublicGetIndexMarketHistoryIndex";
                } else if (isTrue(isEqual(price, "premiumIndex")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), price), " kline data")) ;
                } else
                {
                    method = "contractPublicGetMarketHistoryKline";
                }
            } else if (isTrue(getValue(market, "linear")))
            {
                if (isTrue(isEqual(price, "mark")))
                {
                    method = "contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";
                } else if (isTrue(isEqual(price, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), price), " kline data")) ;
                } else if (isTrue(isEqual(price, "premiumIndex")))
                {
                    method = "contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline";
                } else
                {
                    method = "contractPublicGetLinearSwapExMarketHistoryKline";
                }
                fieldName = "contract_code";
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(price, "mark")))
                {
                    method = "contractPublicGetIndexMarketHistorySwapMarkPriceKline";
                } else if (isTrue(isEqual(price, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), price), " kline data")) ;
                } else if (isTrue(isEqual(price, "premiumIndex")))
                {
                    method = "contractPublicGetIndexMarketHistorySwapPremiumIndexKline";
                } else
                {
                    method = "contractPublicGetSwapExMarketHistoryKline";
                }
            } else if (isTrue(getValue(market, "linear")))
            {
                if (isTrue(isEqual(price, "mark")))
                {
                    method = "contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";
                } else if (isTrue(isEqual(price, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), price), " kline data")) ;
                } else if (isTrue(isEqual(price, "premiumIndex")))
                {
                    method = "contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline";
                } else
                {
                    method = "contractPublicGetLinearSwapExMarketHistoryKline";
                }
            }
            fieldName = "contract_code";
        }
        if (isTrue(getValue(market, "contract")))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = 2000;
            }
            ((Dictionary<string, object>)request)["size"] = limit;
            if (isTrue(isEqual(price, null)))
            {
                object duration = this.parseTimeframe(timeframe);
                if (isTrue(isEqual(since, null)))
                {
                    object now = this.seconds();
                    ((Dictionary<string, object>)request)["from"] = subtract(now, multiply(duration, (subtract(limit, 1))));
                    ((Dictionary<string, object>)request)["to"] = now;
                } else
                {
                    object start = this.parseToInt(divide(since, 1000));
                    ((Dictionary<string, object>)request)["from"] = start;
                    ((Dictionary<string, object>)request)["to"] = this.sum(start, multiply(duration, (subtract(limit, 1))));
                }
            }
        }
        ((Dictionary<string, object>)request)[(string)fieldName] = getValue(market, "id");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "status":"ok",
        //         "ch":"market.ethbtc.kline.1min",
        //         "ts":1591515374371,
        //         "data":[
        //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
        //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
        //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetV1AccountAccounts(parameters);
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {"id":5202591,"type":"point","subtype":"","state":"working"},
        //             {"id":1528640,"type":"spot","subtype":"","state":"working"},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseAccounts(data);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "id": 5202591,
        //         "type": "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
        //         "subtype": "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
        //         "state": "working" // working, lock
        //     }
        //
        object typeId = this.safeString(account, "type");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object type = this.safeValue(accountsById, typeId, typeId);
        return new Dictionary<string, object>() {
            { "info", account },
            { "id", this.safeString(account, "id") },
            { "type", type },
            { "code", null },
        };
    }

    public async virtual Task<object> fetchAccountIdByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object accounts = await this.loadAccounts();
        object accountId = this.safeValue(parameters, "account-id");
        if (isTrue(!isEqual(accountId, null)))
        {
            return accountId;
        }
        object indexedAccounts = this.indexBy(accounts, "type");
        object defaultAccount = this.safeValue(accounts, 0, new Dictionary<string, object>() {});
        object account = this.safeValue(indexedAccounts, type, defaultAccount);
        return this.safeString(account, "id");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.spotPublicGetV2ReferenceCurrencies(parameters);
        //
        //    {
        //        "code": 200,
        //        "data": [
        //            {
        //                "currency": "sxp",
        //                "assetType": "1",
        //                "chains": [
        //                    {
        //                        "chain": "sxp",
        //                        "displayName": "ERC20",
        //                        "baseChain": "ETH",
        //                        "baseChainProtocol": "ERC20",
        //                        "isDynamic": true,
        //                        "numOfConfirmations": "12",
        //                        "numOfFastConfirmations": "12",
        //                        "depositStatus": "allowed",
        //                        "minDepositAmt": "0.23",
        //                        "withdrawStatus": "allowed",
        //                        "minWithdrawAmt": "0.23",
        //                        "withdrawPrecision": "8",
        //                        "maxWithdrawAmt": "227000.000000000000000000",
        //                        "withdrawQuotaPerDay": "227000.000000000000000000",
        //                        "withdrawQuotaPerYear": null,
        //                        "withdrawQuotaTotal": null,
        //                        "withdrawFeeType": "fixed",
        //                        "transactFeeWithdraw": "11.1653",
        //                        "addrWithTag": false,
        //                        "addrDepositTag": false
        //                    }
        //                ],
        //                "instStatus": "normal"
        //            }
        //        ]
        //    }
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)this.options)["networkChainIdsByNames"] = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)this.options)["networkNamesByChainIds"] = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            ((Dictionary<string, object>)getValue(this.options, "networkChainIdsByNames"))[(string)code] = new Dictionary<string, object>() {};
            object chains = this.safeValue(entry, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object instStatus = this.safeString(entry, "instStatus");
            object currencyActive = isEqual(instStatus, "normal");
            object minPrecision = null;
            object minWithdraw = null;
            object maxWithdraw = null;
            object deposit = null;
            object withdraw = null;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chainEntry = getValue(chains, j);
                object uniqueChainId = this.safeString(chainEntry, "chain"); // i.e. usdterc20, trc20usdt ...
                object title = this.safeString(chainEntry, "displayName");
                ((Dictionary<string, object>)getValue(getValue(this.options, "networkChainIdsByNames"), code))[(string)title] = uniqueChainId;
                ((Dictionary<string, object>)getValue(this.options, "networkNamesByChainIds"))[(string)uniqueChainId] = title;
                object networkCode = this.networkIdToCode(title, code);
                minWithdraw = this.safeNumber(chainEntry, "minWithdrawAmt");
                maxWithdraw = this.safeNumber(chainEntry, "maxWithdrawAmt");
                object withdrawStatus = this.safeString(chainEntry, "withdrawStatus");
                object depositStatus = this.safeString(chainEntry, "depositStatus");
                object withdrawEnabled = (isEqual(withdrawStatus, "allowed"));
                object depositEnabled = (isEqual(depositStatus, "allowed"));
                object active = isTrue(withdrawEnabled) && isTrue(depositEnabled);
                object precision = this.parsePrecision(this.safeString(chainEntry, "withdrawPrecision"));
                if (isTrue(!isEqual(precision, null)))
                {
                    minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : Precise.stringMin(precision, minPrecision);
                }
                if (isTrue(isTrue(withdrawEnabled) && !isTrue(withdraw)))
                {
                    withdraw = true;
                } else if (!isTrue(withdrawEnabled))
                {
                    withdraw = false;
                }
                if (isTrue(isTrue(depositEnabled) && !isTrue(deposit)))
                {
                    deposit = true;
                } else if (!isTrue(depositEnabled))
                {
                    deposit = false;
                }
                object fee = this.safeNumber(chainEntry, "transactFeeWithdraw");
                ((Dictionary<string, object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chainEntry },
                    { "id", uniqueChainId },
                    { "network", networkCode },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minWithdraw },
                            { "max", maxWithdraw },
                        } },
                    } },
                    { "active", active },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "fee", fee },
                    { "precision", this.parseNumber(precision) },
                };
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "id", currencyId },
                { "active", currencyActive },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", null },
                { "name", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", minWithdraw },
                        { "max", maxWithdraw },
                    } },
                } },
                { "precision", this.parseNumber(minPrecision) },
                { "networks", networks },
            };
        }
        return result;
    }

    public override object networkIdToCode(object networkId, object currencyCode = null)
    {
        // here network-id is provided as a pair of currency & chain (i.e. trc20usdt)
        object keys = new List<object>(((Dictionary<string,object>)getValue(this.options, "networkNamesByChainIds")).Keys);
        object keysLength = getArrayLength(keys);
        if (isTrue(isEqual(keysLength, 0)))
        {
            throw new ExchangeError ((string)add(this.id, " networkIdToCode() - markets need to be loaded at first")) ;
        }
        object networkTitle = this.safeValue(getValue(this.options, "networkNamesByChainIds"), networkId, networkId);
        return base.networkIdToCode(networkTitle);
    }

    public override object networkCodeToId(object networkCode, object currencyCode = null)
    {
        if (isTrue(isEqual(currencyCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " networkCodeToId() requires a currencyCode argument")) ;
        }
        object keys = new List<object>(((Dictionary<string,object>)getValue(this.options, "networkChainIdsByNames")).Keys);
        object keysLength = getArrayLength(keys);
        if (isTrue(isEqual(keysLength, 0)))
        {
            throw new ExchangeError ((string)add(this.id, " networkCodeToId() - markets need to be loaded at first")) ;
        }
        object uniqueNetworkIds = this.safeValue(getValue(this.options, "networkChainIdsByNames"), currencyCode, new Dictionary<string, object>() {});
        object networkTitle = base.networkCodeToId(networkCode);
        return this.safeValue(uniqueNetworkIds, networkTitle, networkTitle);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object options = this.safeValue(this.options, "fetchBalance", new Dictionary<string, object>() {});
        object request = new Dictionary<string, object>() {};
        object method = null;
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object defaultSubType = this.safeString2(this.options, "defaultSubType", "subType", "linear");
        object subType = this.safeString2(options, "defaultSubType", "subType", defaultSubType);
        subType = this.safeString2(parameters, "defaultSubType", "subType", subType);
        object inverse = (isEqual(subType, "inverse"));
        object linear = (isEqual(subType, "linear"));
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"defaultSubType", "subType"});
        object isolated = (isEqual(marginMode, "isolated"));
        object cross = (isEqual(marginMode, "cross"));
        object margin = isTrue((isEqual(type, "margin"))) || isTrue((isTrue(spot) && isTrue((isTrue(cross) || isTrue(isolated)))));
        if (isTrue(isTrue(spot) || isTrue(margin)))
        {
            if (isTrue(margin))
            {
                if (isTrue(isolated))
                {
                    method = "spotPrivateGetV1MarginAccountsBalance";
                } else
                {
                    method = "spotPrivateGetV1CrossMarginAccountsBalance";
                }
            } else
            {
                await this.loadAccounts();
                object accountId = await this.fetchAccountIdByType(type, parameters);
                ((Dictionary<string, object>)request)["account-id"] = accountId;
                method = "spotPrivateGetV1AccountAccountsAccountIdBalance";
            }
        } else if (isTrue(linear))
        {
            if (isTrue(isolated))
            {
                method = "contractPrivatePostLinearSwapApiV1SwapAccountInfo";
            } else
            {
                method = "contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo";
            }
        } else if (isTrue(inverse))
        {
            if (isTrue(future))
            {
                method = "contractPrivatePostApiV1ContractAccountInfo";
            } else if (isTrue(swap))
            {
                method = "contractPrivatePostSwapApiV1SwapAccountInfo";
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 1528640,
        //             "type": "spot",
        //             "state": "working",
        //             "list": [
        //                 { "currency": "lun", "type": "trade", "balance": "0", "seq-num": "0" },
        //                 { "currency": "lun", "type": "frozen", "balance": "0", "seq-num": "0" },
        //                 { "currency": "ht", "type": "frozen", "balance": "0", "seq-num": "145" },
        //             ]
        //         },
        //         "ts":1637644827566
        //     }
        //
        // cross margin
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 51015302,
        //             "type": "cross-margin",
        //             "state": "working",
        //             "risk-rate": "2",
        //             "acct-balance-sum": "100",
        //             "debt-balance-sum": "0",
        //             "list": [
        //                 { "currency": "usdt", "type": "trade", "balance": "100" },
        //                 { "currency": "usdt", "type": "frozen", "balance": "0" },
        //                 { "currency": "usdt", "type": "loan-available", "balance": "200" },
        //                 { "currency": "usdt", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "ht", "type": "loan-available", "balance": "36.60724091" },
        //                 { "currency": "ht", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "btc", "type": "trade", "balance": "1168.533000000000000000" },
        //                 { "currency": "btc", "type": "frozen", "balance": "0.000000000000000000" },
        //                 { "currency": "btc", "type": "loan", "balance": "-2.433000000000000000" },
        //                 { "currency": "btc", "type": "interest", "balance": "-0.000533000000000000" },
        //                 { "currency": "btc", "type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                 { "currency": "btc", "type": "loan-available", "balance": "8161.876538350676000000" }
        //             ]
        //         },
        //         "code": 200
        //     }
        //
        // isolated margin
        //
        //     {
        //         "data": [
        //             {
        //                 "id": 18264,
        //                 "type": "margin",
        //                 "state": "working",
        //                 "symbol": "btcusdt",
        //                 "fl-price": "0",
        //                 "fl-type": "safe",
        //                 "risk-rate": "475.952571086994250554",
        //                 "list": [
        //                     { "currency": "btc","type": "trade","balance": "1168.533000000000000000" },
        //                     { "currency": "btc","type": "frozen","balance": "0.000000000000000000" },
        //                     { "currency": "btc","type": "loan","balance": "-2.433000000000000000" },
        //                     { "currency": "btc","type": "interest","balance": "-0.000533000000000000" },
        //                     { "currency": "btc","type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                     { "currency": "btc","type": "loan-available", "balance": "8161.876538350676000000" }
        //                 ]
        //             }
        //         ]
        //     }
        //
        // future, swap isolated
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "BTC",
        //                 "margin_balance": 0,
        //                 "margin_position": 0E-18,
        //                 "margin_frozen": 0,
        //                 "margin_available": 0E-18,
        //                 "profit_real": 0,
        //                 "profit_unreal": 0,
        //                 "risk_rate": null,
        //                 "withdraw_available": 0,
        //                 "liquidation_price": null,
        //                 "lever_rate": 5,
        //                 "adjust_factor": 0.025000000000000000,
        //                 "margin_static": 0,
        //                 "is_debit": 0, // future only
        //                 "contract_code": "BTC-USD", // swap only
        //                 "margin_asset": "USDT", // linear only
        //                 "margin_mode": "isolated", // linear only
        //                 "margin_account": "BTC-USDT" // linear only
        //                 "transfer_profit_ratio": null // inverse only
        //             },
        //         ],
        //         "ts": 1637644827566
        //     }
        //
        // linear cross futures and linear cross swap
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "futures_contract_detail": [
        //                     {
        //                         "symbol": "ETH",
        //                         "contract_code": "ETH-USDT-220325",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.060000000000000000,
        //                         "contract_type": "quarter",
        //                         "pair": "ETH-USDT",
        //                         "business_type": "futures"
        //                     },
        //                 ],
        //                 "margin_mode": "cross",
        //                 "margin_account": "USDT",
        //                 "margin_asset": "USDT",
        //                 "margin_balance": 200.000000000000000000,
        //                 "margin_static": 200.000000000000000000,
        //                 "margin_position": 0,
        //                 "margin_frozen": 0,
        //                 "profit_real": 0E-18,
        //                 "profit_unreal": 0,
        //                 "withdraw_available": 2E+2,
        //                 "risk_rate": null,
        //                 "contract_detail": [
        //                     {
        //                         "symbol": "MANA",
        //                         "contract_code": "MANA-USDT",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.100000000000000000,
        //                         "contract_type": "swap",
        //                         "pair": "MANA-USDT",
        //                         "business_type": "swap"
        //                     },
        //                 ]
        //             }
        //         ],
        //         "ts": 1640915104870
        //     }
        //
        // TODO add balance parsing for linear swap
        //
        object result = ((object)new Dictionary<string, object>() {
            { "info", response },
        });
        object data = this.safeValue(response, "data");
        if (isTrue(isTrue(spot) || isTrue(margin)))
        {
            if (isTrue(isolated))
            {
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object entry = getValue(data, i);
                    object symbol = this.safeSymbol(this.safeString(entry, "symbol"));
                    object balances = this.safeValue(entry, "list");
                    object subResult = new Dictionary<string, object>() {};
                    for (object j = 0; isLessThan(j, getArrayLength(balances)); postFixIncrement(ref j))
                    {
                        object balance = getValue(balances, j);
                        object currencyId = this.safeString(balance, "currency");
                        object code = this.safeCurrencyCode(currencyId);
                        ((Dictionary<string, object>)subResult)[(string)code] = this.parseMarginBalanceHelper(balance, code, subResult);
                    }
                    ((Dictionary<string, object>)result)[(string)symbol] = this.safeBalance(subResult);
                }
            } else
            {
                object balances = this.safeValue(data, "list", new List<object>() {});
                for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
                {
                    object balance = getValue(balances, i);
                    object currencyId = this.safeString(balance, "currency");
                    object code = this.safeCurrencyCode(currencyId);
                    ((Dictionary<string, object>)result)[(string)code] = this.parseMarginBalanceHelper(balance, code, result);
                }
                result = this.safeBalance(result);
            }
        } else if (isTrue(linear))
        {
            object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
            if (isTrue(isolated))
            {
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object balance = getValue(data, i);
                    object marketId = this.safeString2(balance, "contract_code", "margin_account");
                    object market = this.safeMarket(marketId);
                    object currencyId = this.safeString(balance, "margin_asset");
                    object currency = this.safeCurrency(currencyId);
                    object code = this.safeString(market, "settle", getValue(currency, "code"));
                    // the exchange outputs positions for delisted markets
                    // https://www.huobi.com/support/en-us/detail/74882968522337
                    // we skip it if the market was delisted
                    if (isTrue(!isEqual(code, null)))
                    {
                        object account = this.account();
                        ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "margin_balance");
                        ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "margin_frozen");
                        object accountsByCode = new Dictionary<string, object>() {};
                        ((Dictionary<string, object>)accountsByCode)[(string)code] = account;
                        object symbol = getValue(market, "symbol");
                        ((Dictionary<string, object>)result)[(string)symbol] = this.safeBalance(accountsByCode);
                    }
                }
            } else
            {
                object account = this.account();
                ((Dictionary<string, object>)account)["free"] = this.safeString(first, "margin_balance", "margin_available");
                ((Dictionary<string, object>)account)["used"] = this.safeString(first, "margin_frozen");
                object currencyId = this.safeString2(first, "margin_asset", "symbol");
                object code = this.safeCurrencyCode(currencyId);
                ((Dictionary<string, object>)result)[(string)code] = account;
                result = this.safeBalance(result);
            }
        } else if (isTrue(inverse))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object balance = getValue(data, i);
                object currencyId = this.safeString(balance, "symbol");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "margin_available");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "margin_frozen");
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
            result = this.safeBalance(result);
        }
        return result;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            method = "spotPrivateGetV1OrderOrdersOrderId";
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                method = "spotPrivateGetV1OrderOrdersGetClientOrder";
            } else
            {
                ((Dictionary<string, object>)request)["order-id"] = id;
            }
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchOrder() requires a symbol for "), marketType), " orders")) ;
            }
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapOrderInfo";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo";
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(marketType, "future")))
                {
                    method = "contractPrivatePostApiV1ContractOrderInfo";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
                } else if (isTrue(isEqual(marketType, "swap")))
                {
                    method = "contractPrivatePostSwapApiV1SwapOrderInfo";
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() does not support "), marketType), " markets")) ;
                }
            }
            object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["order_id"] = id;
            } else
            {
                ((Dictionary<string, object>)request)["client_order_id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "id":438398393065481,
        //             "symbol":"ethusdt",
        //             "account-id":1528640,
        //             "client-order-id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
        //             "amount":"0.100000000000000000",
        //             "price":"3000.000000000000000000",
        //             "created-at":1640549994642,
        //             "type":"buy-limit",
        //             "field-amount":"0.0",
        //             "field-cash-amount":"0.0",
        //             "field-fees":"0.0",
        //             "finished-at":0,
        //             "source":"spot-api",
        //             "state":"submitted",
        //             "canceled-at":0
        //         }
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "business_type":"swap",
        //                 "contract_type":"swap",
        //                 "pair":"BTC-USDT",
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "volume":1,
        //                 "price":3000,
        //                 "order_price_type":"limit",
        //                 "order_type":1,
        //                 "direction":"buy",
        //                 "offset":"open",
        //                 "lever_rate":1,
        //                 "order_id":924912513206878210,
        //                 "client_order_id":null,
        //                 "created_at":1640557927189,
        //                 "trade_volume":0,
        //                 "trade_turnover":0,
        //                 "fee":0,
        //                 "trade_avg_price":null,
        //                 "margin_frozen":3.000000000000000000,
        //                 "profit":0,
        //                 "status":3,
        //                 "order_source":"api",
        //                 "order_id_str":"924912513206878210",
        //                 "fee_asset":"USDT",
        //                 "liquidation_type":"0",
        //                 "canceled_at":0,
        //                 "margin_asset":"USDT",
        //                 "margin_account":"USDT",
        //                 "margin_mode":"cross",
        //                 "is_tpsl":0,
        //                 "real_profit":0
        //             }
        //         ],
        //         "ts":1640557982556
        //     }
        //
        // linear swap isolated margin detail
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_code": "BTC-USDT",
        //             "instrument_price": 0,
        //             "final_interest": 0,
        //             "adjust_value": 0,
        //             "lever_rate": 10,
        //             "direction": "sell",
        //             "offset": "open",
        //             "volume": 1.000000000000000000,
        //             "price": 13059.800000000000000000,
        //             "created_at": 1603703614712,
        //             "canceled_at": 0,
        //             "order_source": "api",
        //             "order_price_type": "opponent",
        //             "margin_frozen": 0,
        //             "profit": 0,
        //             "trades": [
        //                 {
        //                     "trade_id": 131560927,
        //                     "trade_price": 13059.800000000000000000,
        //                     "trade_volume": 1.000000000000000000,
        //                     "trade_turnover": 13.059800000000000000,
        //                     "trade_fee": -0.005223920000000000,
        //                     "created_at": 1603703614715,
        //                     "role": "taker",
        //                     "fee_asset": "USDT",
        //                     "profit": 0,
        //                     "real_profit": 0,
        //                     "id": "131560927-770334322963152896-1"
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1,
        //             "liquidation_type": "0",
        //             "fee_asset": "USDT",
        //             "fee": -0.005223920000000000,
        //             "order_id": 770334322963152896,
        //             "order_id_str": "770334322963152896",
        //             "client_order_id": 57012021045,
        //             "order_type": "1",
        //             "status": 6,
        //             "trade_avg_price": 13059.800000000000000000,
        //             "trade_turnover": 13.059800000000000000,
        //             "trade_volume": 1.000000000000000000,
        //             "margin_asset": "USDT",
        //             "margin_mode": "isolated",
        //             "margin_account": "BTC-USDT",
        //             "real_profit": 0,
        //             "is_tpsl": 0
        //         },
        //         "ts": 1603703678477
        //     }
        object order = this.safeValue(response, "data");
        if (isTrue((order.GetType().IsGenericType && order.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            order = this.safeValue(order, 0);
        }
        return this.parseOrder(order);
    }

    public virtual object parseMarginBalanceHelper(object balance, object code, object result)
    {
        object account = null;
        if (isTrue(((Dictionary<string,object>)result).ContainsKey(toStringOrNull(code))))
        {
            account = getValue(result, code);
        } else
        {
            account = this.account();
        }
        if (isTrue(isEqual(getValue(balance, "type"), "trade")))
        {
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "balance");
        }
        if (isTrue(isEqual(getValue(balance, "type"), "frozen")))
        {
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "balance");
        }
        return account;
    }

    public async virtual Task<object> fetchSpotOrdersByStates(object states, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchOrdersByStatesMethod", "spot_private_get_v1_order_orders"); // spot_private_get_v1_order_history
        if (isTrue(isEqual(method, "spot_private_get_v1_order_orders")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
            }
        }
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "states", states },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start-time"] = since; // a window of 48 hours within 180 days
            ((Dictionary<string, object>)request)["end-time"] = this.sum(since, multiply(multiply(multiply(48, 60), 60), 1000));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot_private_get_v1_order_orders GET /v1/order/orders
        //
        //     {
        //         status: "ok",
        //         data: [
        //             {
        //                 id: 13997833014,
        //                 symbol: "ethbtc",
        //                 'account-id': 3398321,
        //                 'client-order-id': "23456",
        //                 amount: "0.045000000000000000",
        //                 price: "0.034014000000000000",
        //                 'created-at': 1545836976871,
        //                 type: "sell-limit",
        //                 'field-amount': "0.045000000000000000",
        //                 'field-cash-amount': "0.001530630000000000",
        //                 'field-fees': "0.000003061260000000",
        //                 'finished-at': 1545837948214,
        //                 source: "spot-api",
        //                 state: "filled",
        //                 'canceled-at': 0
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchClosedSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchContractOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchContractOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contract", getValue(market, "id") },
            { "trade_type", 0 },
            { "type", 1 },
            { "status", "0" },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_time"] = since; // max 90 days back
        }
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchContractOrders", parameters);
            marginMode = ((List<object>)marginModeparametersVariable)[0];
            parameters = ((List<object>)marginModeparametersVariable)[1];
            marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
            method = this.getSupportedMapping(marginMode, new Dictionary<string, object>() {
                { "isolated", "contractPrivatePostLinearSwapApiV3SwapHisorders" },
                { "cross", "contractPrivatePostLinearSwapApiV3SwapCrossHisorders" },
            });
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
                { "future", "contractPrivatePostApiV3ContractHisorders" },
                { "swap", "contractPrivatePostSwapApiV3SwapHisorders" },
            });
            if (isTrue(isEqual(marketType, "future")))
            {
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["page_size"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "order_id": 773131315209248768,
        //                     "contract_code": "ADA201225",
        //                     "symbol": "ADA",
        //                     "lever_rate": 20,
        //                     "direction": "buy",
        //                     "offset": "close",
        //                     "volume": 1,
        //                     "price": 0.0925,
        //                     "create_date": 1604370469629,
        //                     "update_time": 1603704221118,
        //                     "order_source": "web",
        //                     "order_price_type": 6,
        //                     "order_type": 1,
        //                     "margin_frozen": 0,
        //                     "profit": 0,
        //                     "contract_type": "quarter",
        //                     "trade_volume": 0,
        //                     "trade_turnover": 0,
        //                     "fee": 0,
        //                     "trade_avg_price": 0,
        //                     "status": 3,
        //                     "order_id_str": "773131315209248768",
        //                     "fee_asset": "ADA",
        //                     "liquidation_type": "0",
        //                     "is_tpsl": 0,
        //                     "real_profit": 0
        //                     "margin_asset": "USDT",
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "trade_partition": "USDT", // only in isolated & cross of linear
        //                     "reduce_only": "1", // only in isolated & cross of linear
        //                     "contract_type": "quarter", // only in cross-margin (inverse & linear)
        //                     "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
        //                     "business_type": "futures" // only in cross-margin (inverse & linear)
        //                 }
        //             ],
        //             "total_page": 19,
        //             "current_page": 1,
        //             "total_size": 19
        //         },
        //         "ts": 1604370617322
        //     }
        //
        object orders = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchClosedContractOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "5,6,7" },
        };
        return await this.fetchContractOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "fetchSpotOrders" },
            { "swap", "fetchContractOrders" },
            { "future", "fetchContractOrders" },
        });
        if (isTrue(isEqual(method, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrders() does not support "), marketType), " markets yet")) ;
        }
        object contract = isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")));
        if (isTrue(isTrue(contract) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchOrders() requires a symbol argument for "), marketType), " orders")) ;
        }
        return await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, limit, parameters }));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "fetchClosedSpotOrders" },
            { "swap", "fetchClosedContractOrders" },
            { "future", "fetchClosedContractOrders" },
        });
        if (isTrue(isEqual(method, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchClosedOrders() does not support "), marketType), " markets yet")) ;
        }
        return await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, limit, parameters }));
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            method = "spotPrivateGetV1OrderOpenOrders";
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
            // todo replace with fetchAccountIdByType
            object accountId = this.safeString(parameters, "account-id");
            if (isTrue(isEqual(accountId, null)))
            {
                // pick the first account
                await this.loadAccounts();
                for (object i = 0; isLessThan(i, getArrayLength(this.accounts)); postFixIncrement(ref i))
                {
                    object account = getValue(this.accounts, i);
                    if (isTrue(isEqual(getValue(account, "type"), "spot")))
                    {
                        accountId = this.safeString(account, "id");
                        if (isTrue(!isEqual(accountId, null)))
                        {
                            break;
                        }
                    }
                }
            }
            ((Dictionary<string, object>)request)["account-id"] = accountId;
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["size"] = limit;
            }
            parameters = this.omit(parameters, "account-id");
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchOpenOrders() requires a symbol for "), marketType), " orders")) ;
            }
            object marketInner = this.market(symbol);
            ((Dictionary<string, object>)request)["contract_code"] = getValue(marketInner, "id");
            if (isTrue(getValue(marketInner, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapOpenorders";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCrossOpenorders";
                }
            } else if (isTrue(getValue(marketInner, "inverse")))
            {
                if (isTrue(getValue(marketInner, "future")))
                {
                    method = "contractPrivatePostApiV1ContractOpenorders";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(marketInner, "settleId");
                } else if (isTrue(getValue(marketInner, "swap")))
                {
                    method = "contractPrivatePostSwapApiV1SwapOpenorders";
                }
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["page_size"] = limit;
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"ethusdt",
        //                 "source":"api",
        //                 "amount":"0.010000000000000000",
        //                 "account-id":1528640,
        //                 "created-at":1561597491963,
        //                 "price":"400.000000000000000000",
        //                 "filled-amount":"0.0",
        //                 "filled-cash-amount":"0.0",
        //                 "filled-fees":"0.0",
        //                 "id":38477101630,
        //                 "state":"submitted",
        //                 "type":"sell-limit"
        //             }
        //         ]
        //     }
        //
        // futures
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "ADA",
        //                     "contract_code": "ADA201225",
        //                     "contract_type": "quarter",
        //                     "volume": 1,
        //                     "price": 0.0925,
        //                     "order_price_type": "post_only",
        //                     "order_type": 1,
        //                     "direction": "buy",
        //                     "offset": "close",
        //                     "lever_rate": 20,
        //                     "order_id": 773131315209248768,
        //                     "client_order_id": null,
        //                     "created_at": 1604370469629,
        //                     "trade_volume": 0,
        //                     "trade_turnover": 0,
        //                     "fee": 0,
        //                     "trade_avg_price": null,
        //                     "margin_frozen": 0,
        //                     "profit": 0,
        //                     "status": 3,
        //                     "order_source": "web",
        //                     "order_id_str": "773131315209248768",
        //                     "fee_asset": "ADA",
        //                     "liquidation_type": null,
        //                     "canceled_at": null,
        //                     "is_tpsl": 0,
        //                     "update_time": 1606975980467,
        //                     "real_profit": 0
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1
        //         },
        //         "ts": 1604370488518
        //     }
        //
        object orders = this.safeValue(response, "data");
        if (!isTrue((orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            orders = this.safeValue(orders, "orders", new List<object>() {});
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "partial-filled", "open" },
            { "partial-canceled", "canceled" },
            { "filled", "closed" },
            { "canceled", "canceled" },
            { "submitted", "open" },
            { "created", "open" },
            { "1", "open" },
            { "2", "open" },
            { "3", "open" },
            { "4", "open" },
            { "5", "canceled" },
            { "6", "closed" },
            { "7", "canceled" },
            { "11", "canceling" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         id:  13997833014,
        //         symbol: "ethbtc",
        //         'account-id':  3398321,
        //         amount: "0.045000000000000000",
        //         price: "0.034014000000000000",
        //         'created-at':  1545836976871,
        //         type: "sell-limit",
        //         'field-amount': "0.045000000000000000", // they have fixed it for filled-amount
        //         'field-cash-amount': "0.001530630000000000", // they have fixed it for filled-cash-amount
        //         'field-fees': "0.000003061260000000", // they have fixed it for filled-fees
        //         'finished-at':  1545837948214,
        //         source: "spot-api",
        //         state: "filled",
        //         'canceled-at':  0
        //     }
        //
        //     {
        //         id:  20395337822,
        //         symbol: "ethbtc",
        //         'account-id':  5685075,
        //         amount: "0.001000000000000000",
        //         price: "0.0",
        //         'created-at':  1545831584023,
        //         type: "buy-market",
        //         'field-amount': "0.029100000000000000", // they have fixed it for filled-amount
        //         'field-cash-amount': "0.000999788700000000", // they have fixed it for filled-cash-amount
        //         'field-fees': "0.000058200000000000", // they have fixed it for filled-fees
        //         'finished-at':  1545831584181,
        //         source: "spot-api",
        //         state: "filled",
        //         'canceled-at':  0
        //     }
        //
        // linear swap cross margin createOrder
        //
        //     {
        //         "order_id":924660854912552960,
        //         "order_id_str":"924660854912552960"
        //     }
        //
        // contracts fetchOrder
        //
        //     {
        //         "business_type":"swap",
        //         "contract_type":"swap",
        //         "pair":"BTC-USDT",
        //         "symbol":"BTC",
        //         "contract_code":"BTC-USDT",
        //         "volume":1,
        //         "price":3000,
        //         "order_price_type":"limit",
        //         "order_type":1,
        //         "direction":"buy",
        //         "offset":"open",
        //         "lever_rate":1,
        //         "order_id":924912513206878210,
        //         "client_order_id":null,
        //         "created_at":1640557927189,
        //         "trade_volume":0,
        //         "trade_turnover":0,
        //         "fee":0,
        //         "trade_avg_price":null,
        //         "margin_frozen":3.000000000000000000,
        //         "profit":0,
        //         "status":3,
        //         "order_source":"api",
        //         "order_id_str":"924912513206878210",
        //         "fee_asset":"USDT",
        //         "liquidation_type":"0",
        //         "canceled_at":0,
        //         "margin_asset":"USDT",
        //         "margin_account":"USDT",
        //         "margin_mode":"cross",
        //         "is_tpsl":0,
        //         "real_profit":0
        //     }
        //
        // contracts fetchOrder detailed
        //
        //     {
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "instrument_price": 0,
        //         "final_interest": 0,
        //         "adjust_value": 0,
        //         "lever_rate": 10,
        //         "direction": "sell",
        //         "offset": "open",
        //         "volume": 1.000000000000000000,
        //         "price": 13059.800000000000000000,
        //         "created_at": 1603703614712,
        //         "canceled_at": 0,
        //         "order_source": "api",
        //         "order_price_type": "opponent",
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "trades": [
        //             {
        //                 "trade_id": 131560927,
        //                 "trade_price": 13059.800000000000000000,
        //                 "trade_volume": 1.000000000000000000,
        //                 "trade_turnover": 13.059800000000000000,
        //                 "trade_fee": -0.005223920000000000,
        //                 "created_at": 1603703614715,
        //                 "role": "taker",
        //                 "fee_asset": "USDT",
        //                 "profit": 0,
        //                 "real_profit": 0,
        //                 "id": "131560927-770334322963152896-1"
        //             }
        //         ],
        //         "total_page": 1,
        //         "current_page": 1,
        //         "total_size": 1,
        //         "liquidation_type": "0",
        //         "fee_asset": "USDT",
        //         "fee": -0.005223920000000000,
        //         "order_id": 770334322963152896,
        //         "order_id_str": "770334322963152896",
        //         "client_order_id": 57012021045,
        //         "order_type": "1",
        //         "status": 6,
        //         "trade_avg_price": 13059.800000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "margin_asset": "USDT",
        //         "margin_mode": "isolated",
        //         "margin_account": "BTC-USDT",
        //         "real_profit": 0,
        //         "is_tpsl": 0
        //     }
        //
        // fetchOrders
        //
        //     {
        //         "order_id": 773131315209248768,
        //         "contract_code": "ADA201225",
        //         "symbol": "ADA",
        //         "lever_rate": 20,
        //         "direction": "buy",
        //         "offset": "close",
        //         "volume": 1,
        //         "price": 0.0925,
        //         "create_date": 1604370469629,
        //         "update_time": 1603704221118,
        //         "order_source": "web",
        //         "order_price_type": 6,
        //         "order_type": 1,
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "contract_type": "quarter",
        //         "trade_volume": 0,
        //         "trade_turnover": 0,
        //         "fee": 0,
        //         "trade_avg_price": 0,
        //         "status": 3,
        //         "order_id_str": "773131315209248768",
        //         "fee_asset": "ADA",
        //         "liquidation_type": "0",
        //         "is_tpsl": 0,
        //         "real_profit": 0
        //         "margin_asset": "USDT",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "trade_partition": "USDT", // only in isolated & cross of linear
        //         "reduce_only": "1", // only in isolated & cross of linear
        //         "contract_type": "quarter", // only in cross-margin (inverse & linear)
        //         "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
        //         "business_type": "futures" // only in cross-margin (inverse & linear)
        //     }
        //
        object id = this.safeString2(order, "id", "order_id_str");
        object side = this.safeString(order, "direction");
        object type = this.safeString(order, "order_price_type");
        if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("type"))))
        {
            object orderType = ((string)getValue(order, "type")).Split((string)"-").ToList<object>();
            side = getValue(orderType, 0);
            type = getValue(orderType, 1);
        }
        object status = this.parseOrderStatus(this.safeString2(order, "state", "status"));
        object marketId = this.safeString2(order, "contract_code", "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeIntegerN(order, new List<object>() {"created_at", "created-at", "create_date"});
        object clientOrderId = this.safeString2(order, "client_order_id", "client-order-id");
        object cost = null;
        object amount = null;
        if (isTrue(isTrue((!isEqual(type, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(type, "market"), 0)))))
        {
            // for market orders amount is in quote currency, meaning it is the cost
            if (isTrue(isEqual(side, "sell")))
            {
                cost = this.safeString(order, "field-cash-amount");
            } else
            {
                cost = this.safeString(order, "amount");
            }
        } else
        {
            amount = this.safeString2(order, "volume", "amount");
            cost = this.safeStringN(order, new List<object>() {"filled-cash-amount", "field-cash-amount", "trade_turnover"}); // same typo
        }
        object filled = this.safeStringN(order, new List<object>() {"filled-amount", "field-amount", "trade_volume"}); // typo in their API, filled amount
        object price = this.safeString(order, "price");
        object feeCost = this.safeString2(order, "filled-fees", "field-fees"); // typo in their API, filled feeSide
        feeCost = this.safeString(order, "fee", feeCost);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrency = null;
            object feeCurrencyId = this.safeString(order, "fee_asset");
            if (isTrue(!isEqual(feeCurrencyId, null)))
            {
                feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            } else
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object stopPrice = this.safeString(order, "stop-price");
        object average = this.safeString(order, "trade_avg_price");
        object trades = this.safeValue(order, "trades");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @param {float|undefined} params.stopPrice *spot and margin only* The price at which a trigger order is triggered at
        * @param {string|undefined} params.operator *spot and margin only* gte or lte, trigger price condition
        * @param {string|undefined} params.offset *contract only* 'open', 'close', or 'both', required in hedge mode
        * @param {bool|undefined} params.postOnly *contract only* true or false
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "createSpotOrder" },
            { "swap", "createContractOrder" },
            { "future", "createContractOrder" },
        });
        if (isTrue(isEqual(method, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), marketType), " markets yet")) ;
        }
        return await ((Task<object>)callDynamically(this, method, new object[] { symbol, type, side, amount, price, query }));
    }

    public async virtual Task<object> createSpotOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object accountId = await this.fetchAccountIdByType(getValue(market, "type"));
        object request = new Dictionary<string, object>() {
            { "account-id", accountId },
            { "symbol", getValue(market, "id") },
        };
        object orderType = ((string)type).Replace((string)"buy-", (string)"");
        orderType = ((string)orderType).Replace((string)"sell-", (string)"");
        object options = this.safeValue(this.options, getValue(market, "type"), new Dictionary<string, object>() {});
        object stopPrice = this.safeString2(parameters, "stopPrice", "stop-price");
        if (isTrue(isEqual(stopPrice, null)))
        {
            object stopOrderTypes = this.safeValue(options, "stopOrderTypes", new Dictionary<string, object>() {});
            if (isTrue(((Dictionary<string,object>)stopOrderTypes).ContainsKey(toStringOrNull(orderType))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a stopPrice or a stop-price parameter for a stop order")) ;
            }
        } else
        {
            object stopOperator = this.safeString(parameters, "operator");
            if (isTrue(isEqual(stopOperator, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires an operator parameter \"gte\" or \"lte\" for a stop order")) ;
            }
            parameters = this.omit(parameters, new List<object>() {"stopPrice", "stop-price"});
            ((Dictionary<string, object>)request)["stop-price"] = this.priceToPrecision(symbol, stopPrice);
            ((Dictionary<string, object>)request)["operator"] = stopOperator;
            if (isTrue(isTrue((isEqual(orderType, "limit"))) || isTrue((isEqual(orderType, "limit-fok")))))
            {
                orderType = add("stop-", orderType);
            } else if (isTrue(isTrue((!isEqual(orderType, "stop-limit"))) && isTrue((!isEqual(orderType, "stop-limit-fok")))))
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), type), " orders")) ;
            }
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(orderType, "market"), isEqual(orderType, "limit-maker"), parameters);
        postOnly = ((List<object>)postOnlyparametersVariable)[0];
        parameters = ((List<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            orderType = "limit-maker";
        }
        ((Dictionary<string, object>)request)["type"] = add(add(side, "-"), orderType);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client-order-id"); // must be 64 chars max and unique within 24 hours
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
            object brokerId = this.safeString(broker, "id");
            ((Dictionary<string, object>)request)["client-order-id"] = add(brokerId, this.uuid());
        } else
        {
            ((Dictionary<string, object>)request)["client-order-id"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client-order-id", "postOnly"});
        if (isTrue(isTrue((isEqual(orderType, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            if (isTrue(getValue(this.options, "createMarketBuyOrderRequiresPrice")))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options[\'createMarketBuyOrderRequiresPrice\'] = false. Make sure you know what you\'re doing.")) ;
                } else
                {
                    // despite that cost = amount * price is in quote currency and should have quote precision
                    // the exchange API requires the cost supplied in 'amount' to be of base precision
                    // more about it here:
                    // https://github.com/ccxt/ccxt/pull/4395
                    // https://github.com/ccxt/ccxt/issues/7611
                    // we use amountToPrecision here because the exchange requires cost in base precision
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    ((Dictionary<string, object>)request)["amount"] = this.costToPrecision(symbol, Precise.stringMul(amountString, priceString));
                }
            } else
            {
                ((Dictionary<string, object>)request)["amount"] = this.costToPrecision(symbol, amount);
            }
        } else
        {
            ((Dictionary<string, object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        object limitOrderTypes = this.safeValue(options, "limitOrderTypes", new Dictionary<string, object>() {});
        if (isTrue(((Dictionary<string,object>)limitOrderTypes).ContainsKey(toStringOrNull(orderType))))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.spotPrivatePostV1OrderOrdersPlace(this.extend(request, parameters));
        //
        // spot
        //
        //     {"status":"ok","data":"438398393065481"}
        //
        object id = this.safeString(response, "data");
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", id },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "status", null },
            { "symbol", null },
            { "type", null },
            { "side", null },
            { "price", null },
            { "amount", null },
            { "filled", null },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", null },
            { "clientOrderId", null },
            { "average", null },
        };
    }

    public async virtual Task<object> createContractOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object offset = this.safeString(parameters, "offset");
        object stopPrice = this.safeString(parameters, "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            throw new NotSupported ((string)add(this.id, " createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
            { "volume", this.amountToPrecision(symbol, amount) },
            { "direction", side },
            { "lever_rate", 1 },
        };
        object stopLossOrderPrice = this.safeString(parameters, "sl_order_price");
        object stopLossTriggerPrice = this.safeString(parameters, "sl_trigger_price");
        object takeProfitOrderPrice = this.safeString(parameters, "tp_order_price");
        object takeProfitTriggerPrice = this.safeString(parameters, "tp_trigger_price");
        object isOpenOrder = (isEqual(offset, "open"));
        object isStopOrder = false;
        if (isTrue(!isEqual(stopLossTriggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["sl_trigger_price"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
            isStopOrder = true;
            if (isTrue(!isEqual(price, null)))
            {
                ((Dictionary<string, object>)request)["sl_order_price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(!isEqual(stopLossOrderPrice, null)))
        {
            ((Dictionary<string, object>)request)["sl_order_price"] = this.priceToPrecision(symbol, stopLossOrderPrice);
            isStopOrder = true;
        }
        if (isTrue(!isEqual(takeProfitTriggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["tp_trigger_price"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
            isStopOrder = true;
            if (isTrue(!isEqual(price, null)))
            {
                ((Dictionary<string, object>)request)["tp_order_price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(!isEqual(takeProfitOrderPrice, null)))
        {
            ((Dictionary<string, object>)request)["tp_order_price"] = this.priceToPrecision(symbol, takeProfitOrderPrice);
            isStopOrder = true;
        }
        if (isTrue(isTrue(isStopOrder) && !isTrue(isOpenOrder)))
        {
            throw new NotSupported ((string)add(this.id, " createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"sl_order_price", "sl_trigger_price", "tp_order_price", "tp_trigger_price"});
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, "post_only"), parameters);
        postOnly = ((List<object>)postOnlyparametersVariable)[0];
        parameters = ((List<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            type = "post_only";
        }
        if (isTrue(isTrue(isTrue(isTrue(isEqual(type, "limit")) || isTrue(isEqual(type, "ioc"))) || isTrue(isEqual(type, "fok"))) || isTrue(isEqual(type, "post_only"))))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        ((Dictionary<string, object>)request)["order_price_type"] = type;
        object broker = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
        object brokerId = this.safeString(broker, "id");
        ((Dictionary<string, object>)request)["channel_code"] = brokerId;
        object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["client_order_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
        }
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
            marginMode = ((List<object>)marginModeparametersVariable)[0];
            parameters = ((List<object>)marginModeparametersVariable)[1];
            marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                method = "contractPrivatePostLinearSwapApiV1SwapOrder";
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                method = "contractPrivatePostLinearSwapApiV1SwapCrossOrder";
            }
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "swap")))
            {
                method = "contractPrivatePostSwapApiV1SwapOrder";
            } else if (isTrue(getValue(market, "future")))
            {
                method = "contractPrivatePostApiV1ContractOrder";
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "order_id":924660854912552960,
        //             "order_id_str":"924660854912552960"
        //         },
        //         "ts":1640497927185
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderId = this.safeString2(parameters, "client-order-id", "clientOrderId");
            method = "spotPrivatePostV1OrderOrdersOrderIdSubmitcancel";
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["order-id"] = id;
            } else
            {
                ((Dictionary<string, object>)request)["client-order-id"] = clientOrderId;
                method = "spotPrivatePostV1OrderOrdersSubmitCancelClientOrder";
                parameters = this.omit(parameters, new List<object>() {"client-order-id", "clientOrderId"});
            }
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " cancelOrder() requires a symbol for "), marketType), " orders")) ;
            }
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCancel";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCrossCancel";
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(getValue(market, "future")))
                {
                    method = "contractPrivatePostApiV1ContractCancel";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
                } else if (isTrue(getValue(market, "swap")))
                {
                    method = "contractPrivatePostSwapApiV1SwapCancel";
                }
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not support "), marketType), " markets")) ;
            }
            object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["order_id"] = id;
            } else
            {
                ((Dictionary<string, object>)request)["client_order_id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         'status': 'ok',
        //         'data': '10138899000',
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "errors":[],
        //             "successes":"924660854912552960"
        //         },
        //         "ts":1640504486089
        //     }
        //
        return this.extend(this.parseOrder(response, market), new Dictionary<string, object>() {
            { "id", id },
            { "status", "canceled" },
        });
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids order ids
        * @param {string|undefined} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderIds = this.safeValue2(parameters, "client-order-id", "clientOrderId");
            clientOrderIds = this.safeValue2(parameters, "client-order-ids", "clientOrderIds", clientOrderIds);
            if (isTrue(isEqual(clientOrderIds, null)))
            {
                if (isTrue(((clientOrderIds).GetType() == typeof(string))))
                {
                    ((Dictionary<string, object>)request)["order-ids"] = ids;
                } else
                {
                    ((Dictionary<string, object>)request)["order-ids"] = String.Join(",", ((List<object>)ids).ToArray());
                }
            } else
            {
                if (isTrue(((clientOrderIds).GetType() == typeof(string))))
                {
                    ((Dictionary<string, object>)request)["client-order-ids"] = clientOrderIds;
                } else
                {
                    ((Dictionary<string, object>)request)["client-order-ids"] = String.Join(",", ((List<object>)clientOrderIds).ToArray());
                }
                parameters = this.omit(parameters, new List<object>() {"client-order-id", "client-order-ids", "clientOrderId", "clientOrderIds"});
            }
            method = "spotPrivatePostV1OrderOrdersBatchcancel";
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " cancelOrders() requires a symbol for "), marketType), " orders")) ;
            }
            object marketInner = this.market(symbol);
            ((Dictionary<string, object>)request)["contract_code"] = getValue(marketInner, "id");
            if (isTrue(getValue(marketInner, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrders", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCancel";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCrossCancel";
                }
            } else if (isTrue(getValue(marketInner, "inverse")))
            {
                if (isTrue(getValue(marketInner, "future")))
                {
                    method = "contractPrivatePostApiV1ContractCancel";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(marketInner, "settleId");
                } else if (isTrue(getValue(marketInner, "swap")))
                {
                    method = "contractPrivatePostSwapApiV1SwapCancel";
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " cancelOrders() does not support "), marketType), " markets")) ;
                }
            }
            object clientOrderIds = this.safeString2(parameters, "client_order_id", "clientOrderId");
            clientOrderIds = this.safeString2(parameters, "client_order_ids", "clientOrderIds", clientOrderIds);
            if (isTrue(isEqual(clientOrderIds, null)))
            {
                ((Dictionary<string, object>)request)["order_id"] = String.Join(",", ((List<object>)ids).ToArray());
            } else
            {
                ((Dictionary<string, object>)request)["client_order_id"] = clientOrderIds;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "client_order_ids", "clientOrderId", "clientOrderIds"});
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "success": [
        //                 "5983466"
        //             ],
        //             "failed": [
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "first"
        //                 },
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "second"
        //                 },
        //                 {
        //                     "err-msg": "The record is not found.",
        //                     "order-id": "",
        //                     "err-code": "base-not-found",
        //                     "client-order-id": "third"
        //                 }
        //             ]
        //         }
        //     }
        //
        // contracts
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "errors": [
        //                 {
        //                     "order_id": "769206471845261312",
        //                     "err_code": 1061,
        //                     "err_msg": "This order doesnt exist."
        //                 }
        //             ],
        //             "successes": "773120304138219520"
        //         },
        //         "ts": 1604367997451
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
            method = "spotPrivatePostV1OrderOrdersBatchCancelOpenOrders";
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " cancelAllOrders() requires a symbol for "), marketType), " orders")) ;
            }
            object marketInner = this.market(symbol);
            ((Dictionary<string, object>)request)["contract_code"] = getValue(marketInner, "id");
            if (isTrue(getValue(marketInner, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCancelallall";
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    method = "contractPrivatePostLinearSwapApiV1SwapCrossCancelall";
                }
            } else if (isTrue(getValue(marketInner, "inverse")))
            {
                if (isTrue(isEqual(marketType, "future")))
                {
                    method = "contractPrivatePostApiV1ContractCancelall";
                    ((Dictionary<string, object>)request)["symbol"] = getValue(marketInner, "settleId");
                } else if (isTrue(isEqual(marketType, "swap")))
                {
                    method = "contractPrivatePostSwapApiV1SwapCancelall";
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() does not support "), marketType), " markets")) ;
                }
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         code: 200,
        //         data: {
        //             "success-count": 2,
        //             "failed-count": 0,
        //             "next-id": 5454600
        //         }
        //     }
        //
        return response;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         currency: "usdt",
        //         address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         addressTag: "",
        //         chain: "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "addressTag");
        object currencyId = this.safeString(depositAddress, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object code = this.safeCurrencyCode(currencyId, currency);
        object note = this.safeString(depositAddress, "note");
        object networkId = this.safeString(depositAddress, "chain");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", this.networkIdToCode(networkId, code) },
            { "note", note },
            { "info", depositAddress },
        };
    }

    public async virtual Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchDepositAddressesByNetwork
        * @description fetch a dictionary of addresses for a currency, indexed by network
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.spotPrivateGetV2AccountDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         code: 200,
        //         data: [
        //             {
        //                 currency: "eth",
        //                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //                 addressTag: "",
        //                 chain: "eth"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object parsed = this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        var networkCodeparamsOmitedVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((List<object>) networkCodeparamsOmitedVariable)[0];
        var paramsOmited = ((List<object>) networkCodeparamsOmitedVariable)[1];
        object indexedAddresses = await this.fetchDepositAddressesByNetwork(code, paramsOmited);
        object selectedNetworkCode = this.selectNetworkCodeFromUnifiedNetworks(getValue(currency, "code"), networkCode, indexedAddresses);
        return getValue(indexedAddresses, selectedNetworkCode);
    }

    public async virtual Task<object> fetchWithdrawAddresses(object code, object note = null, object networkCode = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(request, parameters));
        //
        //     {
        //         code: 200,
        //         data: [
        //             {
        //                 currency: "eth",
        //                 chain: "eth"
        //                 note: "Binance - TRC20",
        //                 addressTag: "",
        //                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object allAddresses = ((object)this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false)); // cjg: to do remove this weird object or array ambiguity
        object addresses = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(allAddresses)); postFixIncrement(ref i))
        {
            object address = getValue(allAddresses, i);
            object noteMatch = isTrue((isEqual(note, null))) || isTrue((isEqual(getValue(address, "note"), note)));
            object networkMatch = isTrue((isEqual(networkCode, null))) || isTrue((isEqual(getValue(address, "network"), networkCode)));
            if (isTrue(isTrue(noteMatch) && isTrue(networkMatch)))
            {
                ((List<object>)addresses).Add(address);
            }
        }
        return addresses;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "deposit" },
            { "direct", "next" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // max 100
        }
        object response = await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(request, parameters));
        //
        //    {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "id": "75115912",
        //                 "type": "deposit",
        //                 "sub-type": "NORMAL",
        //                 "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
        //                 "currency": "usdt",
        //                 "chain": "trc20usdt",
        //                 "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
        //                 "amount": "12.000000000000000000",
        //                 "from-addr-tag": "",
        //                 "address-id": "0",
        //                 "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
        //                 "address-tag": "",
        //                 "fee": "0",
        //                 "state": "safe",
        //                 "wallet-confirm": "2",
        //                 "created-at": "1621843808662",
        //                 "updated-at": "1621843857137"
        //             },
        //         ]
        //     }
        //
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "withdraw" },
            { "direct", "next" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // max 100
        }
        object response = await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(request, parameters));
        //
        //    {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "id": "61335312",
        //                 "type": "withdraw",
        //                 "sub-type": "NORMAL",
        //                 "currency": "usdt",
        //                 "chain": "trc20usdt",
        //                 "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
        //                 "amount": "12.000000000000000000",
        //                 "from-addr-tag": "",
        //                 "address-id": "27321591",
        //                 "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
        //                 "address-tag": "",
        //                 "fee": "1.000000000000000000",
        //                 "state": "confirmed",
        //                 "created-at": "1621852316553",
        //                 "updated-at": "1621852467041"
        //             },
        //         ]
        //     }
        //
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": "75115912",
        //         "type": "deposit",
        //         "sub-type": "NORMAL",
        //         "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
        //         "currency": "usdt",
        //         "chain": "trc20usdt",
        //         "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
        //         "amount": "2849.000000000000000000",
        //         "from-addr-tag": "",
        //         "address-id": "0",
        //         "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
        //         "address-tag": "",
        //         "fee": "0",
        //         "state": "safe",
        //         "wallet-confirm": "2",
        //         "created-at": "1621843808662",
        //         "updated-at": "1621843857137"
        //     },
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "61335312",
        //         "type": "withdraw",
        //         "sub-type": "NORMAL",
        //         "currency": "usdt",
        //         "chain": "trc20usdt",
        //         "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
        //         "amount": "12.000000000000000000",
        //         "from-addr-tag": "",
        //         "address-id": "27321591",
        //         "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
        //         "address-tag": "",
        //         "fee": "1.000000000000000000",
        //         "state": "confirmed",
        //         "created-at": "1621852316553",
        //         "updated-at": "1621852467041"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        object timestamp = this.safeInteger(transaction, "created-at");
        object code = this.safeCurrencyCode(this.safeString(transaction, "currency"));
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
        }
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            feeCost = Precise.stringAbs(feeCost);
        }
        object networkId = this.safeString(transaction, "chain");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "data") },
            { "txid", this.safeString(transaction, "tx-hash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId, code) },
            { "address", this.safeString(transaction, "address") },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "address-tag") },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "state")) },
            { "updated", this.safeInteger(transaction, "updated-at") },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCost) },
                { "rate", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "unknown", "failed" },
            { "confirming", "pending" },
            { "confirmed", "ok" },
            { "safe", "ok" },
            { "orphan", "failed" },
            { "submitted", "pending" },
            { "canceled", "canceled" },
            { "reexamine", "pending" },
            { "reject", "failed" },
            { "pass", "pending" },
            { "wallet-reject", "failed" },
            { "confirm-error", "failed" },
            { "repealed", "failed" },
            { "wallet-transfer", "pending" },
            { "pre-transfer", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "currency", ((string)getValue(currency, "id")).ToLower() },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["addr-tag"] = tag; // only for XRP?
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((List<object>)networkCodeparametersVariable)[0];
        parameters = ((List<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((Dictionary<string, object>)request)["chain"] = this.networkCodeToId(networkCode, code);
        }
        amount = parseFloat(this.currencyToPrecision(code, amount, networkCode));
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        if (isTrue(this.safeValue(withdrawOptions, "includeFee", false)))
        {
            object fee = this.safeNumber(parameters, "fee");
            if (isTrue(isEqual(fee, null)))
            {
                object currencies = await this.fetchCurrencies();
                this.currencies = this.deepExtend(this.currencies, currencies);
                object targetNetwork = this.safeValue(getValue(currency, "networks"), networkCode, new Dictionary<string, object>() {});
                fee = this.safeNumber(targetNetwork, "fee");
                if (isTrue(isEqual(fee, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " withdraw() function can not find withdraw fee for chosen network. You need to re-load markets with \"exchange.loadMarkets(true)\", or provide the \"fee\" parameter")) ;
                }
            }
            // fee needs to be deducted from whole amount
            object feeString = this.currencyToPrecision(code, fee, networkCode);
            parameters = this.omit(parameters, "fee");
            object amountString = this.numberToString(amount);
            object amountSubtractedString = Precise.stringSub(amountString, feeString);
            object amountSubtracted = parseFloat(amountSubtractedString);
            ((Dictionary<string, object>)request)["fee"] = parseFloat(feeString);
            amount = parseFloat(this.currencyToPrecision(code, amountSubtracted, networkCode));
        }
        ((Dictionary<string, object>)request)["amount"] = amount;
        object response = await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "data": 12345,
        //         "status": "ok"
        //     }
        //
        object id = this.safeString(transfer, "data");
        object code = this.safeCurrencyCode(null, currency);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name huobi#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://huobiapi.github.io/docs/dm/v1/en/#transfer-margin-between-spot-account-and-future-account
        * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-fund-between-spot-account-and-future-contract-account
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-transfer-margin-between-spot-account-and-usdt-margined-contracts-account
        * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-cross-margin-account-cross
        * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-isolated-margin-account-isolated
        * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-cross-margin-account-to-spot-trading-account-cross
        * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-isolated-margin-account-to-spot-trading-account-isolated
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from 'spot', 'future', 'swap'
        * @param {string} toAccount account to transfer to 'spot', 'future', 'swap'
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @param {string|undefined} params.symbol used for isolated margin transfer
        * @param {string|undefined} params.subType 'linear' or 'inverse', only used when transfering to/from swap accounts
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", parseFloat(this.currencyToPrecision(code, amount)) },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("transfer", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object method = null;
        object fromAccountId = this.convertTypeToAccount(fromAccount);
        object toAccountId = this.convertTypeToAccount(toAccount);
        object toCross = isEqual(toAccountId, "cross");
        object fromCross = isEqual(fromAccountId, "cross");
        object toIsolated = this.inArray(toAccountId, this.ids);
        object fromIsolated = this.inArray(fromAccountId, this.ids);
        object fromSpot = isEqual(fromAccountId, "pro");
        object toSpot = isEqual(toAccountId, "pro");
        if (isTrue(isTrue(fromSpot) && isTrue(toSpot)))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " transfer () cannot make a transfer between "), fromAccount), " and "), toAccount)) ;
        }
        object fromOrToFuturesAccount = isTrue((isEqual(fromAccountId, "futures"))) || isTrue((isEqual(toAccountId, "futures")));
        if (isTrue(fromOrToFuturesAccount))
        {
            object type = add(add(fromAccountId, "-to-"), toAccountId);
            type = this.safeString(parameters, "type", type);
            ((Dictionary<string, object>)request)["type"] = type;
            method = "spotPrivatePostV1FuturesTransfer";
        } else if (isTrue(isTrue(fromSpot) && isTrue(toCross)))
        {
            method = "privatePostCrossMarginTransferIn";
        } else if (isTrue(isTrue(fromCross) && isTrue(toSpot)))
        {
            method = "privatePostCrossMarginTransferOut";
        } else if (isTrue(isTrue(fromSpot) && isTrue(toIsolated)))
        {
            ((Dictionary<string, object>)request)["symbol"] = toAccountId;
            method = "privatePostDwTransferInMargin";
        } else if (isTrue(isTrue(fromIsolated) && isTrue(toSpot)))
        {
            ((Dictionary<string, object>)request)["symbol"] = fromAccountId;
            method = "privatePostDwTransferOutMargin";
        } else
        {
            method = "v2PrivatePostAccountTransfer";
            if (isTrue(isEqual(subType, "linear")))
            {
                if (isTrue(isTrue((isEqual(fromAccountId, "swap"))) || isTrue((isEqual(fromAccount, "linear-swap")))))
                {
                    fromAccountId = "linear-swap";
                } else
                {
                    toAccountId = "linear-swap";
                }
                // check if cross-margin or isolated
                object symbol = this.safeString(parameters, "symbol");
                parameters = this.omit(parameters, "symbol");
                if (isTrue(!isEqual(symbol, null)))
                {
                    symbol = this.marketId(symbol);
                    ((Dictionary<string, object>)request)["margin-account"] = symbol;
                } else
                {
                    ((Dictionary<string, object>)request)["margin-account"] = "USDT"; // cross-margin
                }
            }
            ((Dictionary<string, object>)request)["from"] = ((bool) isTrue(fromSpot)) ? "spot" : fromAccountId;
            ((Dictionary<string, object>)request)["to"] = ((bool) isTrue(toSpot)) ? "spot" : toAccountId;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //    {
        //        code: '200',
        //        data: '660150061',
        //        message: 'Succeed',
        //        success: true,
        //        'print-log': true
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public async virtual Task<object> fetchBorrowRatesPerSymbol(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchBorrowRatesPerSymbol
        * @description fetch borrow rates for currencies within individual markets
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by market symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetV1MarginLoanInfo(parameters);
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "1inchusdt",
        //                "currencies": [
        //                    {
        //                        "currency": "1inch",
        //                        "interest-rate": "0.00098",
        //                        "min-loan-amt": "90.000000000000000000",
        //                        "max-loan-amt": "1000.000000000000000000",
        //                        "loanable-amt": "0.0",
        //                        "actual-rate": "0.00098"
        //                    },
        //                    {
        //                        "currency": "usdt",
        //                        "interest-rate": "0.00098",
        //                        "min-loan-amt": "100.000000000000000000",
        //                        "max-loan-amt": "1000.000000000000000000",
        //                        "loanable-amt": "0.0",
        //                        "actual-rate": "0.00098"
        //                    }
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        object timestamp = this.milliseconds();
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rate = getValue(data, i);
            object currencies = this.safeValue(rate, "currencies", new List<object>() {});
            object symbolRates = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(currencies)); postFixIncrement(ref j))
            {
                object currency = getValue(currencies, j);
                object currencyId = this.safeString(currency, "currency");
                object code = this.safeCurrencyCode(currencyId, "currency");
                ((Dictionary<string, object>)symbolRates)[(string)code] = new Dictionary<string, object>() {
                    { "currency", code },
                    { "rate", this.safeNumber(currency, "actual-rate") },
                    { "span", 86400000 },
                    { "timestamp", timestamp },
                    { "datetime", this.iso8601(timestamp) },
                };
            }
            object marketId = this.safeString(rate, "symbol");
            object symbol = this.safeSymbol(marketId);
            ((Dictionary<string, object>)rates)[(string)symbol] = symbolRates;
        }
        return rates;
    }

    public async override Task<object> fetchBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetV1MarginLoanInfo(parameters);
        // {
        //     "status": "ok",
        //     "data": [
        //         {
        //             "symbol": "1inchusdt",
        //             "currencies": [
        //                 {
        //                     "currency": "1inch",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "90.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 },
        //                 {
        //                     "currency": "usdt",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "100.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 }
        //             ]
        //         },
        //         ...
        //     ]
        // }
        object timestamp = this.milliseconds();
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object currencies = this.safeValue(market, "currencies", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(currencies)); postFixIncrement(ref j))
            {
                object currency = getValue(currencies, j);
                object currencyId = this.safeString(currency, "currency");
                object code = this.safeCurrencyCode(currencyId, "currency");
                ((Dictionary<string, object>)rates)[(string)code] = new Dictionary<string, object>() {
                    { "currency", code },
                    { "rate", this.safeNumber(currency, "actual-rate") },
                    { "span", 86400000 },
                    { "timestamp", timestamp },
                    { "datetime", this.iso8601(timestamp) },
                    { "info", null },
                };
            }
        }
        return rates;
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since not used by huobi, but filtered internally by ccxt
        * @param {int|undefined} limit not used by huobi, but filtered internally by ccxt
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        object method = null;
        if (isTrue(getValue(market, "inverse")))
        {
            method = "contractPublicGetSwapApiV1SwapHistoricalFundingRate";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRateHistory() supports inverse and linear swaps only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "total_page": 62,
        //         "current_page": 1,
        //         "total_size": 1237,
        //         "data": [
        //             {
        //                 "avg_premium_index": "-0.000208064395065541",
        //                 "funding_rate": "0.000100000000000000",
        //                 "realized_rate": "0.000100000000000000",
        //                 "funding_time": "1638921600000",
        //                 "contract_code": "BTC-USDT",
        //                 "symbol": "BTC",
        //                 "fee_asset": "USDT"
        //             },
        //         ]
        //     },
        //     "ts": 1638939294277
        // }
        //
        object data = this.safeValue(response, "data");
        object result = this.safeValue(data, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "contract_code");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "funding_time");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // {
        //      "status": "ok",
        //      "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BCH-USD",
        //         "symbol": "BCH",
        //         "fee_asset": "BCH",
        //         "funding_time": "1639094400000",
        //         "next_funding_time": "1639123200000"
        //     },
        //     "ts": 1639085854775
        // }
        //
        object nextFundingRate = this.safeNumber(contract, "estimated_rate");
        object fundingTimestamp = this.safeInteger(contract, "funding_time");
        object nextFundingTimestamp = this.safeInteger(contract, "next_funding_time");
        object marketId = this.safeString(contract, "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "funding_rate") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", nextFundingRate },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = null;
        if (isTrue(getValue(market, "inverse")))
        {
            method = "contractPublicGetSwapApiV1SwapFundingRate";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "contractPublicGetLinearSwapApiV1SwapFundingRate";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRate() supports inverse and linear swaps only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BTC-USDT",
        //         "symbol": "BTC",
        //         "fee_asset": "USDT",
        //         "funding_time": "1603699200000",
        //         "next_funding_time": "1603728000000"
        //     },
        //     "ts": 1603696494714
        // }
        //
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object options = this.safeValue(this.options, "fetchFundingRates", new Dictionary<string, object>() {});
        object defaultSubType = this.safeString(this.options, "defaultSubType", "inverse");
        object subType = this.safeString(options, "subType", defaultSubType);
        subType = this.safeString(parameters, "subType", subType);
        object request = new Dictionary<string, object>() {};
        object method = this.getSupportedMapping(subType, new Dictionary<string, object>() {
            { "linear", "contractPublicGetLinearSwapApiV1SwapBatchFundingRate" },
            { "inverse", "contractPublicGetSwapApiV1SwapBatchFundingRate" },
        });
        parameters = this.omit(parameters, "subType");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "estimated_rate": "0.000100000000000000",
        //                 "funding_rate": "0.000100000000000000",
        //                 "contract_code": "MANA-USDT",
        //                 "symbol": "MANA",
        //                 "fee_asset": "USDT",
        //                 "funding_time": "1643356800000",
        //                 "next_funding_time": "1643385600000",
        //                 "trade_partition":"USDT"
        //             },
        //         ],
        //         "ts": 1643346173103
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = this.parseFundingRates(data);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @param {string|undefined} code unified currency code
        * @param {string|undefined} symbol unified market symbol when fetch interest in isolated markets
        * @param {int|undefined} since the earliest time in ms to fetch borrrow interest for
        * @param {int|undefined} limit the maximum number of structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start-date"] = this.yyyymmdd(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        object market = null;
        object method = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            method = "privateGetMarginLoanOrders";
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
        } else
        {
            method = "privateGetCrossMarginLoanOrders";
            if (isTrue(!isEqual(code, null)))
            {
                object currency = this.currency(code);
                ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //    {
        //        "status":"ok",
        //        "data":[
        //            {
        //                "loan-balance":"0.100000000000000000",
        //                "interest-balance":"0.000200000000000000",
        //                "loan-amount":"0.100000000000000000",
        //                "accrued-at":1511169724531,
        //                "interest-amount":"0.000200000000000000",
        //                "filled-points":"0.2",
        //                "filled-ht":"0.2",
        //                "currency":"btc",
        //                "id":394,
        //                "state":"accrual",
        //                "account-id":17747,
        //                "user-id":119913,
        //                "created-at":1511169724531
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        object interest = this.parseBorrowInterests(data, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        // isolated
        //    {
        //        "interest-rate":"0.000040830000000000",
        //        "user-id":35930539,
        //        "account-id":48916071,
        //        "updated-at":1649320794195,
        //        "deduct-rate":"1",
        //        "day-interest-rate":"0.000980000000000000",
        //        "hour-interest-rate":"0.000040830000000000",
        //        "loan-balance":"100.790000000000000000",
        //        "interest-balance":"0.004115260000000000",
        //        "loan-amount":"100.790000000000000000",
        //        "paid-coin":"0.000000000000000000",
        //        "accrued-at":1649320794148,
        //        "created-at":1649320794148,
        //        "interest-amount":"0.004115260000000000",
        //        "deduct-amount":"0",
        //        "deduct-currency":"",
        //        "paid-point":"0.000000000000000000",
        //        "currency":"usdt",
        //        "symbol":"ltcusdt",
        //        "id":20242721,
        //    }
        //
        // cross
        //   {
        //       "id":3416576,
        //       "user-id":35930539,
        //       "account-id":48956839,
        //       "currency":"usdt",
        //       "loan-amount":"102",
        //       "loan-balance":"102",
        //       "interest-amount":"0.00416466",
        //       "interest-balance":"0.00416466",
        //       "created-at":1649322735333,
        //       "accrued-at":1649322735382,
        //       "state":"accrual",
        //       "filled-points":"0",
        //       "filled-ht":"0"
        //   }
        //
        object marketId = this.safeString(info, "symbol");
        object marginMode = ((bool) isTrue((isEqual(marketId, null)))) ? "cross" : "isolated";
        market = this.safeMarket(marketId);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeNumber(info, "accrued-at");
        return new Dictionary<string, object>() {
            { "account", ((bool) isTrue((isEqual(marginMode, "isolated")))) ? symbol : "cross" },
            { "symbol", symbol },
            { "marginMode", marginMode },
            { "currency", this.safeCurrencyCode(this.safeString(info, "currency")) },
            { "interest", this.safeNumber(info, "interest-amount") },
            { "interestRate", this.safeNumber(info, "interest-rate") },
            { "amountBorrowed", this.safeNumber(info, "loan-amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = "/";
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(((api).GetType() == typeof(string))))
        {
            // signing implementation for the old endpoints
            if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isEqual(api, "private")))))
            {
                url = add(url, this.version);
            } else if (isTrue(isTrue((isEqual(api, "v2Public"))) || isTrue((isEqual(api, "v2Private")))))
            {
                url = add(url, "v2");
            }
            url = add(url, add("/", this.implodeParams(path, parameters)));
            if (isTrue(isTrue(isEqual(api, "private")) || isTrue(isEqual(api, "v2Private"))))
            {
                this.checkRequiredCredentials();
                object timestamp = this.ymdhms(this.milliseconds(), "T");
                object request = new Dictionary<string, object>() {
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "AccessKeyId", this.apiKey },
                    { "Timestamp", timestamp },
                };
                if (isTrue(!isEqual(method, "POST")))
                {
                    request = this.extend(request, query);
                }
                object sortedRequest = this.keysort(request);
                object auth = this.urlencode(sortedRequest);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                object payload = String.Join("\n", ((List<object>)new List<object>() {method, this.hostname, url, auth}).ToArray()); // eslint-disable-line quotes
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
                auth = add(auth, add("&", this.urlencode(new Dictionary<string, object>() {
    { "Signature", signature },
})));
                url = add(url, add("?", auth));
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/json" },
                    };
                } else
                {
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/x-www-form-urlencoded" },
                    };
                }
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
            url = add(this.implodeParams(getValue(getValue(this.urls, "api"), api), new Dictionary<string, object>() {
    { "hostname", this.hostname },
}), url);
        } else
        {
            // signing implementation for the new endpoints
            // const [ type, access ] = api;
            object type = this.safeString(api, 0);
            object access = this.safeString(api, 1);
            object levelOneNestedPath = this.safeString(api, 2);
            object levelTwoNestedPath = this.safeString(api, 3);
            object hostname = null;
            object hostnames = this.safeValue(getValue(this.urls, "hostnames"), type);
            if (isTrue(!((hostnames).GetType() == typeof(string))))
            {
                hostnames = this.safeValue(hostnames, levelOneNestedPath);
                if (isTrue(isTrue((!((hostnames).GetType() == typeof(string)))) && isTrue((!isEqual(levelTwoNestedPath, null)))))
                {
                    hostnames = this.safeValue(hostnames, levelTwoNestedPath);
                }
            }
            hostname = hostnames;
            url = add(url, this.implodeParams(path, parameters));
            if (isTrue(isEqual(access, "public")))
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else if (isTrue(isEqual(access, "private")))
            {
                this.checkRequiredCredentials();
                object timestamp = this.ymdhms(this.milliseconds(), "T");
                object request = new Dictionary<string, object>() {
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "AccessKeyId", this.apiKey },
                    { "Timestamp", timestamp },
                };
                if (isTrue(!isEqual(method, "POST")))
                {
                    request = this.extend(request, query);
                }
                request = ((object)this.keysort(request));
                object auth = this.urlencode(request);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                object payload = String.Join("\n", ((List<object>)new List<object>() {method, hostname, url, auth}).ToArray()); // eslint-disable-line quotes
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
                auth = add(auth, add("&", this.urlencode(new Dictionary<string, object>() {
    { "Signature", signature },
})));
                url = add(url, add("?", auth));
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    if (isTrue(isEqual(getArrayLength(body), 2)))
                    {
                        body = "{}";
                    }
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/json" },
                    };
                } else
                {
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/x-www-form-urlencoded" },
                    };
                }
            }
            url = add(this.implodeParams(getValue(getValue(this.urls, "api"), type), new Dictionary<string, object>() {
    { "hostname", hostname },
}), url);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(((Dictionary<string,object>)response).ContainsKey(toStringOrNull("status"))))
        {
            //
            //     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
            //
            object status = this.safeString(response, "status");
            if (isTrue(isEqual(status, "error")))
            {
                object code = this.safeString2(response, "err-code", "err_code");
                object feedback = add(add(this.id, " "), body);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object message = this.safeString2(response, "err-msg", "err_msg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        if (isTrue(((Dictionary<string,object>)response).ContainsKey(toStringOrNull("code"))))
        {
            // {code: '1003', message: 'invalid signature'}
            object feedback = add(add(this.id, " "), body);
            object code = this.safeString(response, "code");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
        }
        return null;
    }

    public async virtual Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-account-financial-records-via-multiple-fields-new   // linear swaps
        * @see https://huobiapi.github.io/docs/dm/v1/en/#query-financial-records-via-multiple-fields-new                          // coin-m futures
        * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-financial-records-via-multiple-fields-new          // coin-m swaps
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch funding history for
        * @param {int|undefined} limit the maximum number of funding history structures to retrieve
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = null;
        object request = new Dictionary<string, object>() {
            { "type", "30,31" },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_date"] = since;
        }
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((Dictionary<string, object>)request)["contract"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                method = "contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact";
                //
                //    {
                //        status: 'ok',
                //        data: {
                //           financial_record: [
                //               {
                //                   id: '1320088022',
                //                   type: '30',
                //                   amount: '0.004732510000000000',
                //                   ts: '1641168019321',
                //                   contract_code: 'BTC-USDT',
                //                   asset: 'USDT',
                //                   margin_account: 'BTC-USDT',
                //                   face_margin_account: ''
                //               },
                //           ],
                //           remain_size: '0',
                //           next_id: null
                //        },
                //        ts: '1641189898425'
                //    }
                //
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchFundingHistory", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    ((Dictionary<string, object>)request)["mar_acct"] = getValue(market, "id");
                } else
                {
                    ((Dictionary<string, object>)request)["mar_acct"] = getValue(market, "quoteId");
                }
            } else
            {
                method = "contractPrivatePostSwapApiV3SwapFinancialRecordExact";
            }
        } else
        {
            method = "contractPrivatePostApiV3ContractFinancialRecordExact";
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseIncomes(data, market, since, limit);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("setLeverage", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
            marginMode = ((List<object>)marginModeparametersVariable)[0];
            parameters = ((List<object>)marginModeparametersVariable)[1];
            marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
            method = this.getSupportedMapping(marginMode, new Dictionary<string, object>() {
                { "isolated", "contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate" },
                { "cross", "contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate" },
            });
        } else
        {
            method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
                { "future", "contractPrivatePostApiV1ContractSwitchLeverRate" },
                { "swap", "contractPrivatePostSwapApiV1SwapSwitchLeverRate" },
            });
        }
        object request = new Dictionary<string, object>() {
            { "lever_rate", leverage },
        };
        if (isTrue(isTrue(isEqual(marketType, "future")) && isTrue(getValue(market, "inverse"))))
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
        } else
        {
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return response;
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //       id: '1667161118',
        //       symbol: 'BTC',
        //       type: '31',
        //       amount: '-2.11306593188E-7',
        //       ts: '1641139308983',
        //       contract_code: 'BTC-USD'
        //     }
        //
        object marketId = this.safeString(income, "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "amount");
        object timestamp = this.safeInteger(income, "ts");
        object id = this.safeString(income, "id");
        object currencyId = this.safeString2(income, "symbol", "asset");
        object code = this.safeCurrencyCode(currencyId);
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
        };
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //       symbol: 'BTC',
        //       contract_code: 'BTC-USDT',
        //       volume: '1.000000000000000000',
        //       available: '1.000000000000000000',
        //       frozen: '0E-18',
        //       cost_open: '47162.000000000000000000',
        //       cost_hold: '47151.300000000000000000',
        //       profit_unreal: '0.007300000000000000',
        //       profit_rate: '-0.000144183876850008',
        //       lever_rate: '2',
        //       position_margin: '23.579300000000000000',
        //       direction: 'buy',
        //       profit: '-0.003400000000000000',
        //       last_price: '47158.6',
        //       margin_asset: 'USDT',
        //       margin_mode: 'isolated',
        //       margin_account: 'BTC-USDT',
        //       margin_balance: '24.973020070000000000',
        //       margin_position: '23.579300000000000000',
        //       margin_frozen: '0',
        //       margin_available: '1.393720070000000000',
        //       profit_real: '0E-18',
        //       risk_rate: '1.044107779705080303',
        //       withdraw_available: '1.386420070000000000000000000000000000',
        //       liquidation_price: '22353.229148614609571788',
        //       adjust_factor: '0.015000000000000000',
        //       margin_static: '24.965720070000000000'
        //     }
        //
        market = this.safeMarket(this.safeString(position, "contract_code"));
        object symbol = getValue(market, "symbol");
        object contracts = this.safeString(position, "volume");
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object entryPrice = this.safeNumber(position, "cost_open");
        object initialMargin = this.safeString(position, "position_margin");
        object rawSide = this.safeString(position, "direction");
        object side = ((bool) isTrue((isEqual(rawSide, "buy")))) ? "long" : "short";
        object unrealizedProfit = this.safeNumber(position, "profit_unreal");
        object marginMode = this.safeString(position, "margin_mode");
        object leverage = this.safeString(position, "lever_rate");
        object percentage = Precise.stringMul(this.safeString(position, "profit_rate"), "100");
        object lastPrice = this.safeString(position, "last_price");
        object faceValue = Precise.stringMul(contracts, contractSizeString);
        object notional = null;
        if (isTrue(getValue(market, "linear")))
        {
            notional = Precise.stringMul(faceValue, lastPrice);
        } else
        {
            notional = Precise.stringDiv(faceValue, lastPrice);
            marginMode = "cross";
        }
        object intialMarginPercentage = Precise.stringDiv(initialMargin, notional);
        object collateral = this.safeString(position, "margin_balance");
        object liquidationPrice = this.safeNumber(position, "liquidation_price");
        object adjustmentFactor = this.safeString(position, "adjust_factor");
        object maintenanceMarginPercentage = Precise.stringDiv(adjustmentFactor, leverage);
        object maintenanceMargin = Precise.stringMul(maintenanceMarginPercentage, notional);
        object marginRatio = Precise.stringDiv(maintenanceMargin, collateral);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", contractSize },
            { "entryPrice", entryPrice },
            { "collateral", this.parseNumber(collateral) },
            { "side", side },
            { "unrealizedProfit", unrealizedProfit },
            { "leverage", this.parseNumber(leverage) },
            { "percentage", this.parseNumber(percentage) },
            { "marginMode", marginMode },
            { "notional", this.parseNumber(notional) },
            { "markPrice", null },
            { "lastPrice", null },
            { "liquidationPrice", liquidationPrice },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(intialMarginPercentage) },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
        });
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeString(symbols, 0);
            market = this.market(first);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchPositions", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            marketType = "future";
        }
        object method = null;
        if (isTrue(isEqual(subType, "linear")))
        {
            method = this.getSupportedMapping(marginMode, new Dictionary<string, object>() {
                { "isolated", "contractPrivatePostLinearSwapApiV1SwapPositionInfo" },
                { "cross", "contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo" },
            });
        } else
        {
            method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
                { "future", "contractPrivatePostApiV1ContractPositionInfo" },
                { "swap", "contractPrivatePostSwapApiV1SwapPositionInfo" },
            });
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        object data = this.safeValue(response, "data", new List<object>() {});
        object timestamp = this.safeInteger(response, "ts");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object position = getValue(data, i);
            object parsed = this.parsePosition(position);
            ((List<object>)result).Add(this.extend(parsed, new Dictionary<string, object>() {
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            }));
        }
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchPosition
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchPosition", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchPosition", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            method = this.getSupportedMapping(marginMode, new Dictionary<string, object>() {
                { "isolated", "contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo" },
                { "cross", "contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo" },
            });
        } else
        {
            method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
                { "future", "contractPrivatePostApiV1ContractAccountPositionInfo" },
                { "swap", "contractPrivatePostSwapApiV1SwapAccountPositionInfo" },
            });
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue(getValue(market, "future")) && isTrue(getValue(market, "inverse"))))
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "settleId");
        } else
        {
            if (isTrue(isEqual(marginMode, "cross")))
            {
                ((Dictionary<string, object>)request)["margin_account"] = "USDT"; // only allowed value
            }
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        object data = this.safeValue(response, "data");
        object account = null;
        if (isTrue(isEqual(marginMode, "cross")))
        {
            account = data;
        } else
        {
            account = this.safeValue(data, 0);
        }
        object omitted = this.omit(account, new List<object>() {"positions"});
        object positions = this.safeValue(account, "positions");
        object position = null;
        if (isTrue(isTrue(getValue(market, "future")) && isTrue(getValue(market, "inverse"))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
            {
                object entry = getValue(positions, i);
                if (isTrue(isEqual(getValue(entry, "contract_code"), getValue(market, "id"))))
                {
                    position = entry;
                    break;
                }
            }
        } else
        {
            position = this.safeValue(positions, 0);
        }
        object timestamp = this.safeInteger(response, "ts");
        object parsed = this.parsePosition(this.extend(position, omitted));
        return this.extend(parsed, new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "trade" },
            { "etf", "trade" },
            { "transact-fee", "fee" },
            { "fee-deduction", "fee" },
            { "transfer", "transfer" },
            { "credit", "credit" },
            { "liquidation", "trade" },
            { "interest", "credit" },
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "withdraw-fee", "fee" },
            { "exchange", "exchange" },
            { "other-types", "transfer" },
            { "rebate", "rebate" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "accountId": 10000001,
        //         "currency": "usdt",
        //         "transactAmt": 10.000000000000000000,
        //         "transactType": "transfer",
        //         "transferType": "margin-transfer-out",
        //         "transactId": 0,
        //         "transactTime": 1629882331066,
        //         "transferer": 28483123,
        //         "transferee": 13496526
        //     }
        //
        object id = this.safeString(item, "transactId");
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(item, "transactAmt");
        object transferType = this.safeString(item, "transferType");
        object type = this.parseLedgerEntryType(transferType);
        object direction = this.safeString(item, "direction");
        object timestamp = this.safeInteger(item, "transactTime");
        object datetime = this.iso8601(timestamp);
        object account = this.safeString(item, "accountId");
        return new Dictionary<string, object>() {
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", id },
            { "referenceAccount", account },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
            { "info", item },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountId = await this.fetchAccountIdByType("spot", parameters);
        object request = new Dictionary<string, object>() {
            { "accountId", accountId },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // max 500
        }
        object response = await this.spotPrivateGetV2AccountLedger(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": 10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-out",
        //                 "transactId": 0,
        //                 "transactTime": 1629882331066,
        //                 "transferer": 28483123,
        //                 "transferee": 13496526
        //             },
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": -10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-in",
        //                 "transactId": 0,
        //                 "transactTime": 1629882096562,
        //                 "transferer": 13496526,
        //                 "transferee": 28483123
        //             }
        //         ],
        //         "nextId": 1624316679,
        //         "ok": true
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(parameters);
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "MANA",
        //                "contract_code": "MANA-USDT",
        //                "margin_mode": "isolated",
        //                "trade_partition": "USDT",
        //                "list": [
        //                    {
        //                        "lever_rate": 75,
        //                        "ladders": [
        //                            {
        //                                "ladder": 0,
        //                                "min_size": 0,
        //                                "max_size": 999,
        //                                "adjust_factor": 0.7
        //                            },
        //                            ...
        //                        ]
        //                    }
        //                    ...
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseLeverageTiers(data, symbols, "contract_code");
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchMarketLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            if (!isTrue(getValue(market, "contract")))
            {
                throw new BadRequest ((string)add(this.id, " fetchMarketLeverageTiers() symbol supports contract markets only")) ;
            }
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
        }
        object response = await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(this.extend(request, parameters));
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "MANA",
        //                "contract_code": "MANA-USDT",
        //                "margin_mode": "isolated",
        //                "trade_partition": "USDT",
        //                "list": [
        //                    {
        //                        "lever_rate": 75,
        //                        "ladders": [
        //                            {
        //                                "ladder": 0,
        //                                "min_size": 0,
        //                                "max_size": 999,
        //                                "adjust_factor": 0.7
        //                            },
        //                            ...
        //                        ]
        //                    }
        //                    ...
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        object tiers = this.parseLeverageTiers(data, new List<object>() {symbol}, "contract_code");
        return this.safeValue(tiers, symbol);
    }

    public override object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object list = this.safeValue(item, "list", new List<object>() {});
            object tiers = new List<object>() {};
            object currency = this.safeString(item, "trade_partition");
            object id = this.safeString(item, marketIdKey);
            object symbol = this.safeSymbol(id);
            if (isTrue(this.inArray(symbol, symbols)))
            {
                for (object j = 0; isLessThan(j, getArrayLength(list)); postFixIncrement(ref j))
                {
                    object obj = getValue(list, j);
                    object leverage = this.safeString(obj, "lever_rate");
                    object ladders = this.safeValue(obj, "ladders", new List<object>() {});
                    for (object k = 0; isLessThan(k, getArrayLength(ladders)); postFixIncrement(ref k))
                    {
                        object bracket = getValue(ladders, k);
                        object adjustFactor = this.safeString(bracket, "adjust_factor");
                        ((List<object>)tiers).Add(new Dictionary<string, object>() {
                            { "tier", this.safeInteger(bracket, "ladder") },
                            { "currency", this.safeCurrencyCode(currency) },
                            { "minNotional", this.safeNumber(bracket, "min_size") },
                            { "maxNotional", this.safeNumber(bracket, "max_size") },
                            { "maintenanceMarginRate", this.parseNumber(Precise.stringDiv(adjustFactor, leverage)) },
                            { "maxLeverage", this.parseNumber(leverage) },
                            { "info", bracket },
                        });
                    }
                }
                ((Dictionary<string, object>)result)[(string)symbol] = tiers;
            }
        }
        return result;
    }

    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOpenInterestHistory
        * @description Retrieves the open interest history of a currency
        * @see https://huobiapi.github.io/docs/dm/v1/en/#query-information-on-open-interest
        * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-information-on-open-interest
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-information-on-open-interest
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} timeframe '1h', '4h', '12h', or '1d'
        * @param {int|undefined} since Not used by huobi api, but response parsed by CCXT
        * @param {int|undefined} limit Default：48，Data Range [1,200]
        * @param {object} params Exchange specific parameters
        * @param {int} params.amount_type *required* Open interest unit. 1-cont，2-cryptocurrency
        * @param {int|undefined} params.pair eg BTC-USDT *Only for USDT-M*
        * @returns {object} an array of [open interest structures]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
        */
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isTrue(isTrue(!isEqual(timeframe, "1h")) && isTrue(!isEqual(timeframe, "4h"))) && isTrue(!isEqual(timeframe, "12h"))) && isTrue(!isEqual(timeframe, "1d"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe")) ;
        }
        await this.loadMarkets();
        object timeframes = new Dictionary<string, object>() {
            { "1h", "60min" },
            { "4h", "4hour" },
            { "12h", "12hour" },
            { "1d", "1day" },
        };
        object market = this.market(symbol);
        object amountType = this.safeNumber2(parameters, "amount_type", "amountType");
        if (isTrue(isEqual(amountType, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenInterestHistory requires parameter params.amountType to be either 1 (cont), or 2 (cryptocurrency)")) ;
        }
        object request = new Dictionary<string, object>() {
            { "period", getValue(timeframes, timeframe) },
            { "amount_type", amountType },
        };
        object method = null;
        if (isTrue(getValue(market, "future")))
        {
            ((Dictionary<string, object>)request)["contract_type"] = this.safeString(getValue(market, "info"), "contract_type");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "baseId"); // currency code on coin-m futures
            method = "contractPublicGetApiV1ContractHisOpenInterest"; // coin-m futures
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["contract_type"] = "swap";
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
            method = "contractPublicGetLinearSwapApiV1SwapHisOpenInterest"; // USDT-M
        } else
        {
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
            method = "contractPublicGetSwapApiV1SwapHisOpenInterest"; // coin-m swaps
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
        //    {
        //        status: 'ok',
        //        data: {
        //            symbol: 'BTC',
        //            tick: [
        //                {
        //                    volume: '4385.4350000000000000',
        //                    amount_type: '2',
        //                    ts: '1648220400000',
        //                    value: '194059884.1850000000000000'
        //                },
        //                ...
        //            ],
        //            contract_code: 'BTC-USDT',
        //            business_type: 'swap',
        //            pair: 'BTC-USDT',
        //            contract_type: 'swap',
        //            trade_partition: 'USDT'
        //        },
        //        ts: '1648223733007'
        //    }
        //
        //  contractPublicGetSwapApiV1SwapHisOpenInterest
        //    {
        //        "status": "ok",
        //        "data": {
        //            "symbol": "CRV",
        //            "tick": [
        //                {
        //                    "volume": 19174.0000000000000000,
        //                    "amount_type": 1,
        //                    "ts": 1648224000000
        //                },
        //                ...
        //            ],
        //            "contract_code": "CRV-USD"
        //        },
        //        "ts": 1648226554260
        //    }
        //
        //  contractPublicGetApiV1ContractHisOpenInterest
        //    {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_type": "this_week",
        //             "tick": [
        //                {
        //                     "volume": "48419.0000000000000000",
        //                     "amount_type": 1,
        //                     "ts": 1648224000000
        //                },
        //                ...
        //            ]
        //        },
        //        "ts": 1648227062944
        //    }
        //
        object data = this.safeValue(response, "data");
        object tick = this.safeValue(data, "tick");
        return this.parseOpenInterests(tick, market, since, limit);
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
        * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} params exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        if (isTrue(getValue(market, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOpenInterest() does not currently support option markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        object method = null;
        if (isTrue(getValue(market, "future")))
        {
            ((Dictionary<string, object>)request)["contract_type"] = this.safeString(getValue(market, "info"), "contract_type");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "baseId");
            method = "contractPublicGetApiV1ContractOpenInterest"; // COIN-M futures
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["contract_type"] = "swap";
            method = "contractPublicGetLinearSwapApiV1SwapOpenInterest"; // USDT-M
        } else
        {
            method = "contractPublicGetSwapApiV1SwapOpenInterest"; // COIN-M swaps
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // USDT-M contractPublicGetLinearSwapApiV1SwapOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 7192610.000000000000000000,
        //                 "amount": 7192.610000000000000000,
        //                 "symbol": "BTC",
        //                 "value": 134654290.332000000000000000,
        //                 "contract_code": "BTC-USDT",
        //                 "trade_amount": 70692.804,
        //                 "trade_volume": 70692804,
        //                 "trade_turnover": 1379302592.9518,
        //                 "business_type": "swap",
        //                 "pair": "BTC-USDT",
        //                 "contract_type": "swap",
        //                 "trade_partition": "USDT"
        //             }
        //         ],
        //         "ts": 1664336503144
        //     }
        //
        // COIN-M Swap contractPublicGetSwapApiV1SwapOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 518018.000000000000000000,
        //                 "amount": 2769.675777407074725180,
        //                 "symbol": "BTC",
        //                 "contract_code": "BTC-USD",
        //                 "trade_amount": 9544.4032080046491323463688602729806842458,
        //                 "trade_volume": 1848448,
        //                 "trade_turnover": 184844800.000000000000000000
        //             }
        //         ],
        //         "ts": 1664337226028
        //     }
        //
        // COIN-M Futures contractPublicGetApiV1ContractOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 118850.000000000000000000,
        //                 "amount": 635.502025211544374189,
        //                 "symbol": "BTC",
        //                 "contract_type": "this_week",
        //                 "contract_code": "BTC220930",
        //                 "trade_amount": 1470.9400749347598691119206024033947897351,
        //                 "trade_volume": 286286,
        //                 "trade_turnover": 28628600.000000000000000000
        //             }
        //         ],
        //         "ts": 1664337928805
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object openInterest = this.parseOpenInterest(getValue(data, 0), market);
        object timestamp = this.safeInteger(response, "ts");
        return this.extend(openInterest, new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // fetchOpenInterestHistory
        //
        //    {
        //        volume: '4385.4350000000000000',
        //        amount_type: '2',
        //        ts: '1648220400000',
        //        value: '194059884.1850000000000000'
        //    }
        //
        // fetchOpenInterest: USDT-M
        //
        //     {
        //         "volume": 7192610.000000000000000000,
        //         "amount": 7192.610000000000000000,
        //         "symbol": "BTC",
        //         "value": 134654290.332000000000000000,
        //         "contract_code": "BTC-USDT",
        //         "trade_amount": 70692.804,
        //         "trade_volume": 70692804,
        //         "trade_turnover": 1379302592.9518,
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "contract_type": "swap",
        //         "trade_partition": "USDT"
        //     }
        //
        // fetchOpenInterest: COIN-M Swap
        //
        //     {
        //         "volume": 518018.000000000000000000,
        //         "amount": 2769.675777407074725180,
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USD",
        //         "trade_amount": 9544.4032080046491323463688602729806842458,
        //         "trade_volume": 1848448,
        //         "trade_turnover": 184844800.000000000000000000
        //     }
        //
        // fetchOpenInterest: COIN-M Futures
        //
        //     {
        //         "volume": 118850.000000000000000000,
        //         "amount": 635.502025211544374189,
        //         "symbol": "BTC",
        //         "contract_type": "this_week",
        //         "contract_code": "BTC220930",
        //         "trade_amount": 1470.9400749347598691119206024033947897351,
        //         "trade_volume": 286286,
        //         "trade_turnover": 28628600.000000000000000000
        //     }
        //
        object timestamp = this.safeInteger(interest, "ts");
        object amount = this.safeNumber(interest, "volume");
        object value = this.safeNumber(interest, "value");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "baseVolume", amount },
            { "quoteVolume", value },
            { "openInterestAmount", amount },
            { "openInterestValue", value },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#borrowMargin
        * @description create a loan to borrow margin
        * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
        * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("borrowMargin", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        object method = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " borrowMargin() requires a symbol argument for isolated margin")) ;
            }
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            method = "privatePostMarginOrders";
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            method = "privatePostCrossMarginOrders";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // Cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        // Isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#repayMargin
        * @description repay borrowed margin and interest
        * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol unified market symbol
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("repayMargin", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        object marginAccounts = this.safeValue(this.options, "marginAccounts", new Dictionary<string, object>() {});
        object accountType = this.getSupportedMapping(marginMode, marginAccounts);
        object accountId = await this.fetchAccountIdByType(accountType, parameters);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "accountId", accountId },
        };
        object response = await this.v2PrivatePostAccountRepayment(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "data": [
        //             {
        //                 "repayId":1174424,
        //                 "repayTime":1600747722018
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "Data", new List<object>() {});
        object loan = this.safeValue(data, 0);
        object transaction = this.parseMarginLoan(loan, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId":1174424,
        //         "repayTime":1600747722018
        //     }
        //
        object timestamp = this.safeInteger(info, "repayTime");
        return new Dictionary<string, object>() {
            { "id", this.safeInteger2(info, "repayId", "data") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchSettlementHistory
        * @description Fetches historical settlement records
        * @param {string} symbol unified symbol of the market to fetch the settlement history for
        * @param {int} since timestamp in ms, value range = current time - 90 days，default = current time - 90 days
        * @param {int} limit page items, default 20, shall not exceed 50
        * @param {object} params exchange specific params
        * @param {int} params.until timestamp in ms, value range = start_time -> current time，default = current time
        * @param {int} params.page_index page index, default page 1 if not filled
        * @param {int} params.code unified currency code, can be used when symbol is undefined
        * @returns A list of settlement history objects
        */
        parameters ??= new Dictionary<string, object>();
        object code = this.safeString(parameters, "code");
        object until = this.safeInteger2(parameters, "until", "till");
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchSettlementHistory", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        if (isTrue(isEqual(type, "future")))
        {
            if (isTrue(isTrue(isEqual(symbol, null)) && isTrue(isEqual(code, null))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " requires a symbol argument or params[\"code\"] for fetchSettlementHistory future")) ;
            }
        } else if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " requires a symbol argument for fetchSettlementHistory swap")) ;
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "future")))
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "baseId");
        } else
        {
            ((Dictionary<string, object>)request)["contract_code"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_at"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["end_at"] = until;
        }
        object method = "contractPublicGetApiV1ContractSettlementRecords";
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "linear")))
            {
                method = "contractPublicGetLinearSwapApiV1SwapSettlementRecords";
            } else
            {
                method = "contractPublicGetSwapApiV1SwapSettlementRecords";
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // linear swap, coin-m swap
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //        "total_page": 14,
        //        "current_page": 1,
        //        "total_size": 270,
        //        "settlement_record": [
        //            {
        //                "symbol": "ADA",
        //                "contract_code": "ADA-USDT",
        //                "settlement_time": 1652313600000,
        //                "clawback_ratio": 0E-18,
        //                "settlement_price": 0.512303000000000000,
        //                "settlement_type": "settlement",
        //                "business_type": "swap",
        //                "pair": "ADA-USDT",
        //                "trade_partition": "USDT"
        //            },
        //            ...
        //        ],
        //        "ts": 1652338693256
        //    }
        //
        // coin-m future
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //            "total_page": 5,
        //            "current_page": 1,
        //            "total_size": 90,
        //            "settlement_record": [
        //                {
        //                    "symbol": "FIL",
        //                    "settlement_time": 1652342400000,
        //                    "clawback_ratio": 0E-18,
        //                    "list": [
        //                        {
        //                            "contract_code": "FIL220513",
        //                            "settlement_price": 7.016000000000000000,
        //                            "settlement_type": "settlement"
        //                        },
        //                        ...
        //                    ]
        //                },
        //            ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        object settlementRecord = this.safeValue(data, "settlement_record");
        object settlements = this.parseSettlements(settlementRecord, market);
        return this.sortBy(settlements, "timestamp");
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-currencies-v2
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the huobi api endpoint
        * @returns {[object]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPublicGetV2ReferenceCurrencies(parameters);
        //
        //    {
        //        "code": 200,
        //        "data": [
        //            {
        //                "currency": "sxp",
        //                "assetType": "1",
        //                "chains": [
        //                    {
        //                        "chain": "sxp",
        //                        "displayName": "ERC20",
        //                        "baseChain": "ETH",
        //                        "baseChainProtocol": "ERC20",
        //                        "isDynamic": true,
        //                        "numOfConfirmations": "12",
        //                        "numOfFastConfirmations": "12",
        //                        "depositStatus": "allowed",
        //                        "minDepositAmt": "0.23",
        //                        "withdrawStatus": "allowed",
        //                        "minWithdrawAmt": "0.23",
        //                        "withdrawPrecision": "8",
        //                        "maxWithdrawAmt": "227000.000000000000000000",
        //                        "withdrawQuotaPerDay": "227000.000000000000000000",
        //                        "withdrawQuotaPerYear": null,
        //                        "withdrawQuotaTotal": null,
        //                        "withdrawFeeType": "fixed",
        //                        "transactFeeWithdraw": "11.1653",
        //                        "addrWithTag": false,
        //                        "addrDepositTag": false
        //                    }
        //                ],
        //                "instStatus": "normal"
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //            {
        //              "currency": "sxp",
        //              "assetType": "1",
        //              "chains": [
        //                  {
        //                      "chain": "sxp",
        //                      "displayName": "ERC20",
        //                      "baseChain": "ETH",
        //                      "baseChainProtocol": "ERC20",
        //                      "isDynamic": true,
        //                      "numOfConfirmations": "12",
        //                      "numOfFastConfirmations": "12",
        //                      "depositStatus": "allowed",
        //                      "minDepositAmt": "0.23",
        //                      "withdrawStatus": "allowed",
        //                      "minWithdrawAmt": "0.23",
        //                      "withdrawPrecision": "8",
        //                      "maxWithdrawAmt": "227000.000000000000000000",
        //                      "withdrawQuotaPerDay": "227000.000000000000000000",
        //                      "withdrawQuotaPerYear": null,
        //                      "withdrawQuotaTotal": null,
        //                      "withdrawFeeType": "fixed",
        //                      "transactFeeWithdraw": "11.1653",
        //                      "addrWithTag": false,
        //                      "addrDepositTag": false
        //                  }
        //              ],
        //              "instStatus": "normal"
        //          }
        //
        object chains = this.safeValue(fee, "chains", new List<object>() {});
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
        {
            object chainEntry = getValue(chains, j);
            object networkId = this.safeString(chainEntry, "chain");
            object withdrawFeeType = this.safeString(chainEntry, "withdrawFeeType");
            object networkCode = this.networkIdToCode(networkId);
            object withdrawFee = null;
            object withdrawResult = null;
            if (isTrue(isEqual(withdrawFeeType, "fixed")))
            {
                withdrawFee = this.safeNumber(chainEntry, "transactFeeWithdraw");
                withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", false },
                };
            } else
            {
                withdrawFee = this.safeNumber(chainEntry, "transactFeeRateWithdraw");
                withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", true },
                };
            }
            ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", withdrawResult },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
            result = this.assignDefaultDepositWithdrawFees(result, currency);
        }
        return result;
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "ADA",
        //            "contract_code": "ADA-USDT",
        //            "settlement_time": 1652313600000,
        //            "clawback_ratio": 0E-18,
        //            "settlement_price": 0.512303000000000000,
        //            "settlement_type": "settlement",
        //            "business_type": "swap",
        //            "pair": "ADA-USDT",
        //            "trade_partition": "USDT"
        //        },
        //        ...
        //    ]
        //
        // coin-m future, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "FIL",
        //            "settlement_time": 1652342400000,
        //            "clawback_ratio": 0E-18,
        //            "list": [
        //                {
        //                    "contract_code": "FIL220513",
        //                    "settlement_price": 7.016000000000000000,
        //                    "settlement_type": "settlement"
        //                },
        //                ...
        //            ]
        //        },
        //    ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            object settlement = getValue(settlements, i);
            object list = this.safeValue(settlement, "list");
            if (isTrue(!isEqual(list, null)))
            {
                object timestamp = this.safeInteger(settlement, "settlement_time");
                object timestampDetails = new Dictionary<string, object>() {
                    { "timestamp", timestamp },
                    { "datetime", this.iso8601(timestamp) },
                };
                for (object j = 0; isLessThan(j, getArrayLength(list)); postFixIncrement(ref j))
                {
                    object item = getValue(list, j);
                    object parsedSettlement = this.parseSettlement(item, market);
                    ((List<object>)result).Add(this.extend(parsedSettlement, timestampDetails));
                }
            } else
            {
                ((List<object>)result).Add(this.parseSettlement(getValue(settlements, i), market));
            }
        }
        return result;
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    {
        //        "symbol": "ADA",
        //        "contract_code": "ADA-USDT",
        //        "settlement_time": 1652313600000,
        //        "clawback_ratio": 0E-18,
        //        "settlement_price": 0.512303000000000000,
        //        "settlement_type": "settlement",
        //        "business_type": "swap",
        //        "pair": "ADA-USDT",
        //        "trade_partition": "USDT"
        //    }
        //
        // coin-m future, fetchSettlementHistory
        //
        //    {
        //        "contract_code": "FIL220513",
        //        "settlement_price": 7.016000000000000000,
        //        "settlement_type": "settlement"
        //    }
        //
        object timestamp = this.safeInteger(settlement, "settlement_time");
        object marketId = this.safeString(settlement, "contract_code");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "settlement_price") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }
}
