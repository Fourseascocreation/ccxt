using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class digifinex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "digifinex" },
            { "name", "DigiFinex" },
            { "countries", new List<object>() {"SG"} },
            { "version", "v3" },
            { "rateLimit", 900 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "1h", "60" },
                { "4h", "240" },
                { "12h", "720" },
                { "1d", "1D" },
                { "1w", "1W" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://openapi.digifinex.com" },
                } },
                { "www", "https://www.digifinex.com" },
                { "doc", new List<object>() {"https://docs.digifinex.com"} },
                { "fees", "https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex" },
                { "referral", "https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new List<object>() {"{market}/symbols", "kline", "margin/currencies", "margin/symbols", "markets", "order_book", "ping", "spot/symbols", "time", "trades", "trades/symbols", "ticker", "currencies"} },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new List<object>() {"public/api_weight", "public/candles", "public/candles_history", "public/depth", "public/funding_rate", "public/funding_rate_history", "public/instrument", "public/instruments", "public/ticker", "public/tickers", "public/time", "public/trades"} },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new List<object>() {"{market}/financelog", "{market}/mytrades", "{market}/order", "{market}/order/detail", "{market}/order/current", "{market}/order/history", "margin/assets", "margin/financelog", "margin/mytrades", "margin/order", "margin/order/current", "margin/order/history", "margin/positions", "otc/financelog", "spot/assets", "spot/financelog", "spot/mytrades", "spot/order", "spot/order/current", "spot/order/history", "deposit/address", "deposit/history", "withdraw/history"} },
                        { "post", new List<object>() {"{market}/order/cancel", "{market}/order/new", "{market}/order/batch_new", "margin/order/cancel", "margin/order/new", "margin/position/close", "spot/order/cancel", "spot/order/new", "transfer", "withdraw/new", "withdraw/cancel"} },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new List<object>() {"account/balance", "account/positions", "account/finance_record", "account/trading_fee_rate", "account/transfer_record", "trade/history_orders", "trade/history_trades", "trade/open_orders", "trade/order_info"} },
                        { "post", new List<object>() {"account/leverage", "trade/batch_cancel_order", "trade/batch_order", "trade/cancel_order", "trade/order_place"} },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "10001", new List<object>() {typeof(BadRequest), "Wrong request method, please check it\'s a GET ot POST request"} },
                    { "10002", new List<object>() {typeof(AuthenticationError), "Invalid ApiKey"} },
                    { "10003", new List<object>() {typeof(AuthenticationError), "Sign doesn\'t match"} },
                    { "10004", new List<object>() {typeof(BadRequest), "Illegal request parameters"} },
                    { "10005", new List<object>() {typeof(DDoSProtection), "Request frequency exceeds the limit"} },
                    { "10006", new List<object>() {typeof(PermissionDenied), "Unauthorized to execute this request"} },
                    { "10007", new List<object>() {typeof(PermissionDenied), "IP address Unauthorized"} },
                    { "10008", new List<object>() {typeof(InvalidNonce), "Timestamp for this request is invalid, timestamp must within 1 minute"} },
                    { "10009", new List<object>() {typeof(NetworkError), "Unexist endpoint, please check endpoint URL"} },
                    { "10011", new List<object>() {typeof(AccountSuspended), "ApiKey expired. Please go to client side to re-create an ApiKey"} },
                    { "20001", new List<object>() {typeof(PermissionDenied), "Trade is not open for this trading pair"} },
                    { "20002", new List<object>() {typeof(PermissionDenied), "Trade of this trading pair is suspended"} },
                    { "20003", new List<object>() {typeof(InvalidOrder), "Invalid price or amount"} },
                    { "20007", new List<object>() {typeof(InvalidOrder), "Price precision error"} },
                    { "20008", new List<object>() {typeof(InvalidOrder), "Amount precision error"} },
                    { "20009", new List<object>() {typeof(InvalidOrder), "Amount is less than the minimum requirement"} },
                    { "20010", new List<object>() {typeof(InvalidOrder), "Cash Amount is less than the minimum requirement"} },
                    { "20011", new List<object>() {typeof(InsufficientFunds), "Insufficient balance"} },
                    { "20012", new List<object>() {typeof(BadRequest), "Invalid trade type, valid value: buy/sell)"} },
                    { "20013", new List<object>() {typeof(InvalidOrder), "No order info found"} },
                    { "20014", new List<object>() {typeof(BadRequest), "Invalid date, Valid format: 2018-07-25)"} },
                    { "20015", new List<object>() {typeof(BadRequest), "Date exceeds the limit"} },
                    { "20018", new List<object>() {typeof(PermissionDenied), "Your trading rights have been banned by the system"} },
                    { "20019", new List<object>() {typeof(BadSymbol), "Wrong trading pair symbol. Correct format:\"usdt_btc\". Quote asset is in the front"} },
                    { "20020", new List<object>() {typeof(DDoSProtection), "You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user\'s transaction rate and withdrawal rate."} },
                    { "50000", new List<object>() {typeof(ExchangeError), "Exception error"} },
                    { "20021", new List<object>() {typeof(BadRequest), "Invalid currency"} },
                    { "20022", new List<object>() {typeof(BadRequest), "The ending timestamp must be larger than the starting timestamp"} },
                    { "20023", new List<object>() {typeof(BadRequest), "Invalid transfer type"} },
                    { "20024", new List<object>() {typeof(BadRequest), "Invalid amount"} },
                    { "20025", new List<object>() {typeof(BadRequest), "This currency is not transferable at the moment"} },
                    { "20026", new List<object>() {typeof(InsufficientFunds), "Transfer amount exceed your balance"} },
                    { "20027", new List<object>() {typeof(PermissionDenied), "Abnormal account status"} },
                    { "20028", new List<object>() {typeof(PermissionDenied), "Blacklist for transfer"} },
                    { "20029", new List<object>() {typeof(PermissionDenied), "Transfer amount exceed your daily limit"} },
                    { "20030", new List<object>() {typeof(BadRequest), "You have no position on this trading pair"} },
                    { "20032", new List<object>() {typeof(PermissionDenied), "Withdrawal limited"} },
                    { "20033", new List<object>() {typeof(BadRequest), "Wrong Withdrawal ID"} },
                    { "20034", new List<object>() {typeof(PermissionDenied), "Withdrawal service of this crypto has been closed"} },
                    { "20035", new List<object>() {typeof(PermissionDenied), "Withdrawal limit"} },
                    { "20036", new List<object>() {typeof(ExchangeError), "Withdrawal cancellation failed"} },
                    { "20037", new List<object>() {typeof(InvalidAddress), "The withdrawal address, Tag or chain type is not included in the withdrawal management list"} },
                    { "20038", new List<object>() {typeof(InvalidAddress), "The withdrawal address is not on the white list"} },
                    { "20039", new List<object>() {typeof(ExchangeError), "Can\'t be canceled in current status"} },
                    { "20040", new List<object>() {typeof(RateLimitExceeded), "Withdraw too frequently; limitation: 3 times a minute, 100 times a day"} },
                    { "20041", new List<object>() {typeof(PermissionDenied), "Beyond the daily withdrawal limit"} },
                    { "20042", new List<object>() {typeof(BadSymbol), "Current trading pair does not support API trading"} },
                    { "400002", new List<object>() {typeof(BadRequest), "Invalid Parameter"} },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "types", new List<object>() {"spot", "margin", "otc"} },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "1" },
                    { "margin", "2" },
                    { "OTC", "3" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ARBITRUM", "Arbitrum" },
                    { "AVALANCEC", "AVAX-CCHAIN" },
                    { "AVALANCEX", "AVAX-XCHAIN" },
                    { "BEP20", "BEP20" },
                    { "BSC", "BEP20" },
                    { "CARDANO", "Cardano" },
                    { "CELO", "Celo" },
                    { "CHILIZ", "Chiliz" },
                    { "COSMOS", "COSMOS" },
                    { "CRC20", "Crypto.com" },
                    { "CRONOS", "Crypto.com" },
                    { "DOGECOIN", "DogeChain" },
                    { "ERC20", "ERC20" },
                    { "ETH", "ERC20" },
                    { "ETHW", "ETHW" },
                    { "IOTA", "MIOTA" },
                    { "KLAYTN", "KLAY" },
                    { "MATIC", "Polygon" },
                    { "METIS", "MetisDAO" },
                    { "MOONBEAM", "GLMR" },
                    { "MOONRIVER", "Moonriver" },
                    { "OPTIMISM", "OPETH" },
                    { "POLYGON", "Polygon" },
                    { "RIPPLE", "XRP" },
                    { "SOLANA", "SOL" },
                    { "STELLAR", "Stella" },
                    { "TERRACLASSIC", "TerraClassic" },
                    { "TERRA", "Terra" },
                    { "TON", "Ton" },
                    { "TRC20", "TRC20" },
                    { "TRON", "TRC20" },
                    { "TRX", "TRC20" },
                    { "VECHAIN", "Vechain" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "Arbitrum", "ARBITRUM" },
                    { "AVAX-CCHAIN", "AVALANCEC" },
                    { "AVAX-XCHAIN", "AVALANCEX" },
                    { "BEP20", "BEP20" },
                    { "Cardano", "CARDANO" },
                    { "Celo", "CELO" },
                    { "Chiliz", "CHILIZ" },
                    { "COSMOS", "COSMOS" },
                    { "Crypto.com", "CRC20" },
                    { "DogeChain", "DOGECOIN" },
                    { "ERC20", "ERC20" },
                    { "ETHW", "ETHW" },
                    { "MIOTA", "IOTA" },
                    { "KLAY", "KLAYTN" },
                    { "Polygon", "POLYGON" },
                    { "MetisDAO", "METIS" },
                    { "Moonriver", "MOONRIVER" },
                    { "GLMR", "MOONBEAM" },
                    { "OPETH", "OPTIMISM" },
                    { "XRP", "RIPPLE" },
                    { "SOL", "SOLANA" },
                    { "Stella", "STELLAR" },
                    { "Terra", "TERRA" },
                    { "TerraClassic", "TERRACLASSIC" },
                    { "Ton", "TON" },
                    { "TRC20", "TRC20" },
                    { "Vechain", "VECHAIN" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BHT", "Black House Test" },
                { "EPS", "Epanus" },
                { "FREE", "FreeRossDAO" },
                { "MBN", "Mobilian Coin" },
                { "TEL", "TEL666" },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetCurrencies(parameters);
        //
        //     {
        //         "data":[
        //             {
        //                 "deposit_status":1,
        //                 "min_deposit_amount":10,
        //                 "withdraw_fee_rate":0,
        //                 "min_withdraw_amount":10,
        //                 "min_withdraw_fee":5,
        //                 "currency":"USDT",
        //                 "withdraw_status":0,
        //                 "chain":"OMNI"
        //             },
        //             {
        //                 "deposit_status":1,
        //                 "min_deposit_amount":10,
        //                 "withdraw_fee_rate":0,
        //                 "min_withdraw_amount":10,
        //                 "min_withdraw_fee":3,
        //                 "currency":"USDT",
        //                 "withdraw_status":1,
        //                 "chain":"ERC20"
        //             },
        //             {
        //                 "deposit_status":0,
        //                 "min_deposit_amount":0,
        //                 "withdraw_fee_rate":0,
        //                 "min_withdraw_amount":0,
        //                 "min_withdraw_fee":0,
        //                 "currency":"DGF13",
        //                 "withdraw_status":0,
        //                 "chain":""
        //             },
        //         ],
        //         "code":200
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currency = getValue(data, i);
            object id = this.safeString(currency, "currency");
            object code = this.safeCurrencyCode(id);
            object depositStatus = this.safeInteger(currency, "deposit_status", 1);
            object withdrawStatus = this.safeInteger(currency, "withdraw_status", 1);
            object deposit = isGreaterThan(depositStatus, 0);
            object withdraw = isGreaterThan(withdrawStatus, 0);
            object active = isTrue(deposit) && isTrue(withdraw);
            object feeString = this.safeString(currency, "min_withdraw_fee"); // withdraw_fee_rate was zero for all currencies, so this was the worst case scenario
            object minWithdrawString = this.safeString(currency, "min_withdraw_amount");
            object minDepositString = this.safeString(currency, "min_deposit_amount");
            object minDeposit = this.parseNumber(minDepositString);
            object minWithdraw = this.parseNumber(minWithdrawString);
            object fee = this.parseNumber(feeString);
            // define precision with temporary way
            object minFoundPrecision = Precise.stringMin(feeString, Precise.stringMin(minDepositString, minWithdrawString));
            object precision = this.parseNumber(minFoundPrecision);
            object networkId = this.safeString(currency, "chain");
            object networkCode = this.networkIdToCode(networkId);
            object network = new Dictionary<string, object>() {
                { "info", currency },
                { "id", networkId },
                { "network", networkCode },
                { "active", active },
                { "fee", fee },
                { "precision", precision },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", minWithdraw },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", minDeposit },
                        { "max", null },
                    } },
                } },
            };
            if (isTrue(((Dictionary<string,object>)result).ContainsKey(toStringOrNull(code))))
            {
                if (isTrue((getValue(getValue(result, code), "info").GetType().IsGenericType && getValue(getValue(result, code), "info").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
                {
                    ((List<object>)getValue(getValue(result, code), "info")).Add(currency);
                } else
                {
                    ((Dictionary<string, object>)getValue(result, code))["info"] = new List<object>() {getValue(getValue(result, code), "info"), currency};
                }
                if (isTrue(withdraw))
                {
                    ((Dictionary<string, object>)getValue(result, code))["withdraw"] = true;
                    ((Dictionary<string, object>)getValue(getValue(getValue(result, code), "limits"), "withdraw"))["min"] = mathMin(getValue(getValue(getValue(getValue(result, code), "limits"), "withdraw"), "min"), minWithdraw);
                }
                if (isTrue(deposit))
                {
                    ((Dictionary<string, object>)getValue(result, code))["deposit"] = true;
                    ((Dictionary<string, object>)getValue(getValue(getValue(result, code), "limits"), "deposit"))["min"] = mathMin(getValue(getValue(getValue(getValue(result, code), "limits"), "deposit"), "min"), minDeposit);
                }
                if (isTrue(active))
                {
                    ((Dictionary<string, object>)getValue(result, code))["active"] = true;
                }
            } else
            {
                ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", id },
                    { "code", code },
                    { "info", currency },
                    { "type", null },
                    { "name", null },
                    { "active", active },
                    { "deposit", deposit },
                    { "withdraw", withdraw },
                    { "fee", this.parseNumber(feeString) },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minWithdraw },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", minDeposit },
                            { "max", null },
                        } },
                    } },
                    { "networks", new Dictionary<string, object>() {} },
                };
            }
            if (isTrue(!isEqual(networkId, null)))
            {
                ((Dictionary<string, object>)getValue(getValue(result, code), "networks"))[(string)networkId] = network;
            } else
            {
                ((Dictionary<string, object>)getValue(result, code))["active"] = active;
                ((Dictionary<string, object>)getValue(result, code))["fee"] = this.parseNumber(feeString);
                ((Dictionary<string, object>)getValue(result, code))["deposit"] = deposit;
                ((Dictionary<string, object>)getValue(result, code))["withdraw"] = withdraw;
                ((Dictionary<string, object>)getValue(result, code))["limits"] = new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", minWithdraw },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", minDeposit },
                        { "max", null },
                    } },
                };
            }
            ((Dictionary<string, object>)getValue(result, code))["precision"] = ((bool) isTrue((isEqual(getValue(getValue(result, code), "precision"), null)))) ? precision : mathMax(getValue(getValue(result, code), "precision"), precision);
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchMarkets
        * @description retrieves data on all markets for digifinex
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object method = this.safeString(options, "method", "fetch_markets_v2");
        return await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
    }

    public async virtual Task<object> fetchMarketsV2(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchMarketsV2", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object method = ((bool) isTrue((!isEqual(marginMode, null)))) ? "publicSpotGetMarginSymbols" : "publicSpotGetTradesSymbols";
        object promises = new List<object> {((Task<object>)callDynamically(this, method, new object[] { query })), this.publicSwapGetPublicInstruments(parameters)};
        promises = await promiseAll(promises);
        object spotMarkets = getValue(promises, 0);
        object swapMarkets = getValue(promises, 1);
        //
        // spot and margin
        //
        //     {
        //         "symbol_list":[
        //             {
        //                 "order_types":["LIMIT","MARKET"],
        //                 "quote_asset":"USDT",
        //                 "minimum_value":2,
        //                 "amount_precision":4,
        //                 "status":"TRADING",
        //                 "minimum_amount":0.0001,
        //                 "symbol":"BTC_USDT",
        //                 "is_allow":1,
        //                 "zone":"MAIN",
        //                 "base_asset":"BTC",
        //                 "price_precision":2
        //             }
        //         ],
        //         "code":0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "type": "REAL",
        //                 "contract_type": "PERPETUAL",
        //                 "base_currency": "BTC",
        //                 "quote_currency": "USDT",
        //                 "clear_currency": "USDT",
        //                 "contract_value": "0.001",
        //                 "contract_value_currency": "BTC",
        //                 "is_inverse": false,
        //                 "is_trading": true,
        //                 "status": "ONLINE",
        //                 "price_precision": 4,
        //                 "tick_size": "0.0001",
        //                 "min_order_amount": 1,
        //                 "open_max_limits": [
        //                     {
        //                         "leverage": "50",
        //                         "max_limit": "1000000"
        //                     }
        //                 ]
        //             },
        //         ]
        //     }
        //
        object spotData = this.safeValue(spotMarkets, "symbol_list", new List<object>() {});
        object swapData = this.safeValue(swapMarkets, "data", new List<object>() {});
        object response = this.arrayConcat(spotData, swapData);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object id = this.safeString2(market, "symbol", "instrument_id");
            object baseId = this.safeString2(market, "base_asset", "base_currency");
            object quoteId = this.safeString2(market, "quote_asset", "quote_currency");
            object settleId = this.safeString(market, "clear_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            //
            // The status is documented in the exchange API docs as follows:
            // TRADING, HALT (delisted), BREAK (trading paused)
            // https://docs.digifinex.vip/en-ww/v3/#/public/spot/symbols
            // However, all spot markets actually have status === 'HALT'
            // despite that they appear to be active on the exchange website.
            // Apparently, we can't trust this status.
            // const status = this.safeString (market, 'status');
            // const active = (status === 'TRADING');
            //
            object isAllowed = this.safeInteger(market, "is_allow", 1);
            object type = ((bool) isTrue((isEqual(defaultType, "margin")))) ? "margin" : "spot";
            object spot = isEqual(settle, null);
            object swap = !isTrue(spot);
            object margin = ((bool) isTrue((!isEqual(marginMode, null)))) ? true : null;
            object symbol = add(add(bs, "/"), quote);
            object isInverse = null;
            object isLinear = null;
            if (isTrue(swap))
            {
                type = "swap";
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
                isInverse = this.safeValue(market, "is_inverse");
                isLinear = ((bool) isTrue((!isTrue(isInverse)))) ? true : false;
                object isTrading = this.safeValue(market, "isTrading");
                if (isTrue(isTrading))
                {
                    isAllowed = 1;
                }
            }
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", margin },
                { "swap", swap },
                { "future", false },
                { "option", false },
                { "active", ((bool) isTrue(isAllowed)) ? true : false },
                { "contract", swap },
                { "linear", isLinear },
                { "inverse", isInverse },
                { "contractSize", this.safeNumber(market, "contract_value") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "amount_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber2(market, "minimum_amount", "min_order_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "tick_size") },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimum_value") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchMarketsV1(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetMarkets(parameters);
        //
        //     {
        //         "data": [
        //             {
        //                 "volume_precision":4,
        //                 "price_precision":2,
        //                 "market":"btc_usdt",
        //                 "min_amount":2,
        //                 "min_volume":0.0001
        //             },
        //         ],
        //         "date":1564507456,
        //         "code":0
        //     }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "market");
            var baseIdquoteIdVariable = ((string)id).Split((string)"_").ToList<object>();
            var baseId = ((List<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((List<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_precision"))) },
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "volume_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_volume") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_amount") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public virtual object parseBalance(object response)
    {
        //
        // spot and margin
        //
        //     {
        //         "currency": "BTC",
        //         "free": 4723846.89208129,
        //         "total": 0
        //     }
        //
        // swap
        //
        //     {
        //         "equity": "0",
        //         "currency": "BTC",
        //         "margin": "0",
        //         "frozen_margin": "0",
        //         "frozen_money": "0",
        //         "margin_ratio": "0",
        //         "realized_pnl": "0",
        //         "avail_balance": "0",
        //         "unrealized_pnl": "0",
        //         "time_stamp": 1661487402396
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object free = this.safeString2(balance, "free", "avail_balance");
            object total = this.safeString2(balance, "total", "equity");
            ((Dictionary<string, object>)account)["free"] = free;
            ((Dictionary<string, object>)account)["used"] = Precise.stringSub(total, free);
            ((Dictionary<string, object>)account)["total"] = total;
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#spot-account-assets
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-assets
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#accountbalance
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotAssets" },
            { "margin", "privateSpotGetMarginAssets" },
            { "swap", "privateSwapGetAccountBalance" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginAssets";
            marketType = "margin";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "list": [
        //             {
        //                 "currency": "BTC",
        //                 "free": 4723846.89208129,
        //                 "total": 0
        //             },
        //             ...
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "equity": "0",
        //                 "currency": "BTC",
        //                 "margin": "0",
        //                 "frozen_margin": "0",
        //                 "frozen_money": "0",
        //                 "margin_ratio": "0",
        //                 "realized_pnl": "0",
        //                 "avail_balance": "0",
        //                 "unrealized_pnl": "0",
        //                 "time_stamp": 1661487402396
        //             },
        //             ...
        //         ]
        //     }
        //
        object balanceRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "data" : "list";
        object balances = this.safeValue(response, balanceRequest, new List<object>() {});
        return this.parseBalance(balances);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-orderbook
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrderBook", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            method = "publicSwapGetPublicDepth";
            ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
        } else
        {
            method = "publicSpotGetOrderBook";
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot
        //
        //     {
        //         "bids": [
        //             [9605.77,0.0016],
        //             [9605.46,0.0003],
        //             [9602.04,0.0127],
        //         ],
        //         "asks": [
        //             [9627.22,0.025803],
        //             [9627.12,0.168543],
        //             [9626.52,0.0011529],
        //         ],
        //         "date":1564509499,
        //         "code":0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "timestamp": 1667975290425,
        //             "asks": [
        //                 ["18384.7",3492],
        //                 ["18402.7",5000],
        //                 ["18406.7",5000],
        //             ],
        //             "bids": [
        //                 ["18366.2",4395],
        //                 ["18364.3",3070],
        //                 ["18359.4",5000],
        //             ]
        //         }
        //     }
        //
        object timestamp = null;
        object orderBook = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            orderBook = this.safeValue(response, "data", new Dictionary<string, object>() {});
            timestamp = this.safeInteger(orderBook, "timestamp");
        } else
        {
            orderBook = response;
            timestamp = this.safeTimestamp(response, "date");
        }
        return this.parseOrderBook(orderBook, getValue(market, "symbol"), timestamp);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#ticker-price
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#tickers
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object method = "publicSpotGetTicker";
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(type, "swap")))
        {
            method = "publicSwapGetPublicTickers";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //    {
        //        "ticker": [{
        //            "vol": 40717.4461,
        //            "change": -1.91,
        //            "base_vol": 392447999.65374,
        //            "sell": 9592.23,
        //            "last": 9592.22,
        //            "symbol": "btc_usdt",
        //            "low": 9476.24,
        //            "buy": 9592.03,
        //            "high": 9793.87
        //        }],
        //        "date": 1589874294,
        //        "code": 0
        //    }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "SUSHIUSDTPERP",
        //                 "index_price": "1.1297",
        //                 "mark_price": "1.1289",
        //                 "max_buy_price": "1.1856",
        //                 "min_sell_price": "1.0726",
        //                 "best_bid": "1.1278",
        //                 "best_bid_size": "500",
        //                 "best_ask": "1.1302",
        //                 "best_ask_size": "471",
        //                 "high_24h": "1.2064",
        //                 "open_24h": "1.1938",
        //                 "low_24h": "1.1239",
        //                 "last": "1.1302",
        //                 "last_qty": "29",
        //                 "volume_24h": "4946163",
        //                 "price_change_percent": "-0.053275255486681085",
        //                 "open_interest": "-",
        //                 "timestamp": 1663222782100
        //             },
        //             ...
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object tickers = this.safeValue2(response, "ticker", "data", new List<object>() {});
        object date = this.safeInteger(response, "date");
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object rawTicker = this.extend(new Dictionary<string, object>() {
                { "date", date },
            }, getValue(tickers, i));
            object ticker = this.parseTicker(rawTicker);
            object symbol = getValue(ticker, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#ticker-price
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = "publicSpotGetTicker";
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "swap")))
        {
            method = "publicSwapGetPublicTicker";
            ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //    {
        //        "ticker": [{
        //            "vol": 40717.4461,
        //            "change": -1.91,
        //            "base_vol": 392447999.65374,
        //            "sell": 9592.23,
        //            "last": 9592.22,
        //            "symbol": "btc_usdt",
        //            "low": 9476.24,
        //            "buy": 9592.03,
        //            "high": 9793.87
        //        }],
        //        "date": 1589874294,
        //        "code": 0
        //    }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "index_price": "20141.9967",
        //             "mark_price": "20139.3404",
        //             "max_buy_price": "21146.4838",
        //             "min_sell_price": "19132.2725",
        //             "best_bid": "20140.0998",
        //             "best_bid_size": "3116",
        //             "best_ask": "20140.0999",
        //             "best_ask_size": "9004",
        //             "high_24h": "20410.6496",
        //             "open_24h": "20308.6998",
        //             "low_24h": "19600",
        //             "last": "20140.0999",
        //             "last_qty": "2",
        //             "volume_24h": "49382816",
        //             "price_change_percent": "-0.008301855936636448",
        //             "open_interest": "-",
        //             "timestamp": 1663221614998
        //         }
        //     }
        //
        object date = this.safeInteger(response, "date");
        object tickers = this.safeValue(response, "ticker", new List<object>() {});
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object firstTicker = this.safeValue(tickers, 0, new Dictionary<string, object>() {});
        object result = null;
        if (isTrue(getValue(market, "swap")))
        {
            result = data;
        } else
        {
            result = this.extend(new Dictionary<string, object>() {
                { "date", date },
            }, firstTicker);
        }
        return this.parseTicker(result, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot: fetchTicker, fetchTickers
        //
        //     {
        //         "last":0.021957,
        //         "symbol": "btc_usdt",
        //         "base_vol":2249.3521732227,
        //         "change":-0.6,
        //         "vol":102443.5111,
        //         "sell":0.021978,
        //         "low":0.021791,
        //         "buy":0.021946,
        //         "high":0.022266,
        //         "date"1564518452, // injected from fetchTicker/fetchTickers
        //     }
        //
        // swap: fetchTicker, fetchTickers
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "index_price": "20141.9967",
        //         "mark_price": "20139.3404",
        //         "max_buy_price": "21146.4838",
        //         "min_sell_price": "19132.2725",
        //         "best_bid": "20140.0998",
        //         "best_bid_size": "3116",
        //         "best_ask": "20140.0999",
        //         "best_ask_size": "9004",
        //         "high_24h": "20410.6496",
        //         "open_24h": "20308.6998",
        //         "low_24h": "19600",
        //         "last": "20140.0999",
        //         "last_qty": "2",
        //         "volume_24h": "49382816",
        //         "price_change_percent": "-0.008301855936636448",
        //         "open_interest": "-",
        //         "timestamp": 1663221614998
        //     }
        //
        object marketId = this.safeStringUpper2(ticker, "symbol", "instrument_id");
        object symbol = this.safeSymbol(marketId, market);
        market = this.safeMarket(marketId);
        object timestamp = this.safeTimestamp(ticker, "date");
        if (isTrue(getValue(market, "swap")))
        {
            timestamp = this.safeInteger(ticker, "timestamp");
        }
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString2(ticker, "high", "high_24h") },
            { "low", this.safeString2(ticker, "low", "low_24h") },
            { "bid", this.safeString2(ticker, "buy", "best_bid") },
            { "bidVolume", this.safeString(ticker, "best_bid_size") },
            { "ask", this.safeString2(ticker, "sell", "best_ask") },
            { "askVolume", this.safeString(ticker, "best_ask_size") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open_24h") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString2(ticker, "change", "price_change_percent") },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "vol", "volume_24h") },
            { "quoteVolume", this.safeString(ticker, "base_vol") },
            { "info", ticker },
        }, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot: fetchTrades
        //
        //     {
        //         "date":1564520003,
        //         "id":1596149203,
        //         "amount":0.7073,
        //         "type":"buy",
        //         "price":0.02193,
        //     }
        //
        // swap: fetchTrades
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "trade_id": "1595190773677035521",
        //         "direction": "4",
        //         "volume": "4",
        //         "price": "16188.3",
        //         "trade_time": 1669158092314
        //     }
        //
        // spot: fetchMyTrades
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "order_id": "6707cbdcda0edfaa7f4ab509e4cbf966",
        //         "id": 28457,
        //         "price": 0.1,
        //         "amount": 0,
        //         "fee": 0.096,
        //         "fee_currency": "USDT",
        //         "timestamp": 1499865549,
        //         "side": "buy", // or "side": "sell_market"
        //         "is_maker": true
        //     }
        //
        // swap: fetchMyTrades
        //
        //     {
        //         "trade_id": "1590136768424841218",
        //         "instrument_id": "BTCUSDTPERP",
        //         "order_id": "1590136768156405760",
        //         "type": 1,
        //         "order_type": 8,
        //         "price": "18514.5",
        //         "size": "1",
        //         "fee": "0.00925725",
        //         "close_profit": "0",
        //         "leverage": "20",
        //         "trade_type": 0,
        //         "match_role": 1,
        //         "trade_time": 1667953123562
        //     }
        //
        object id = this.safeString2(trade, "id", "trade_id");
        object orderId = this.safeString(trade, "order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeStringN(trade, new List<object>() {"amount", "volume", "size"});
        object marketId = this.safeStringUpper2(trade, "symbol", "instrument_id");
        object symbol = this.safeSymbol(marketId, market);
        if (isTrue(isEqual(market, null)))
        {
            market = this.safeMarket(marketId);
        }
        object timestamp = this.safeTimestamp2(trade, "date", "timestamp");
        object side = this.safeString2(trade, "type", "side");
        object type = null;
        object takerOrMaker = null;
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            timestamp = this.safeInteger(trade, "trade_time");
            object orderType = this.safeString(trade, "order_type");
            object tradeRole = this.safeString(trade, "match_role");
            object direction = this.safeString(trade, "direction");
            if (isTrue(!isEqual(orderType, null)))
            {
                type = ((bool) isTrue((isEqual(orderType, "0")))) ? "limit" : null;
            }
            if (isTrue(isEqual(tradeRole, "1")))
            {
                takerOrMaker = "taker";
            } else if (isTrue(isEqual(tradeRole, "2")))
            {
                takerOrMaker = "maker";
            } else
            {
                takerOrMaker = null;
            }
            if (isTrue(isTrue((isEqual(side, "1"))) || isTrue((isEqual(direction, "1")))))
            {
                // side = 'open long';
                side = "buy";
            } else if (isTrue(isTrue((isEqual(side, "2"))) || isTrue((isEqual(direction, "2")))))
            {
                // side = 'open short';
                side = "sell";
            } else if (isTrue(isTrue((isEqual(side, "3"))) || isTrue((isEqual(direction, "3")))))
            {
                // side = 'close long';
                side = "sell";
            } else if (isTrue(isTrue((isEqual(side, "4"))) || isTrue((isEqual(direction, "4")))))
            {
                // side = 'close short';
                side = "buy";
            }
        } else
        {
            object parts = ((string)side).Split((string)"_").ToList<object>();
            side = this.safeString(parts, 0);
            type = this.safeString(parts, 1);
            if (isTrue(isEqual(type, null)))
            {
                type = "limit";
            }
            object isMaker = this.safeValue(trade, "is_maker");
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_currency");
            object feeCurrencyCode = null;
            if (isTrue(!isEqual(feeCurrencyId, null)))
            {
                feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "order", orderId },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetTime(parameters);
        //
        //     {
        //         "server_time": 1589873762,
        //         "code": 0
        //     }
        //
        return this.safeTimestamp(response, "server_time");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetPing(parameters);
        //
        //     {
        //         "msg": "pong",
        //         "code": 0
        //     }
        //
        object code = this.safeInteger(response, "code");
        object status = ((bool) isTrue((isEqual(code, 0)))) ? "ok" : "maintenance";
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-recent-trades
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#recenttrades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = "publicSpotGetTrades";
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "swap")))
        {
            method = "publicSwapGetPublicTrades";
            ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "data":[
        //             {
        //                 "date":1564520003,
        //                 "id":1596149203,
        //                 "amount":0.7073,
        //                 "type":"buy",
        //                 "price":0.02193,
        //             },
        //             {
        //                 "date":1564520002,
        //                 "id":1596149165,
        //                 "amount":0.3232,
        //                 "type":"sell",
        //                 "price":0.021927,
        //             },
        //         ],
        //         "code": 0,
        //         "date": 1564520003,
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "trade_id": "1595190773677035521",
        //                 "direction": "4",
        //                 "volume": "4",
        //                 "price": "16188.3",
        //                 "trade_time": 1669158092314
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1556712900,
        //         2205.899,
        //         0.029967,
        //         0.02997,
        //         0.029871,
        //         0.029927
        //     ]
        //
        if (isTrue(getValue(market, "swap")))
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        } else
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 5), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 1)};
        }
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-candles-data
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#recentcandle
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = "publicSpotGetKline";
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "swap")))
        {
            method = "publicSwapGetPublicCandles";
            ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["granularity"] = timeframe;
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["limit"] = limit;
            }
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["period"] = this.safeString(this.timeframes, timeframe, timeframe);
            if (isTrue(!isEqual(since, null)))
            {
                object startTime = this.parseToInt(divide(since, 1000));
                ((Dictionary<string, object>)request)["start_time"] = startTime;
                if (isTrue(!isEqual(limit, null)))
                {
                    object duration = this.parseTimeframe(timeframe);
                    ((Dictionary<string, object>)request)["end_time"] = this.sum(startTime, multiply(limit, duration));
                }
            } else if (isTrue(!isEqual(limit, null)))
            {
                object endTime = this.seconds();
                object duration = this.parseTimeframe(timeframe);
                ((Dictionary<string, object>)request)["start_time"] = this.sum(endTime, multiply(prefixUnaryNeg(ref limit), duration));
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "data":[
        //             [1556712900,2205.899,0.029967,0.02997,0.029871,0.029927],
        //             [1556713800,1912.9174,0.029992,0.030014,0.029955,0.02996],
        //             [1556714700,1556.4795,0.029974,0.030019,0.029969,0.02999],
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "granularity": "1m",
        //             "candles": [
        //                 [1588089660000,"6900","6900","6900","6900","0","0"],
        //                 [1588089720000,"6900","6900","6900","6900","0","0"],
        //                 [1588089780000,"6900","6900","6900","6900","0","0"],
        //             ]
        //         }
        //     }
        //
        object candles = null;
        if (isTrue(getValue(market, "swap")))
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            candles = this.safeValue(data, "candles", new List<object>() {});
        } else
        {
            candles = this.safeValue(response, "data", new List<object>() {});
        }
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#createOrder
        * @description create a trade order
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#create-new-order
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderplace
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @param {string} params.timeInForce "GTC", "IOC", "FOK", or "PO"
        * @param {bool} params.postOnly true or false
        * @param {bool} params.reduceOnly true or false
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketType = null;
        object marginMode = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostSpotOrderNew" },
            { "margin", "privateSpotPostMarginOrderNew" },
            { "swap", "privateSwapPostTradeOrderPlace" },
        });
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotPostMarginOrderNew";
            marketType = "margin";
        }
        object request = new Dictionary<string, object>() {};
        object swap = (isEqual(marketType, "swap"));
        object isMarketOrder = (isEqual(type, "market"));
        object isLimitOrder = (isEqual(type, "limit"));
        object marketIdRequest = ((bool) isTrue(swap)) ? "instrument_id" : "symbol";
        ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        object postOnly = this.isPostOnly(isMarketOrder, false, parameters);
        object postOnlyParsed = null;
        if (isTrue(swap))
        {
            object reduceOnly = this.safeValue(parameters, "reduceOnly", false);
            object timeInForce = this.safeString(parameters, "timeInForce");
            object orderType = null;
            if (isTrue(isEqual(side, "buy")))
            {
                object requestType = ((bool) isTrue((reduceOnly))) ? 4 : 1;
                ((Dictionary<string, object>)request)["type"] = requestType;
            } else
            {
                object requestType = ((bool) isTrue((reduceOnly))) ? 3 : 2;
                ((Dictionary<string, object>)request)["type"] = requestType;
            }
            if (isTrue(isLimitOrder))
            {
                orderType = 0;
            }
            if (isTrue(isEqual(timeInForce, "FOK")))
            {
                orderType = ((bool) isTrue(isMarketOrder)) ? 15 : 9;
            } else if (isTrue(isEqual(timeInForce, "IOC")))
            {
                orderType = ((bool) isTrue(isMarketOrder)) ? 13 : 4;
            } else if (isTrue(isTrue((isEqual(timeInForce, "GTC"))) || isTrue((isMarketOrder))))
            {
                orderType = 14;
            } else if (isTrue(isEqual(timeInForce, "PO")))
            {
                postOnly = true;
            }
            if (isTrue(!isEqual(price, null)))
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((Dictionary<string, object>)request)["order_type"] = orderType;
            ((Dictionary<string, object>)request)["size"] = amount; // swap orders require the amount to be the number of contracts
            parameters = this.omit(parameters, new List<object>() {"reduceOnly", "timeInForce"});
        } else
        {
            postOnlyParsed = ((bool) isTrue((isEqual(postOnly, true)))) ? 1 : 2;
            ((Dictionary<string, object>)request)["market"] = marketType;
            object suffix = "";
            if (isTrue(isEqual(type, "market")))
            {
                suffix = "_market";
            } else
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((Dictionary<string, object>)request)["type"] = add(side, suffix);
            // limit orders require the amount in the base currency, market orders require the amount in the quote currency
            ((Dictionary<string, object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(postOnly))
        {
            if (isTrue(postOnlyParsed))
            {
                ((Dictionary<string, object>)request)["postOnly"] = postOnlyParsed;
            } else
            {
                ((Dictionary<string, object>)request)["postOnly"] = postOnly;
            }
        }
        object query = this.omit(parameters, new List<object>() {"postOnly", "post_only"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": "1590873693003714560"
        //     }
        //
        object result = this.parseOrder(response, market);
        return this.extend(result, new Dictionary<string, object>() {
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "amount", amount },
            { "price", price },
        });
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#cancelOrder
        * @description cancels an open order
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#cancel-order
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#cancelorder
        * @param {string} id order id
        * @param {string|undefined} symbol not used by digifinex cancelOrder ()
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostSpotOrderCancel" },
            { "margin", "privateSpotPostMarginOrderCancel" },
            { "swap", "privateSwapPostTradeCancelOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotPostMarginOrderCancel";
            marketType = "margin";
        }
        id = ((object)id).ToString();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            this.checkRequiredSymbol("cancelOrder", symbol);
            ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "success": [
        //             "198361cecdc65f9c8c9bb2fa68faec40",
        //             "3fb0d98e51c18954f10d439a9cf57de0"
        //         ],
        //         "error": [
        //             "78a7104e3c65cc0c5a212a53e76d0205"
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": "1590923061186531328"
        //     }
        //
        if (isTrue(isTrue((isEqual(marketType, "spot"))) || isTrue((isEqual(marketType, "margin")))))
        {
            object canceledOrders = this.safeValue(response, "success", new List<object>() {});
            object numCanceledOrders = getArrayLength(canceledOrders);
            if (isTrue(!isEqual(numCanceledOrders, 1)))
            {
                throw new OrderNotFound ((string)add(add(add(this.id, " cancelOrder() "), id), " not found")) ;
            }
        }
        return response;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids order ids
        * @param {string|undefined} symbol not used by digifinex cancelOrders ()
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        object orderType = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, "type");
        object request = new Dictionary<string, object>() {
            { "market", orderType },
            { "order_id", String.Join(",", ((List<object>)ids).ToArray()) },
        };
        object response = await this.privateSpotPostSpotOrderCancel(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "success": [
        //             "198361cecdc65f9c8c9bb2fa68faec40",
        //             "3fb0d98e51c18954f10d439a9cf57de0"
        //         ],
        //         "error": [
        //             "78a7104e3c65cc0c5a212a53e76d0205"
        //         ]
        //     }
        //
        object canceledOrders = this.safeValue(response, "success", new List<object>() {});
        object numCanceledOrders = getArrayLength(canceledOrders);
        if (isTrue(isLessThan(numCanceledOrders, 1)))
        {
            throw new OrderNotFound ((string)add(this.id, " cancelOrders() error")) ;
        }
        return response;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "open" },
            { "1", "open" },
            { "2", "closed" },
            { "3", "canceled" },
            { "4", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot: createOrder
        //
        //     {
        //         "code": 0,
        //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
        //     }
        //
        // swap: createOrder
        //
        //     {
        //         "code": 0,
        //         "data": "1590873693003714560"
        //     }
        //
        // spot: fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
        //         "created_date": 1562303547,
        //         "finished_date": 0,
        //         "price": 0.1,
        //         "amount": 1,
        //         "cash_amount": 1,
        //         "executed_amount": 0,
        //         "avg_price": 0,
        //         "status": 1,
        //         "type": "buy",
        //         "kind": "margin"
        //     }
        //
        // swap: fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "order_id": "1590898207657824256",
        //         "instrument_id": "BTCUSDTPERP",
        //         "margin_mode": "crossed",
        //         "contract_val": "0.001",
        //         "type": 1,
        //         "order_type": 0,
        //         "price": "14000",
        //         "size": "6",
        //         "filled_qty": "0",
        //         "price_avg": "0",
        //         "fee": "0",
        //         "state": 0,
        //         "leverage": "20",
        //         "turnover": "0",
        //         "has_stop": 0,
        //         "insert_time": 1668134664828,
        //         "time_stamp": 1668134664828
        //     }
        //
        object timestamp = null;
        object lastTradeTimestamp = null;
        object timeInForce = null;
        object type = null;
        object side = this.safeString(order, "type");
        object marketId = this.safeString2(order, "symbol", "instrument_id");
        object symbol = this.safeSymbol(marketId, market, "_");
        market = this.market(symbol);
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            object orderType = this.safeInteger(order, "order_type");
            if (isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(orderType, 9))) || isTrue((isEqual(orderType, 10)))) || isTrue((isEqual(orderType, 11)))) || isTrue((isEqual(orderType, 12)))) || isTrue((isEqual(orderType, 15)))))
            {
                timeInForce = "FOK";
            } else if (isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(orderType, 1))) || isTrue((isEqual(orderType, 2)))) || isTrue((isEqual(orderType, 3)))) || isTrue((isEqual(orderType, 4)))) || isTrue((isEqual(orderType, 13)))))
            {
                timeInForce = "IOC";
            } else if (isTrue(isTrue(isTrue(isTrue((isEqual(orderType, 6))) || isTrue((isEqual(orderType, 7)))) || isTrue((isEqual(orderType, 8)))) || isTrue((isEqual(orderType, 14)))))
            {
                timeInForce = "GTC";
            }
            if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(orderType, 0))) || isTrue((isEqual(orderType, 1)))) || isTrue((isEqual(orderType, 4)))) || isTrue((isEqual(orderType, 5)))) || isTrue((isEqual(orderType, 9)))) || isTrue((isEqual(orderType, 10)))))
            {
                type = "limit";
            } else
            {
                type = "market";
            }
            if (isTrue(isEqual(side, "1")))
            {
                side = "open long";
            } else if (isTrue(isEqual(side, "2")))
            {
                side = "open short";
            } else if (isTrue(isEqual(side, "3")))
            {
                side = "close long";
            } else if (isTrue(isEqual(side, "4")))
            {
                side = "close short";
            }
            timestamp = this.safeInteger(order, "insert_time");
            lastTradeTimestamp = this.safeInteger(order, "time_stamp");
        } else
        {
            timestamp = this.safeTimestamp(order, "created_date");
            lastTradeTimestamp = this.safeTimestamp(order, "finished_date");
            if (isTrue(!isEqual(side, null)))
            {
                object parts = ((string)side).Split((string)"_").ToList<object>();
                object numParts = getArrayLength(parts);
                if (isTrue(isGreaterThan(numParts, 1)))
                {
                    side = getValue(parts, 0);
                    type = getValue(parts, 1);
                } else
                {
                    type = "limit";
                }
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "order_id", "data") },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "side", side },
            { "price", this.safeNumber(order, "price") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", this.safeNumber2(order, "amount", "size") },
            { "filled", this.safeNumber2(order, "executed_amount", "filled_qty") },
            { "remaining", null },
            { "cost", null },
            { "average", this.safeNumber2(order, "avg_price", "price_avg") },
            { "status", this.parseOrderStatus(this.safeString2(order, "status", "state")) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#current-active-orders
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#openorder
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotOrderCurrent" },
            { "margin", "privateSpotGetMarginOrderCurrent" },
            { "swap", "privateSwapGetTradeOpenOrders" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginOrderCurrent";
            marketType = "margin";
        }
        object request = new Dictionary<string, object>() {};
        object swap = (isEqual(marketType, "swap"));
        if (isTrue(swap))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_timestamp"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["limit"] = limit;
            }
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
        }
        if (isTrue(!isEqual(market, null)))
        {
            object marketIdRequest = ((bool) isTrue(swap)) ? "instrument_id" : "symbol";
            ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
        //                 "created_date": 1562303547,
        //                 "finished_date": 0,
        //                 "price": 0.1,
        //                 "amount": 1,
        //                 "cash_amount": 1,
        //                 "executed_amount": 0,
        //                 "avg_price": 0,
        //                 "status": 1,
        //                 "type": "buy",
        //                 "kind": "margin"
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "order_id": "1590898207657824256",
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "margin_mode": "crossed",
        //                 "contract_val": "0.001",
        //                 "type": 1,
        //                 "order_type": 0,
        //                 "price": "14000",
        //                 "size": "6",
        //                 "filled_qty": "0",
        //                 "price_avg": "0",
        //                 "fee": "0",
        //                 "state": 0,
        //                 "leverage": "20",
        //                 "turnover": "0",
        //                 "has_stop": 0,
        //                 "insert_time": 1668134664828,
        //                 "time_stamp": 1668134664828
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-all-orders-including-history-orders
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#historyorder
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotOrderHistory" },
            { "margin", "privateSpotGetMarginOrderHistory" },
            { "swap", "privateSwapGetTradeHistoryOrders" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginOrderHistory";
            marketType = "margin";
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_timestamp"] = since;
            }
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_time"] = this.parseToInt(divide(since, 1000)); // default 3 days from now, max 30 days
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            object marketIdRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "instrument_id" : "symbol";
            ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
        //                 "created_date": 1562303547,
        //                 "finished_date": 0,
        //                 "price": 0.1,
        //                 "amount": 1,
        //                 "cash_amount": 1,
        //                 "executed_amount": 0,
        //                 "avg_price": 0,
        //                 "status": 1,
        //                 "type": "buy",
        //                 "kind": "margin"
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "order_id": "1590136768156405760",
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "margin_mode": "crossed",
        //                 "contract_val": "0.001",
        //                 "type": 1,
        //                 "order_type": 8,
        //                 "price": "18660.2",
        //                 "size": "1",
        //                 "filled_qty": "1",
        //                 "price_avg": "18514.5",
        //                 "fee": "0.00925725",
        //                 "state": 2,
        //                 "leverage": "20",
        //                 "turnover": "18.5145",
        //                 "has_stop": 0,
        //                 "insert_time": 1667953123526,
        //                 "time_stamp": 1667953123596
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-order-status
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderinfo
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotOrder" },
            { "margin", "privateSpotGetMarginOrder" },
            { "swap", "privateSwapGetTradeOrderInfo" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginOrder";
            marketType = "margin";
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(market, null)))
            {
                ((Dictionary<string, object>)request)["instrument_id"] = getValue(market, "id");
            }
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
        //                 "created_date": 1562303547,
        //                 "finished_date": 0,
        //                 "price": 0.1,
        //                 "amount": 1,
        //                 "cash_amount": 1,
        //                 "executed_amount": 0,
        //                 "avg_price": 0,
        //                 "status": 1,
        //                 "type": "buy",
        //                 "kind": "margin"
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "order_id": "1590923061186531328",
        //             "instrument_id": "ETHUSDTPERP",
        //             "margin_mode": "crossed",
        //             "contract_val": "0.01",
        //             "type": 1,
        //             "order_type": 0,
        //             "price": "900",
        //             "size": "6",
        //             "filled_qty": "0",
        //             "price_avg": "0",
        //             "fee": "0",
        //             "state": 0,
        //             "leverage": "20",
        //             "turnover": "0",
        //             "has_stop": 0,
        //             "insert_time": 1668140590372,
        //             "time_stamp": 1668140590372
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        object order = ((bool) isTrue((isEqual(marketType, "swap")))) ? data : this.safeValue(data, 0);
        if (isTrue(isEqual(order, null)))
        {
            throw new OrderNotFound ((string)add(add(add(this.id, " fetchOrder() order "), ((object)id).ToString()), " not found")) ;
        }
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#customer-39-s-trades
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#historytrade
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotMytrades" },
            { "margin", "privateSpotGetMarginMytrades" },
            { "swap", "privateSwapGetTradeHistoryTrades" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginMytrades";
            marketType = "margin";
        }
        if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_timestamp"] = since;
            }
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_time"] = this.parseToInt(divide(since, 1000)); // default 3 days from now, max 30 days
            }
        }
        object marketIdRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "instrument_id" : "symbol";
        if (isTrue(!isEqual(symbol, null)))
        {
            ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //      {
        //          "list":[
        //              {
        //                  "timestamp":1639506068,
        //                  "is_maker":false,
        //                  "id":"8975951332",
        //                  "amount":31.83,
        //                  "side":"sell_market",
        //                  "symbol":"DOGE_USDT",
        //                  "fee_currency":"USDT",
        //                  "fee":0.01163774826
        //                  ,"order_id":"32b169792f4a7a19e5907dc29fc123d4",
        //                  "price":0.182811
        //                }
        //             ],
        //           "code": 0
        //      }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "trade_id": "1590136768424841218",
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "order_id": "1590136768156405760",
        //                 "type": 1,
        //                 "order_type": 8,
        //                 "price": "18514.5",
        //                 "size": "1",
        //                 "fee": "0.00925725",
        //                 "close_profit": "0",
        //                 "leverage": "20",
        //                 "trade_type": 0,
        //                 "match_role": 1,
        //                 "trade_time": 1667953123562
        //             },
        //             ...
        //         ]
        //     }
        //
        object responseRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "data" : "list";
        object data = this.safeValue(response, responseRequest, new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {};
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // spot and margin
        //
        //     {
        //         "currency_mark": "BTC",
        //         "type": 100234,
        //         "num": -10,
        //         "balance": 0.1,
        //         "time": 1546272000
        //     }
        //
        // swap
        //
        //     {
        //         "currency": "USDT",
        //         "finance_type": 17,
        //         "change": "-3.01",
        //         "timestamp": 1650809432000
        //     }
        //
        object type = this.parseLedgerEntryType(this.safeString2(item, "type", "finance_type"));
        object code = this.safeCurrencyCode(this.safeString2(item, "currency_mark", "currency"), currency);
        object amount = this.safeNumber2(item, "num", "change");
        object after = this.safeNumber(item, "balance");
        object timestamp = this.safeTimestamp(item, "time");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(item, "timestamp");
        }
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", null },
            { "direction", null },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", null },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#spot-margin-otc-financial-logs
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#bills
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetSpotFinancelog" },
            { "margin", "privateSpotGetMarginFinancelog" },
            { "swap", "privateSwapGetAccountFinanceRecord" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchLedger", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateSpotGetMarginFinancelog";
            marketType = "margin";
        }
        if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_timestamp"] = since;
            }
        } else
        {
            ((Dictionary<string, object>)request)["market"] = marketType;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_time"] = this.parseToInt(divide(since, 1000)); // default 3 days from now, max 30 days
            }
        }
        object currencyIdRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "currency" : "currency_mark";
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)[(string)currencyIdRequest] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "total": 521,
        //             "finance": [
        //                 {
        //                     "currency_mark": "BTC",
        //                     "type": 100234,
        //                     "num": 28457,
        //                     "balance": 0.1,
        //                     "time": 1546272000
        //                 }
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "currency": "USDT",
        //                 "finance_type": 17,
        //                 "change": "3.01",
        //                 "timestamp": 1650809432000
        //             },
        //         ]
        //     }
        //
        object ledger = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            ledger = this.safeValue(response, "data", new List<object>() {});
        } else
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            ledger = this.safeValue(data, "finance", new List<object>() {});
        }
        return this.parseLedger(ledger, currency, since, limit);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "addressTag":"",
        //         "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
        //         "currency":"USDT",
        //         "chain":"ERC20"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "addressTag");
        object currencyId = this.safeStringUpper(depositAddress, "currency");
        object code = this.safeCurrencyCode(currencyId);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateSpotGetDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "data":[
        //             {
        //                 "addressTag":"",
        //                 "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
        //                 "currency":"USDT",
        //                 "chain":"ERC20"
        //             }
        //         ],
        //         "code":200
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object addresses = this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")});
        object address = this.safeValue(addresses, code);
        if (isTrue(isEqual(address, null)))
        {
            throw new InvalidAddress ((string)add(add(add(this.id, " fetchDepositAddress() did not return an address for "), code), " - create the deposit address in the user settings on the exchange website first.")) ;
        }
        return address;
    }

    public async virtual Task<object> fetchTransactionsByType(object type, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = mathMin(500, limit);
        }
        object method = ((bool) isTrue((isEqual(type, "deposit")))) ? "privateSpotGetDepositHistory" : "privateSpotGetWithdrawHistory";
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "code": 200,
        //         "data": [
        //             {
        //                 "id": 1171,
        //                 "currency": "xrp",
        //                 "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
        //                 "chain": "",
        //                 "amount": 7.457467,
        //                 "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
        //                 "memo": "100040",
        //                 "fee": 0,
        //                 "state": "safe",
        //                 "created_date": "2020-04-20 11:23:00",
        //                 "finished_date": "2020-04-20 13:23:00"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, new Dictionary<string, object>() {
            { "type", type },
        });
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("deposit", code, since, limit, parameters);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("withdrawal", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        // deposit state includes: 1 (in deposit), 2 (to be confirmed), 3 (successfully deposited), 4 (stopped)
        // withdrawal state includes: 1 (application in progress), 2 (to be confirmed), 3 (completed), 4 (rejected)
        object statuses = new Dictionary<string, object>() {
            { "1", "pending" },
            { "2", "pending" },
            { "3", "ok" },
            { "4", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "code": 200,
        //         "withdraw_id": 700
        //     }
        //
        // fetchDeposits, fetchWithdrawals
        //
        //     {
        //         "id": 1171,
        //         "currency": "xrp",
        //         "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
        //         "chain": "",
        //         "amount": 7.457467,
        //         "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
        //         "memo": "100040",
        //         "fee": 0,
        //         "state": "safe",
        //         "created_date": "2020-04-20 11:23:00",
        //         "finished_date": "2020-04-20 13:23:00"
        //     }
        //
        object id = this.safeString2(transaction, "id", "withdraw_id");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "memo");
        object txid = this.safeString(transaction, "hash");
        object currencyId = this.safeStringUpper(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.parse8601(this.safeString(transaction, "created_date"));
        object updated = this.parse8601(this.safeString(transaction, "finished_date"));
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object amount = this.safeNumber(transaction, "amount");
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            };
        }
        object network = this.safeString(transaction, "chain");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "type", null },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", fee },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "code": 0
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "transfer_id": 130524,
        //         "type": 1,
        //         "currency": "USDT",
        //         "amount": "24",
        //         "timestamp": 1666505659000
        //     }
        //
        object fromAccount = null;
        object toAccount = null;
        object type = this.safeInteger(transfer, "type");
        if (isTrue(isEqual(type, 1)))
        {
            fromAccount = "spot";
            toAccount = "swap";
        } else if (isTrue(isEqual(type, 2)))
        {
            fromAccount = "swap";
            toAccount = "spot";
        }
        object timestamp = this.safeInteger(transfer, "timestamp");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "transfer_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(this.safeString(transfer, "currency"), currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(this.safeString(transfer, "code")) },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "currency_mark", getValue(currency, "id") },
            { "num", this.currencyToPrecision(code, amount) },
            { "from", fromId },
            { "to", toId },
        };
        object response = await this.privateSpotPostTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 0
        //     }
        //
        return this.parseTransfer(response, currency);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "amount", this.currencyToPrecision(code, amount) },
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["memo"] = tag;
        }
        object response = await this.privateSpotPostWithdrawNew(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "withdraw_id": 700
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateSpotGetMarginPositions(this.extend(request, parameters));
        //
        //     {
        //         "margin": "45.71246418952618",
        //         "code": 0,
        //         "margin_rate": "7.141978570340037",
        //         "positions": [
        //             {
        //                 "amount": 0.0006103,
        //                 "side": "go_long",
        //                 "entry_price": 31428.72,
        //                 "liquidation_rate": 0.3,
        //                 "liquidation_price": 10225.335481159,
        //                 "unrealized_roe": -0.0076885829266987,
        //                 "symbol": "BTC_USDT",
        //                 "unrealized_pnl": -0.049158102631999,
        //                 "leverage_ratio": 3
        //             }
        //         ],
        //         "unrealized_pnl": "-0.049158102631998504"
        //     }
        //
        object rows = this.safeValue(response, "positions");
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "amount": 0.0006103,
        //         "side": "go_long",
        //         "entry_price": 31428.72,
        //         "liquidation_rate": 0.3,
        //         "liquidation_price": 10225.335481159,
        //         "unrealized_roe": -0.0076885829266987,
        //         "symbol": "BTC_USDT",
        //         "unrealized_pnl": -0.049158102631999,
        //         "leverage_ratio": 3
        //     }
        //
        object symbol = this.safeString(info, "symbol");
        object amountString = this.safeString(info, "amount");
        object leverageString = this.safeString(info, "leverage_ratio");
        object amountInvested = Precise.stringDiv(amountString, leverageString);
        object amountBorrowed = Precise.stringSub(amountString, amountInvested);
        object currency = ((bool) isTrue((isEqual(market, null)))) ? null : getValue(market, "base");
        return new Dictionary<string, object>() {
            { "account", this.safeSymbol(symbol, market) },
            { "currency", currency },
            { "interest", null },
            { "interestRate", 0.001 },
            { "amountBorrowed", this.parseNumber(amountBorrowed) },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.privateSpotGetMarginAssets(this.extend(request, parameters));
        //
        //     {
        //         "list": [
        //             {
        //                 "valuation_rate": 1,
        //                 "total": 1.92012186174,
        //                 "free": 1.92012186174,
        //                 "currency": "USDT"
        //             },
        //         ],
        //         "total": 45.133305540922,
        //         "code": 0,
        //         "unrealized_pnl": 0,
        //         "free": 45.133305540922,
        //         "equity": 45.133305540922
        //     }
        //
        object data = this.safeValue(response, "list", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            if (isTrue(isEqual(this.safeString(entry, "currency"), code)))
            {
                result = entry;
            }
        }
        object currency = this.safeString(result, "currency");
        return this.parseBorrowRate(result, currency);
    }

    public async override Task<object> fetchBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateSpotGetMarginAssets(parameters);
        //
        //     {
        //         "list": [
        //             {
        //                 "valuation_rate": 1,
        //                 "total": 1.92012186174,
        //                 "free": 1.92012186174,
        //                 "currency": "USDT"
        //             },
        //         ],
        //         "total": 45.133305540922,
        //         "code": 0,
        //         "unrealized_pnl": 0,
        //         "free": 45.133305540922,
        //         "equity": 45.133305540922
        //     }
        //
        object result = this.safeValue(response, "list");
        return this.parseBorrowRates(result, "currency");
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "valuation_rate": 1,
        //         "total": 1.92012186174,
        //         "free": 1.92012186174,
        //         "currency": "USDT"
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", 0.001 },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public virtual object parseBorrowRates(object info, object codeKey)
    {
        //
        //     {
        //         "valuation_rate": 1,
        //         "total": 1.92012186174,
        //         "free": 1.92012186174,
        //         "currency": "USDT"
        //     },
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object item = getValue(info, i);
            object currency = this.safeString(item, codeKey);
            object code = this.safeCurrencyCode(currency);
            object borrowRate = this.parseBorrowRate(item, currency);
            ((Dictionary<string, object>)result)[(string)code] = borrowRate;
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#currentfundingrate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_id", getValue(market, "id") },
        };
        object response = await this.publicSwapGetPublicFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "funding_rate": "-0.00012",
        //             "funding_time": 1662710400000,
        //             "next_funding_rate": "0.0001049907085171607",
        //             "next_funding_time": 1662739200000
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "funding_rate": "-0.00012",
        //         "funding_time": 1662710400000,
        //         "next_funding_rate": "0.0001049907085171607",
        //         "next_funding_time": 1662739200000
        //     }
        //
        object marketId = this.safeString(contract, "instrument_id");
        object timestamp = this.safeInteger(contract, "funding_time");
        object nextTimestamp = this.safeInteger(contract, "next_funding_time");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeString(contract, "funding_rate") },
            { "fundingTimestamp", timestamp },
            { "fundingDatetime", this.iso8601(timestamp) },
            { "nextFundingRate", this.safeString(contract, "next_funding_rate") },
            { "nextFundingTimestamp", nextTimestamp },
            { "nextFundingDatetime", this.iso8601(nextTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchFundingRateHistory", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_timestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicSwapGetPublicFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "funding_rates": [
        //                 {
        //                     "rate": "-0.00375",
        //                     "time": 1607673600000
        //                 },
        //                 ...
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.safeValue(data, "funding_rates", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(data, "instrument_id");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "time");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeString(entry, "rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#tradingfee
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchTradingFee() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_id", getValue(market, "id") },
        };
        object response = await this.privateSwapGetAccountTradingFeeRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "taker_fee_rate": "0.0005",
        //             "maker_fee_rate": "0.0003"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "taker_fee_rate": "0.0005",
        //         "maker_fee_rate": "0.0003"
        //     }
        //
        object marketId = this.safeString(fee, "instrument_id");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
        };
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchPositions
        * @description fetch all open positions
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-positions
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object market = null;
        object marketType = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = null;
            if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                object symbolsLength = getArrayLength(symbols);
                if (isTrue(isGreaterThan(symbolsLength, 1)))
                {
                    throw new BadRequest ((string)add(this.id, " fetchPositions() symbols argument cannot contain more than 1 symbol")) ;
                }
                symbol = getValue(symbols, 0);
            } else
            {
                symbol = symbols;
            }
            market = this.market(symbol);
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchPositions", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            marketType = "margin";
        }
        if (isTrue(!isEqual(market, null)))
        {
            object marketIdRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "instrument_id" : "symbol";
            ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        }
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetMarginPositions" },
            { "margin", "privateSpotGetMarginPositions" },
            { "swap", "privateSwapGetAccountPositions" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "margin_mode": "crossed",
        //                 "avail_position": "1",
        //                 "avg_cost": "18369.3",
        //                 "last": "18404.7",
        //                 "leverage": "20",
        //                 "liquidation_price": "451.12820512820264",
        //                 "maint_margin_ratio": "0.005",
        //                 "margin": "0.918465",
        //                 "position": "1",
        //                 "realized_pnl": "0",
        //                 "unrealized_pnl": "0.03410000000000224",
        //                 "unrealized_pnl_rate": "0.03712716325608732",
        //                 "side": "long",
        //                 "open_outstanding": "0",
        //                 "risk_score": "0.495049504950495",
        //                 "margin_ratio": "0.4029464788983229",
        //                 "timestamp": 1667960497145
        //             },
        //             ...
        //         ]
        //     }
        //
        // margin
        //
        //     {
        //         "margin": "77.71534772983289",
        //         "code": 0,
        //         "margin_rate": "10.284503769497306",
        //         "positions": [
        //             {
        //                 "amount": 0.0010605,
        //                 "side": "go_long",
        //                 "entry_price": 18321.39,
        //                 "liquidation_rate": 0.3,
        //                 "liquidation_price": -52754.371758471,
        //                 "unrealized_roe": -0.002784390267332,
        //                 "symbol": "BTC_USDT",
        //                 "unrealized_pnl": -0.010820048189999,
        //                 "leverage_ratio": 5
        //             },
        //             ...
        //         ],
        //         "unrealized_pnl": "-0.10681600018999979"
        //     }
        //
        object positionRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "data" : "positions";
        object positions = this.safeValue(response, positionRequest, new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parsePosition(getValue(positions, i), market));
        }
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchPosition
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-positions
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positions
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPosition", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchPosition", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            marketType = "margin";
        }
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetMarginPositions" },
            { "margin", "privateSpotGetMarginPositions" },
            { "swap", "privateSwapGetAccountPositions" },
        });
        object marketIdRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "instrument_id" : "symbol";
        ((Dictionary<string, object>)request)[(string)marketIdRequest] = getValue(market, "id");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "margin_mode": "crossed",
        //                 "avail_position": "1",
        //                 "avg_cost": "18369.3",
        //                 "last": "18388.9",
        //                 "leverage": "20",
        //                 "liquidation_price": "383.38712921065553",
        //                 "maint_margin_ratio": "0.005",
        //                 "margin": "0.918465",
        //                 "position": "1",
        //                 "realized_pnl": "0",
        //                 "unrealized_pnl": "0.021100000000004115",
        //                 "unrealized_pnl_rate": "0.02297311274790451",
        //                 "side": "long",
        //                 "open_outstanding": "0",
        //                 "risk_score": "0.4901960784313725",
        //                 "margin_ratio": "0.40486964045976204",
        //                 "timestamp": 1667960241758
        //             }
        //         ]
        //     }
        //
        // margin
        //
        //     {
        //         "margin": "77.71534772983289",
        //         "code": 0,
        //         "margin_rate": "10.284503769497306",
        //         "positions": [
        //             {
        //                 "amount": 0.0010605,
        //                 "side": "go_long",
        //                 "entry_price": 18321.39,
        //                 "liquidation_rate": 0.3,
        //                 "liquidation_price": -52754.371758471,
        //                 "unrealized_roe": -0.002784390267332,
        //                 "symbol": "BTC_USDT",
        //                 "unrealized_pnl": -0.010820048189999,
        //                 "leverage_ratio": 5
        //             }
        //         ],
        //         "unrealized_pnl": "-0.10681600018999979"
        //     }
        //
        object dataRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "data" : "positions";
        object data = this.safeValue(response, dataRequest, new List<object>() {});
        object position = this.parsePosition(getValue(data, 0), market);
        if (isTrue(isEqual(marketType, "swap")))
        {
            return position;
        } else
        {
            return this.extend(position, new Dictionary<string, object>() {
                { "collateral", this.safeNumber(response, "margin") },
                { "marginRatio", this.safeNumber(response, "margin_rate") },
            });
        }
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // swap
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "margin_mode": "crossed",
        //         "avail_position": "1",
        //         "avg_cost": "18369.3",
        //         "last": "18388.9",
        //         "leverage": "20",
        //         "liquidation_price": "383.38712921065553",
        //         "maint_margin_ratio": "0.005",
        //         "margin": "0.918465",
        //         "position": "1",
        //         "realized_pnl": "0",
        //         "unrealized_pnl": "0.021100000000004115",
        //         "unrealized_pnl_rate": "0.02297311274790451",
        //         "side": "long",
        //         "open_outstanding": "0",
        //         "risk_score": "0.4901960784313725",
        //         "margin_ratio": "0.40486964045976204",
        //         "timestamp": 1667960241758
        //     }
        //
        // margin
        //
        //     {
        //         "amount": 0.0010605,
        //         "side": "go_long",
        //         "entry_price": 18321.39,
        //         "liquidation_rate": 0.3,
        //         "liquidation_price": -52754.371758471,
        //         "unrealized_roe": -0.002784390267332,
        //         "symbol": "BTC_USDT",
        //         "unrealized_pnl": -0.010820048189999,
        //         "leverage_ratio": 5
        //     }
        //
        object marketId = this.safeString2(position, "instrument_id", "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object marginMode = this.safeString(position, "margin_mode");
        if (isTrue(!isEqual(marginMode, null)))
        {
            marginMode = ((bool) isTrue((isEqual(marginMode, "crossed")))) ? "cross" : "isolated";
        } else
        {
            marginMode = "crossed";
        }
        object timestamp = this.safeInteger(position, "timestamp");
        object side = this.safeString(position, "side");
        if (isTrue(isEqual(side, "go_long")))
        {
            side = "long";
        } else if (isTrue(isEqual(side, "go_short")))
        {
            side = "short";
        }
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", this.safeNumber(position, "amount") },
            { "marginMode", marginMode },
            { "liquidationPrice", this.safeNumber(position, "liquidation_price") },
            { "entryPrice", this.safeNumber2(position, "avg_cost", "entry_price") },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_pnl") },
            { "contracts", this.safeNumber(position, "avail_position") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", this.safeNumber(position, "last") },
            { "side", side },
            { "hedged", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "maintenanceMargin", this.safeNumber(position, "margin") },
            { "maintenanceMarginPercentage", this.safeNumber(position, "maint_margin_ratio") },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber2(position, "leverage", "leverage_ratio") },
            { "marginRatio", this.safeNumber(position, "margin_ratio") },
            { "percentage", null },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#setLeverage
        * @description set the level of leverage for a market
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#setleverage
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @param {string|undefined} params.marginMode either 'cross' or 'isolated', default is cross
        * @param {string|undefined} params.side either 'long' or 'short', required for isolated markets only
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbol("setLeverage", symbol);
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 100")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_id", getValue(market, "id") },
            { "leverage", leverage },
        };
        object defaultMarginMode = this.safeString2(this.options, "marginMode", "defaultMarginMode");
        object marginMode = this.safeStringLower2(parameters, "marginMode", "defaultMarginMode", defaultMarginMode);
        if (isTrue(!isEqual(marginMode, null)))
        {
            marginMode = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "crossed" : "isolated";
            ((Dictionary<string, object>)request)["margin_mode"] = marginMode;
            parameters = this.omit(parameters, new List<object>() {"marginMode", "defaultMarginMode"});
        }
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            object side = this.safeString(parameters, "side");
            if (isTrue(!isEqual(side, null)))
            {
                ((Dictionary<string, object>)request)["side"] = side;
                parameters = this.omit(parameters, "side");
            } else
            {
                this.checkRequiredArgument("setLeverage", side, "side", new List<object>() {"long", "short"});
            }
        }
        return await this.privateSwapPostAccountLeverage(this.extend(request, parameters));
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchTransfers
        * @description fetch the transfer history, only transfers between spot and swap accounts are supported
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#transferrecord
        * @param {string|undefined} code unified currency code of the currency transferred
        * @param {int|undefined} since the earliest time in ms to fetch transfers for
        * @param {int|undefined} limit the maximum number of  transfers to retrieve
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {[object]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.safeCurrencyCode(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_timestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20 max 100
        }
        object response = await this.privateSwapGetAccountTransferRecord(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "transfer_id": 130524,
        //                 "type": 1,
        //                 "currency": "USDT",
        //                 "amount": "24",
        //                 "timestamp": 1666505659000
        //             },
        //             ...
        //         ]
        //     }
        //
        object transfers = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchLeverageTiers
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#instruments
        * @description retrieve information on the maximum leverage, for different trade sizes
        * @param {[string]|undefined} symbols a list of unified market symbols
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSwapGetPublicInstruments(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "instrument_id": "BTCUSDTPERP",
        //                 "type": "REAL",
        //                 "contract_type": "PERPETUAL",
        //                 "base_currency": "BTC",
        //                 "quote_currency": "USDT",
        //                 "clear_currency": "USDT",
        //                 "contract_value": "0.001",
        //                 "contract_value_currency": "BTC",
        //                 "is_inverse": false,
        //                 "is_trading": true,
        //                 "status": "ONLINE",
        //                 "price_precision": 1,
        //                 "tick_size": "0.1",
        //                 "min_order_amount": 1,
        //                 "open_max_limits": [
        //                     {
        //                         "leverage": "50",
        //                         "max_limit": "1000000"
        //                     },
        //                 ]
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        symbols = this.marketSymbols(symbols);
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        //
        //     [
        //         {
        //             "instrument_id": "BTCUSDTPERP",
        //             "type": "REAL",
        //             "contract_type": "PERPETUAL",
        //             "base_currency": "BTC",
        //             "quote_currency": "USDT",
        //             "clear_currency": "USDT",
        //             "contract_value": "0.001",
        //             "contract_value_currency": "BTC",
        //             "is_inverse": false,
        //             "is_trading": true,
        //             "status": "ONLINE",
        //             "price_precision": 1,
        //             "tick_size": "0.1",
        //             "min_order_amount": 1,
        //             "open_max_limits": [
        //                 {
        //                     "leverage": "50",
        //                     "max_limit": "1000000"
        //                 }
        //             ]
        //         },
        //     ]
        //
        object tiers = new Dictionary<string, object>() {};
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object marketId = this.safeString(entry, "instrument_id");
            object market = this.safeMarket(marketId);
            object symbol = this.safeSymbol(marketId, market);
            object symbolsLength = 0;
            ((Dictionary<string, object>)tiers)[(string)symbol] = this.parseMarketLeverageTiers(getValue(response, i), market);
            if (isTrue(!isEqual(symbols, null)))
            {
                symbolsLength = getArrayLength(symbols);
                if (isTrue(this.inArray(symbol, symbols)))
                {
                    ((Dictionary<string, object>)result)[(string)symbol] = this.parseMarketLeverageTiers(getValue(response, i), market);
                }
            }
            if (isTrue(isTrue(!isEqual(symbol, null)) && isTrue((isTrue(isEqual(symbolsLength, 0)) || isTrue(this.inArray(symbols, symbol))))))
            {
                ((Dictionary<string, object>)result)[(string)symbol] = this.parseMarketLeverageTiers(getValue(response, i), market);
            }
        }
        return result;
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchMarketLeverageTiers
        * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#instrument
        * @description retrieve information on the maximum leverage, for different trade sizes for a single market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchMarketLeverageTiers() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_id", getValue(market, "id") },
        };
        object response = await this.publicSwapGetPublicInstrument(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "instrument_id": "BTCUSDTPERP",
        //             "type": "REAL",
        //             "contract_type": "PERPETUAL",
        //             "base_currency": "BTC",
        //             "quote_currency": "USDT",
        //             "clear_currency": "USDT",
        //             "contract_value": "0.001",
        //             "contract_value_currency": "BTC",
        //             "is_inverse": false,
        //             "is_trading": true,
        //             "status": "ONLINE",
        //             "price_precision": 1,
        //             "tick_size": "0.1",
        //             "min_order_amount": 1,
        //             "open_max_limits": [
        //                 {
        //                     "leverage": "50",
        //                     "max_limit": "1000000"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarketLeverageTiers(data, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     {
        //         "instrument_id": "BTCUSDTPERP",
        //         "type": "REAL",
        //         "contract_type": "PERPETUAL",
        //         "base_currency": "BTC",
        //         "quote_currency": "USDT",
        //         "clear_currency": "USDT",
        //         "contract_value": "0.001",
        //         "contract_value_currency": "BTC",
        //         "is_inverse": false,
        //         "is_trading": true,
        //         "status": "ONLINE",
        //         "price_precision": 1,
        //         "tick_size": "0.1",
        //         "min_order_amount": 1,
        //         "open_max_limits": [
        //             {
        //                 "leverage": "50",
        //                 "max_limit": "1000000"
        //             }
        //         ]
        //     }
        //
        object tiers = new List<object>() {};
        object brackets = this.safeValue(info, "open_max_limits", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(brackets)); postFixIncrement(ref i))
        {
            object tier = getValue(brackets, i);
            object marketId = this.safeString(info, "instrument_id");
            market = this.safeMarket(marketId);
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "settle") },
                { "minNotional", null },
                { "maxNotional", this.safeNumber(tier, "max_limit") },
                { "maintenanceMarginRate", null },
                { "maxLeverage", this.safeNumber(tier, "leverage") },
                { "info", tier },
            });
        }
        return tiers;
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[string|undefined, object]} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeValue(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(!isEqual(marginMode, "cross")))
            {
                throw new NotSupported ((string)add(this.id, " only cross margin is supported")) ;
            }
        } else
        {
            if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
            {
                marginMode = "cross";
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name digifinex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-currency-deposit-and-withdrawal-information
        * @param {[string]|undefined} codes not used by fetchDepositWithdrawFees ()
        * @param {object} params extra parameters specific to the digifinex api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetCurrencies(parameters);
        //
        //   {
        //       "data": [
        //           {
        //               "deposit_status": 0,
        //               "min_withdraw_fee": 5,
        //               "withdraw_fee_currency": "USDT",
        //               "chain": "OMNI",
        //               "withdraw_fee_rate": 0,
        //               "min_withdraw_amount": 10,
        //               "currency": "USDT",
        //               "withdraw_status": 0,
        //               "min_deposit_amount": 10
        //           },
        //           {
        //               "deposit_status": 1,
        //               "min_withdraw_fee": 5,
        //               "withdraw_fee_currency": "USDT",
        //               "chain": "ERC20",
        //               "withdraw_fee_rate": 0,
        //               "min_withdraw_amount": 10,
        //               "currency": "USDT",
        //               "withdraw_status": 1,
        //               "min_deposit_amount": 10
        //           },
        //       ],
        //       "code": 200,
        //   }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(data, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        //
        //     [
        //         {
        //             "deposit_status": 0,
        //             "min_withdraw_fee": 5,
        //             "withdraw_fee_currency": "USDT",
        //             "chain": "OMNI",
        //             "withdraw_fee_rate": 0,
        //             "min_withdraw_amount": 10,
        //             "currency": "USDT",
        //             "withdraw_status": 0,
        //             "min_deposit_amount": 10
        //         },
        //         {
        //             "deposit_status": 1,
        //             "min_withdraw_fee": 5,
        //             "withdraw_fee_currency": "USDT",
        //             "chain": "ERC20",
        //             "withdraw_fee_rate": 0,
        //             "min_withdraw_amount": 10,
        //             "currency": "USDT",
        //             "withdraw_status": 1,
        //             "min_deposit_amount": 10
        //         },
        //     ]
        //
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                    ((Dictionary<string, object>)getValue(depositWithdrawFees, code))["info"] = new List<object>() {};
                }
                ((List<object>)getValue(getValue(depositWithdrawFees, code), "info")).Add(entry);
                object networkId = this.safeString(entry, "chain");
                object withdrawFee = this.safeValue(entry, "min_withdraw_fee");
                object withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                };
                object depositResult = new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                };
                if (isTrue(!isEqual(networkId, null)))
                {
                    object networkCode = this.networkIdToCode(networkId);
                    ((Dictionary<string, object>)getValue(getValue(depositWithdrawFees, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                        { "withdraw", withdrawResult },
                        { "deposit", depositResult },
                    };
                } else
                {
                    ((Dictionary<string, object>)getValue(depositWithdrawFees, code))["withdraw"] = withdrawResult;
                    ((Dictionary<string, object>)getValue(depositWithdrawFees, code))["deposit"] = depositResult;
                }
            }
        }
        object depositWithdrawCodes = new List<object>(((Dictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawCodes)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawCodes, i);
            object currency = this.currency(code);
            ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.assignDefaultDepositWithdrawFees(getValue(depositWithdrawFees, code), currency);
        }
        return depositWithdrawFees;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object pathPart = ((bool) isTrue((isEqual(endpoint, "spot")))) ? "/v3" : "/swap/v2";
        object request = add("/", this.implodeParams(path, parameters));
        object payload = add(pathPart, request);
        object url = add(getValue(getValue(this.urls, "api"), "rest"), payload);
        object query = this.omit(parameters, this.extractParams(path));
        object urlencoded = this.urlencode(this.keysort(query));
        if (isTrue(signed))
        {
            object auth = null;
            object nonce = null;
            if (isTrue(isEqual(pathPart, "/swap/v2")))
            {
                nonce = ((object)this.milliseconds()).ToString();
                auth = add(add(nonce, method), payload);
                if (isTrue(isEqual(method, "GET")))
                {
                    if (isTrue(urlencoded))
                    {
                        auth = add(auth, add("?", urlencoded));
                    }
                } else if (isTrue(isEqual(method, "POST")))
                {
                    object swapPostParams = json(parameters);
                    urlencoded = swapPostParams;
                    auth = add(auth, swapPostParams);
                }
            } else
            {
                nonce = ((object)this.nonce()).ToString();
                auth = urlencoded;
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(urlencoded))
                {
                    url = add(url, add("?", urlencoded));
                }
            } else if (isTrue(isEqual(method, "POST")))
            {
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/x-www-form-urlencoded" },
                };
                if (isTrue(urlencoded))
                {
                    body = urlencoded;
                }
            }
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-SIGN", signature },
                { "ACCESS-TIMESTAMP", nonce },
            };
        } else
        {
            if (isTrue(urlencoded))
            {
                url = add(url, add("?", urlencoded));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object statusCode, object statusText, object url, object method, object responseHeaders, object responseBody, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fall back to default error handler
        }
        object code = this.safeString(response, "code");
        if (isTrue(isTrue((isEqual(code, "0"))) || isTrue((isEqual(code, "200")))))
        {
            return null;  // no error
        }
        object feedback = add(add(this.id, " "), responseBody);
        if (isTrue(isEqual(code, null)))
        {
            throw new BadResponse ((string)feedback) ;
        }
        object unknownError = new List<object>() {typeof(ExchangeError), feedback};
        var ExceptionClassmessageVariable = this.safeValue(getValue(this.exceptions, "exact"), code, unknownError);
        var ExceptionClass = ((List<object>) ExceptionClassmessageVariable)[0];
        var message = ((List<object>) ExceptionClassmessageVariable)[1];
        throwDynamicException((string)ExceptionClass, message);return null;
    }
}
