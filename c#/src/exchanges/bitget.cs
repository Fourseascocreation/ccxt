using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bitget : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitget" },
            { "name", "Bitget" },
            { "countries", new List<object>() {"SG"} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", true },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "hostname", "bitget.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api.{hostname}" },
                    { "mix", "https://api.{hostname}" },
                } },
                { "www", "https://www.bitget.com" },
                { "doc", new List<object>() {"https://bitgetlimited.github.io/apidoc/en/mix", "https://bitgetlimited.github.io/apidoc/en/spot", "https://bitgetlimited.github.io/apidoc/en/broker"} },
                { "fees", "https://www.bitget.cc/zh-CN/rate?tab=1" },
                { "referral", "https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "public/time", 1 },
                            { "public/currencies", 1 },
                            { "public/products", 1 },
                            { "public/product", 1 },
                            { "market/ticker", 1 },
                            { "market/tickers", 1 },
                            { "market/fills", 1 },
                            { "market/candles", 1 },
                            { "market/depth", 1 },
                            { "market/spot-vip-level", 2 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "market/contracts", 1 },
                            { "market/depth", 1 },
                            { "market/ticker", 1 },
                            { "market/tickers", 1 },
                            { "market/fills", 1 },
                            { "market/candles", 1 },
                            { "market/index", 1 },
                            { "market/funding-time", 1 },
                            { "market/history-fundRate", 1 },
                            { "market/current-fundRate", 1 },
                            { "market/open-interest", 1 },
                            { "market/mark-price", 1 },
                            { "market/symbol-leverage", 1 },
                            { "market/contract-vip-level", 2 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/getInfo", 20 },
                            { "account/assets", 2 },
                            { "account/transferRecords", 4 },
                            { "wallet/deposit-address", 4 },
                            { "wallet/withdrawal-inner", 4 },
                            { "wallet/withdrawal-list", 1 },
                            { "wallet/deposit-list", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "account/bills", 2 },
                            { "account/sub-account-spot-assets", 200 },
                            { "trade/orders", 2 },
                            { "trade/batch-orders", 4 },
                            { "trade/cancel-order", 2 },
                            { "trade/cancel-batch-orders", 4 },
                            { "trade/orderInfo", 1 },
                            { "trade/open-orders", 1 },
                            { "trade/history", 1 },
                            { "trade/fills", 1 },
                            { "wallet/transfer", 4 },
                            { "wallet/withdrawal", 4 },
                            { "wallet/subTransfer", 10 },
                            { "plan/placePlan", 1 },
                            { "plan/modifyPlan", 1 },
                            { "plan/cancelPlan", 1 },
                            { "plan/currentPlan", 1 },
                            { "plan/historyPlan", 1 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/account", 2 },
                            { "account/accounts", 2 },
                            { "account/accountBill", 2 },
                            { "account/accountBusinessBill", 4 },
                            { "account/open-count", 1 },
                            { "order/current", 2 },
                            { "order/history", 2 },
                            { "order/detail", 2 },
                            { "order/fills", 2 },
                            { "order/historyProductType", 8 },
                            { "order/allFills", 2 },
                            { "plan/currentPlan", 2 },
                            { "plan/historyPlan", 2 },
                            { "position/singlePosition", 2 },
                            { "position/allPosition", 2 },
                            { "trace/currentTrack", 2 },
                            { "trace/followerOrder", 2 },
                            { "trace/historyTrack", 2 },
                            { "trace/summary", 2 },
                            { "trace/profitSettleTokenIdGroup", 2 },
                            { "trace/profitDateGroupList", 2 },
                            { "trade/profitDateList", 2 },
                            { "trace/waitProfitDateList", 2 },
                            { "trace/traderSymbols", 2 },
                            { "order/marginCoinCurrent", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "account/setLeverage", 8 },
                            { "account/setMargin", 8 },
                            { "account/setMarginMode", 8 },
                            { "account/setPositionMode", 8 },
                            { "order/placeOrder", 2 },
                            { "order/batch-orders", 2 },
                            { "order/cancel-order", 2 },
                            { "order/cancel-all-orders", 2 },
                            { "order/cancel-batch-orders", 2 },
                            { "plan/placePlan", 2 },
                            { "plan/modifyPlan", 2 },
                            { "plan/modifyPlanPreset", 2 },
                            { "plan/placeTPSL", 2 },
                            { "plan/placeTrailStop", 2 },
                            { "plan/placePositionsTPSL", 2 },
                            { "plan/modifyTPSLPlan", 2 },
                            { "plan/cancelPlan", 2 },
                            { "plan/cancelAllPlan", 2 },
                            { "trace/closeTrackOrder", 2 },
                            { "trace/setUpCopySymbols", 2 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0006") },
                    { "maker", this.parseNumber("0.0004") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "failure to get a peer from the ring-balancer", typeof(ExchangeNotAvailable) },
                    { "4010", typeof(PermissionDenied) },
                    { "4001", typeof(ExchangeError) },
                    { "4002", typeof(ExchangeError) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AuthenticationError) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(InvalidNonce) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(BadRequest) },
                    { "30008", typeof(RequestTimeout) },
                    { "30009", typeof(ExchangeError) },
                    { "30010", typeof(AuthenticationError) },
                    { "30011", typeof(PermissionDenied) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(AuthenticationError) },
                    { "30014", typeof(DDoSProtection) },
                    { "30015", typeof(AuthenticationError) },
                    { "30016", typeof(ExchangeError) },
                    { "30017", typeof(ExchangeError) },
                    { "30018", typeof(ExchangeError) },
                    { "30019", typeof(ExchangeNotAvailable) },
                    { "30020", typeof(BadRequest) },
                    { "30021", typeof(BadRequest) },
                    { "30022", typeof(PermissionDenied) },
                    { "30023", typeof(BadRequest) },
                    { "30024", typeof(BadSymbol) },
                    { "30025", typeof(BadRequest) },
                    { "30026", typeof(DDoSProtection) },
                    { "30027", typeof(AuthenticationError) },
                    { "30028", typeof(PermissionDenied) },
                    { "30029", typeof(AccountSuspended) },
                    { "30030", typeof(ExchangeError) },
                    { "30031", typeof(BadRequest) },
                    { "30032", typeof(BadSymbol) },
                    { "30033", typeof(BadRequest) },
                    { "30034", typeof(ExchangeError) },
                    { "30035", typeof(ExchangeError) },
                    { "30036", typeof(ExchangeError) },
                    { "30037", typeof(ExchangeNotAvailable) },
                    { "30038", typeof(OnMaintenance) },
                    { "32001", typeof(AccountSuspended) },
                    { "32002", typeof(PermissionDenied) },
                    { "32003", typeof(CancelPending) },
                    { "32004", typeof(ExchangeError) },
                    { "32005", typeof(InvalidOrder) },
                    { "32006", typeof(InvalidOrder) },
                    { "32007", typeof(InvalidOrder) },
                    { "32008", typeof(InvalidOrder) },
                    { "32009", typeof(InvalidOrder) },
                    { "32010", typeof(ExchangeError) },
                    { "32011", typeof(ExchangeError) },
                    { "32012", typeof(ExchangeError) },
                    { "32013", typeof(ExchangeError) },
                    { "32014", typeof(ExchangeError) },
                    { "32015", typeof(ExchangeError) },
                    { "32016", typeof(ExchangeError) },
                    { "32017", typeof(ExchangeError) },
                    { "32018", typeof(ExchangeError) },
                    { "32019", typeof(ExchangeError) },
                    { "32020", typeof(ExchangeError) },
                    { "32021", typeof(ExchangeError) },
                    { "32022", typeof(ExchangeError) },
                    { "32023", typeof(ExchangeError) },
                    { "32024", typeof(ExchangeError) },
                    { "32025", typeof(ExchangeError) },
                    { "32026", typeof(ExchangeError) },
                    { "32027", typeof(ExchangeError) },
                    { "32028", typeof(AccountSuspended) },
                    { "32029", typeof(ExchangeError) },
                    { "32030", typeof(InvalidOrder) },
                    { "32031", typeof(ArgumentsRequired) },
                    { "32038", typeof(AuthenticationError) },
                    { "32040", typeof(ExchangeError) },
                    { "32044", typeof(ExchangeError) },
                    { "32045", typeof(ExchangeError) },
                    { "32046", typeof(ExchangeError) },
                    { "32047", typeof(ExchangeError) },
                    { "32048", typeof(InvalidOrder) },
                    { "32049", typeof(ExchangeError) },
                    { "32050", typeof(InvalidOrder) },
                    { "32051", typeof(InvalidOrder) },
                    { "32052", typeof(ExchangeError) },
                    { "32053", typeof(ExchangeError) },
                    { "32057", typeof(ExchangeError) },
                    { "32054", typeof(ExchangeError) },
                    { "32055", typeof(InvalidOrder) },
                    { "32056", typeof(ExchangeError) },
                    { "32058", typeof(ExchangeError) },
                    { "32059", typeof(InvalidOrder) },
                    { "32060", typeof(InvalidOrder) },
                    { "32061", typeof(InvalidOrder) },
                    { "32062", typeof(InvalidOrder) },
                    { "32063", typeof(InvalidOrder) },
                    { "32064", typeof(ExchangeError) },
                    { "32065", typeof(ExchangeError) },
                    { "32066", typeof(ExchangeError) },
                    { "32067", typeof(ExchangeError) },
                    { "32068", typeof(ExchangeError) },
                    { "32069", typeof(ExchangeError) },
                    { "32070", typeof(ExchangeError) },
                    { "32071", typeof(ExchangeError) },
                    { "32072", typeof(ExchangeError) },
                    { "32073", typeof(ExchangeError) },
                    { "32074", typeof(ExchangeError) },
                    { "32075", typeof(ExchangeError) },
                    { "32076", typeof(ExchangeError) },
                    { "32077", typeof(ExchangeError) },
                    { "32078", typeof(ExchangeError) },
                    { "32079", typeof(ExchangeError) },
                    { "32080", typeof(ExchangeError) },
                    { "32083", typeof(ExchangeError) },
                    { "33001", typeof(PermissionDenied) },
                    { "33002", typeof(AccountSuspended) },
                    { "33003", typeof(InsufficientFunds) },
                    { "33004", typeof(ExchangeError) },
                    { "33005", typeof(ExchangeError) },
                    { "33006", typeof(ExchangeError) },
                    { "33007", typeof(ExchangeError) },
                    { "33008", typeof(InsufficientFunds) },
                    { "33009", typeof(ExchangeError) },
                    { "33010", typeof(ExchangeError) },
                    { "33011", typeof(ExchangeError) },
                    { "33012", typeof(ExchangeError) },
                    { "33013", typeof(InvalidOrder) },
                    { "33014", typeof(OrderNotFound) },
                    { "33015", typeof(InvalidOrder) },
                    { "33016", typeof(ExchangeError) },
                    { "33017", typeof(InsufficientFunds) },
                    { "33018", typeof(ExchangeError) },
                    { "33020", typeof(ExchangeError) },
                    { "33021", typeof(BadRequest) },
                    { "33022", typeof(InvalidOrder) },
                    { "33023", typeof(ExchangeError) },
                    { "33024", typeof(InvalidOrder) },
                    { "33025", typeof(InvalidOrder) },
                    { "33026", typeof(ExchangeError) },
                    { "33027", typeof(InvalidOrder) },
                    { "33028", typeof(InvalidOrder) },
                    { "33029", typeof(InvalidOrder) },
                    { "33034", typeof(ExchangeError) },
                    { "33035", typeof(ExchangeError) },
                    { "33036", typeof(ExchangeError) },
                    { "33037", typeof(ExchangeError) },
                    { "33038", typeof(ExchangeError) },
                    { "33039", typeof(ExchangeError) },
                    { "33040", typeof(ExchangeError) },
                    { "33041", typeof(ExchangeError) },
                    { "33042", typeof(ExchangeError) },
                    { "33043", typeof(ExchangeError) },
                    { "33044", typeof(ExchangeError) },
                    { "33045", typeof(ExchangeError) },
                    { "33046", typeof(ExchangeError) },
                    { "33047", typeof(ExchangeError) },
                    { "33048", typeof(ExchangeError) },
                    { "33049", typeof(ExchangeError) },
                    { "33050", typeof(ExchangeError) },
                    { "33051", typeof(ExchangeError) },
                    { "33059", typeof(BadRequest) },
                    { "33060", typeof(BadRequest) },
                    { "33061", typeof(ExchangeError) },
                    { "33062", typeof(ExchangeError) },
                    { "33063", typeof(ExchangeError) },
                    { "33064", typeof(ExchangeError) },
                    { "33065", typeof(ExchangeError) },
                    { "21009", typeof(ExchangeError) },
                    { "34001", typeof(PermissionDenied) },
                    { "34002", typeof(InvalidAddress) },
                    { "34003", typeof(ExchangeError) },
                    { "34004", typeof(ExchangeError) },
                    { "34005", typeof(ExchangeError) },
                    { "34006", typeof(ExchangeError) },
                    { "34007", typeof(ExchangeError) },
                    { "34008", typeof(InsufficientFunds) },
                    { "34009", typeof(ExchangeError) },
                    { "34010", typeof(ExchangeError) },
                    { "34011", typeof(ExchangeError) },
                    { "34012", typeof(ExchangeError) },
                    { "34013", typeof(ExchangeError) },
                    { "34014", typeof(ExchangeError) },
                    { "34015", typeof(ExchangeError) },
                    { "34016", typeof(PermissionDenied) },
                    { "34017", typeof(AccountSuspended) },
                    { "34018", typeof(AuthenticationError) },
                    { "34019", typeof(PermissionDenied) },
                    { "34020", typeof(PermissionDenied) },
                    { "34021", typeof(InvalidAddress) },
                    { "34022", typeof(ExchangeError) },
                    { "34023", typeof(PermissionDenied) },
                    { "34026", typeof(ExchangeError) },
                    { "34036", typeof(ExchangeError) },
                    { "34037", typeof(ExchangeError) },
                    { "34038", typeof(ExchangeError) },
                    { "34039", typeof(ExchangeError) },
                    { "35001", typeof(ExchangeError) },
                    { "35002", typeof(ExchangeError) },
                    { "35003", typeof(ExchangeError) },
                    { "35004", typeof(ExchangeError) },
                    { "35005", typeof(AuthenticationError) },
                    { "35008", typeof(InvalidOrder) },
                    { "35010", typeof(InvalidOrder) },
                    { "35012", typeof(InvalidOrder) },
                    { "35014", typeof(InvalidOrder) },
                    { "35015", typeof(InvalidOrder) },
                    { "35017", typeof(ExchangeError) },
                    { "35019", typeof(InvalidOrder) },
                    { "35020", typeof(InvalidOrder) },
                    { "35021", typeof(InvalidOrder) },
                    { "35022", typeof(ExchangeError) },
                    { "35024", typeof(ExchangeError) },
                    { "35025", typeof(InsufficientFunds) },
                    { "35026", typeof(ExchangeError) },
                    { "35029", typeof(OrderNotFound) },
                    { "35030", typeof(InvalidOrder) },
                    { "35031", typeof(InvalidOrder) },
                    { "35032", typeof(ExchangeError) },
                    { "35037", typeof(ExchangeError) },
                    { "35039", typeof(ExchangeError) },
                    { "35040", typeof(InvalidOrder) },
                    { "35044", typeof(ExchangeError) },
                    { "35046", typeof(InsufficientFunds) },
                    { "35047", typeof(InsufficientFunds) },
                    { "35048", typeof(ExchangeError) },
                    { "35049", typeof(InvalidOrder) },
                    { "35050", typeof(InvalidOrder) },
                    { "35052", typeof(InsufficientFunds) },
                    { "35053", typeof(ExchangeError) },
                    { "35055", typeof(InsufficientFunds) },
                    { "35057", typeof(ExchangeError) },
                    { "35058", typeof(ExchangeError) },
                    { "35059", typeof(BadRequest) },
                    { "35060", typeof(BadRequest) },
                    { "35061", typeof(BadRequest) },
                    { "35062", typeof(InvalidOrder) },
                    { "35063", typeof(InvalidOrder) },
                    { "35064", typeof(InvalidOrder) },
                    { "35066", typeof(InvalidOrder) },
                    { "35067", typeof(InvalidOrder) },
                    { "35068", typeof(InvalidOrder) },
                    { "35069", typeof(InvalidOrder) },
                    { "35070", typeof(InvalidOrder) },
                    { "35071", typeof(InvalidOrder) },
                    { "35072", typeof(InvalidOrder) },
                    { "35073", typeof(InvalidOrder) },
                    { "35074", typeof(InvalidOrder) },
                    { "35075", typeof(InvalidOrder) },
                    { "35076", typeof(InvalidOrder) },
                    { "35077", typeof(InvalidOrder) },
                    { "35078", typeof(InvalidOrder) },
                    { "35079", typeof(InvalidOrder) },
                    { "35080", typeof(InvalidOrder) },
                    { "35081", typeof(InvalidOrder) },
                    { "35082", typeof(InvalidOrder) },
                    { "35083", typeof(InvalidOrder) },
                    { "35084", typeof(InvalidOrder) },
                    { "35085", typeof(InvalidOrder) },
                    { "35086", typeof(InvalidOrder) },
                    { "35087", typeof(InvalidOrder) },
                    { "35088", typeof(InvalidOrder) },
                    { "35089", typeof(InvalidOrder) },
                    { "35090", typeof(ExchangeError) },
                    { "35091", typeof(ExchangeError) },
                    { "35092", typeof(ExchangeError) },
                    { "35093", typeof(ExchangeError) },
                    { "35094", typeof(ExchangeError) },
                    { "35095", typeof(BadRequest) },
                    { "35096", typeof(ExchangeError) },
                    { "35097", typeof(ExchangeError) },
                    { "35098", typeof(ExchangeError) },
                    { "35099", typeof(ExchangeError) },
                    { "36001", typeof(BadRequest) },
                    { "36002", typeof(BadRequest) },
                    { "36005", typeof(ExchangeError) },
                    { "36101", typeof(AuthenticationError) },
                    { "36102", typeof(PermissionDenied) },
                    { "36103", typeof(AccountSuspended) },
                    { "36104", typeof(PermissionDenied) },
                    { "36105", typeof(PermissionDenied) },
                    { "36106", typeof(AccountSuspended) },
                    { "36107", typeof(PermissionDenied) },
                    { "36108", typeof(InsufficientFunds) },
                    { "36109", typeof(PermissionDenied) },
                    { "36201", typeof(PermissionDenied) },
                    { "36202", typeof(PermissionDenied) },
                    { "36203", typeof(InvalidOrder) },
                    { "36204", typeof(ExchangeError) },
                    { "36205", typeof(BadRequest) },
                    { "36206", typeof(BadRequest) },
                    { "36207", typeof(InvalidOrder) },
                    { "36208", typeof(InvalidOrder) },
                    { "36209", typeof(InvalidOrder) },
                    { "36210", typeof(InvalidOrder) },
                    { "36211", typeof(InvalidOrder) },
                    { "36212", typeof(InvalidOrder) },
                    { "36213", typeof(InvalidOrder) },
                    { "36214", typeof(ExchangeError) },
                    { "36216", typeof(OrderNotFound) },
                    { "36217", typeof(InvalidOrder) },
                    { "36218", typeof(InvalidOrder) },
                    { "36219", typeof(InvalidOrder) },
                    { "36220", typeof(InvalidOrder) },
                    { "36221", typeof(InvalidOrder) },
                    { "36222", typeof(InvalidOrder) },
                    { "36223", typeof(InvalidOrder) },
                    { "36224", typeof(InvalidOrder) },
                    { "36225", typeof(InvalidOrder) },
                    { "36226", typeof(InvalidOrder) },
                    { "36227", typeof(InvalidOrder) },
                    { "36228", typeof(InvalidOrder) },
                    { "36229", typeof(InvalidOrder) },
                    { "36230", typeof(InvalidOrder) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "405", typeof(BadRequest) },
                    { "415", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "1001", typeof(RateLimitExceeded) },
                    { "1002", typeof(ExchangeError) },
                    { "1003", typeof(ExchangeError) },
                    { "40001", typeof(AuthenticationError) },
                    { "40002", typeof(AuthenticationError) },
                    { "40003", typeof(AuthenticationError) },
                    { "40004", typeof(InvalidNonce) },
                    { "40005", typeof(InvalidNonce) },
                    { "40006", typeof(AuthenticationError) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(AuthenticationError) },
                    { "40010", typeof(AuthenticationError) },
                    { "40011", typeof(AuthenticationError) },
                    { "40012", typeof(AuthenticationError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(PermissionDenied) },
                    { "40015", typeof(ExchangeError) },
                    { "40016", typeof(PermissionDenied) },
                    { "40017", typeof(ExchangeError) },
                    { "40018", typeof(PermissionDenied) },
                    { "40019", typeof(InvalidOrder) },
                    { "40102", typeof(BadRequest) },
                    { "40103", typeof(BadRequest) },
                    { "40104", typeof(ExchangeError) },
                    { "40105", typeof(ExchangeError) },
                    { "40106", typeof(ExchangeError) },
                    { "40107", typeof(ExchangeError) },
                    { "40108", typeof(InvalidOrder) },
                    { "40109", typeof(OrderNotFound) },
                    { "40200", typeof(OnMaintenance) },
                    { "40201", typeof(InvalidOrder) },
                    { "40202", typeof(ExchangeError) },
                    { "40203", typeof(BadRequest) },
                    { "40204", typeof(BadRequest) },
                    { "40205", typeof(BadRequest) },
                    { "40206", typeof(BadRequest) },
                    { "40207", typeof(BadRequest) },
                    { "40208", typeof(BadRequest) },
                    { "40209", typeof(BadRequest) },
                    { "40300", typeof(ExchangeError) },
                    { "40301", typeof(PermissionDenied) },
                    { "40302", typeof(BadRequest) },
                    { "40303", typeof(BadRequest) },
                    { "40304", typeof(BadRequest) },
                    { "40305", typeof(BadRequest) },
                    { "40306", typeof(ExchangeError) },
                    { "40308", typeof(OnMaintenance) },
                    { "40309", typeof(BadSymbol) },
                    { "40400", typeof(ExchangeError) },
                    { "40401", typeof(ExchangeError) },
                    { "40402", typeof(BadRequest) },
                    { "40403", typeof(BadRequest) },
                    { "40404", typeof(BadRequest) },
                    { "40405", typeof(BadRequest) },
                    { "40406", typeof(BadRequest) },
                    { "40407", typeof(ExchangeError) },
                    { "40408", typeof(ExchangeError) },
                    { "40409", typeof(ExchangeError) },
                    { "40500", typeof(InvalidOrder) },
                    { "40501", typeof(ExchangeError) },
                    { "40502", typeof(ExchangeError) },
                    { "40503", typeof(ExchangeError) },
                    { "40504", typeof(ExchangeError) },
                    { "40505", typeof(ExchangeError) },
                    { "40506", typeof(AuthenticationError) },
                    { "40507", typeof(AuthenticationError) },
                    { "40508", typeof(ExchangeError) },
                    { "40509", typeof(ExchangeError) },
                    { "40600", typeof(ExchangeError) },
                    { "40601", typeof(ExchangeError) },
                    { "40602", typeof(ExchangeError) },
                    { "40603", typeof(ExchangeError) },
                    { "40604", typeof(ExchangeNotAvailable) },
                    { "40605", typeof(ExchangeError) },
                    { "40606", typeof(ExchangeError) },
                    { "40607", typeof(ExchangeError) },
                    { "40608", typeof(ExchangeError) },
                    { "40609", typeof(ExchangeError) },
                    { "40700", typeof(BadRequest) },
                    { "40701", typeof(ExchangeError) },
                    { "40702", typeof(ExchangeError) },
                    { "40703", typeof(ExchangeError) },
                    { "40704", typeof(ExchangeError) },
                    { "40705", typeof(BadRequest) },
                    { "40706", typeof(InvalidOrder) },
                    { "40707", typeof(BadRequest) },
                    { "40708", typeof(BadRequest) },
                    { "40709", typeof(ExchangeError) },
                    { "40710", typeof(ExchangeError) },
                    { "40711", typeof(InsufficientFunds) },
                    { "40712", typeof(InsufficientFunds) },
                    { "40713", typeof(ExchangeError) },
                    { "40714", typeof(ExchangeError) },
                    { "41114", typeof(OnMaintenance) },
                    { "43011", typeof(InvalidOrder) },
                    { "43025", typeof(InvalidOrder) },
                    { "45110", typeof(InvalidOrder) },
                    { "invalid sign", typeof(AuthenticationError) },
                    { "invalid currency", typeof(BadSymbol) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "invalid period", typeof(BadRequest) },
                    { "invalid user", typeof(ExchangeError) },
                    { "invalid amount", typeof(InvalidOrder) },
                    { "invalid type", typeof(InvalidOrder) },
                    { "invalid orderId", typeof(InvalidOrder) },
                    { "invalid record", typeof(ExchangeError) },
                    { "invalid accountId", typeof(BadRequest) },
                    { "invalid address", typeof(BadRequest) },
                    { "accesskey not null", typeof(AuthenticationError) },
                    { "illegal accesskey", typeof(AuthenticationError) },
                    { "sign not null", typeof(AuthenticationError) },
                    { "req_time is too much difference from server time", typeof(InvalidNonce) },
                    { "permissions not right", typeof(PermissionDenied) },
                    { "illegal sign invalid", typeof(AuthenticationError) },
                    { "user locked", typeof(AccountSuspended) },
                    { "Request Frequency Is Too High", typeof(RateLimitExceeded) },
                    { "more than a daily rate of cash", typeof(BadRequest) },
                    { "more than the maximum daily withdrawal amount", typeof(BadRequest) },
                    { "need to bind email or mobile", typeof(ExchangeError) },
                    { "user forbid", typeof(PermissionDenied) },
                    { "User Prohibited Cash Withdrawal", typeof(PermissionDenied) },
                    { "Cash Withdrawal Is Less Than The Minimum Value", typeof(BadRequest) },
                    { "Cash Withdrawal Is More Than The Maximum Value", typeof(BadRequest) },
                    { "the account with in 24 hours ban coin", typeof(PermissionDenied) },
                    { "order cancel fail", typeof(BadRequest) },
                    { "base symbol error", typeof(BadSymbol) },
                    { "base date error", typeof(ExchangeError) },
                    { "api signature not valid", typeof(AuthenticationError) },
                    { "gateway internal error", typeof(ExchangeError) },
                    { "audit failed", typeof(ExchangeError) },
                    { "order queryorder invalid", typeof(BadRequest) },
                    { "market no need price", typeof(InvalidOrder) },
                    { "limit need price", typeof(InvalidOrder) },
                    { "userid not equal to account_id", typeof(ExchangeError) },
                    { "your balance is low", typeof(InsufficientFunds) },
                    { "address invalid cointype", typeof(ExchangeError) },
                    { "system exception", typeof(ExchangeError) },
                    { "50003", typeof(ExchangeError) },
                    { "50004", typeof(BadSymbol) },
                    { "50006", typeof(PermissionDenied) },
                    { "50007", typeof(PermissionDenied) },
                    { "50008", typeof(RequestTimeout) },
                    { "50009", typeof(RateLimitExceeded) },
                    { "50010", typeof(ExchangeError) },
                    { "50014", typeof(InvalidOrder) },
                    { "50015", typeof(InvalidOrder) },
                    { "50016", typeof(InvalidOrder) },
                    { "50017", typeof(InvalidOrder) },
                    { "50018", typeof(InvalidOrder) },
                    { "50019", typeof(InvalidOrder) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(InvalidOrder) },
                    { "50026", typeof(InvalidOrder) },
                    { "invalid order query time", typeof(ExchangeError) },
                    { "invalid start time", typeof(BadRequest) },
                    { "invalid end time", typeof(BadRequest) },
                    { "20003", typeof(ExchangeError) },
                    { "01001", typeof(ExchangeError) },
                    { "43111", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "invalid size, valid range", typeof(ExchangeError) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "JADE", "Jade Protocol" },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "4h", "4h" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1H" },
                        { "2h", "2H" },
                        { "4h", "4H" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                } },
                { "fetchMarkets", new List<object>() {"spot", "swap"} },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "broker", "p4sve" },
                { "withdraw", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "main", "EXCHANGE" },
                    { "spot", "EXCHANGE" },
                    { "future", "USDT_MIX" },
                    { "contract", "CONTRACT" },
                    { "mix", "USD_MIX" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "EXCHANGE", "spot" },
                    { "USDT_MIX", "future" },
                    { "CONTRACT", "swap" },
                    { "USD_MIX", "swap" },
                } },
                { "sandboxMode", false },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                    { "BSC", "BEP20" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                    { "BSC", "BEP20" },
                } },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        ((Dictionary<string, object>)this.options)["sandboxMode"] = enabled;
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetPublicTime(parameters);
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645837773501,
        //       data: '1645837773501'
        //     }
        //
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMarkets
        * @description retrieves data on all markets for bitget
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        object types = this.safeValue(this.options, "fetchMarkets", new List<object>() {"spot", "swap"});
        if (isTrue(sandboxMode))
        {
            types = new List<object>() {"swap"};
        }
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            object type = getValue(types, i);
            if (isTrue(isEqual(type, "swap")))
            {
                object subTypes = null;
                if (isTrue(sandboxMode))
                {
                    // the following are simulated trading markets [ 'sumcbl', 'sdmcbl', 'scmcbl' ];
                    subTypes = new List<object>() {"sumcbl", "sdmcbl", "scmcbl"};
                } else
                {
                    subTypes = new List<object>() {"umcbl", "dmcbl", "cmcbl"};
                }
                for (object j = 0; isLessThan(j, getArrayLength(subTypes)); postFixIncrement(ref j))
                {
                    ((List<object>)promises).Add(this.fetchMarketsByType(type, this.extend(parameters, new Dictionary<string, object>() {
                        { "productType", getValue(subTypes, j) },
                    })));
                }
            } else
            {
                ((List<object>)promises).Add(this.fetchMarketsByType(getValue(types, i), parameters));
            }
        }
        promises = await promiseAll(promises);
        object result = getValue(promises, 0);
        for (object i = 1; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    public virtual object parseMarkets(object markets)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseMarket(getValue(markets, i)));
        }
        return result;
    }

    public virtual object parseMarket(object market)
    {
        //
        // spot
        //
        //    {
        //        symbol: 'ALPHAUSDT_SPBL',
        //        symbolName: 'ALPHAUSDT',
        //        baseCoin: 'ALPHA',
        //        quoteCoin: 'USDT',
        //        minTradeAmount: '2',
        //        maxTradeAmount: '0',
        //        minTradeUSDT": '5',
        //        takerFeeRate: '0.001',
        //        makerFeeRate: '0.001',
        //        priceScale: '4',
        //        quantityScale: '4',
        //        status: 'online'
        //    }
        //
        // swap
        //
        //    {
        //        symbol: 'BTCUSDT_UMCBL',
        //        makerFeeRate: '0.0002',
        //        takerFeeRate: '0.0006',
        //        feeRateUpRatio: '0.005',
        //        openCostUpRatio: '0.01',
        //        quoteCoin: 'USDT',
        //        baseCoin: 'BTC',
        //        buyLimitPriceRatio: '0.01',
        //        sellLimitPriceRatio: '0.01',
        //        supportMarginCoins: [ 'USDT' ],
        //        minTradeNum: '0.001',
        //        priceEndStep: '5',
        //        volumePlace: '3',
        //        pricePlace: '1',
        //        symbolStatus: "normal",
        //        offTime: "-1",
        //        limitOpenTime: "-1"
        //    }
        //
        object marketId = this.safeString(market, "symbol");
        object quoteId = this.safeString(market, "quoteCoin");
        object baseId = this.safeString(market, "baseCoin");
        object quote = this.safeCurrencyCode(quoteId);
        object bs = this.safeCurrencyCode(baseId);
        object supportMarginCoins = this.safeValue(market, "supportMarginCoins", new List<object>() {});
        object settleId = this.safeString(supportMarginCoins, 0);
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object parts = ((string)marketId).Split((string)"_").ToList<object>();
        object typeId = this.safeString(parts, 1);
        object type = null;
        object swap = false;
        object spot = false;
        object future = false;
        object contract = false;
        object pricePrecision = null;
        object amountPrecision = null;
        object linear = null;
        object inverse = null;
        object expiry = null;
        object expiryDatetime = null;
        if (isTrue(isEqual(typeId, "SPBL")))
        {
            type = "spot";
            spot = true;
            pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "priceScale")));
            amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityScale")));
        } else
        {
            object expiryString = this.safeString(parts, 2);
            if (isTrue(!isEqual(expiryString, null)))
            {
                object year = add("20", ((string)expiryString).Substring((int)0, (int)2));
                object month = ((string)expiryString).Substring((int)2, (int)4);
                object day = ((string)expiryString).Substring((int)4, (int)6);
                expiryDatetime = add(add(add(add(add(year, "-"), month), "-"), day), "T00:00:00Z");
                expiry = this.parse8601(expiryDatetime);
                type = "future";
                future = true;
                symbol = add(add(add(add(symbol, ":"), settle), "-"), expiryString);
            } else
            {
                type = "swap";
                swap = true;
                symbol = add(add(symbol, ":"), settle);
            }
            contract = true;
            linear = isTrue(isTrue(isTrue((isEqual(typeId, "UMCBL"))) || isTrue((isEqual(typeId, "CMCBL")))) || isTrue((isEqual(typeId, "SUMCBL")))) || isTrue((isEqual(typeId, "SCMCBL")));
            inverse = !isTrue(linear);
            object priceDecimals = this.safeInteger(market, "pricePlace");
            object amountDecimals = this.safeInteger(market, "volumePlace");
            object priceStep = this.safeString(market, "priceEndStep");
            object amountStep = this.safeString(market, "minTradeNum");
            var precisePrice = new Precise(priceStep);
            precisePrice.decimals = mathMax(precisePrice.decimals, priceDecimals);
            precisePrice.reduce();
            object priceString = ((object)precisePrice).ToString();
            pricePrecision = this.parseNumber(priceString);
            var preciseAmount = new Precise(amountStep);
            preciseAmount.decimals = mathMax(preciseAmount.decimals, amountDecimals);
            preciseAmount.reduce();
            object amountString = ((object)preciseAmount).ToString();
            amountPrecision = this.parseNumber(amountString);
        }
        object status = this.safeString2(market, "status", "symbolStatus");
        object active = null;
        if (isTrue(!isEqual(status, null)))
        {
            active = (isTrue(isEqual(status, "online")) || isTrue(isEqual(status, "normal")));
        }
        object minCost = null;
        if (isTrue(isEqual(quote, "USDT")))
        {
            minCost = this.safeNumber(market, "minTradeUSDT");
        }
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", false },
            { "swap", swap },
            { "future", future },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "linear", linear },
            { "inverse", inverse },
            { "taker", this.safeNumber(market, "takerFeeRate") },
            { "maker", this.safeNumber(market, "makerFeeRate") },
            { "contractSize", 1 },
            { "expiry", expiry },
            { "expiryDatetime", expiryDatetime },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber2(market, "minTradeNum", "minTradeAmount") },
                    { "max", this.safeNumber(market, "maxTradeAmount") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", null },
                } },
            } },
            { "info", market },
        };
    }

    public async virtual Task<object> fetchMarketsByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "publicSpotGetPublicProducts" },
            { "swap", "publicMixGetMarketContracts" },
        });
        object response = await this.callAsync(method, parameters);
        //
        // spot
        //
        //    {
        //        code: '00000',
        //        msg: 'success',
        //        requestTime: 1645840064031,
        //        data: [
        //            {
        //                symbol: 'ALPHAUSDT_SPBL',
        //                symbolName: 'ALPHAUSDT',
        //                baseCoin: 'ALPHA',
        //                quoteCoin: 'USDT',
        //                minTradeAmount: '2',
        //                maxTradeAmount: '0',
        //                takerFeeRate: '0.001',
        //                makerFeeRate: '0.001',
        //                priceScale: '4',
        //                quantityScale: '4',
        //                status: 'online'
        //            }
        //        ]
        //    }
        //
        // swap
        //
        //    {
        //        code: '00000',
        //        msg: 'success',
        //        requestTime: 1645840821493,
        //        data: [
        //            {
        //                symbol: 'BTCUSDT_UMCBL',
        //                makerFeeRate: '0.0002',
        //                takerFeeRate: '0.0006',
        //                feeRateUpRatio: '0.005',
        //                openCostUpRatio: '0.01',
        //                quoteCoin: 'USDT',
        //                baseCoin: 'BTC',
        //                buyLimitPriceRatio: '0.01',
        //                sellLimitPriceRatio: '0.01',
        //                supportMarginCoins: [Array],
        //                minTradeNum: '0.001',
        //                priceEndStep: '5',
        //                volumePlace: '3',
        //                pricePlace: '1'
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(data);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetPublicCurrencies(parameters);
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645935668288,
        //       data: [
        //         {
        //           coinId: '230',
        //           coinName: 'KIN',
        //           transfer: 'false',
        //           chains: [
        //             {
        //               chain: 'SOL',
        //               needTag: 'false',
        //               withdrawable: 'true',
        //               rechargeable: 'true',
        //               withdrawFee: '187500',
        //               depositConfirm: '100',
        //               withdrawConfirm: '100',
        //               minDepositAmount: '12500',
        //               minWithdrawAmount: '250000',
        //               browserUrl: 'https://explorer.solana.com/tx/'
        //             }
        //           ]
        //         }
        //       ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "coinId");
            object code = this.safeCurrencyCode(this.safeString(entry, "coinName"));
            object chains = this.safeValue(entry, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chain");
                object network = this.safeCurrencyCode(networkId);
                object withdrawEnabled = this.safeString(chain, "withdrawable");
                object depositEnabled = this.safeString(chain, "rechargeable");
                ((Dictionary<string, object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "minWithdrawAmount") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "minDepositAmount") },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "withdraw", isEqual(withdrawEnabled, "true") },
                    { "deposit", isEqual(depositEnabled, "true") },
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "precision", null },
                };
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", networks },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-deposit-list
        * @param {string|undefined} code unified currency code
        * @param {int} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @param {string|undefined} params.pageNo pageNo default 1
        * @param {string|undefined} params.pageSize pageSize default 20. Max 100
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a `code` argument")) ;
        }
        object currency = this.currency(code);
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 31556952000); // 1yr
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "code") },
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.privateSpotGetWalletDepositList(this.extend(request, parameters));
        //
        //      {
        //          "code": "00000",
        //          "msg": "success",
        //          "requestTime": 0,
        //          "data": [{
        //              "id": "925607360021839872",
        //              "txId": "f73a4ac034da06b729f49676ca8801f406a093cf90c69b16e5a1cc9080df4ccb",
        //              "coin": "USDT",
        //              "type": "deposit",
        //              "amount": "19.44800000",
        //              "status": "success",
        //              "toAddress": "TRo4JMfZ1XYHUgnLsUMfDEf8MWzcWaf8uh",
        //              "fee": null,
        //              "chain": "TRC20",
        //              "confirm": null,
        //              "cTime": "1656407912259",
        //              "uTime": "1656407940148"
        //          }]
        //      }
        //
        object rawTransactions = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, currency, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @param {string} params.chain the chain to withdraw to
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        object chain = this.safeString(parameters, "chain");
        if (isTrue(isEqual(chain, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a chain parameter")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "code") },
            { "address", address },
            { "chain", chain },
            { "amount", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["tag"] = tag;
        }
        object response = await this.privateSpotPostWalletWithdrawal(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "data": "888291686266343424"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "id", this.safeString(response, "data") },
            { "info", response },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "amount", null },
            { "type", "withdrawal" },
            { "currency", null },
            { "status", null },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "fee", null },
        };
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeValue(withdrawOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((Dictionary<string, object>)result)["currency"] = code;
            ((Dictionary<string, object>)result)["timestamp"] = this.milliseconds();
            ((Dictionary<string, object>)result)["datetime"] = this.iso8601(this.milliseconds());
            ((Dictionary<string, object>)result)["amount"] = amount;
            ((Dictionary<string, object>)result)["tag"] = tag;
            ((Dictionary<string, object>)result)["address"] = address;
            ((Dictionary<string, object>)result)["addressTo"] = address;
            ((Dictionary<string, object>)result)["network"] = chain;
        }
        return result;
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-withdraw-list
        * @param {string|undefined} code unified currency code
        * @param {int} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @param {string|undefined} params.pageNo pageNo default 1
        * @param {string|undefined} params.pageSize pageSize default 20. Max 100
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires a `code` argument")) ;
        }
        object currency = this.currency(code);
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 31556952000); // 1yr
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "code") },
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.privateSpotGetWalletWithdrawalList(this.extend(request, parameters));
        //
        //      {
        //          "code": "00000",
        //          "msg": "success",
        //          "requestTime": 0,
        //          "data": [{
        //              "id": "925607360021839872",
        //              "txId": "f73a4ac034da06b729f49676ca8801f406a093cf90c69b16e5a1cc9080df4ccb",
        //              "coin": "USDT",
        //              "type": "deposit",
        //              "amount": "19.44800000",
        //              "status": "success",
        //              "toAddress": "TRo4JMfZ1XYHUgnLsUMfDEf8MWzcWaf8uh",
        //              "fee": null,
        //              "chain": "TRC20",
        //              "confirm": null,
        //              "cTime": "1656407912259",
        //              "uTime": "1656407940148"
        //          }]
        //      }
        //
        object rawTransactions = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "id": "925607360021839872",
        //         "txId": "f73a4ac034da06b729f49676ca8801f406a093cf90c69b16e5a1cc9080df4ccb",
        //         "coin": "USDT",
        //         "type": "deposit",
        //         "amount": "19.44800000",
        //         "status": "success",
        //         "toAddress": "TRo4JMfZ1XYHUgnLsUMfDEf8MWzcWaf8uh",
        //         "fee": null,
        //         "chain": "TRC20",
        //         "confirm": null,
        //         "cTime": "1656407912259",
        //         "uTime": "1656407940148"
        //     }
        //
        object timestamp = this.safeInteger(transaction, "cTime");
        object networkId = this.safeString(transaction, "chain");
        object currencyId = this.safeString(transaction, "coin");
        object status = this.safeString(transaction, "status");
        return new Dictionary<string, object>() {
            { "id", this.safeString(transaction, "id") },
            { "info", transaction },
            { "txid", this.safeString(transaction, "txId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", networkId },
            { "addressFrom", null },
            { "address", this.safeString(transaction, "toAddress") },
            { "addressTo", this.safeString(transaction, "toAddress") },
            { "amount", this.safeNumber(transaction, "amount") },
            { "type", this.safeString(transaction, "type") },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "status", this.parseTransactionStatus(status) },
            { "updated", this.safeNumber(transaction, "uTime") },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "fee", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
            { "Pending", "pending" },
            { "pending_review", "pending" },
            { "pending_review_fail", "failed" },
            { "reject", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = this.safeString(parameters, "network");
        object networkId = this.networkCodeToId(networkCode, code);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "code") },
        };
        if (isTrue(!isEqual(networkId, null)))
        {
            ((Dictionary<string, object>)request)["chain"] = networkId;
        }
        object response = await this.privateSpotGetWalletDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "data": {
        //             "address": "1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv",
        //             "chain": "BTC-Bitcoin",
        //             "coin": "BTC",
        //             "tag": "",
        //             "url": "https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        "address": "1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv",
        //        "chain": "BTC-Bitcoin",
        //        "coin": "BTC",
        //        "tag": "",
        //        "url": "https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
        //    }
        //
        object currencyId = this.safeString(depositAddress, "coin");
        object networkId = this.safeString(depositAddress, "chain");
        object parsedCurrency = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "currency", parsedCurrency },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", this.safeString(depositAddress, "tag") },
            { "network", this.networkIdToCode(networkId, parsedCurrency) },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrderBook", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "publicSpotGetMarketDepth" },
            { "swap", "publicMixGetMarketDepth" },
        });
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645854610294,
        //       data: {
        //         asks: [ [ '39102', '11.026' ] ],
        //         bids: [ [ '39100.5', '1.773' ] ],
        //         timestamp: '1645854610294'
        //       }
        //     }
        //
        object data = this.safeValue(response, "data");
        object timestamp = this.safeInteger(data, "timestamp");
        return this.parseOrderBook(data, symbol, timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //     {
        //         symbol: 'BTCUSDT',
        //         high24h: '40252.43',
        //         low24h: '38548.54',
        //         close: '39102.16',
        //         quoteVol: '67295596.1458',
        //         baseVol: '1723.4152',
        //         usdtVol: '67295596.14578',
        //         ts: '1645856170030',
        //         buyOne: '39096.16',
        //         sellOne: '39103.99'
        //     }
        //
        // swap
        //
        //     {
        //         symbol: 'BTCUSDT_UMCBL',
        //         last: '39086',
        //         bestAsk: '39087',
        //         bestBid: '39086',
        //         high24h: '40312',
        //         low24h: '38524.5',
        //         timestamp: '1645856591864',
        //         priceChangePercent: '-0.00861',
        //         baseVolume: '142251.757',
        //         quoteVolume: '5552388715.9215',
        //         usdtVolume: '5552388715.9215'
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        if (isTrue(isTrue(isTrue((isEqual(market, null))) && isTrue((!isEqual(marketId, null)))) && isTrue((isEqual(getIndexOf(marketId, "_"), -1)))))
        {
            // fetchTickers fix:
            // spot symbol are different from the "request id"
            // so we need to convert it to the exchange-specific id
            // otherwise we will not be able to find the market
            marketId = add(marketId, "_SPBL");
        }
        object symbol = this.safeSymbol(marketId, market);
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        object close = this.safeString2(ticker, "close", "last");
        object quoteVolume = this.safeString2(ticker, "quoteVol", "quoteVolume");
        object baseVolume = this.safeString2(ticker, "baseVol", "baseVolume");
        object timestamp = this.safeInteger2(ticker, "ts", "timestamp");
        object datetime = this.iso8601(timestamp);
        object bid = this.safeString2(ticker, "buyOne", "bestBid");
        object ask = this.safeString2(ticker, "sellOne", "bestAsk");
        object percentage = Precise.stringMul(this.safeString(ticker, "priceChangePercent"), "100");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", null },
            { "ask", ask },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", close },
            { "last", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTicker", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "publicSpotGetMarketTicker" },
            { "swap", "publicMixGetMarketTicker" },
        });
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //     {
        //         code: '00000',
        //         msg: 'success',
        //         requestTime: '1645856138576',
        //         data: {
        //             symbol: 'BTCUSDT',
        //             high24h: '40252.43',
        //             low24h: '38548.54',
        //             close: '39104.65',
        //             quoteVol: '67221762.2184',
        //             baseVol: '1721.527',
        //             usdtVol: '67221762.218361',
        //             ts: '1645856138031',
        //             buyOne: '39102.55',
        //             sellOne: '39110.56'
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTicker(data, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-all-tickers
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#get-all-symbol-ticker
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        await this.loadMarkets();
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "publicSpotGetMarketTickers" },
            { "swap", "publicMixGetMarketTickers" },
        });
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(method, "publicMixGetMarketTickers")))
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", null, parameters);
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            object productType = ((bool) isTrue((isEqual(subType, "linear")))) ? "UMCBL" : "DMCBL";
            if (isTrue(sandboxMode))
            {
                productType = add("S", productType);
            }
            ((Dictionary<string, object>)request)["productType"] = productType;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "code":"00000",
        //         "msg":"success",
        //         "requestTime":1653237548496,
        //         "data":[
        //             {
        //                 "symbol":"LINKUSDT",
        //                 "high24h":"7.2634",
        //                 "low24h":"7.1697",
        //                 "close":"7.2444",
        //                 "quoteVol":"330424.2366",
        //                 "baseVol":"46401.3116",
        //                 "usdtVol":"330424.2365573",
        //                 "ts":"1653237548026",
        //                 "buyOne":"7.2382",
        //                 "sellOne":"7.2513"
        //             },
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code":"00000",
        //         "msg":"success",
        //         "requestTime":1653237819762,
        //         "data":[
        //             {
        //                 "symbol":"BTCUSDT_UMCBL",
        //                 "last":"29891.5",
        //                 "bestAsk":"29891.5",
        //                 "bestBid":"29889.5",
        //                 "high24h":"29941.5",
        //                 "low24h":"29737.5",
        //                 "timestamp":"1653237819761",
        //                 "priceChangePercent":"0.00163",
        //                 "baseVolume":"127937.56",
        //                 "quoteVolume":"3806276573.6285",
        //                 "usdtVolume":"3806276573.6285"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTickers(data, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot
        //
        //     {
        //         symbol: 'BTCUSDT_SPBL',
        //         tradeId: '881371996363608065',
        //         side: 'sell',
        //         fillPrice: '39123.05',
        //         fillQuantity: '0.0363',
        //         fillTime: '1645861379709'
        //     }
        //
        // swap
        //
        //     {
        //         tradeId: '881373204067311617',
        //         price: '39119.0',
        //         size: '0.001',
        //         side: 'buy',
        //         timestamp: '1645861667648',
        //         symbol: 'BTCUSDT_UMCBL'
        //     }
        //
        // private
        //
        //     {
        //         accountId: '4383649766',
        //         symbol: 'ETHBTC_SPBL',
        //         orderId: '1009402341131468800',
        //         fillId: '1009402351489581068',
        //         orderType: 'limit',
        //         side: 'sell',
        //         fillPrice: '0.06997800',
        //         fillQuantity: '0.04120000',
        //         fillTotalAmount: '0.00288309',
        //         feeCcy: 'BTC',
        //         fees: '-0.00000288',
        //         cTime: '1676386195060'
        //     }
        //
        //     {
        //         tradeId: '881640729552281602',
        //         symbol: 'BTCUSDT_UMCBL',
        //         orderId: '881640729145409536',
        //         price: '38429.50',
        //         sizeQty: '0.001',
        //         fee: '0',
        //         side: 'open_long',
        //         fillAmount: '38.4295',
        //         profit: '0',
        //         cTime: '1645925450694'
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object id = this.safeString2(trade, "tradeId", "fillId");
        object order = this.safeString(trade, "orderId");
        object side = this.safeString(trade, "side");
        object price = this.safeString2(trade, "fillPrice", "price");
        object amount = this.safeString2(trade, "fillQuantity", "size");
        amount = this.safeString(trade, "sizeQty", amount);
        object timestamp = this.safeInteger2(trade, "fillTime", "timestamp");
        timestamp = this.safeInteger(trade, "cTime", timestamp);
        object fee = null;
        object feeAmount = this.safeString(trade, "fees");
        object type = this.safeString(trade, "orderType");
        if (isTrue(!isEqual(feeAmount, null)))
        {
            object currencyCode = this.safeCurrencyCode(this.safeString(trade, "feeCcy"));
            fee = new Dictionary<string, object>() {
                { "code", currencyCode },
                { "currency", currencyCode },
                { "cost", Precise.stringNeg(feeAmount) },
            };
        }
        object datetime = this.iso8601(timestamp);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", order },
            { "symbol", symbol },
            { "side", side },
            { "type", type },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
            { "timestamp", timestamp },
            { "datetime", datetime },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object limit = null, object since = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTrades", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "publicSpotGetMarketFills" },
            { "swap", "publicMixGetMarketFills" },
        });
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645861382032',
        //       data: [
        //         {
        //           symbol: 'BTCUSDT_SPBL',
        //           tradeId: '881371996363608065',
        //           side: 'sell',
        //           fillPrice: '39123.05',
        //           fillQuantity: '0.0363',
        //           fillTime: '1645861379709'
        //         }
        //       ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicSpotGetPublicProduct(this.extend(request, parameters));
        //
        //     {
        //         code: '00000',
        //         msg: 'success',
        //         requestTime: '1646255374000',
        //         data: {
        //           symbol: 'ethusdt_SPBL',
        //           symbolName: null,
        //           baseCoin: 'ETH',
        //           quoteCoin: 'USDT',
        //           minTradeAmount: '0',
        //           maxTradeAmount: '0',
        //           takerFeeRate: '0.002',
        //           makerFeeRate: '0.002',
        //           priceScale: '2',
        //           quantityScale: '4',
        //           status: 'online'
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetPublicProducts(parameters);
        //
        //     {
        //         code: '00000',
        //         msg: 'success',
        //         requestTime: '1646255662391',
        //         data: [
        //           {
        //             symbol: 'ALPHAUSDT_SPBL',
        //             symbolName: 'ALPHAUSDT',
        //             baseCoin: 'ALPHA',
        //             quoteCoin: 'USDT',
        //             minTradeAmount: '2',
        //             maxTradeAmount: '0',
        //             takerFeeRate: '0.001',
        //             makerFeeRate: '0.001',
        //             priceScale: '4',
        //             quantityScale: '4',
        //             status: 'online'
        //           },
        //           ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object feeInfo = getValue(data, i);
            object fee = this.parseTradingFee(feeInfo);
            object symbol = getValue(fee, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public virtual object parseTradingFee(object data, object market = null)
    {
        object marketId = this.safeString(data, "symbol");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(data, "makerFeeRate") },
            { "taker", this.safeNumber(data, "takerFeeRate") },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //
        //     {
        //         open: '57882.31',
        //         high: '58967.24',
        //         low: '57509.56',
        //         close: '57598.96',
        //         quoteVol: '439160536.605821',
        //         baseVol: '7531.2927',
        //         usdtVol: '439160536.605821',
        //         ts: '1637337600000'
        //     }
        //
        // swap
        //
        //     [
        //         "1645911960000",
        //         "39406",
        //         "39407",
        //         "39374.5",
        //         "39379",
        //         "35.526",
        //         "1399132.341"
        //     ]
        //
        return new List<object> {this.safeInteger2(ohlcv, 0, "ts"), this.safeNumber2(ohlcv, 1, "open"), this.safeNumber2(ohlcv, 2, "high"), this.safeNumber2(ohlcv, 3, "low"), this.safeNumber2(ohlcv, 4, "close"), this.safeNumber2(ohlcv, 5, "baseVol")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @param {int|undefined} params.until timestamp in ms of the latest candle to fetch
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOHLCV", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "publicSpotGetMarketCandles" },
            { "swap", "publicMixGetMarketCandles" },
        });
        object until = this.safeInteger2(query, "until", "till");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object timeframes = getValue(getValue(this.options, "timeframes"), marketType);
        object selectedTimeframe = this.safeString(timeframes, timeframe, timeframe);
        object duration = this.parseTimeframe(timeframe);
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["period"] = selectedTimeframe;
            ((Dictionary<string, object>)request)["limit"] = limit;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["after"] = since;
                if (isTrue(isEqual(until, null)))
                {
                    ((Dictionary<string, object>)request)["before"] = this.sum(since, multiply(multiply(limit, duration), 1000));
                }
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["before"] = until;
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            ((Dictionary<string, object>)request)["granularity"] = selectedTimeframe;
            object now = this.milliseconds();
            if (isTrue(isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = subtract(now, multiply((subtract(limit, 1)), (multiply(duration, 1000))));
                ((Dictionary<string, object>)request)["endTime"] = now;
            } else
            {
                ((Dictionary<string, object>)request)["startTime"] = this.sum(since, multiply(duration, 1000));
                if (isTrue(!isEqual(until, null)))
                {
                    ((Dictionary<string, object>)request)["endTime"] = until;
                } else
                {
                    ((Dictionary<string, object>)request)["endTime"] = this.sum(since, multiply(multiply(limit, duration), 1000));
                }
            }
        }
        object ommitted = this.omit(query, new List<object>() {"until", "till"});
        object response = await this.callAsync(method, this.extend(request, ommitted));
        //  [ ["1645911960000","39406","39407","39374.5","39379","35.526","1399132.341"] ]
        object data = this.safeValue(response, "data", response);
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        await this.loadMarkets();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotGetAccountAssets" },
            { "swap", "privateMixGetAccountAccounts" },
        });
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(marketType, "swap")))
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            object productType = ((bool) isTrue((isEqual(subType, "linear")))) ? "UMCBL" : "DMCBL";
            if (isTrue(sandboxMode))
            {
                productType = add("S", productType);
            }
            ((Dictionary<string, object>)request)["productType"] = productType;
        }
        object response = await this.callAsync(method, this.extend(request, query));
        // spot
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645928868827,
        //       data: [
        //         {
        //           coinId: 1,
        //           coinName: 'BTC',
        //           available: '0.00070000',
        //           frozen: '0.00000000',
        //           lock: '0.00000000',
        //           uTime: '1645921706000'
        //         }
        //       ]
        //     }
        //
        // swap
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645928929251,
        //       data: [
        //         {
        //           marginCoin: 'USDT',
        //           locked: '0',
        //           available: '8.078525',
        //           crossMaxAvailable: '8.078525',
        //           fixedMaxAvailable: '8.078525',
        //           maxTransferOut: '8.078525',
        //           equity: '10.02508',
        //           usdtEquity: '10.02508',
        //           btcEquity: '0.00026057027'
        //         }
        //       ]
        //     }
        object data = this.safeValue(response, "data");
        return this.parseBalance(data);
    }

    public virtual object parseBalance(object balance)
    {
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        //
        //     {
        //       coinId: '1',
        //       coinName: 'BTC',
        //       available: '0.00099900',
        //       frozen: '0.00000000',
        //       lock: '0.00000000',
        //       uTime: '1661595535000'
        //     }
        //
        for (object i = 0; isLessThan(i, getArrayLength(balance)); postFixIncrement(ref i))
        {
            object entry = getValue(balance, i);
            object currencyId = this.safeString2(entry, "coinName", "marginCoin");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object frozen = this.safeString(entry, "frozen");
            object locked = this.safeString2(entry, "lock", "locked");
            ((Dictionary<string, object>)account)["used"] = Precise.stringAdd(frozen, locked);
            ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "available");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "open" },
            { "init", "open" },
            { "not_trigger", "open" },
            { "triggered", "closed" },
            { "full_fill", "closed" },
            { "filled", "closed" },
            { "fail_trigger", "canceled" },
            { "cancel", "canceled" },
            { "cancelled", "canceled" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //     {
        //       accountId: '6394957606',
        //       symbol: 'BTCUSDT_SPBL',
        //       orderId: '881623995442958336',
        //       clientOrderId: '135335e9-b054-4e43-b00a-499f11d3a5cc',
        //       price: '39000.000000000000',
        //       quantity: '0.000700000000',
        //       orderType: 'limit',
        //       side: 'buy',
        //       status: 'new',
        //       fillPrice: '0.000000000000',
        //       fillQuantity: '0.000000000000',
        //       fillTotalAmount: '0.000000000000',
        //       cTime: '1645921460972'
        //     }
        //
        // swap
        //     {
        //       symbol: 'BTCUSDT_UMCBL',
        //       size: 0.001,
        //       orderId: '881640729145409536',
        //       clientOid: '881640729204129792',
        //       filledQty: 0.001,
        //       fee: 0,
        //       price: null,
        //       priceAvg: 38429.5,
        //       state: 'filled',
        //       side: 'open_long',
        //       timeInForce: 'normal',
        //       totalProfits: 0,
        //       posSide: 'long',
        //       marginCoin: 'USDT',
        //       filledAmount: 38.4295,
        //       orderType: 'market',
        //       cTime: '1645925450611',
        //       uTime: '1645925450746'
        //     }
        //
        // stop
        //
        //     {
        //         "orderId": "910246821491617792",
        //         "symbol": "BTCUSDT_UMCBL",
        //         "marginCoin": "USDT",
        //         "size": "16",
        //         "executePrice": "20000",
        //         "triggerPrice": "24000",
        //         "status": "not_trigger",
        //         "orderType": "limit",
        //         "planType": "normal_plan",
        //         "side": "open_long",
        //         "triggerType": "market_price",
        //         "presetTakeProfitPrice": "0",
        //         "presetTakeLossPrice": "0",
        //         "cTime": "1652745674488"
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object id = this.safeString(order, "orderId");
        object price = this.safeString2(order, "price", "executePrice");
        object amount = this.safeString2(order, "quantity", "size");
        object filled = this.safeString2(order, "fillQuantity", "filledQty");
        object cost = this.safeString2(order, "fillTotalAmount", "filledAmount");
        object average = this.safeString2(order, "fillPrice", "priceAvg");
        object type = this.safeString(order, "orderType");
        object timestamp = this.safeInteger(order, "cTime");
        object side = this.safeString2(order, "side", "posSide");
        if (isTrue(isTrue((isEqual(side, "open_long"))) || isTrue((isEqual(side, "close_short")))))
        {
            side = "buy";
        } else if (isTrue(isTrue((isEqual(side, "close_long"))) || isTrue((isEqual(side, "open_short")))))
        {
            side = "sell";
        }
        object clientOrderId = this.safeString2(order, "clientOrderId", "clientOid");
        object fee = null;
        object rawStatus = this.safeString2(order, "status", "state");
        object status = this.parseOrderStatus(rawStatus);
        object lastTradeTimestamp = this.safeInteger(order, "uTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", this.safeNumber(order, "triggerPrice") },
            { "triggerPrice", this.safeNumber(order, "triggerPrice") },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderType", type },
        };
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object isStopLossOrTakeProfit = isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice")) ;
        }
        if (isTrue(isTrue((isEqual(type, "limit"))) && isTrue((isEqual(triggerPrice, null)))))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeOrders" },
            { "swap", "privateMixPostOrderPlaceOrder" },
        });
        object exchangeSpecificParam = this.safeString2(parameters, "force", "timeInForceValue");
        object postOnly = this.isPostOnly(isMarketOrder, isEqual(exchangeSpecificParam, "post_only"), parameters);
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isStopLossOrTakeProfit))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() does not support stop loss/take profit orders on spot markets, only swap markets")) ;
            }
            object timeInForceKey = "force";
            object quantityKey = "quantity";
            object quantity = null;
            object createMarketBuyOrderRequiresPrice = this.safeValue(this.options, "createMarketBuyOrderRequiresPrice", true);
            if (isTrue(isTrue(isTrue(createMarketBuyOrderRequiresPrice) && isTrue(isMarketOrder)) && isTrue((isEqual(side, "buy")))))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object cost = this.parseNumber(Precise.stringMul(amountString, priceString));
                    quantity = this.priceToPrecision(symbol, cost);
                }
            } else
            {
                quantity = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["clientOrderId"] = clientOrderId;
            }
            ((Dictionary<string, object>)request)["side"] = side;
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                quantityKey = "size";
                timeInForceKey = "timeInForceValue";
                // default triggerType to market price for unification
                object triggerType = this.safeString(parameters, "triggerType", "market_price");
                ((Dictionary<string, object>)request)["triggerType"] = triggerType;
                ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                ((Dictionary<string, object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                method = "privateSpotPostPlanPlacePlan";
            }
            if (isTrue(!isEqual(quantity, null)))
            {
                ((Dictionary<string, object>)request)[(string)quantityKey] = quantity;
            }
            if (isTrue(postOnly))
            {
                ((Dictionary<string, object>)request)[(string)timeInForceKey] = "post_only";
            } else
            {
                ((Dictionary<string, object>)request)[(string)timeInForceKey] = "normal";
            }
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["clientOid"] = clientOrderId;
            }
            ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
            if (isTrue(postOnly))
            {
                ((Dictionary<string, object>)request)["timeInForceValue"] = "post_only";
            }
            object reduceOnly = this.safeValue(parameters, "reduceOnly", false);
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                // default triggerType to market price for unification
                object triggerType = this.safeString(parameters, "triggerType", "market_price");
                ((Dictionary<string, object>)request)["triggerType"] = triggerType;
                ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((Dictionary<string, object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                }
                method = "privateMixPostPlanPlacePlan";
            }
            if (isTrue(isStopLossOrTakeProfit))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new ExchangeError ((string)add(this.id, " createOrder() bitget stopLoss or takeProfit orders must be market orders")) ;
                }
                if (isTrue(isStopLossOrder))
                {
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                    ((Dictionary<string, object>)request)["planType"] = "loss_plan";
                } else if (isTrue(isTakeProfitOrder))
                {
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                    ((Dictionary<string, object>)request)["planType"] = "profit_plan";
                }
                ((Dictionary<string, object>)request)["holdSide"] = ((bool) isTrue((isEqual(side, "buy")))) ? "long" : "short";
                method = "privateMixPostPlanPlaceTPSL";
            } else
            {
                if (isTrue(reduceOnly))
                {
                    ((Dictionary<string, object>)request)["side"] = ((bool) isTrue((isEqual(side, "buy")))) ? "close_short" : "close_long";
                } else
                {
                    ((Dictionary<string, object>)request)["side"] = ((bool) isTrue((isEqual(side, "buy")))) ? "open_long" : "open_short";
                }
            }
            ((Dictionary<string, object>)request)["marginCoin"] = getValue(market, "settleId");
        }
        object omitted = this.omit(query, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "postOnly"});
        object response = await this.callAsync(method, this.extend(request, omitted));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1645932209602,
        //         "data": {
        //             "orderId": "881669078313766912",
        //             "clientOrderId": "iauIBf#a45b595f96474d888d0ada"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#editOrder
        * @description edit a trade order
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("editOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "orderType", type },
        };
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object isStopOrder = isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice")) ;
        }
        if (isTrue(!isTrue(isStopOrder) && !isTrue(isTriggerOrder)))
        {
            throw new InvalidOrder ((string)add(this.id, " editOrder() only support plan orders")) ;
        }
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostPlanModifyPlan" },
            { "swap", "privateMixPostPlanModifyPlan" },
        });
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            // default triggerType to market price for unification
            object triggerType = this.safeString(parameters, "triggerType", "market_price");
            ((Dictionary<string, object>)request)["triggerType"] = triggerType;
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((Dictionary<string, object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isStopOrder))
            {
                throw new InvalidOrder ((string)add(this.id, " editOrder() does not support stop orders on spot markets, only swap markets")) ;
            }
            object editMarketBuyOrderRequiresPrice = this.safeValue(this.options, "editMarketBuyOrderRequiresPrice", true);
            if (isTrue(isTrue(isTrue(editMarketBuyOrderRequiresPrice) && isTrue(isMarketOrder)) && isTrue((isEqual(side, "buy")))))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the editMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object cost = this.parseNumber(Precise.stringMul(amountString, priceString));
                    ((Dictionary<string, object>)request)["size"] = this.priceToPrecision(symbol, cost);
                }
            } else
            {
                ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
            if (isTrue(isStopOrder))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new ExchangeError ((string)add(this.id, " editOrder() bitget stopLoss or takeProfit orders must be market orders")) ;
                }
                if (isTrue(isStopLossOrder))
                {
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                    ((Dictionary<string, object>)request)["planType"] = "loss_plan";
                } else if (isTrue(isTakeProfitOrder))
                {
                    ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                    ((Dictionary<string, object>)request)["planType"] = "profit_plan";
                }
                method = "privateMixPostPlanModifyTPSLPlan";
            }
            ((Dictionary<string, object>)request)["marginCoin"] = getValue(market, "settleId");
        }
        object omitted = this.omit(query, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice"});
        object response = await this.callAsync(method, this.extend(request, omitted));
        //
        // spot
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1668136575920,
        //         "data": {
        //         "orderId": "974792060738441216",
        //         "clientOrderId": "974792554995224576"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("cancelOrder", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeCancelOrder" },
            { "swap", "privateMixPostOrderCancelOrder" },
        });
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object stop = this.safeValue(query, "stop");
        if (isTrue(stop))
        {
            if (isTrue(isEqual(marketType, "spot")))
            {
                method = "privateSpotPostPlanCancelPlan";
            } else
            {
                object planType = this.safeString(parameters, "planType");
                if (isTrue(isEqual(planType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan or loss_plan")) ;
                }
                ((Dictionary<string, object>)request)["planType"] = planType;
                method = "privateMixPostPlanCancelPlan";
            }
        }
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((Dictionary<string, object>)request)["marginCoin"] = getValue(market, "settleId");
        }
        object ommitted = this.omit(query, new List<object>() {"stop", "planType"});
        object response = await this.callAsync(method, this.extend(request, ommitted));
        return this.parseOrder(response, market);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("cancelOrders", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = this.safeString(parameters, "type", getValue(market, "type"));
        if (isTrue(isEqual(type, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a type parameter (one of \'spot\', \'swap\').")) ;
        }
        parameters = this.omit(parameters, "type");
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(isEqual(type, "spot")))
        {
            method = "apiPostOrderOrdersBatchcancel";
            ((Dictionary<string, object>)request)["method"] = "batchcancel";
            object jsonIds = this.json(ids);
            object parts = ((string)jsonIds).Split((string)"\"").ToList<object>();
            ((Dictionary<string, object>)request)["order_ids"] = String.Join("", parts);
        } else if (isTrue(isEqual(type, "swap")))
        {
            method = "privateMixPostOrderCancelBatchOrders";
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["marginCoin"] = getValue(market, "quote");
            ((Dictionary<string, object>)request)["orderIds"] = ids;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "success": [
        //                 "673451224205135872",
        //             ],
        //             "failed": [
        //                 {
        //                 "err-msg": "invalid record",
        //                 "order-id": "673451224205135873",
        //                 "err-code": "base record invalid"
        //                 }
        //             ]
        //         }
        //     }
        //
        //     swap
        //
        //     {
        //         "result":true,
        //         "symbol":"cmt_btcusdt",
        //         "order_ids":[
        //             "258414711",
        //             "478585558"
        //         ],
        //         "fail_infos":[
        //             {
        //                 "order_id":"258414711",
        //                 "err_code":"401",
        //                 "err_msg":""
        //             }
        //         ]
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelAllOrders
        * @description cancel all open orders
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#cancel-all-order
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#cancel-all-trigger-order-tpsl
        * @param {string|undefined} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @param {string} params.code marginCoin unified currency code
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("cancelAllOrders", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object productType = ((bool) isTrue((isEqual(subType, "linear")))) ? "UMCBL" : "DMCBL";
        if (isTrue(sandboxMode))
        {
            productType = add("S", productType);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrders () does not support spot markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "productType", productType },
        };
        object method = null;
        object stop = this.safeValue(query, "stop");
        object planType = this.safeString(query, "planType");
        if (isTrue(isTrue(!isEqual(stop, null)) || isTrue(!isEqual(planType, null))))
        {
            if (isTrue(isEqual(planType, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan, loss_plan, pos_profit, pos_loss, moving_plan or track_plan")) ;
            }
            method = "privateMixPostPlanCancelAllPlan";
        } else
        {
            object code = this.safeString2(parameters, "code", "marginCoin");
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders () requires a code argument [marginCoin] in the params")) ;
            }
            object currency = this.currency(code);
            ((Dictionary<string, object>)request)["marginCoin"] = this.safeCurrencyCode(code, currency);
            method = "privateMixPostOrderCancelAllOrders";
        }
        object ommitted = this.omit(query, new List<object>() {"stop", "code", "marginCoin"});
        object response = await this.callAsync(method, this.extend(request, ommitted));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1663312535998,
        //         "data": {
        //             "result": true,
        //             "order_ids": ["954564352813969409"],
        //             "fail_infos": [
        //                 {
        //                     "order_id": "",
        //                     "err_code": "",
        //                     "err_msg": ""
        //                 }
        //             ]
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOrder", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeOrderInfo" },
            { "swap", "privateMixGetOrderDetail" },
        });
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object response = await this.callAsync(method, this.extend(request, query));
        // spot
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645926849436',
        //       data: [
        //         {
        //           accountId: '6394957606',
        //           symbol: 'BTCUSDT_SPBL',
        //           orderId: '881626139738935296',
        //           clientOrderId: '525890c8-767e-4cd6-8585-38160ed7bb5e',
        //           price: '38000.000000000000',
        //           quantity: '0.000700000000',
        //           orderType: 'limit',
        //           side: 'buy',
        //           status: 'new',
        //           fillPrice: '0.000000000000',
        //           fillQuantity: '0.000000000000',
        //           fillTotalAmount: '0.000000000000',
        //           cTime: '1645921972212'
        //         }
        //       ]
        //     }
        //
        // swap
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645926587877',
        //       data: {
        //         symbol: 'BTCUSDT_UMCBL',
        //         size: '0.001',
        //         orderId: '881640729145409536',
        //         clientOid: '881640729204129792',
        //         filledQty: '0.001',
        //         fee: '0E-8',
        //         price: null,
        //         priceAvg: '38429.50',
        //         state: 'filled',
        //         side: 'open_long',
        //         timeInForce: 'normal',
        //         totalProfits: '0E-8',
        //         posSide: 'long',
        //         marginCoin: 'USDT',
        //         filledAmount: '38.4295',
        //         orderType: 'market',
        //         cTime: '1645925450611',
        //         uTime: '1645925450746'
        //       }
        //     }
        //
        object data = this.safeValue(response, "data");
        object first = this.safeValue(data, 0, data);
        return this.parseOrder(first, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of open order structures to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOpenOrders", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        object query = null;
                var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((List<object>)marketTypequeryVariable)[0];
        query = ((List<object>)marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeOpenOrders" },
            { "swap", "privateMixGetOrderCurrent" },
        });
        object stop = this.safeValue(query, "stop");
        if (isTrue(stop))
        {
            if (isTrue(isEqual(marketType, "spot")))
            {
                method = "privateSpotPostPlanCurrentPlan";
                if (isTrue(!isEqual(limit, null)))
                {
                    ((Dictionary<string, object>)request)["pageSize"] = limit;
                }
            } else
            {
                method = "privateMixGetPlanCurrentPlan";
            }
            query = this.omit(query, "stop");
        }
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //  spot
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645921640193,
        //       data: [
        //         {
        //           accountId: '6394957606',
        //           symbol: 'BTCUSDT_SPBL',
        //           orderId: '881623995442958336',
        //           clientOrderId: '135335e9-b054-4e43-b00a-499f11d3a5cc',
        //           price: '39000.000000000000',
        //           quantity: '0.000700000000',
        //           orderType: 'limit',
        //           side: 'buy',
        //           status: 'new',
        //           fillPrice: '0.000000000000',
        //           fillQuantity: '0.000000000000',
        //           fillTotalAmount: '0.000000000000',
        //           cTime: '1645921460972'
        //         }
        //       ]
        //     }
        //
        // swap
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645922324630,
        //       data: [
        //         {
        //           symbol: 'BTCUSDT_UMCBL',
        //           size: 0.001,
        //           orderId: '881627074081226752',
        //           clientOid: '881627074160918528',
        //           filledQty: 0,
        //           fee: 0,
        //           price: 38000,
        //           state: 'new',
        //           side: 'open_long',
        //           timeInForce: 'normal',
        //           totalProfits: 0,
        //           posSide: 'long',
        //           marginCoin: 'USDT',
        //           filledAmount: 0,
        //           orderType: 'limit',
        //           cTime: '1645922194995',
        //           uTime: '1645922194995'
        //         }
        //       ]
        //     }
        //
        // stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1652745815697,
        //         "data": [
        //             {
        //                 "orderId": "910246821491617792",
        //                 "symbol": "BTCUSDT_UMCBL",
        //                 "marginCoin": "USDT",
        //                 "size": "16",
        //                 "executePrice": "20000",
        //                 "triggerPrice": "24000",
        //                 "status": "not_trigger",
        //                 "orderType": "limit",
        //                 "planType": "normal_plan",
        //                 "side": "open_long",
        //                 "triggerType": "market_price",
        //                 "presetTakeProfitPrice": "0",
        //                 "presetTakeLossPrice": "0",
        //                 "cTime": "1652745674488"
        //             }
        //         ]
        //     }
        //
        // spot plan order
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1668134581006,
        //         "data": {
        //             "nextFlag": false,
        //             "endId": 974792555020390400,
        //             "orderList": [{
        //                 "orderId": "974792555020390400",
        //                 "symbol": "TRXUSDT_SPBL",
        //                 "size": "151",
        //                 "executePrice": "0.041572",
        //                 "triggerPrice": "0.041572",
        //                 "status": "not_trigger",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "triggerType": "fill_price",
        //                 "cTime": "1668134576563"
        //             }]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        if (!isTrue((data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            data = this.safeValue(data, "orderList", new List<object>() {});
        }
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-order-history
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#get-history-orders
        * @param {string} symbol unified market symbol of the closed orders
        * @param {int|undefined} since timestamp in ms of the earliest order
        * @param {int|undefined} limit the max number of closed orders to return
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbol("fetchClosedOrders", symbol);
        object market = this.market(symbol);
        object response = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object status = this.parseOrderStatus(this.safeString2(entry, "state", "status"));
            if (isTrue(isEqual(status, "closed")))
            {
                ((List<object>)result).Add(entry);
            }
        }
        return this.parseOrders(result, market, since, limit);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-order-history
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#get-history-orders
        * @param {string} symbol unified market symbol of the canceled orders
        * @param {int|undefined} since timestamp in ms of the earliest order
        * @param {int|undefined} limit the max number of canceled orders to return
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbol("fetchCanceledOrders", symbol);
        object market = this.market(symbol);
        object response = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object status = this.parseOrderStatus(this.safeString2(entry, "state", "status"));
            if (isTrue(isEqual(status, "canceled")))
            {
                ((List<object>)result).Add(entry);
            }
        }
        return this.parseOrders(result, market, since, limit);
    }

    public async virtual Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
                var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchCanceledAndClosedOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeHistory" },
            { "swap", "privateMixGetOrderHistory" },
        });
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(stop))
        {
            if (isTrue(isEqual(marketType, "spot")))
            {
                method = "privateSpotPostPlanHistoryPlan";
            } else
            {
                method = "privateMixGetPlanHistoryPlan";
            }
            parameters = this.omit(parameters, "stop");
        }
        if (isTrue(isTrue(isEqual(marketType, "swap")) || isTrue(stop)))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = 100;
            }
            ((Dictionary<string, object>)request)["pageSize"] = limit;
            if (isTrue(isEqual(since, null)))
            {
                since = 0;
            }
            ((Dictionary<string, object>)request)["startTime"] = since;
            ((Dictionary<string, object>)request)["endTime"] = this.milliseconds();
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1663623237813,
        //         "data": [
        //             {
        //                 "accountId": "7264631750",
        //                 "symbol": "BTCUSDT_SPBL",
        //                 "orderId": "909129926745432064",
        //                 "clientOrderId": "9e12ee3d-6a87-4e68-b1cc-094422d223a5",
        //                 "price": "30001.580000000000",
        //                 "quantity": "0.000600000000",
        //                 "orderType": "limit",
        //                 "side": "sell",
        //                 "status": "full_fill",
        //                 "fillPrice": "30001.580000000000",
        //                 "fillQuantity": "0.000600000000",
        //                 "fillTotalAmount": "18.000948000000",
        //                 "cTime": "1652479386030"
        //             },
        //             ...
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1663622728935,
        //         "data": {
        //             "nextFlag": false,
        //             "endId": "908510348120305664",
        //             "orderList": [
        //                 {
        //                     "symbol": "BTCUSDT_UMCBL",
        //                     "size": 0.004,
        //                     "orderId": "954568553644306433",
        //                     "clientOid": "954568553677860864",
        //                     "filledQty": 0.000,
        //                     "fee": 0E-8,
        //                     "price": 18000.00,
        //                     "state": "canceled",
        //                     "side": "open_long",
        //                     "timeInForce": "normal",
        //                     "totalProfits": 0E-8,
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "filledAmount": 0.0000,
        //                     "orderType": "limit",
        //                     "leverage": "3",
        //                     "marginMode": "fixed",
        //                     "cTime": "1663312798899",
        //                     "uTime": "1663312809425"
        //                 },
        //                 ...
        //             ]
        //         }
        //     }
        //
        // spot plan order
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1668134626684,
        //         "data": {
        //             "nextFlag": false,
        //             "endId": 974792060738441216,
        //             "orderList": [
        //                 {
        //                 "orderId": "974792060738441216",
        //                 "symbol": "TRXUSDT_SPBL",
        //                 "size": "156",
        //                 "executePrice": "0.041272",
        //                 "triggerPrice": "0.041222",
        //                 "status": "cancel",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "triggerType": "fill_price",
        //                 "cTime": "1668134458717"
        //                 }
        //             ]
        //         }
        //     }
        //
        // swap plan order
        //
        //     {
        //         "code":"00000",
        //         "data":[
        //             {
        //                 "orderId":"803521986049314816",
        //                 "executeOrderId":"84271931884910",
        //                 "symbol":"BTCUSDT_UMCBL",
        //                 "marginCoin":"USDT",
        //                 "size":"1",
        //                 "executePrice":"38923.1",
        //                 "triggerPrice":"45000.3",
        //                 "status":"cancel",
        //                 "orderType":"limit",
        //                 "planType":"normal_plan",
        //                 "side":"open_long",
        //                 "triggerType":"fill_price",
        //                 "presetTakeProfitPrice":"0",
        //                 "presetTakeLossPrice":"0",
        //                 "ctime":"1627300490867"
        //             }
        //         ],
        //         "msg":"success",
        //         "requestTime":1627354109502
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.safeValue(data, "orderList", data);
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["coinId"] = getValue(currency, "id");
        }
        object response = await this.privateSpotPostAccountBills(this.extend(request, parameters));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645929886887',
        //       data: [
        //         {
        //           billId: '881626974170554368',
        //           coinId: '2',
        //           coinName: 'USDT',
        //           groupType: 'transfer',
        //           bizType: 'transfer-out',
        //           quantity: '-10.00000000',
        //           balance: '73.36005300',
        //           fees: '0.00000000',
        //           cTime: '1645922171146'
        //         }
        //       ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //       billId: '881626974170554368',
        //       coinId: '2',
        //       coinName: 'USDT',
        //       groupType: 'transfer',
        //       bizType: 'transfer-out',
        //       quantity: '-10.00000000',
        //       balance: '73.36005300',
        //       fees: '0.00000000',
        //       cTime: '1645922171146'
        //     }
        //
        object id = this.safeString(item, "billId");
        object currencyId = this.safeString(item, "coinId");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.parseNumber(Precise.stringAbs(this.safeString(item, "quantity")));
        object timestamp = this.safeInteger(item, "cTime");
        object bizType = this.safeString(item, "bizType");
        object direction = null;
        if (isTrue(isTrue(!isEqual(bizType, null)) && isTrue(isGreaterThanOrEqual(getIndexOf(bizType, "-"), 0))))
        {
            object parts = ((string)bizType).Split((string)"-").ToList<object>();
            direction = getValue(parts, 1);
        }
        object type = this.safeString(item, "groupType");
        object fee = this.safeNumber(item, "fees");
        object after = this.safeNumber(item, "balance");
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", null },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchMyTrades", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchMyTrades() only supports spot markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateSpotPostTradeFills(this.extend(request, parameters));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645918954082',
        //       data: [
        //         {
        //           accountId: '6394957606',
        //           symbol: 'LTCUSDT_SPBL',
        //           orderId: '864752115272552448',
        //           fillId: '864752115685969921',
        //           orderType: 'limit',
        //           side: 'buy',
        //           fillPrice: '127.92000000',
        //           fillQuantity: '0.10000000',
        //           fillTotalAmount: '12.79200000',
        //           feeCcy: 'LTC',
        //           fees: '0.00000000',
        //           cTime: '1641898891373'
        //         }
        //       ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTrades(data, market, since, limit);
    }

    public async virtual Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOrderTrades", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrderTrades", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateSpotPostTradeFills" },
            { "swap", "privateMixGetOrderFills" },
        });
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object response = await this.callAsync(method, this.extend(request, query));
        // spot
        //
        // swap
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: 1645927862710,
        //       data: [
        //         {
        //           tradeId: '881640729552281602',
        //           symbol: 'BTCUSDT_UMCBL',
        //           orderId: '881640729145409536',
        //           price: '38429.50',
        //           sizeQty: '0.001',
        //           fee: '0',
        //           side: 'open_long',
        //           fillAmount: '38.4295',
        //           profit: '0',
        //           cTime: '1645925450694'
        //         }
        //       ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchPosition
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateMixGetPositionSinglePosition(this.extend(request, parameters));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645933957584',
        //       data: [
        //         {
        //           marginCoin: 'USDT',
        //           symbol: 'BTCUSDT_UMCBL',
        //           holdSide: 'long',
        //           openDelegateCount: '0',
        //           margin: '1.921475',
        //           available: '0.001',
        //           locked: '0',
        //           total: '0.001',
        //           leverage: '20',
        //           achievedProfits: '0',
        //           averageOpenPrice: '38429.5',
        //           marginMode: 'fixed',
        //           holdMode: 'double_hold',
        //           unrealizedPL: '0.1634',
        //           liquidationPrice: '0',
        //           keepMarginRate: '0.004',
        //           cTime: '1645922194988'
        //         }
        //       ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parsePositions(data);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeString(symbols, 0);
            market = this.market(first);
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object productType = ((bool) isTrue((isEqual(subType, "linear")))) ? "UMCBL" : "DMCBL";
        if (isTrue(sandboxMode))
        {
            productType = add("S", productType);
        }
        object request = new Dictionary<string, object>() {
            { "productType", productType },
        };
        object response = await this.privateMixGetPositionAllPosition(this.extend(request, parameters));
        //
        //     {
        //       code: '00000',
        //       msg: 'success',
        //       requestTime: '1645933905060',
        //       data: [
        //         {
        //           marginCoin: 'USDT',
        //           symbol: 'BTCUSDT_UMCBL',
        //           holdSide: 'long',
        //           openDelegateCount: '0',
        //           margin: '1.921475',
        //           available: '0.001',
        //           locked: '0',
        //           total: '0.001',
        //           leverage: '20',
        //           achievedProfits: '0',
        //           averageOpenPrice: '38429.5',
        //           marginMode: 'fixed',
        //           holdMode: 'double_hold',
        //           unrealizedPL: '0.14869',
        //           liquidationPrice: '0',
        //           keepMarginRate: '0.004',
        //           cTime: '1645922194988'
        //         }
        //       ]
        //     }
        //
        object position = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parsePosition(getValue(position, i)));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         marginCoin: 'USDT',
        //         symbol: 'BTCUSDT_UMCBL',
        //         holdSide: 'long',
        //         openDelegateCount: '0',
        //         margin: '1.921475',
        //         available: '0.001',
        //         locked: '0',
        //         total: '0.001',
        //         leverage: '20',
        //         achievedProfits: '0',
        //         averageOpenPrice: '38429.5',
        //         marginMode: 'fixed',
        //         holdMode: 'double_hold',
        //         unrealizedPL: '0.14869',
        //         liquidationPrice: '0',
        //         keepMarginRate: '0.004',
        //         cTime: '1645922194988'
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(position, "cTime");
        object marginMode = this.safeString(position, "marginMode");
        object collateral = null;
        object initialMargin = null;
        object unrealizedPnl = this.safeString(position, "unrealizedPL");
        object rawCollateral = this.safeString(position, "margin");
        if (isTrue(isEqual(marginMode, "fixed")))
        {
            marginMode = "isolated";
            collateral = Precise.stringAdd(rawCollateral, unrealizedPnl);
        } else if (isTrue(isEqual(marginMode, "crossed")))
        {
            marginMode = "cross";
            initialMargin = rawCollateral;
        }
        object holdMode = this.safeString(position, "holdMode");
        object hedged = null;
        if (isTrue(isEqual(holdMode, "double_hold")))
        {
            hedged = true;
        } else if (isTrue(isEqual(holdMode, "single_hold")))
        {
            hedged = false;
        }
        object side = this.safeString(position, "holdSide");
        object leverage = this.safeString(position, "leverage");
        object contractSizeNumber = this.safeValue(market, "contractSize");
        object contractSize = this.numberToString(contractSizeNumber);
        object baseAmount = this.safeString(position, "total");
        object entryPrice = this.safeString(position, "averageOpenPrice");
        object maintenanceMarginPercentage = this.safeString(position, "keepMarginRate");
        object openNotional = Precise.stringMul(entryPrice, baseAmount);
        if (isTrue(isEqual(initialMargin, null)))
        {
            initialMargin = Precise.stringDiv(openNotional, leverage);
        }
        object contracts = this.parseNumber(Precise.stringDiv(baseAmount, contractSize));
        object markPrice = this.safeString(position, "marketPrice");
        object notional = Precise.stringMul(baseAmount, markPrice);
        object initialMarginPercentage = Precise.stringDiv(initialMargin, notional);
        object liquidationPrice = this.parseNumber(this.omitZero(this.safeString(position, "liquidationPrice")));
        object calcTakerFeeRate = "0.0006";
        object calcTakerFeeMult = "0.9994";
        if (isTrue(isTrue(isTrue((isEqual(liquidationPrice, null))) && isTrue((isEqual(marginMode, "isolated")))) && isTrue(Precise.stringGt(baseAmount, "0"))))
        {
            object signedMargin = Precise.stringDiv(rawCollateral, baseAmount);
            object signedMmp = maintenanceMarginPercentage;
            if (isTrue(isEqual(side, "short")))
            {
                signedMargin = Precise.stringNeg(signedMargin);
                signedMmp = Precise.stringNeg(signedMmp);
            }
            object mmrMinusOne = Precise.stringSub("1", signedMmp);
            object numerator = Precise.stringSub(entryPrice, signedMargin);
            if (isTrue(isEqual(side, "long")))
            {
                mmrMinusOne = Precise.stringMul(mmrMinusOne, calcTakerFeeMult);
            } else
            {
                numerator = Precise.stringMul(numerator, calcTakerFeeMult);
            }
            liquidationPrice = this.parseNumber(Precise.stringDiv(numerator, mmrMinusOne));
        }
        object feeToClose = Precise.stringMul(notional, calcTakerFeeRate);
        object maintenanceMargin = Precise.stringAdd(Precise.stringMul(maintenanceMarginPercentage, notional), feeToClose);
        object marginRatio = Precise.stringDiv(maintenanceMargin, collateral);
        object percentage = Precise.stringMul(Precise.stringDiv(unrealizedPnl, initialMargin, 4), "100");
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", this.parseNumber(notional) },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnl) },
            { "percentage", this.parseNumber(percentage) },
            { "contracts", contracts },
            { "contractSize", contractSizeNumber },
            { "markPrice", this.parseNumber(markPrice) },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverage) },
            { "marginRatio", this.parseNumber(marginRatio) },
        };
    }

    public async virtual Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchFundingRateHistory", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.publicMixGetMarketHistoryFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1652406728393,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "fundingRate": "-0.0003",
        //                 "settleTime": "1652396400000"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market);
            object timestamp = this.safeInteger(entry, "settleTime");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeString(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicMixGetMarketCurrentFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1652401684275,
        //         "data": {
        //             "symbol": "BTCUSDT_UMCBL",
        //             "fundingRate": "-0.000182"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT_UMCBL",
        //         "fundingRate": "-0.000182"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async virtual Task<object> fetchFundingHistory(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingHistory
        * @description fetch the funding history
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#get-account-bill
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the starting timestamp in milliseconds
        * @param {int|undefined} limit the number of entries to return
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
        }
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 31556952000); // 1 year
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "quoteId") },
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object response = await this.privateMixGetAccountAccountBill(this.extend(request, parameters));
        //
        //    {
        //        "code": "00000",
        //        "msg": "success",
        //        "data": {
        //            "result": [
        //                {
        //                    "id": "892962903462432768",
        //                    "symbol": "ETHUSDT_UMCBL",
        //                    "marginCoin": "USDT",
        //                    "amount": "0",
        //                    "fee": "-0.1765104",
        //                    "feeByCoupon": "",
        //                    "feeCoin": "USDT",
        //                    "business": "contract_settle_fee",
        //                    "cTime": "1648624867354"
        //                }
        //            ],
        //            "endId": "885353495773458432",
        //            "nextFlag": false,
        //            "preFlag": false
        //    }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.safeValue(data, "result", new List<object>() {});
        return this.parseFundingHistories(result, market, since, limit);
    }

    public virtual object parseFundingHistory(object contract, object market = null)
    {
        //
        //     {
        //         "id": "892962903462432768",
        //         "symbol": "ETHUSDT_UMCBL",
        //         "marginCoin": "USDT",
        //         "amount": "0",
        //         "fee": "-0.1765104",
        //         "feeByCoupon": "",
        //         "feeCoin": "USDT",
        //         "business": "contract_settle_fee",
        //         "cTime": "1648624867354"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "swap");
        object currencyId = this.safeString(contract, "marginCoin");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeNumber(contract, "amount");
        object timestamp = this.safeInteger(contract, "cTime");
        object id = this.safeString(contract, "id");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "code", code },
            { "amount", amount },
            { "id", id },
        };
    }

    public virtual object parseFundingHistories(object contracts, object market = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(contracts)); postFixIncrement(ref i))
        {
            object contract = getValue(contracts, i);
            object business = this.safeString(contract, "business");
            if (isTrue(!isEqual(business, "contract_settle_fee")))
            {

            }
            ((List<object>)result).Add(this.parseFundingHistory(contract, market));
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object holdSide = this.safeString(parameters, "holdSide");
        object market = this.market(symbol);
        object marginCoin = ((bool) isTrue((getValue(market, "linear")))) ? getValue(market, "quote") : getValue(market, "base");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", marginCoin },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "holdSide", holdSide },
        };
        parameters = this.omit(parameters, "holdSide");
        object response = await this.privateMixPostAccountSetMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1652483636792,
        //         "data": {
        //             "result": true
        //         }
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "00000")))) ? "ok" : "failed";
        object code = ((bool) isTrue((getValue(market, "linear")))) ? getValue(market, "quote") : getValue(market, "base");
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", null },
            { "amount", null },
            { "code", code },
            { "symbol", getValue(market, "symbol") },
            { "status", status },
        };
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isGreaterThan(amount, 0)))
        {
            throw new BadRequest ((string)add(this.id, " reduceMargin() amount parameter must be a negative value")) ;
        }
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " reduceMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " addMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async virtual Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchLeverage
        * @description fetch the set leverage for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateMixGetAccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 0,
        //         "data": {
        //             "marginCoin": "SUSDT",
        //             "locked": "0",
        //             "available": "3000",
        //             "crossMaxAvailable": "3000",
        //             "fixedMaxAvailable": "3000",
        //             "maxTransferOut": "3000",
        //             "equity": "3000",
        //             "usdtEquity": "3000",
        //             "btcEquity": "0.12217217236",
        //             "crossRiskRate": "0",
        //             "crossMarginLeverage": 20,
        //             "fixedLongLeverage": 40,
        //             "fixedShortLeverage": 10,
        //             "marginMode": "fixed",
        //             "holdMode": "double_hold",
        //             "unrealizedPL": null,
        //             "bonus": "0"
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("setLeverage", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "leverage", leverage },
        };
        return await this.privateMixPostAccountSetLeverage(this.extend(request, parameters));
    }

    public async virtual Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("setMarginMode", symbol);
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue((!isEqual(marginMode, "fixed"))) && isTrue((!isEqual(marginMode, "crossed")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() marginMode must be \"fixed\" or \"crossed\"")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "marginMode", marginMode },
        };
        return await this.privateMixPostAccountSetMarginMode(this.extend(request, parameters));
    }

    public async virtual Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setPositionMode
        * @description set hedged to true or false for a market
        * @param {bool} hedged set to true to use dualSidePosition
        * @param {string|undefined} symbol not used by bitget setPositionMode ()
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {object} response from the exchange
        *
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        object holdMode = ((bool) isTrue(hedged)) ? "double_hold" : "single_hold";
        object request = new Dictionary<string, object>() {
            { "holdMode", holdMode },
        };
        object subType = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
                var subTypeparametersVariable = this.handleSubTypeAndParams("setPositionMode", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object productType = ((bool) isTrue((isEqual(subType, "linear")))) ? "UMCBL" : "DMCBL";
        if (isTrue(sandboxMode))
        {
            productType = add("S", productType);
        }
        ((Dictionary<string, object>)request)["productType"] = productType;
        object response = await this.privateMixPostAccountSetPositionMode(this.extend(request, parameters));
        //
        //    {
        //         "code": "40919",
        //         "msg": "This function is not open yet",
        //         "requestTime": 1672212431093,
        //         "data": null
        //     }
        //
        return response;
    }

    public async virtual Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://bitgetlimited.github.io/apidoc/en/mix/#get-open-interest
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} params exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicMixGetMarketOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 0,
        //         "data": {
        //             "symbol": "BTCUSDT_UMCBL",
        //             "amount": "130818.967",
        //             "timestamp": "1663399151127"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#get-transfer-list
        * @param {string|undefined} code unified currency code of the currency transferred
        * @param {int|undefined} since the earliest time in ms to fetch transfers for
        * @param {int|undefined} limit the maximum number of  transfers structures to retrieve
        * @param {object} params extra parameters specific to the bitget api endpoint
        * @returns {[object]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchTransfers", null, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object fromAccount = this.safeString(parameters, "fromAccount", type);
        parameters = this.omit(parameters, "fromAccount");
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        type = this.safeString(accountsByType, fromAccount);
        object request = new Dictionary<string, object>() {
            { "fromType", type },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["coinId"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateSpotGetAccountTransferRecords(this.extend(request, parameters));
        //
        //     {
        //         "code":"00000",
        //         "message":"success",
        //         "data":[{
        //             "cTime":"1622697148",
        //             "coinId":"22",
        //             "coinName":"usdt",
        //             "groupType":"deposit",
        //             "bizType":"transfer-in",
        //             "quantity":"1",
        //             "balance": "1",
        //             "fees":"0",
        //             "billId":"1291"
        //         }]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#transfer
        * @see https://bitgetlimited.github.io/apidoc/en/spot/#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the bitget api endpoint
        *
        * EXCHANGE SPECIFIC PARAMS
        * @param {string} params.clientOid custom id
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object fromSwap = isEqual(fromAccount, "swap");
        object toSwap = isEqual(toAccount, "swap");
        object usdt = isEqual(getValue(currency, "code"), "USDT");
        if (isTrue(fromSwap))
        {
            fromAccount = ((bool) isTrue(usdt)) ? "mix_usdt" : "mix_usd";
        } else if (isTrue(toSwap))
        {
            toAccount = ((bool) isTrue(usdt)) ? "mix_usdt" : "mix_usd";
        }
        object request = new Dictionary<string, object>() {
            { "fromType", fromAccount },
            { "toType", toAccount },
            { "amount", amount },
            { "coin", getValue(getValue(currency, "info"), "coinName") },
        };
        object response = await this.privateSpotPostWalletTransfer(this.extend(request, parameters));
        //
        //    {
        //        "code": "00000",
        //        "msg": "success",
        //        "requestTime": 1668119107154,
        //        "data": "SUCCESS"
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //    {
        //        "code": "00000",
        //        "msg": "success",
        //        "requestTime": 1668119107154,
        //        "data": "SUCCESS"
        //    }
        //
        // fetchTransfers
        //
        //     {
        //         "cTime":"1622697148",
        //         "coinId":"22",
        //         "coinName":"usdt",
        //         "groupType":"deposit",
        //         "bizType":"transfer-in",
        //         "quantity":"1",
        //         "balance": "1",
        //         "fees":"0",
        //         "billId":"1291"
        //     }
        //
        object timestamp = this.safeInteger2(transfer, "requestTime", "tradeTime");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeTimestamp(transfer, "cTime");
        }
        object msg = this.safeStringLowerN(transfer, new List<object>() {"msg", "status"});
        object currencyId = this.safeString2(transfer, "code", "coinName");
        if (isTrue(isEqual(currencyId, "00000")))
        {
            currencyId = null;
        }
        object fromAccountRaw = this.safeString(transfer, "fromType");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(accountsById, fromAccountRaw, fromAccountRaw);
        object toAccountRaw = this.safeString(transfer, "toType");
        object toAccount = this.safeString(accountsById, toAccountRaw, toAccountRaw);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString2(transfer, "id", "billId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "amount", this.safeNumberN(transfer, new List<object>() {"size", "quantity", "amount"}) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(msg) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
            { "successful", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT_UMCBL",
        //         "amount": "130818.967",
        //         "timestamp": "1663399151127"
        //     }
        //
        object timestamp = this.safeInteger(interest, "timestamp");
        object id = this.safeString(interest, "symbol");
        object symbol = this.safeSymbol(id, market);
        object amount = this.safeNumber(interest, "amount");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "openInterestAmount", amount },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        // spot
        //
        //     {"status":"fail","err_code":"01001","err_msg":"系统异常，请稍后重试"}
        //     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
        //     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
        //     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
        //     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
        //     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
        //     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
        //     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
        //     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
        //     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
        //
        // swap
        //
        //     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
        //     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
        //     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
        //     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
        //     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
        //     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
        //     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":"订单不存在！"}
        //
        object message = this.safeString(response, "err_msg");
        object errorCode = this.safeString2(response, "code", "err_code");
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, ""))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        object nonZeroErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "00000")));
        if (isTrue(nonZeroErrorCode))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        if (isTrue(isTrue(nonZeroErrorCode) || isTrue(nonEmptyMessage)))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object pathPart = ((bool) isTrue((isEqual(endpoint, "spot")))) ? "/api/spot/v1" : "/api/mix/v1";
        object request = add("/", this.implodeParams(path, parameters));
        object payload = add(pathPart, request);
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), endpoint)), payload);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(!isTrue(signed) && isTrue((isEqual(method, "GET")))))
        {
            object keys = new List<string>(((Dictionary<string,object>)query).Keys);
            object keysLength = getArrayLength(keys);
            if (isTrue(isGreaterThan(keysLength, 0)))
            {
                url = add(add(url, "?"), this.urlencode(query));
            }
        }
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object auth = add(add(timestamp, method), payload);
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(parameters);
                auth = add(auth, body);
            } else
            {
                if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
                {
                    object queryInner = add("?", this.urlencode(this.keysort(parameters)));
                    url = add(url, queryInner);
                    auth = add(auth, queryInner);
                }
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object broker = this.safeString(this.options, "broker");
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-SIGN", signature },
                { "ACCESS-TIMESTAMP", timestamp },
                { "ACCESS-PASSPHRASE", this.password },
                { "X-CHANNEL-API-CODE", broker },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
