using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class gate : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "gate" },
            { "name", "Gate.io" },
            { "countries", new List<object>() {"KR"} },
            { "rateLimit", divide(10, 3) },
            { "version", "v4" },
            { "certified", true },
            { "pro", true },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg" },
                { "doc", "https://www.gate.io/docs/developers/apiv4/en/" },
                { "www", "https://gate.io/" },
                { "api", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "wallet", "https://api.gateio.ws/api/v4" },
                        { "futures", "https://api.gateio.ws/api/v4" },
                        { "margin", "https://api.gateio.ws/api/v4" },
                        { "delivery", "https://api.gateio.ws/api/v4" },
                        { "spot", "https://api.gateio.ws/api/v4" },
                        { "options", "https://api.gateio.ws/api/v4" },
                        { "sub_accounts", "https://api.gateio.ws/api/v4" },
                        { "earn", "https://api.gateio.ws/api/v4" },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "withdrawals", "https://api.gateio.ws/api/v4" },
                        { "wallet", "https://api.gateio.ws/api/v4" },
                        { "futures", "https://api.gateio.ws/api/v4" },
                        { "margin", "https://api.gateio.ws/api/v4" },
                        { "delivery", "https://api.gateio.ws/api/v4" },
                        { "spot", "https://api.gateio.ws/api/v4" },
                        { "options", "https://api.gateio.ws/api/v4" },
                        { "subAccounts", "https://api.gateio.ws/api/v4" },
                        { "rebate", "https://api.gateio.ws/api/v4" },
                        { "earn", "https://api.gateio.ws/api/v4" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "futures", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "delivery", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "options", "https://fx-api-testnet.gateio.ws/api/v4" },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "futures", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "delivery", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "options", "https://fx-api-testnet.gateio.ws/api/v4" },
                    } },
                } },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.gate.io/ref/2436035" },
                    { "discount", 0.2 },
                } },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "addMargin", true },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createMarketOrder", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchNetworkDepositAddress", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "wallet", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currency_chains", 1.5 },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 1 },
                            { "currencies/{currency}", 1 },
                            { "currency_pairs", 1 },
                            { "currency_pairs/{currency_pair}", 1 },
                            { "tickers", 1 },
                            { "order_book", 1 },
                            { "trades", 1 },
                            { "candlesticks", 1 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currency_pairs", 1 },
                            { "currency_pairs/{currency_pair}", 1 },
                            { "cross/currencies", 1 },
                            { "cross/currencies/{currency}", 1 },
                            { "funding_book", 1 },
                        } },
                    } },
                    { "futures", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/contracts", 1.5 },
                            { "{settle}/contracts/{contract}", 1.5 },
                            { "{settle}/order_book", 1.5 },
                            { "{settle}/trades", 1.5 },
                            { "{settle}/candlesticks", 1.5 },
                            { "{settle}/tickers", 1.5 },
                            { "{settle}/funding_rate", 1.5 },
                            { "{settle}/insurance", 1.5 },
                            { "{settle}/contract_stats", 1.5 },
                            { "{settle}/liq_orders", 1.5 },
                        } },
                    } },
                    { "delivery", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/contracts", 1.5 },
                            { "{settle}/contracts/{contract}", 1.5 },
                            { "{settle}/order_book", 1.5 },
                            { "{settle}/trades", 1.5 },
                            { "{settle}/candlesticks", 1.5 },
                            { "{settle}/tickers", 1.5 },
                            { "{settle}/insurance", 1.5 },
                        } },
                    } },
                    { "options", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "underlyings", 1.5 },
                            { "expirations", 1.5 },
                            { "contracts", 1.5 },
                            { "contracts/{contract}", 1.5 },
                            { "settlements", 1.5 },
                            { "settlements/{contract}", 1.5 },
                            { "order_book", 1.5 },
                            { "tickers", 1.5 },
                            { "underlying/tickers/{underlying}", 1.5 },
                            { "candlesticks", 1.5 },
                            { "underlying/candlesticks", 1.5 },
                            { "trades", 1.5 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "uni/currencies", 1.5 },
                            { "uni/currencies/{currency}", 1.5 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "withdrawals", new Dictionary<string, object>() {
                        { "post", new Dictionary<string, object>() {
                            { "withdrawals", 3000 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "withdrawals/{withdrawal_id}", 300 },
                        } },
                    } },
                    { "wallet", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "deposit_address", 300 },
                            { "withdrawals", 300 },
                            { "deposits", 300 },
                            { "sub_account_transfers", 300 },
                            { "withdraw_status", 300 },
                            { "sub_account_balances", 300 },
                            { "fee", 300 },
                            { "total_balance", 300 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "transfers", 300 },
                            { "sub_account_transfers", 300 },
                        } },
                    } },
                    { "subAccounts", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "sub_accounts", 1 },
                            { "sub_accounts/{user_id}", 1 },
                            { "sub_accounts/{user_id}/keys", 1 },
                            { "sub_accounts/{user_id}/keys/{key}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "sub_accounts", 1 },
                            { "sub_accounts/{user_id}/keys", 1 },
                            { "sub_accounts/{user_id}/lock", 1 },
                            { "sub_accounts/{user_id}/unlock", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "sub_accounts/{user_id}/keys/{key}", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "sub_accounts/{user_id}/keys/{key}", 1 },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", 1 },
                            { "open_orders", 1 },
                            { "orders", 1 },
                            { "orders/{order_id}", 1 },
                            { "my_trades", 1 },
                            { "price_orders", 1 },
                            { "price_orders/{order_id}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "batch_orders", 1 },
                            { "orders", 1 },
                            { "cancel_batch_orders", 1 },
                            { "price_orders", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "orders", 1 },
                            { "orders/{order_id}", 1 },
                            { "price_orders", 1 },
                            { "price_orders/{order_id}", 1 },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "orders/{order_id}", 1 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", 1.5 },
                            { "account_book", 1.5 },
                            { "funding_accounts", 1.5 },
                            { "loans", 1.5 },
                            { "loans/{loan_id}", 1.5 },
                            { "loans/{loan_id}/repayment", 1.5 },
                            { "loan_records", 1.5 },
                            { "loan_records/{load_record_id}", 1.5 },
                            { "auto_repay", 1.5 },
                            { "transferable", 1.5 },
                            { "cross/accounts", 1.5 },
                            { "cross/account_book", 1.5 },
                            { "cross/loans", 1.5 },
                            { "cross/loans/{loan_id}", 1.5 },
                            { "cross/loans/repayments", 1.5 },
                            { "cross/transferable", 1.5 },
                            { "loan_records/{loan_record_id}", 1.5 },
                            { "borrowable", 1.5 },
                            { "cross/repayments", 1.5 },
                            { "cross/borrowable", 1.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "loans", 1.5 },
                            { "merged_loans", 1.5 },
                            { "loans/{loan_id}/repayment", 1.5 },
                            { "auto_repay", 1.5 },
                            { "cross/loans", 1.5 },
                            { "cross/loans/repayments", 1.5 },
                            { "cross/repayments", 1.5 },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "loans/{loan_id}", 1.5 },
                            { "loan_records/{loan_record_id}", 1.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "loans/{loan_id}", 1.5 },
                        } },
                    } },
                    { "futures", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/accounts", 1.5 },
                            { "{settle}/account_book", 1.5 },
                            { "{settle}/positions", 1.5 },
                            { "{settle}/positions/{contract}", 1.5 },
                            { "{settle}/orders", 1.5 },
                            { "{settle}/orders/{order_id}", 1.5 },
                            { "{settle}/my_trades", 1.5 },
                            { "{settle}/position_close", 1.5 },
                            { "{settle}/liquidates", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                            { "{settle}/price_orders/{order_id}", 1.5 },
                            { "{settle}/dual_comp/positions/{contract}", 1.5 },
                            { "{settle}/auto_deleverages", 1.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "{settle}/positions/{contract}/margin", 1.5 },
                            { "{settle}/positions/{contract}/leverage", 1.5 },
                            { "{settle}/positions/{contract}/risk_limit", 1.5 },
                            { "{settle}/dual_mode", 1.5 },
                            { "{settle}/dual_comp/positions/{contract}", 1.5 },
                            { "{settle}/dual_comp/positions/{contract}/margin", 1.5 },
                            { "{settle}/dual_comp/positions/{contract}/leverage", 1.5 },
                            { "{settle}/dual_comp/positions/{contract}/risk_limit", 1.5 },
                            { "{settle}/orders", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "{settle}/orders", 1.5 },
                            { "{settle}/orders/{order_id}", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                            { "{settle}/price_orders/{order_id}", 1.5 },
                        } },
                    } },
                    { "delivery", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/accounts", 1.5 },
                            { "{settle}/account_book", 1.5 },
                            { "{settle}/positions", 1.5 },
                            { "{settle}/positions/{contract}", 1.5 },
                            { "{settle}/orders", 1.5 },
                            { "{settle}/orders/{order_id}", 1.5 },
                            { "{settle}/my_trades", 1.5 },
                            { "{settle}/position_close", 1.5 },
                            { "{settle}/liquidates", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                            { "{settle}/price_orders/{order_id}", 1.5 },
                            { "{settle}/settlements", 1.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "{settle}/positions/{contract}/margin", 1.5 },
                            { "{settle}/positions/{contract}/leverage", 1.5 },
                            { "{settle}/positions/{contract}/risk_limit", 1.5 },
                            { "{settle}/orders", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "{settle}/orders", 1.5 },
                            { "{settle}/orders/{order_id}", 1.5 },
                            { "{settle}/price_orders", 1.5 },
                            { "{settle}/price_orders/{order_id}", 1.5 },
                        } },
                    } },
                    { "options", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", 1.5 },
                            { "account_book", 1.5 },
                            { "positions", 1.5 },
                            { "positions/{contract}", 1.5 },
                            { "position_close", 1.5 },
                            { "orders", 1.5 },
                            { "orders/{order_id}", 1.5 },
                            { "my_trades", 1.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orders", 1.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "orders", 1.5 },
                            { "orders/{order_id}", 1.5 },
                        } },
                    } },
                    { "rebate", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "agency/transaction_history", 1.5 },
                            { "agency/commission_history", 1.5 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "uni/lends", 1.5 },
                            { "uni/lend_records", 1.5 },
                            { "uni/interests/{currency}", 1.5 },
                            { "uni/interest_records", 1.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "uni/lends", 1.5 },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "uni/lends", 1.5 },
                        } },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "10s", "10s" },
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "1d", "1d" },
                { "7d", "7d" },
                { "1w", "7d" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "88MPH", "MPH" },
                { "AXIS", "Axis DeFi" },
                { "BIFI", "Bitcoin File" },
                { "BOX", "DefiBox" },
                { "BTCBEAR", "BEAR" },
                { "BTCBULL", "BULL" },
                { "BYN", "BeyondFi" },
                { "EGG", "Goose Finance" },
                { "GTC", "Game.com" },
                { "GTC_HT", "Game.com HT" },
                { "GTC_BSC", "Game.com BSC" },
                { "HIT", "HitChain" },
                { "MM", "Million" },
                { "MPH", "Morpher" },
                { "POINT", "GatePoint" },
                { "RAI", "Rai Reflex Index" },
                { "SBTC", "Super Bitcoin" },
                { "TNC", "Trinity Network Credit" },
                { "VAI", "VAIOT" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "headers", new Dictionary<string, object>() {
                { "X-Gate-Channel-Id", "ccxt" },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "createOrder", new Dictionary<string, object>() {
                    { "expiration", 86400 },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                } },
                { "timeInForce", new Dictionary<string, object>() {
                    { "GTC", "gtc" },
                    { "IOC", "ioc" },
                    { "PO", "poc" },
                    { "POC", "poc" },
                    { "FOK", "fok" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "funding", "spot" },
                    { "spot", "spot" },
                    { "margin", "margin" },
                    { "cross_margin", "cross_margin" },
                    { "cross", "cross_margin" },
                    { "isolated", "margin" },
                    { "swap", "futures" },
                    { "future", "delivery" },
                    { "futures", "futures" },
                    { "delivery", "delivery" },
                } },
                { "defaultType", "spot" },
                { "swap", new Dictionary<string, object>() {
                    { "fetchMarkets", new Dictionary<string, object>() {
                        { "settlementCurrencies", new List<object>() {"usdt", "btc"} },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "fetchMarkets", new Dictionary<string, object>() {
                        { "settlementCurrencies", new List<object>() {"usdt"} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "feeSide", "get" },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00185")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00175")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00165")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00155")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00145")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00135")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00125")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00115")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00105")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00095")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00085")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00055")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00055")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00055")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00195")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00185")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00175")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00165")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00155")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00145")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00135")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00125")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00115")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00105")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00095")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00085")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00065")}} },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "feeSide", "base" },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0") },
                    { "taker", this.parseNumber("0.0005") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0000")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("3"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("6"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("25"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("75"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("200"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("500"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("1250"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("2500"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("3000"), this.parseNumber("-0.00008")}, new List<object> {this.parseNumber("6000"), this.parseNumber("-0.01000")}, new List<object> {this.parseNumber("11000"), this.parseNumber("-0.01002")}, new List<object> {this.parseNumber("20000"), this.parseNumber("-0.01005")}, new List<object> {this.parseNumber("40000"), this.parseNumber("-0.02000")}, new List<object> {this.parseNumber("75000"), this.parseNumber("-0.02005")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00050")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00048")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00046")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00044")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00042")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00040")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00038")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00036")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00034")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00032")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00030")}} },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INVALID_PARAM_VALUE", typeof(BadRequest) },
                    { "INVALID_PROTOCOL", typeof(BadRequest) },
                    { "INVALID_ARGUMENT", typeof(BadRequest) },
                    { "INVALID_REQUEST_BODY", typeof(BadRequest) },
                    { "MISSING_REQUIRED_PARAM", typeof(ArgumentsRequired) },
                    { "BAD_REQUEST", typeof(BadRequest) },
                    { "INVALID_CONTENT_TYPE", typeof(BadRequest) },
                    { "NOT_ACCEPTABLE", typeof(BadRequest) },
                    { "METHOD_NOT_ALLOWED", typeof(BadRequest) },
                    { "NOT_FOUND", typeof(ExchangeError) },
                    { "INVALID_CREDENTIALS", typeof(AuthenticationError) },
                    { "INVALID_KEY", typeof(AuthenticationError) },
                    { "IP_FORBIDDEN", typeof(AuthenticationError) },
                    { "READ_ONLY", typeof(PermissionDenied) },
                    { "INVALID_SIGNATURE", typeof(AuthenticationError) },
                    { "MISSING_REQUIRED_HEADER", typeof(AuthenticationError) },
                    { "REQUEST_EXPIRED", typeof(AuthenticationError) },
                    { "ACCOUNT_LOCKED", typeof(AccountSuspended) },
                    { "FORBIDDEN", typeof(PermissionDenied) },
                    { "SUB_ACCOUNT_NOT_FOUND", typeof(ExchangeError) },
                    { "SUB_ACCOUNT_LOCKED", typeof(AccountSuspended) },
                    { "MARGIN_BALANCE_EXCEPTION", typeof(ExchangeError) },
                    { "MARGIN_TRANSFER_FAILED", typeof(ExchangeError) },
                    { "TOO_MUCH_FUTURES_AVAILABLE", typeof(ExchangeError) },
                    { "FUTURES_BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "ACCOUNT_EXCEPTION", typeof(ExchangeError) },
                    { "SUB_ACCOUNT_TRANSFER_FAILED", typeof(ExchangeError) },
                    { "ADDRESS_NOT_USED", typeof(ExchangeError) },
                    { "TOO_FAST", typeof(RateLimitExceeded) },
                    { "WITHDRAWAL_OVER_LIMIT", typeof(ExchangeError) },
                    { "API_WITHDRAW_DISABLED", typeof(ExchangeNotAvailable) },
                    { "INVALID_WITHDRAW_ID", typeof(ExchangeError) },
                    { "INVALID_WITHDRAW_CANCEL_STATUS", typeof(ExchangeError) },
                    { "INVALID_PRECISION", typeof(InvalidOrder) },
                    { "INVALID_CURRENCY", typeof(BadSymbol) },
                    { "INVALID_CURRENCY_PAIR", typeof(BadSymbol) },
                    { "POC_FILL_IMMEDIATELY", typeof(OrderImmediatelyFillable) },
                    { "ORDER_NOT_FOUND", typeof(OrderNotFound) },
                    { "CLIENT_ID_NOT_FOUND", typeof(OrderNotFound) },
                    { "ORDER_CLOSED", typeof(InvalidOrder) },
                    { "ORDER_CANCELLED", typeof(InvalidOrder) },
                    { "QUANTITY_NOT_ENOUGH", typeof(InvalidOrder) },
                    { "BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "MARGIN_NOT_SUPPORTED", typeof(InvalidOrder) },
                    { "MARGIN_BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "AMOUNT_TOO_LITTLE", typeof(InvalidOrder) },
                    { "AMOUNT_TOO_MUCH", typeof(InvalidOrder) },
                    { "REPEATED_CREATION", typeof(InvalidOrder) },
                    { "LOAN_NOT_FOUND", typeof(OrderNotFound) },
                    { "LOAN_RECORD_NOT_FOUND", typeof(OrderNotFound) },
                    { "NO_MATCHED_LOAN", typeof(ExchangeError) },
                    { "NOT_MERGEABLE", typeof(ExchangeError) },
                    { "NO_CHANGE", typeof(ExchangeError) },
                    { "REPAY_TOO_MUCH", typeof(ExchangeError) },
                    { "TOO_MANY_CURRENCY_PAIRS", typeof(InvalidOrder) },
                    { "TOO_MANY_ORDERS", typeof(InvalidOrder) },
                    { "MIXED_ACCOUNT_TYPE", typeof(InvalidOrder) },
                    { "AUTO_BORROW_TOO_MUCH", typeof(ExchangeError) },
                    { "TRADE_RESTRICTED", typeof(InsufficientFunds) },
                    { "USER_NOT_FOUND", typeof(AccountNotEnabled) },
                    { "CONTRACT_NO_COUNTER", typeof(ExchangeError) },
                    { "CONTRACT_NOT_FOUND", typeof(BadSymbol) },
                    { "RISK_LIMIT_EXCEEDED", typeof(ExchangeError) },
                    { "INSUFFICIENT_AVAILABLE", typeof(InsufficientFunds) },
                    { "LIQUIDATE_IMMEDIATELY", typeof(InvalidOrder) },
                    { "LEVERAGE_TOO_HIGH", typeof(InvalidOrder) },
                    { "LEVERAGE_TOO_LOW", typeof(InvalidOrder) },
                    { "ORDER_NOT_OWNED", typeof(ExchangeError) },
                    { "ORDER_FINISHED", typeof(ExchangeError) },
                    { "POSITION_CROSS_MARGIN", typeof(ExchangeError) },
                    { "POSITION_IN_LIQUIDATION", typeof(ExchangeError) },
                    { "POSITION_IN_CLOSE", typeof(ExchangeError) },
                    { "POSITION_EMPTY", typeof(InvalidOrder) },
                    { "REMOVE_TOO_MUCH", typeof(ExchangeError) },
                    { "RISK_LIMIT_NOT_MULTIPLE", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_HIGH", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_lOW", typeof(ExchangeError) },
                    { "PRICE_TOO_DEVIATED", typeof(InvalidOrder) },
                    { "SIZE_TOO_LARGE", typeof(InvalidOrder) },
                    { "SIZE_TOO_SMALL", typeof(InvalidOrder) },
                    { "PRICE_OVER_LIQUIDATION", typeof(InvalidOrder) },
                    { "PRICE_OVER_BANKRUPT", typeof(InvalidOrder) },
                    { "ORDER_POC_IMMEDIATE", typeof(OrderImmediatelyFillable) },
                    { "INCREASE_POSITION", typeof(InvalidOrder) },
                    { "CONTRACT_IN_DELISTING", typeof(ExchangeError) },
                    { "INTERNAL", typeof(ExchangeNotAvailable) },
                    { "SERVER_ERROR", typeof(ExchangeNotAvailable) },
                    { "TOO_BUSY", typeof(ExchangeNotAvailable) },
                    { "CROSS_ACCOUNT_NOT_FOUND", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_LOW", typeof(BadRequest) },
                    { "AUTO_TRIGGER_PRICE_LESS_LAST", typeof(InvalidOrder) },
                    { "AUTO_TRIGGER_PRICE_GREATE_LAST", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((Dictionary<string, object>)this.options)["sandboxMode"] = enable;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMarkets
        * @description retrieves data on all markets for gate
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-currency-pairs-supported                                     // spot
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-supported-currency-pairs-supported-in-margin-trading         // margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts                                            // swap
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts-2                                          // future
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-the-contracts-with-specified-underlying-and-expiration-time  // option
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        object rawPromises = new List<object> {this.fetchContractMarkets(parameters), this.fetchOptionMarkets(parameters)};
        if (!isTrue(sandboxMode))
        {
            // gate does not have a sandbox for spot markets
            object mainnetOnly = new List<object> {this.fetchSpotMarkets(parameters)};
            rawPromises = this.arrayConcat(rawPromises, mainnetOnly);
        }
        object promises = await promiseAll(rawPromises);
        object spotMarkets = this.safeValue(promises, 0, new List<object>() {});
        object contractMarkets = this.safeValue(promises, 1, new List<object>() {});
        object optionMarkets = this.safeValue(promises, 2, new List<object>() {});
        object markets = this.arrayConcat(spotMarkets, contractMarkets);
        return this.arrayConcat(markets, optionMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object marginResponse = await this.publicMarginGetCurrencyPairs(parameters);
        object spotMarketsResponse = await this.publicSpotGetCurrencyPairs(parameters);
        object marginMarkets = this.indexBy(marginResponse, "id");
        //
        //  Spot
        //
        //     [
        //         {
        //             "id": "QTUM_ETH",
        //             "base": "QTUM",
        //             "quote": "ETH",
        //             "fee": "0.2",
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "0.001",
        //             "amount_precision": 3,
        //             "precision": 6,
        //             "trade_status": "tradable",
        //             "sell_start": 0,
        //             "buy_start": 0
        //         }
        //     ]
        //
        //  Margin
        //
        //     [
        //         {
        //             "id": "ETH_USDT",
        //             "base": "ETH",
        //             "quote": "USDT",
        //             "leverage": 3,
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "100",
        //             "max_quote_amount": "1000000"
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(spotMarketsResponse)); postFixIncrement(ref i))
        {
            object spotMarket = getValue(spotMarketsResponse, i);
            object id = this.safeString(spotMarket, "id");
            object marginMarket = this.safeValue(marginMarkets, id);
            object market = this.deepExtend(marginMarket, spotMarket);
            var baseIdquoteIdVariable = ((string)id).Split((string)"_").ToList<object>();
            var baseId = ((List<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((List<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object takerPercent = this.safeString(market, "fee");
            object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
            object amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "amount_precision")));
            object tradeStatus = this.safeString(market, "trade_status");
            object leverage = this.safeNumber(market, "leverage");
            object margin = !isEqual(leverage, null);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", margin },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(tradeStatus, "tradable")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
                { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(market, "leverage", 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(spotMarket, "min_base_amount", amountPrecision) },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_quote_amount") },
                        { "max", ((bool) isTrue(margin)) ? this.safeNumber(market, "max_quote_amount") : null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object swapSettlementCurrencies = this.getSettlementCurrencies("swap", "fetchMarkets");
        object futureSettlementCurrencies = this.getSettlementCurrencies("future", "fetchMarkets");
        for (object c = 0; isLessThan(c, getArrayLength(swapSettlementCurrencies)); postFixIncrement(ref c))
        {
            object settleId = getValue(swapSettlementCurrencies, c);
            object request = new Dictionary<string, object>() {
                { "settle", settleId },
            };
            object response = await this.publicFuturesGetSettleContracts(this.extend(request, parameters));
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object parsedMarket = this.parseContractMarket(getValue(response, i), settleId);
                ((List<object>)result).Add(parsedMarket);
            }
        }
        for (object c = 0; isLessThan(c, getArrayLength(futureSettlementCurrencies)); postFixIncrement(ref c))
        {
            object settleId = getValue(futureSettlementCurrencies, c);
            object request = new Dictionary<string, object>() {
                { "settle", settleId },
            };
            object response = await this.publicDeliveryGetSettleContracts(this.extend(request, parameters));
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object parsedMarket = this.parseContractMarket(getValue(response, i), settleId);
                ((List<object>)result).Add(parsedMarket);
            }
        }
        return result;
    }

    public virtual object parseContractMarket(object market, object settleId)
    {
        //
        //  Perpetual swap
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        //  Delivery Futures
        //
        //    {
        //        "name": "BTC_USDT_20200814",
        //        "underlying": "BTC_USDT",
        //        "cycle": "WEEKLY",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "mark_type": "index",
        //        "last_price": "9017",
        //        "mark_price": "9019",
        //        "index_price": "9005.3",
        //        "basis_rate": "0.185095",
        //        "basis_value": "13.7",
        //        "basis_impact_value": "100000",
        //        "settle_price": "0",
        //        "settle_price_interval": 60,
        //        "settle_price_duration": 1800,
        //        "settle_fee_rate": "0.0015",
        //        "expire_time": 1593763200,
        //        "order_price_round": "0.1",
        //        "mark_price_round": "0.1",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "maintenance_rate": "1000000",
        //        "risk_limit_base": "140.726652109199",
        //        "risk_limit_step": "1000000",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "ref_discount_rate": "0",
        //        "ref_rebate_rate": "0.2",
        //        "order_price_deviate": "0.5",
        //        "order_size_min": 1,
        //        "order_size_max": 1000000,
        //        "orders_limit": 50,
        //        "orderbook_id": 63,
        //        "trade_id": 26,
        //        "trade_size": 435,
        //        "position_size": 130,
        //        "config_change_time": 1593158867,
        //        "in_delisting": false
        //    }
        //
        object id = this.safeString(market, "name");
        object parts = ((string)id).Split((string)"_").ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object date = this.safeString(parts, 2);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = this.safeCurrencyCode(settleId);
        object expiry = this.safeTimestamp(market, "expire_time");
        object symbol = "";
        object marketType = "swap";
        if (isTrue(!isEqual(date, null)))
        {
            symbol = add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), this.yymmdd(expiry, ""));
            marketType = "future";
        } else
        {
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        }
        object priceDeviate = this.safeString(market, "order_price_deviate");
        object markPrice = this.safeString(market, "mark_price");
        object minMultiplier = Precise.stringSub("1", priceDeviate);
        object maxMultiplier = Precise.stringAdd("1", priceDeviate);
        object minPrice = Precise.stringMul(minMultiplier, markPrice);
        object maxPrice = Precise.stringMul(maxMultiplier, markPrice);
        object takerPercent = this.safeString(market, "taker_fee_rate");
        object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
        object isLinear = isEqual(quote, settle);
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", false },
            { "margin", false },
            { "swap", isEqual(marketType, "swap") },
            { "future", isEqual(marketType, "future") },
            { "option", isEqual(marketType, "option") },
            { "active", true },
            { "contract", true },
            { "linear", isLinear },
            { "inverse", !isTrue(isLinear) },
            { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
            { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
            { "contractSize", this.safeNumber(market, "quanto_multiplier") },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber("1") },
                { "price", this.safeNumber(market, "order_price_round") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "leverage_min") },
                    { "max", this.safeNumber(market, "leverage_max") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "order_size_min") },
                    { "max", this.safeNumber(market, "order_size_max") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minPrice) },
                    { "max", this.parseNumber(maxPrice) },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        };
    }

    public async virtual Task<object> fetchOptionMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object underlyings = await this.fetchOptionUnderlyings();
        for (object i = 0; isLessThan(i, getArrayLength(underlyings)); postFixIncrement(ref i))
        {
            object underlying = getValue(underlyings, i);
            object query = this.extend(new Dictionary<string, object>() {}, parameters);
            ((Dictionary<string, object>)query)["underlying"] = underlying;
            object response = await this.publicOptionsGetContracts(query);
            //
            //    [
            //        {
            //            "orders_limit": "50",
            //            "order_size_max": "100000",
            //            "mark_price_round": "0.1",
            //            "order_size_min": "1",
            //            "position_limit": "1000000",
            //            "orderbook_id": "575967",
            //            "order_price_deviate": "0.9",
            //            "is_call": true, // true means Call false means Put
            //            "last_price": "93.9",
            //            "bid1_size": "0",
            //            "bid1_price": "0",
            //            "taker_fee_rate": "0.0004",
            //            "underlying": "BTC_USDT",
            //            "create_time": "1646381188",
            //            "price_limit_fee_rate": "0.1",
            //            "maker_fee_rate": "0.0004",
            //            "trade_id": "727",
            //            "order_price_round": "0.1",
            //            "settle_fee_rate": "0.0001",
            //            "trade_size": "1982",
            //            "ref_rebate_rate": "0",
            //            "name": "BTC_USDT-20220311-44000-C",
            //            "underlying_price": "39194.26",
            //            "strike_price": "44000",
            //            "multiplier": "0.0001",
            //            "ask1_price": "0",
            //            "ref_discount_rate": "0",
            //            "expiration_time": "1646985600",
            //            "mark_price": "12.15",
            //            "position_size": "4",
            //            "ask1_size": "0",
            //            "tag": "WEEK"
            //        }
            //    ]
            //
            for (object j = 0; isLessThan(j, getArrayLength(response)); postFixIncrement(ref j))
            {
                object market = getValue(response, j);
                object id = this.safeString(market, "name");
                object parts = ((string)underlying).Split((string)"_").ToList<object>();
                object baseId = this.safeString(parts, 0);
                object quoteId = this.safeString(parts, 1);
                object bs = this.safeCurrencyCode(baseId);
                object quote = this.safeCurrencyCode(quoteId);
                object symbol = add(add(bs, "/"), quote);
                object expiry = this.safeTimestamp(market, "expiration_time");
                object strike = this.safeString(market, "strike_price");
                object isCall = this.safeValue(market, "is_call");
                object optionLetter = ((bool) isTrue(isCall)) ? "C" : "P";
                object optionType = ((bool) isTrue(isCall)) ? "call" : "put";
                symbol = add(add(add(add(add(add(add(add(symbol, ":"), quote), "-"), this.yymmdd(expiry)), "-"), strike), "-"), optionLetter);
                object priceDeviate = this.safeString(market, "order_price_deviate");
                object markPrice = this.safeString(market, "mark_price");
                object minMultiplier = Precise.stringSub("1", priceDeviate);
                object maxMultiplier = Precise.stringAdd("1", priceDeviate);
                object minPrice = Precise.stringMul(minMultiplier, markPrice);
                object maxPrice = Precise.stringMul(maxMultiplier, markPrice);
                object takerPercent = this.safeString(market, "taker_fee_rate");
                object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
                ((List<object>)result).Add(new Dictionary<string, object>() {
                    { "id", id },
                    { "symbol", symbol },
                    { "base", bs },
                    { "quote", quote },
                    { "settle", quote },
                    { "baseId", baseId },
                    { "quoteId", quoteId },
                    { "settleId", quoteId },
                    { "type", "option" },
                    { "spot", false },
                    { "margin", false },
                    { "swap", false },
                    { "future", false },
                    { "option", true },
                    { "active", true },
                    { "contract", true },
                    { "linear", true },
                    { "inverse", false },
                    { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
                    { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
                    { "contractSize", this.parseNumber("1") },
                    { "expiry", expiry },
                    { "expiryDatetime", this.iso8601(expiry) },
                    { "strike", strike },
                    { "optionType", optionType },
                    { "precision", new Dictionary<string, object>() {
                        { "amount", this.parseNumber("1") },
                        { "price", this.safeNumber(market, "order_price_round") },
                    } },
                    { "limits", new Dictionary<string, object>() {
                        { "leverage", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "amount", new Dictionary<string, object>() {
                            { "min", this.safeNumber(market, "order_size_min") },
                            { "max", this.safeNumber(market, "order_size_max") },
                        } },
                        { "price", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minPrice) },
                            { "max", this.parseNumber(maxPrice) },
                        } },
                        { "cost", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "info", market },
                });
            }
        }
        return result;
    }

    public async virtual Task<object> fetchOptionUnderlyings()
    {
        object underlyingsResponse = await this.publicOptionsGetUnderlyings();
        //
        //    [
        //        {
        //            "index_time": "1646915796",
        //            "name": "BTC_USDT",
        //            "index_price": "39142.73"
        //        }
        //    ]
        //
        object underlyings = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(underlyingsResponse)); postFixIncrement(ref i))
        {
            object underlying = getValue(underlyingsResponse, i);
            object name = this.safeString(underlying, "name");
            if (isTrue(!isEqual(name, null)))
            {
                ((List<object>)underlyings).Add(name);
            }
        }
        return underlyings;
    }

    public virtual object prepareRequest(object market = null, object type = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#prepareRequest
        * @description Fills request params contract, settle, currency_pair, market and account where applicable
        * @param {object} market CCXT market, required when type is undefined
        * @param {string} type 'spot', 'swap', or 'future', required when market is undefined
        * @param {object} params request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        // * Do not call for multi spot order methods like cancelAllOrders and fetchOpenOrders. Use multiOrderSpotPrepareRequest instead
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            if (isTrue(getValue(market, "contract")))
            {
                ((Dictionary<string, object>)request)["contract"] = getValue(market, "id");
                ((Dictionary<string, object>)request)["settle"] = getValue(market, "settleId");
            } else
            {
                ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
            }
        } else
        {
            object swap = isEqual(type, "swap");
            object future = isEqual(type, "future");
            if (isTrue(isTrue(swap) || isTrue(future)))
            {
                object defaultSettle = ((bool) isTrue(swap)) ? "usdt" : "btc";
                object settle = this.safeStringLower(parameters, "settle", defaultSettle);
                parameters = this.omit(parameters, "settle");
                ((Dictionary<string, object>)request)["settle"] = settle;
            }
        }
        return new List<object>() {request, parameters};
    }

    public virtual object spotOrderPrepareRequest(object market = null, object stop = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#multiOrderSpotPrepareRequest
        * @description Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
        * @param {object} market CCXT market
        * @param {bool} stop true if for a stop order
        * @param {object} params request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        stop ??= false;
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.getMarginMode(stop, parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        if (!isTrue(stop))
        {
            if (isTrue(isEqual(market, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " spotOrderPrepareRequest() requires a market argument for non-stop orders")) ;
            }
            ((Dictionary<string, object>)request)["account"] = marginMode;
            ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id"); // Should always be set for non-stop
        }
        return new List<object>() {request, query};
    }

    public virtual object multiOrderSpotPrepareRequest(object market = null, object stop = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#multiOrderSpotPrepareRequest
        * @description Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
        * @param {object} market CCXT market
        * @param {bool} stop true if for a stop order
        * @param {object} params request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        stop ??= false;
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.getMarginMode(stop, parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "account", marginMode },
        };
        if (isTrue(!isEqual(market, null)))
        {
            if (isTrue(stop))
            {
                // gate spot and margin stop orders use the term market instead of currency_pair, and normal instead of spot. Neither parameter is used when fetching/cancelling a single order. They are used for creating a single stop order, but createOrder does not call this method
                ((Dictionary<string, object>)request)["market"] = getValue(market, "id");
            } else
            {
                ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
            }
        }
        return new List<object>() {request, query};
    }

    public virtual object getMarginMode(object stop, object parameters)
    {
        /**
         * @ignore
         * @method
         * @name gate#getMarginMode
         * @description Gets the margin type for this api call
         * @param {bool} stop True if for a stop order
         * @param {object} params Request params
         * @returns The marginMode and the updated request params with marginMode removed, marginMode value is the value that can be read by the "account" property specified in gates api docs
         */
        object defaultMarginMode = this.safeStringLower2(this.options, "defaultMarginMode", "marginMode", "spot"); // 'margin' is isolated margin on gate's api
        object marginMode = this.safeStringLower2(parameters, "marginMode", "account", defaultMarginMode);
        parameters = this.omit(parameters, new List<object>() {"marginMode", "account"});
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "cross_margin";
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            marginMode = "margin";
        } else if (isTrue(isEqual(marginMode, "")))
        {
            marginMode = "spot";
        }
        if (isTrue(stop))
        {
            if (isTrue(isEqual(marginMode, "spot")))
            {
                // gate spot stop orders use the term normal instead of spot
                marginMode = "normal";
            }
            if (isTrue(isEqual(marginMode, "cross_margin")))
            {
                throw new BadRequest ((string)add(this.id, " getMarginMode() does not support stop orders for cross margin")) ;
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public virtual object getSettlementCurrencies(object type, object method)
    {
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {}); // [ 'BTC', 'USDT' ] unified codes
        object fetchMarketsContractOptions = this.safeValue(options, method, new Dictionary<string, object>() {});
        object defaultSettle = ((bool) isTrue((isEqual(type, "swap")))) ? new List<object>() {"usdt"} : new List<object>() {"btc"};
        return this.safeValue(fetchMarketsContractOptions, "settlementCurrencies", defaultSettle);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        // sandbox/testnet only supports future markets
        parameters ??= new Dictionary<string, object>();
        object apiBackup = this.safeValue(this.urls, "apiBackup");
        if (isTrue(!isEqual(apiBackup, null)))
        {
            return null;
        }
        object response = await this.publicSpotGetCurrencies(parameters);
        //
        //    {
        //        "currency": "BCN",
        //        "delisted": false,
        //        "withdraw_disabled": true,
        //        "withdraw_delayed": false,
        //        "deposit_disabled": true,
        //        "trade_disabled": false
        //    }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object currencyIdLower = this.safeStringLower(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object delisted = this.safeValue(entry, "delisted");
            object withdrawDisabled = this.safeValue(entry, "withdraw_disabled", false);
            object depositDisabled = this.safeValue(entry, "deposit_disabled", false);
            object tradeDisabled = this.safeValue(entry, "trade_disabled", false);
            object withdrawEnabled = !isTrue(withdrawDisabled);
            object depositEnabled = !isTrue(depositDisabled);
            object tradeEnabled = !isTrue(tradeDisabled);
            object listed = !isTrue(delisted);
            object active = isTrue(isTrue(isTrue(listed) && isTrue(tradeEnabled)) && isTrue(withdrawEnabled)) && isTrue(depositEnabled);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "lowerCaseId", currencyIdLower },
                { "name", null },
                { "code", code },
                { "precision", this.parseNumber("1e-4") },
                { "info", entry },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "fees", new List<object>() {} },
                { "limits", this.limits },
            };
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object response = await this.publicFuturesGetSettleContractsContract(this.extend(request, query));
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        return this.parseFundingRate(response);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        var requestqueryVariable = this.prepareRequest(null, "swap", parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object response = await this.publicFuturesGetSettleContracts(this.extend(request, query));
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        object result = this.parseFundingRates(response);
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        object marketId = this.safeString(contract, "name");
        object symbol = this.safeSymbol(marketId, market, "_", "swap");
        object markPrice = this.safeNumber(contract, "mark_price");
        object indexPrice = this.safeNumber(contract, "index_price");
        object interestRate = this.safeNumber(contract, "interest_rate");
        object fundingRate = this.safeNumber(contract, "funding_rate");
        object fundingTime = this.safeTimestamp(contract, "funding_next_apply");
        object fundingRateIndicative = this.safeNumber(contract, "funding_rate_indicative");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", interestRate },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", fundingRateIndicative },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async virtual Task<object> fetchNetworkDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateWalletGetDepositAddress(this.extend(request, parameters));
        object addresses = this.safeValue(response, "multichain_addresses");
        object currencyId = this.safeString(response, "currency");
        code = this.safeCurrencyCode(currencyId);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(addresses)); postFixIncrement(ref i))
        {
            object entry = getValue(addresses, i);
            //
            //    {
            //        "chain": "ETH",
            //        "address": "0x359a697945E79C7e17b634675BD73B33324E9408",
            //        "payment_id": "",
            //        "payment_name": "",
            //        "obtain_failed": "0"
            //    }
            //
            object obtainFailed = this.safeInteger(entry, "obtain_failed");
            if (isTrue(obtainFailed))
            {

            }
            object network = this.safeString(entry, "chain");
            object address = this.safeString(entry, "address");
            object tag = this.safeString(entry, "payment_id");
            ((Dictionary<string, object>)result)[(string)network] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "currency", code },
                { "address", address },
                { "tag", tag },
            };
        }
        return result;
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name gate#createDepositAddress
        * @description create a currency deposit address
        * @see https://www.gate.io/docs/developers/apiv4/en/#generate-currency-deposit-address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchDepositAddress(code, parameters);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.gate.io/docs/developers/apiv4/en/#generate-currency-deposit-address
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateWalletGetDepositAddress(this.extend(request, parameters));
        //
        //    {
        //        "currency": "XRP",
        //        "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
        //        "multichain_addresses": [
        //            {
        //                "chain": "XRP",
        //                "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
        //                "payment_id": "391331007",
        //                "payment_name": "Tag",
        //                "obtain_failed": 0
        //            }
        //        ]
        //    }
        //
        object currencyId = this.safeString(response, "currency");
        code = this.safeCurrencyCode(currencyId);
        object addressField = this.safeString(response, "address");
        object tag = null;
        object address = null;
        if (isTrue(!isEqual(addressField, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(addressField, "New address is being generated for you, please wait"), 0)))
            {
                throw new BadResponse ((string)add(add(this.id, " "), "New address is being generated for you, please wait a few seconds and try again to get the address.")) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(addressField, " "), 0)))
            {
                object splitted = ((string)addressField).Split((string)" ").ToList<object>();
                address = getValue(splitted, 0);
                tag = getValue(splitted, 1);
            } else
            {
                address = addressField;
            }
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "code", code },
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency_pair", getValue(market, "id") },
        };
        object response = await this.privateWalletGetFee(this.extend(request, parameters));
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return this.parseTradingFee(response, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetFee(parameters);
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return this.parseTradingFees(response);
    }

    public virtual object parseTradingFees(object response)
    {
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            ((Dictionary<string, object>)result)[(string)symbol] = this.parseTradingFee(response, market);
        }
        return result;
    }

    public virtual object parseTradingFee(object info, object market = null)
    {
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        object contract = this.safeValue(market, "contract");
        object takerKey = ((bool) isTrue(contract)) ? "futures_taker_fee" : "taker_fee";
        object makerKey = ((bool) isTrue(contract)) ? "futures_maker_fee" : "maker_fee";
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "maker", this.safeNumber(info, makerKey) },
            { "taker", this.safeNumber(info, takerKey) },
        };
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTransactionFees
        * @description *DEPRECATED* please use fetchDepositWithdrawFees instead
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetWithdrawStatus(parameters);
        //
        //    {
        //        "currency": "MTN",
        //        "name": "Medicalchain",
        //        "name_cn": "Medicalchain",
        //        "deposit": "0",
        //        "withdraw_percent": "0%",
        //        "withdraw_fix": "900",
        //        "withdraw_day_limit": "500000",
        //        "withdraw_day_limit_remain": "500000",
        //        "withdraw_amount_mini": "900.1",
        //        "withdraw_eachtime_limit": "90000000000",
        //        "withdraw_fix_on_chains": {
        //            "ETH": "900"
        //        }
        //    }
        //
        object result = new Dictionary<string, object>() {};
        object withdrawFees = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            withdrawFees = new Dictionary<string, object>() {};
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {

            }
            object withdrawFixOnChains = this.safeValue(entry, "withdraw_fix_on_chains");
            if (isTrue(isEqual(withdrawFixOnChains, null)))
            {
                withdrawFees = this.safeNumber(entry, "withdraw_fix");
            } else
            {
                object chainKeys = new List<object>(((Dictionary<string,object>)withdrawFixOnChains).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(chainKeys)); postFixIncrement(ref j))
                {
                    object chainKey = getValue(chainKeys, j);
                    ((Dictionary<string, object>)withdrawFees)[(string)chainKey] = this.parseNumber(getValue(withdrawFixOnChains, chainKey));
                }
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "withdraw", withdrawFees },
                { "deposit", null },
                { "info", entry },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetWithdrawStatus(parameters);
        //
        //    [
        //        {
        //            "currency": "MTN",
        //            "name": "Medicalchain",
        //            "name_cn": "Medicalchain",
        //            "deposit": "0",
        //            "withdraw_percent": "0%",
        //            "withdraw_fix": "900",
        //            "withdraw_day_limit": "500000",
        //            "withdraw_day_limit_remain": "500000",
        //            "withdraw_amount_mini": "900.1",
        //            "withdraw_eachtime_limit": "90000000000",
        //            "withdraw_fix_on_chains": {
        //                "ETH": "900"
        //            }
        //        }
        //    ]
        //
        return this.parseDepositWithdrawFees(response, codes, "currency");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "currency": "MTN",
        //        "name": "Medicalchain",
        //        "name_cn": "Medicalchain",
        //        "deposit": "0",
        //        "withdraw_percent": "0%",
        //        "withdraw_fix": "900",
        //        "withdraw_day_limit": "500000",
        //        "withdraw_day_limit_remain": "500000",
        //        "withdraw_amount_mini": "900.1",
        //        "withdraw_eachtime_limit": "90000000000",
        //        "withdraw_fix_on_chains": {
        //            "ETH": "900"
        //        }
        //    }
        //
        object withdrawFixOnChains = this.safeValue(fee, "withdraw_fix_on_chains");
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdraw_fix") },
                { "percentage", false },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "deposit") },
                { "percentage", false },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(withdrawFixOnChains, null)))
        {
            object chainKeys = new List<object>(((Dictionary<string,object>)withdrawFixOnChains).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(chainKeys)); postFixIncrement(ref i))
            {
                object chainKey = getValue(chainKeys, i);
                ((Dictionary<string, object>)getValue(result, "networks"))[(string)chainKey] = new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.parseNumber(getValue(withdrawFixOnChains, chainKey)) },
                        { "percentage", false },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                };
            }
        }
        return result;
    }

    public async virtual Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch funding history for
        * @param {int|undefined} limit the maximum number of funding history structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // let defaultType = 'future';
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(market, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        ((Dictionary<string, object>)request)["type"] = "fund"; // 'dnw' 'pnl' 'fee' 'refr' 'fund' 'point_dnw' 'point_fee' 'point_refr'
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = divide(since, 1000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "swap", "privateFuturesGetSettleAccountBook" },
            { "future", "privateDeliveryGetSettleAccountBook" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        //    [
        //        {
        //            "time": 1646899200,
        //            "change": "-0.027722",
        //            "balance": "11.653120591841",
        //            "text": "XRP_USDT",
        //            "type": "fund"
        //        },
        //        ...
        //    ]
        //
        return this.parseFundingHistories(response, symbol, since, limit);
    }

    public virtual object parseFundingHistories(object response, object symbol, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object funding = this.parseFundingHistory(entry);
            ((List<object>)result).Add(funding);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object parseFundingHistory(object info, object market = null)
    {
        //
        //    {
        //        "time": 1646899200,
        //        "change": "-0.027722",
        //        "balance": "11.653120591841",
        //        "text": "XRP_USDT",
        //        "type": "fund"
        //    }
        //
        object timestamp = this.safeTimestamp(info, "time");
        object marketId = this.safeString(info, "text");
        market = this.safeMarket(marketId, market, "_", "swap");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "code", this.safeString(market, "settle") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", null },
            { "amount", this.safeNumber(info, "change") },
        };
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'interval': '0', // depth, 0 means no aggregation is applied, default to 0
        //         'limit': limit, // maximum number of order depth data in asks or bids
        //         'with_id': true, // return order book ID
        //     };
        //
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "publicSpotGetOrderBook" },
            { "margin", "publicSpotGetOrderBook" },
            { "swap", "publicFuturesGetSettleOrderBook" },
            { "future", "publicDeliveryGetSettleOrderBook" },
        });
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 10, max 100
        }
        ((Dictionary<string, object>)request)["with_id"] = true;
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // SPOT
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634345973275,
        //         "update": 1634345973271,
        //         "asks": [
        //             ["2.2241","12449.827"],
        //             ["2.2242","200"],
        //             ["2.2244","826.931"],
        //             ["2.2248","3876.107"],
        //             ["2.225","2377.252"],
        //             ["2.22509","439.484"],
        //             ["2.2251","1489.313"],
        //             ["2.2253","714.582"],
        //             ["2.2254","1349.784"],
        //             ["2.2256","234.701"]],
        //          "bids": [
        //             ["2.2236","32.465"],
        //             ["2.2232","243.983"],
        //             ["2.2231","32.207"],
        //             ["2.223","449.827"],
        //             ["2.2228","7.918"],
        //             ["2.2227","12703.482"],
        //             ["2.2226","143.033"],
        //             ["2.2225","143.027"],
        //             ["2.2224","1369.352"],
        //             ["2.2223","756.063"]
        //         ]
        //     }
        //
        // Perpetual Swap
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634350208.745,
        //         "asks": [
        //             {"s": 24909, "p": "61264.8"},
        //             {"s": 81, "p": "61266.6"},
        //             {"s": 2000, "p": "61267.6"},
        //             {"s": 490, "p": "61270.2"},
        //             {"s": 12, "p": "61270.4"},
        //             {"s": 11782, "p": "61273.2"},
        //             {"s": 14666, "p": "61273.3"},
        //             {"s": 22541, "p": "61273.4"},
        //             {"s": 33, "p": "61273.6"},
        //             {"s": 11980, "p": "61274.5"}
        //         ],
        //         "bids": [
        //             {"s": 41844, "p": "61264.7"},
        //             {"s": 13783, "p": "61263.3"},
        //             {"s": 1143, "p": "61259.8"},
        //             {"s": 81, "p": "61258.7"},
        //             {"s": 2471, "p": "61257.8"},
        //             {"s": 2471, "p": "61257.7"},
        //             {"s": 2471, "p": "61256.5"},
        //             {"s": 3, "p": "61254.2"},
        //             {"s": 114, "p": "61252.4"},
        //             {"s": 14372, "p": "61248.6"}
        //         ],
        //         "update": 1634350208.724
        //     }
        //
        object timestamp = this.safeInteger(response, "current");
        if (!isTrue(getValue(market, "spot")))
        {
            timestamp = multiply(timestamp, 1000);
        }
        object priceKey = ((bool) isTrue(getValue(market, "spot"))) ? 0 : "p";
        object amountKey = ((bool) isTrue(getValue(market, "spot"))) ? 1 : "s";
        object nonce = this.safeInteger(response, "id");
        object result = this.parseOrderBook(response, symbol, timestamp, "bids", "asks", priceKey, amountKey);
        ((Dictionary<string, object>)result)["nonce"] = nonce;
        return result;
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "publicSpotGetTickers" },
            { "margin", "publicSpotGetTickers" },
            { "swap", "publicFuturesGetSettleTickers" },
            { "future", "publicDeliveryGetSettleTickers" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        object ticker = this.safeValue(response, 0);
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // SPOT
        //
        //     {
        //         "currency_pair": "KFC_USDT",
        //         "last": "7.255",
        //         "lowest_ask": "7.298",
        //         "highest_bid": "7.218",
        //         "change_percentage": "-1.18",
        //         "base_volume": "1219.053687865",
        //         "quote_volume": "8807.40299875455",
        //         "high_24h": "7.262",
        //         "low_24h": "7.095"
        //     }
        //
        // LINEAR/DELIVERY
        //
        //     {
        //         "contract": "BTC_USDT",
        //         "last": "6432",
        //         "low_24h": "6278",
        //         "high_24h": "6790",
        //         "change_percentage": "4.43",
        //         "total_size": "32323904",
        //         "volume_24h": "184040233284",
        //         "volume_24h_btc": "28613220",
        //         "volume_24h_usd": "184040233284",
        //         "volume_24h_base": "28613220",
        //         "volume_24h_quote": "184040233284",
        //         "volume_24h_settle": "28613220",
        //         "mark_price": "6534",
        //         "funding_rate": "0.0001",
        //         "funding_rate_indicative": "0.0001",
        //         "index_price": "6531"
        //     }
        //
        // bookTicker
        //    {
        //        t: 1671363004228,
        //        u: 9793320464,
        //        s: 'BTC_USDT',
        //        b: '16716.8', // best bid price
        //        B: '0.0134', // best bid size
        //        a: '16716.9', // best ask price
        //        A: '0.0353' // best ask size
        //     }
        //
        object marketId = this.safeString2(ticker, "currency_pair", "contract");
        object marketType = ((bool) isTrue((((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("contract"))))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, market, "_", marketType);
        object last = this.safeString(ticker, "last");
        object ask = this.safeString2(ticker, "lowest_ask", "a");
        object bid = this.safeString2(ticker, "highest_bid", "b");
        object high = this.safeString(ticker, "high_24h");
        object low = this.safeString(ticker, "low_24h");
        object bidVolume = this.safeString(ticker, "B");
        object askVolume = this.safeString(ticker, "A");
        object timestamp = this.safeInteger(ticker, "t");
        object baseVolume = this.safeString2(ticker, "base_volume", "volume_24h_base");
        if (isTrue(isEqual(baseVolume, "nan")))
        {
            baseVolume = "0";
        }
        object quoteVolume = this.safeString2(ticker, "quote_volume", "volume_24h_quote");
        if (isTrue(isEqual(quoteVolume, "nan")))
        {
            quoteVolume = "0";
        }
        object percentage = this.safeString(ticker, "change_percentage");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-details-of-a-specifc-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers-2
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "publicSpotGetTickers" },
            { "margin", "publicSpotGetTickers" },
            { "swap", "publicFuturesGetSettleTickers" },
            { "future", "publicDeliveryGetSettleTickers" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseTickers(response, symbols);
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((Dictionary<string, object>)account)["used"] = this.safeString2(entry, "freeze", "locked");
        ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "available");
        ((Dictionary<string, object>)account)["total"] = this.safeString(entry, "total");
        if (isTrue(((Dictionary<string,object>)entry).ContainsKey(toStringOrNull("borrowed"))))
        {
            ((Dictionary<string, object>)account)["debt"] = this.safeString(entry, "borrowed");
        }
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @param {object} params exchange specific parameters
        * @param {string} params.type spot, margin, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} params.settle 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
        * @param {string} params.marginMode 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string} params.symbol margin only - unified ccxt symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        var typequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        var marginModerequestQueryVariable = this.getMarginMode(false, requestParams);
        var marginMode = ((List<object>) marginModerequestQueryVariable)[0];
        var requestQuery = ((List<object>) marginModerequestQueryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
        }
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", this.getSupportedMapping(marginMode, new Dictionary<string, object>() {
                { "spot", "privateSpotGetAccounts" },
                { "margin", "privateMarginGetAccounts" },
                { "cross_margin", "privateMarginGetCrossAccounts" },
            }) },
            { "funding", "privateMarginGetFundingAccounts" },
            { "swap", "privateFuturesGetSettleAccounts" },
            { "future", "privateDeliveryGetSettleAccounts" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestQuery) }));
        object contract = (isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future"))));
        if (isTrue(contract))
        {
            response = new List<object>() {response};
        }
        //
        // Spot / margin funding
        //
        //     [
        //         {
        //             "currency": "DBC",
        //             "available": "0",
        //             "locked": "0"
        //             "lent": "0", // margin funding only
        //             "total_lent": "0" // margin funding only
        //         },
        //         ...
        //     ]
        //
        //  Margin
        //
        //    [
        //        {
        //            "currency_pair": "DOGE_USDT",
        //            "locked": false,
        //            "risk": "9999.99",
        //            "base": {
        //                "currency": "DOGE",
        //                "available": "0",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            },
        //            "quote": {
        //                "currency": "USDT",
        //                "available": "0.73402",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        ...
        //    ]
        //
        // Cross margin
        //
        //    {
        //        "user_id": 10406147,
        //        "locked": false,
        //        "balances": {
        //            "USDT": {
        //                "available": "1",
        //                "freeze": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        "total": "1",
        //        "borrowed": "0",
        //        "interest": "0",
        //        "risk": "9999.99"
        //    }
        //
        //  Perpetual Swap
        //
        //    {
        //        order_margin: "0",
        //        point: "0",
        //        bonus: "0",
        //        history: {
        //            dnw: "2.1321",
        //            pnl: "11.5351",
        //            refr: "0",
        //            point_fee: "0",
        //            fund: "-0.32340576684",
        //            bonus_dnw: "0",
        //            point_refr: "0",
        //            bonus_offset: "0",
        //            fee: "-0.20132775",
        //            point_dnw: "0",
        //        },
        //        unrealised_pnl: "13.315100000006",
        //        total: "12.51345151332",
        //        available: "0",
        //        in_dual_mode: false,
        //        currency: "USDT",
        //        position_margin: "12.51345151332",
        //        user: "6333333",
        //    }
        //
        // Delivery Future
        //
        //    {
        //        order_margin: "0",
        //        point: "0",
        //        history: {
        //            dnw: "1",
        //            pnl: "0",
        //            refr: "0",
        //            point_fee: "0",
        //            point_dnw: "0",
        //            settle: "0",
        //            settle_fee: "0",
        //            point_refr: "0",
        //            fee: "0",
        //        },
        //        unrealised_pnl: "0",
        //        total: "1",
        //        available: "1",
        //        currency: "USDT",
        //        position_margin: "0",
        //        user: "6333333",
        //    }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object isolated = isEqual(marginMode, "margin");
        object data = response;
        if (isTrue(((Dictionary<string,object>)data).ContainsKey(toStringOrNull("balances"))))
        {
            object flatBalances = new List<object>() {};
            object balances = this.safeValue(data, "balances", new List<object>() {});
            // inject currency and create an artificial balance object
            // so it can follow the existent flow
            object keys = new List<object>(((Dictionary<string,object>)balances).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object currencyId = getValue(keys, i);
                object content = getValue(balances, currencyId);
                ((Dictionary<string, object>)content)["currency"] = currencyId;
                ((List<object>)flatBalances).Add(content);
            }
            data = flatBalances;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            if (isTrue(isolated))
            {
                object marketId = this.safeString(entry, "currency_pair");
                object symbolInner = this.safeSymbol(marketId, null, "_", "margin");
                object bs = this.safeValue(entry, "base", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quote", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((Dictionary<string, object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((Dictionary<string, object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((Dictionary<string, object>)result)[(string)symbolInner] = this.safeBalance(subResult);
            } else
            {
                object code = this.safeCurrencyCode(this.safeString(entry, "currency"));
                ((Dictionary<string, object>)result)[(string)code] = this.parseBalanceHelper(entry);
            }
        }
        return ((bool) isTrue(isolated)) ? result : this.safeBalance(result);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gateio#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#market-candlesticks       // spot
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-futures-candlesticks  // swap
        * @see https://www.gate.io/docs/developers/apiv4/en/#market-candlesticks       // future
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-options-candlesticks  // option
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch, limit is conflicted with since and params["until"], If either since and params["until"] is specified, request will be rejected
        * @param {object} params extra parameters specific to the gateio api endpoint
        * @param {string|undefined} params.price "mark" or "index" for mark price and index price candles
        * @param {int|undefined} params.until timestamp in ms of the latest candle to fetch
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume (units in quote currency)
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object price = this.safeString(parameters, "price");
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.prepareRequest(market, null, parameters);
        request = ((List<object>)requestparametersVariable)[0];
        parameters = ((List<object>)requestparametersVariable)[1];
        ((Dictionary<string, object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        object method = "publicSpotGetCandlesticks";
        object maxLimit = 1000;
        if (isTrue(getValue(market, "contract")))
        {
            maxLimit = 1999;
            limit = ((bool) isTrue((isEqual(limit, null)))) ? maxLimit : mathMin(limit, maxLimit);
            if (isTrue(getValue(market, "future")))
            {
                method = "publicDeliveryGetSettleCandlesticks";
            } else if (isTrue(getValue(market, "swap")))
            {
                method = "publicFuturesGetSettleCandlesticks";
            }
            object isMark = (isEqual(price, "mark"));
            object isIndex = (isEqual(price, "index"));
            if (isTrue(isTrue(isMark) || isTrue(isIndex)))
            {
                ((Dictionary<string, object>)request)["contract"] = add(add(price, "_"), getValue(market, "id"));
                parameters = this.omit(parameters, "price");
            }
        }
        limit = ((bool) isTrue((isEqual(limit, null)))) ? maxLimit : mathMin(limit, maxLimit);
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            until = this.parseToInt(divide(until, 1000));
            parameters = this.omit(parameters, "until");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object duration = this.parseTimeframe(timeframe);
            ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
            object distance = multiply((subtract(limit, 1)), duration);
            object toTimestamp = this.sum(getValue(request, "from"), distance);
            object currentTimestamp = this.seconds();
            object to = mathMin(toTimestamp, currentTimestamp);
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["to"] = mathMin(to, until);
            } else
            {
                ((Dictionary<string, object>)request)["to"] = to;
            }
        } else
        {
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["to"] = until;
            }
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object method = "publicFuturesGetSettleFundingRate";
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "r": "0.00063521",
        //         "t": "1621267200000",
        //     }
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeTimestamp(entry, "t");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "fundingRate", this.safeNumber(entry, "r") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // Spot market candles
        //
        //    [
        //        "1660957920", // timestamp
        //        "6227.070147198573", // quote volume
        //        "0.0000133485", // close
        //        "0.0000133615", // high
        //        "0.0000133347", // low
        //        "0.0000133468", // open
        //        "466641934.99" // base volume
        //    ]
        //
        //
        // Mark and Index price candles
        //
        //     {
        //          "t":1632873600,         // Unix timestamp in seconds
        //          "o": "41025",           // Open price
        //          "h": "41882.17",        // Highest price
        //          "c": "41776.92",        // Close price
        //          "l": "40783.94"         // Lowest price
        //     }
        //
        if (isTrue((ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 5), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 6)};
        } else
        {
            // Mark and Index price candles
            return new List<object> {this.safeTimestamp(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
        }
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        //
        // spot
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'reverse': false, // true to retrieve records where id is smaller than the specified last_id, false to retrieve records where id is larger than the specified last_id
        //     };
        //
        // swap, future
        //
        //     const request = {
        //         'settle': market['settleId'],
        //         'contract': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'from': since / 1000), // starting time in seconds, if not specified, to and limit will be used to limit response items
        //         'to': this.seconds (), // end time in seconds, default to current time
        //     };
        //
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "publicSpotGetTrades" },
            { "margin", "publicSpotGetTrades" },
            { "swap", "publicFuturesGetSettleTrades" },
            { "future", "publicDeliveryGetSettleTrades" },
        });
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 1000
        }
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue((getValue(market, "contract")))))
        {
            ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot
        //
        //     [
        //         {
        //             id: "1852958144",
        //             create_time: "1634673259",
        //             create_time_ms: "1634673259378.105000",
        //             currency_pair: "ADA_USDT",
        //             side: "sell",
        //             amount: "307.078",
        //             price: "2.104",
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //              size: "2",
        //              id: "2522911",
        //              create_time_ms: "1634673380.182",
        //              create_time: "1634673380.182",
        //              contract: "ADA_USDT",
        //              price: "2.10486",
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades requires a symbol argument")) ;
        }
        //
        //      [
        //          {
        //              "id":"3711449544",
        //              "create_time":"1655486040",
        //              "create_time_ms":"1655486040177.599900",
        //              "currency_pair":"SHIB_USDT",
        //              "side":"buy",
        //              "role":"taker",
        //              "amount":"1360039",
        //              "price":"0.0000081084",
        //              "order_id":"169717399644",
        //              "fee":"2720.078",
        //              "fee_currency":"SHIB",
        //              "point_fee":"0",
        //              "gt_fee":"0"
        //          }
        //      ]
        //
        object response = await this.fetchMyTrades(symbol, since, limit, new Dictionary<string, object>() {
            { "order_id", id },
        });
        return response;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMyTrades
        * @description Fetch personal trading history
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string|undefined} params.type 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
        * @param {int|undefined} params.until The latest timestamp, in ms, that fetched trades were made
        * @param {int|undefined} params.page *spot only* Page number
        * @param {string|undefined} params.order_id *spot only* Filter trades with specified order ID. symbol is also required if this field is present
        * @param {string|undefined} params.order *contract only* Futures order ID, return related data only if specified
        * @param {int|undefined} params.offset *contract only* list offset, starting from 0
        * @param {string|undefined} params.last_id *contract only* specify list staring point using the id of last record in previous list-query results
        * @param {int|undefined} params.count_total *contract only* whether to return total number matched, default to 0(no return)
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object marginMode = null;
        object request = new Dictionary<string, object>() {};
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object until = this.safeInteger2(parameters, "until", "till");
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object contract = isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")));
        if (isTrue(contract))
        {
            var requestparametersVariable = this.prepareRequest(market, type, parameters);
            request = ((List<object>)requestparametersVariable)[0];
            parameters = ((List<object>)requestparametersVariable)[1];
        } else
        {
            if (isTrue(!isEqual(market, null)))
            {
                ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id"); // Should always be set for non-stop
            }
            var marginModeparametersVariable = this.getMarginMode(false, parameters);
            marginMode = ((List<object>)marginModeparametersVariable)[0];
            parameters = ((List<object>)marginModeparametersVariable)[1];
            ((Dictionary<string, object>)request)["account"] = marginMode;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 1000
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["to"] = this.parseToInt(divide(until, 1000));
        }
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "privateSpotGetMyTrades" },
            { "margin", "privateSpotGetMyTrades" },
            { "swap", "privateFuturesGetSettleMyTrades" },
            { "future", "privateDeliveryGetSettleMyTrades" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     [
        //         {
        //             "id": "2876130500",
        //             "create_time": "1645464610",
        //             "create_time_ms": "1645464610777.399200",
        //             "currency_pair": "DOGE_USDT",
        //             "side": "sell",
        //             "role": "taker",
        //             "amount": "10.97",
        //             "price": "0.137384",
        //             "order_id": "125924049993",
        //             "fee": "0.00301420496",
        //             "fee_currency": "USDT",
        //             "point_fee": "0",
        //             "gt_fee": "0"
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //             "size": -5,
        //             "order_id": "130264979823",
        //             "id": 26884791,
        //             "role": "taker",
        //             "create_time": 1645465199.5472,
        //             "contract": "DOGE_USDT",
        //             "price": "0.136888"
        //         }
        //     ]
        //
        // future
        //
        //     [
        //         {
        //             "id": 121234231,
        //             "create_time": 1514764800.123,
        //             "contract": "BTC_USDT",
        //             "order_id": "21893289839",
        //             "size": 100,
        //             "price": "100.123",
        //             "role": "taker"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public
        //
        //     {
        //         "id": "1334253759",
        //         "create_time": "1626342738",
        //         "create_time_ms": "1626342738331.497000",
        //         "currency_pair": "BTC_USDT",
        //         "side": "sell",
        //         "amount": "0.0022",
        //         "price": "32452.16"
        //     }
        //
        // public ws
        //
        //     {
        //         id: 221994511,
        //         time: 1580311438.618647,
        //         price: '9309',
        //         amount: '0.0019',
        //         type: 'sell'
        //     }
        //
        // spot rest
        //
        //     {
        //         "id": "2876130500",
        //         "create_time": "1645464610",
        //         "create_time_ms": "1645464610777.399200",
        //         "currency_pair": "DOGE_USDT",
        //         "side": "sell",
        //         "role": "taker",
        //         "amount": "10.97",
        //         "price": "0.137384",
        //         "order_id": "125924049993",
        //         "fee": "0.00301420496",
        //         "fee_currency": "USDT",
        //         "point_fee": "1.1",
        //         "gt_fee":"2.2"
        //     }
        //
        // perpetual swap rest
        //
        //     {
        //         "size": -5,
        //         "order_id": "130264979823",
        //         "id": 26884791,
        //         "role": "taker",
        //         "create_time": 1645465199.5472,
        //         "contract": "DOGE_USDT",
        //         "price": "0.136888"
        //     }
        //
        // future rest
        //
        //     {
        //         "id": 121234231,
        //         "create_time": 1514764800.123,
        //         "contract": "BTC_USDT",
        //         "order_id": "21893289839",
        //         "size": 100,
        //         "price": "100.123",
        //         "role": "taker"
        //     }
        //
        object id = this.safeString(trade, "id");
        object timestamp = this.safeTimestamp2(trade, "time", "create_time");
        timestamp = this.safeInteger(trade, "create_time_ms", timestamp);
        object marketId = this.safeString2(trade, "currency_pair", "contract");
        object marketType = ((bool) isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("contract"))))) ? "contract" : "spot";
        market = this.safeMarket(marketId, market, "_", marketType);
        object amountString = this.safeString2(trade, "amount", "size");
        object priceString = this.safeString(trade, "price");
        object contractSide = ((bool) isTrue(Precise.stringLt(amountString, "0"))) ? "sell" : "buy";
        amountString = Precise.stringAbs(amountString);
        object side = this.safeString2(trade, "side", "type", contractSide);
        object orderId = this.safeString(trade, "order_id");
        object feeAmount = this.safeString(trade, "fee");
        object gtFee = this.safeString(trade, "gt_fee");
        object pointFee = this.safeString(trade, "point_fee");
        object fees = new List<object>() {};
        if (isTrue(!isEqual(feeAmount, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrencyCode, null)))
            {
                feeCurrencyCode = this.safeString(market, "settle");
            }
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", feeCurrencyCode },
            });
        }
        if (isTrue(!isEqual(gtFee, null)))
        {
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", gtFee },
                { "currency", "GT" },
            });
        }
        if (isTrue(!isEqual(pointFee, null)))
        {
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", pointFee },
                { "currency", "GatePoint" },
            });
        }
        object takerOrMaker = this.safeString(trade, "role");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
            { "fees", fees },
        }, market);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            object start = this.parseToInt(divide(since, 1000));
            ((Dictionary<string, object>)request)["from"] = start;
            ((Dictionary<string, object>)request)["to"] = this.sum(start, multiply(multiply(multiply(30, 24), 60), 60));
        }
        object response = await this.privateWalletGetDeposits(this.extend(request, parameters));
        return this.parseTransactions(response, currency);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            object start = this.parseToInt(divide(since, 1000));
            ((Dictionary<string, object>)request)["from"] = start;
            ((Dictionary<string, object>)request)["to"] = this.sum(start, multiply(multiply(multiply(30, 24), 60), 60));
        }
        object response = await this.privateWalletGetWithdrawals(this.extend(request, parameters));
        return this.parseTransactions(response, currency);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "address", address },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["memo"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeStringLower(networks, network, network); // handle ETH>ERC20 alias
        if (isTrue(!isEqual(network, null)))
        {
            ((Dictionary<string, object>)request)["chain"] = network;
            parameters = this.omit(parameters, "network");
        } else
        {
            ((Dictionary<string, object>)request)["chain"] = getValue(currency, "id");
        }
        object response = await this.privateWithdrawalsPostWithdrawals(this.extend(request, parameters));
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        return this.parseTransaction(response, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PEND", "pending" },
            { "REQUEST", "pending" },
            { "DMOVE", "pending" },
            { "CANCEL", "failed" },
            { "DONE", "ok" },
            { "BCODE", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "d", "deposit" },
            { "w", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // deposits
        //
        //    {
        //        "id": "d33361395",
        //        "currency": "USDT_TRX",
        //        "address": "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
        //        "amount": "100",
        //        "txid": "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
        //        "timestamp": "1626345819",
        //        "status": "DONE",
        //        "memo": ""
        //    }
        //
        // withdraw
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        object id = this.safeString(transaction, "id");
        object type = null;
        object amountString = this.safeString(transaction, "amount");
        if (isTrue(!isEqual(id, null)))
        {
            if (isTrue(isEqual(getValue(id, 0), "b")))
            {
                // GateCode handling
                type = ((bool) isTrue(Precise.stringGt(amountString, "0"))) ? "deposit" : "withdrawal";
                amountString = Precise.stringAbs(amountString);
            } else
            {
                type = this.parseTransactionType(getValue(id, 0));
            }
        }
        object feeCostString = this.safeString(transaction, "fee");
        if (isTrue(isEqual(type, "withdrawal")))
        {
            amountString = Precise.stringSub(amountString, feeCostString);
        }
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object txid = this.safeString(transaction, "txid");
        object rawStatus = this.safeString(transaction, "status");
        object status = this.parseTransactionStatus(rawStatus);
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "memo");
        object timestamp = this.safeTimestamp(transaction, "timestamp");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "currency", code },
            { "amount", this.parseNumber(amountString) },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "updated", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostString) },
            } },
        };
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#createOrder
        * @description Create an order on the exchange
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} type 'limit' or 'market' *"market" is contract only*
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount the amount of currency to trade
        * @param {float|undefined} price *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
        * @param {object} params  Extra parameters specific to the exchange API endpoint
        * @param {float|undefined} params.stopPrice The price at which a trigger order is triggered at
        * @param {string|undefined} params.timeInForce "GTC", "IOC", or "PO"
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {int|undefined} params.iceberg Amount to display for the iceberg order, Null or 0 for normal orders, Set to -1 to hide the order completely
        * @param {string|undefined} params.text User defined information
        * @param {string|undefined} params.account *spot and margin only* "spot", "margin" or "cross_margin"
        * @param {bool|undefined} params.auto_borrow *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
        * @param {string|undefined} params.settle *contract only* Unified Currency Code for settle currency
        * @param {bool|undefined} params.reduceOnly *contract only* Indicates if this order is to reduce the size of a position
        * @param {bool|undefined} params.close *contract only* Set as true to close the position, with size set to 0
        * @param {bool|undefined} params.auto_size *contract only* Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
        * @param {int|undefined} params.price_type *contract only* 0 latest deal price, 1 mark price, 2 index price
        * @returns {object|undefined} [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object contract = getValue(market, "contract");
        object trigger = this.safeValue(parameters, "trigger");
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object isStopOrder = isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder);
        if (isTrue(isTrue(isStopLossOrder) && isTrue(isTakeProfitOrder)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() stopLossPrice and takeProfitPrice cannot both be defined")) ;
        }
        object methodTail = "Orders";
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object exchangeSpecificTimeInForce = this.safeStringLowerN(parameters, new List<object>() {"timeInForce", "tif", "time_in_force"});
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(exchangeSpecificTimeInForce, "poc"), parameters);
        postOnly = ((List<object>)postOnlyparametersVariable)[0];
        parameters = ((List<object>)postOnlyparametersVariable)[1];
        object timeInForce = this.handleTimeInForce(parameters);
        if (isTrue(postOnly))
        {
            timeInForce = "poc";
        }
        // we only omit the unified params here
        // this is because the other params will get extended into the request
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice", "reduceOnly", "timeInForce", "postOnly"});
        object isLimitOrder = (isEqual(type, "limit"));
        object isMarketOrder = (isEqual(type, "market"));
        if (isTrue(isTrue(isLimitOrder) && isTrue(isEqual(price, null))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder () requires a price argument for "), type), " orders")) ;
        }
        if (isTrue(isMarketOrder))
        {
            if (isTrue(isTrue((isEqual(timeInForce, "poc"))) || isTrue((isEqual(timeInForce, "gtc")))))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder () timeInForce for market order can only be \"FOK\" or \"IOC\"")) ;
            } else
            {
                if (isTrue(isEqual(timeInForce, null)))
                {
                    object defaultTif = this.safeString(this.options, "defaultTimeInForce", "IOC");
                    object exchangeSpecificTif = this.safeString(getValue(this.options, "timeInForce"), defaultTif, "ioc");
                    timeInForce = exchangeSpecificTif;
                }
            }
            if (isTrue(contract))
            {
                price = 0;
            }
        }
        if (isTrue(contract))
        {
            object amountToPrecision = this.amountToPrecision(symbol, amount);
            object signedAmount = ((bool) isTrue((isEqual(side, "sell")))) ? Precise.stringNeg(amountToPrecision) : amountToPrecision;
            amount = parseInt(signedAmount);
        }
        object request = null;
        object nonTriggerOrder = !isTrue(isStopOrder) && isTrue((isEqual(trigger, null)));
        if (isTrue(nonTriggerOrder))
        {
            if (isTrue(contract))
            {
                // contract order
                request = new Dictionary<string, object>() {
                    { "contract", getValue(market, "id") },
                    { "size", amount },
                    { "settle", getValue(market, "settleId") },
                };
                if (isTrue(isMarketOrder))
                {
                    ((Dictionary<string, object>)request)["price"] = price; // set to 0 for market orders
                } else
                {
                    ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(!isEqual(reduceOnly, null)))
                {
                    ((Dictionary<string, object>)request)["reduce_only"] = reduceOnly;
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((Dictionary<string, object>)request)["tif"] = timeInForce;
                }
            } else
            {
                object marginMode = null;
                var marginModeparametersVariable = this.getMarginMode(false, parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                // spot order
                request = new Dictionary<string, object>() {
                    { "currency_pair", getValue(market, "id") },
                    { "type", type },
                    { "account", marginMode },
                    { "side", side },
                };
                object createMarketBuyOrderRequiresPrice = this.safeValue(this.options, "createMarketBuyOrderRequiresPrice", true);
                if (isTrue(isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")))))
                {
                    if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(isEqual(price, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")) ;
                        } else
                        {
                            object amountString = this.numberToString(amount);
                            object priceString = this.numberToString(price);
                            object cost = this.parseNumber(Precise.stringMul(amountString, priceString));
                            ((Dictionary<string, object>)request)["amount"] = this.costToPrecision(symbol, cost);
                        }
                    } else
                    {
                        object cost = this.safeNumber(parameters, "cost", amount);
                        parameters = this.omit(parameters, "cost");
                        ((Dictionary<string, object>)request)["amount"] = this.costToPrecision(symbol, cost);
                    }
                } else
                {
                    ((Dictionary<string, object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                }
                if (isTrue(isLimitOrder))
                {
                    ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((Dictionary<string, object>)request)["time_in_force"] = timeInForce;
                }
            }
            object clientOrderId = this.safeString2(parameters, "text", "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                // user-defined, must follow the rules if not empty
                //     prefixed with t-
                //     no longer than 28 bytes without t- prefix
                //     can only include 0-9, A-Z, a-z, underscores (_), hyphens (-) or dots (.)
                if (isTrue(isGreaterThan(((string)clientOrderId).Length, 28)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder () clientOrderId or text param must be up to 28 characters")) ;
                }
                parameters = this.omit(parameters, new List<object>() {"text", "clientOrderId"});
                if (isTrue(!isEqual(getValue(clientOrderId, 0), "t")))
                {
                    clientOrderId = add("t-", clientOrderId);
                }
                ((Dictionary<string, object>)request)["text"] = clientOrderId;
            }
        } else
        {
            if (isTrue(contract))
            {
                // contract conditional order
                request = new Dictionary<string, object>() {
                    { "initial", new Dictionary<string, object>() {
                        { "contract", getValue(market, "id") },
                        { "size", amount },
                        { "price", this.priceToPrecision(symbol, price) },
                    } },
                    { "settle", getValue(market, "settleId") },
                };
                if (isTrue(isEqual(trigger, null)))
                {
                    object rule = null;
                    object triggerOrderPrice = null;
                    if (isTrue(isStopLossOrder))
                    {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? 1 : 2;
                        triggerOrderPrice = this.priceToPrecision(symbol, stopLossPrice);
                    } else if (isTrue(isTakeProfitOrder))
                    {
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? 2 : 1;
                        triggerOrderPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    }
                    object priceType = this.safeInteger(parameters, "price_type", 0);
                    if (isTrue(isTrue(isLessThan(priceType, 0)) || isTrue(isGreaterThan(priceType, 2))))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrder () price_type should be 0 latest deal price, 1 mark price, 2 index price")) ;
                    }
                    parameters = this.omit(parameters, new List<object>() {"price_type"});
                    ((Dictionary<string, object>)request)["trigger"] = new Dictionary<string, object>() {
                        { "price_type", priceType },
                        { "price", this.priceToPrecision(symbol, triggerOrderPrice) },
                        { "rule", rule },
                    };
                }
                if (isTrue(!isEqual(reduceOnly, null)))
                {
                    ((Dictionary<string, object>)getValue(request, "initial"))["reduce_only"] = reduceOnly;
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((Dictionary<string, object>)getValue(request, "initial"))["tif"] = timeInForce;
                }
            } else
            {
                // spot conditional order
                object options = this.safeValue(this.options, "createOrder", new Dictionary<string, object>() {});
                object marginMode = null;
                var marginModeparametersVariable = this.getMarginMode(true, parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                if (isTrue(isEqual(timeInForce, null)))
                {
                    timeInForce = "gtc";
                }
                request = new Dictionary<string, object>() {
                    { "put", new Dictionary<string, object>() {
                        { "type", type },
                        { "side", side },
                        { "price", this.priceToPrecision(symbol, price) },
                        { "amount", this.amountToPrecision(symbol, amount) },
                        { "account", marginMode },
                        { "time_in_force", timeInForce },
                    } },
                    { "market", getValue(market, "id") },
                };
                if (isTrue(isEqual(trigger, null)))
                {
                    object defaultExpiration = this.safeInteger(options, "expiration");
                    object expiration = this.safeInteger(parameters, "expiration", defaultExpiration);
                    object rule = null;
                    object triggerOrderPrice = null;
                    if (isTrue(isStopLossOrder))
                    {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? ">=" : "<=";
                        triggerOrderPrice = this.priceToPrecision(symbol, stopLossPrice);
                    } else if (isTrue(isTakeProfitOrder))
                    {
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? "<=" : ">=";
                        triggerOrderPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    }
                    ((Dictionary<string, object>)request)["trigger"] = new Dictionary<string, object>() {
                        { "price", this.priceToPrecision(symbol, triggerOrderPrice) },
                        { "rule", rule },
                        { "expiration", expiration },
                    };
                }
            }
            methodTail = "PriceOrders";
        }
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", add("privateSpotPost", methodTail) },
            { "margin", add("privateSpotPost", methodTail) },
            { "swap", add("privateFuturesPostSettle", methodTail) },
            { "future", add("privateDeliveryPostSettle", methodTail) },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.deepExtend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383156",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383156017,
        //         "status": "open",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {"id": 5891843}
        //
        // future and perpetual swaps
        //
        //     {
        //         "id": 95938572327,
        //         "contract": "ETH_USDT",
        //         "mkfr": "0",
        //         "tkfr": "0.0005",
        //         "tif": "gtc",
        //         "is_reduce_only": false,
        //         "create_time": 1637384600.08,
        //         "price": "3000",
        //         "size": 1,
        //         "refr": "0",
        //         "left": 1,
        //         "text": "api",
        //         "fill_price": "0",
        //         "user": 2436035,
        //         "status": "open",
        //         "is_liq": false,
        //         "refu": 0,
        //         "is_close": false,
        //         "iceberg": 0
        //     }
        //
        // futures and perpetual swaps conditionals
        //
        //     {"id": 7615567}
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#editOrder
        * @description edit a trade order, gate currently only supports the modification of the price or amount fields
        * @see https://www.gate.io/docs/developers/apiv4/en/#amend-an-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " editOrder() supports only spot markets")) ;
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("editOrder", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object account = this.convertTypeToAccount(marketType);
        object isLimitOrder = (isEqual(type, "limit"));
        if (isTrue(isEqual(account, "spot")))
        {
            if (!isTrue(isLimitOrder))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " editOrder() does not support "), type), " orders for "), marketType), " markets")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "currency_pair", getValue(market, "id") },
            { "account", account },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((Dictionary<string, object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privateSpotPatchOrdersOrderId(this.extend(request, query));
        //
        //     {
        //         "id": "243233276443",
        //         "text": "apiv4",
        //         "create_time": "1670908873",
        //         "update_time": "1670914102",
        //         "create_time_ms": 1670908873077,
        //         "update_time_ms": 1670914102241,
        //         "status": "open",
        //         "currency_pair": "ADA_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "sell",
        //         "amount": "10",
        //         "price": "0.6",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "10",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "USDT",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_maker_fee": "0",
        //         "gt_taker_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "ADA"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", "open" },
            { "_new", "open" },
            { "filled", "closed" },
            { "cancelled", "canceled" },
            { "liquidated", "closed" },
            { "ioc", "canceled" },
            { "failed", "canceled" },
            { "expired", "canceled" },
            { "finished", "closed" },
            { "succeeded", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // SPOT
        // createOrder/cancelOrder/fetchOrder/editOrder
        //
        //    {
        //        "id": "62364648575",
        //        "text": "apiv4",
        //        "create_time": "1626354834",
        //        "update_time": "1626354834",
        //        "create_time_ms": "1626354833544",
        //        "update_time_ms": "1626354833544",
        //        "status": "open",
        //        "currency_pair": "BTC_USDT",
        //        "type": "limit",
        //        "account": "spot",
        //        "side": "buy",
        //        "amount": "0.0001",
        //        "price": "30000",
        //        "time_in_force": "gtc",
        //        "iceberg": "0",
        //        "left": "0.0001",
        //        "fill_price": "0",
        //        "filled_total": "0",
        //        "fee": "0",
        //        "fee_currency": "BTC",
        //        "point_fee": "0",
        //        "gt_fee": "0",
        //        "gt_discount": true,
        //        "rebated_fee": "0",
        //        "rebated_fee_currency": "USDT"
        //     }
        //
        // SPOT TRIGGER ORDERS
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "market": "ADA_USDT",
        //        "user": 6392049,
        //        "trigger": {
        //            "price": "1.08", // stopPrice
        //            "rule": "\u003e=",
        //            "expiration": 86400
        //        },
        //        "put": {
        //            "type": "limit",
        //            "side": "buy",
        //            "price": "1.08", // order price
        //            "amount": "1.00000000000000000000",
        //            "account": "normal",
        //            "time_in_force": "gtc"
        //        },
        //        "id": 71639298,
        //        "ctime": 1643945985,
        //        "status": "open"
        //    }
        //
        // FUTURE AND SWAP
        // createOrder/cancelOrder/fetchOrder
        //
        //    {
        //        "id": 123028481731,
        //        "contract": "ADA_USDT",
        //        "mkfr": "-0.00005",
        //        "tkfr": "0.00048",
        //        "tif": "ioc",
        //        "is_reduce_only": false,
        //        "create_time": 1643950262.68,
        //        "finish_time": 1643950262.68,
        //        "price": "0",
        //        "size": 1,
        //        "refr": "0",
        //        "left":0,
        //        "text": "api",
        //        "fill_price": "1.05273",
        //        "user":6329238,
        //        "finish_as": "filled",
        //        "status": "finished",
        //        "is_liq": false,
        //        "refu":0,
        //        "is_close": false,
        //        "iceberg": 0
        //    }
        //
        // TRIGGER ORDERS (FUTURE AND SWAP)
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "user": 6320300,
        //        "trigger": {
        //            "strategy_type": 0,
        //            "price_type": 0,
        //            "price": "1.03", // stopPrice
        //            "rule": 2,
        //            "expiration": 0
        //        },
        //        "initial": {
        //            "contract": "ADA_USDT",
        //            "size": -1,
        //            "price": "1.02",
        //            "tif": "gtc",
        //            "text": "",
        //            "iceberg": 0,
        //            "is_close": false,
        //            "is_reduce_only": false,
        //            "auto_size": ""
        //        },
        //        "id": 126393906,
        //        "trade_id": 0,
        //        "status": "open",
        //        "reason": "",
        //        "create_time": 1643953482,
        //        "finish_time": 1643953482,
        //        "is_stop_order": false,
        //        "stop_trigger": {
        //            "rule": 0,
        //            "trigger_price": "",
        //            "order_price": ""
        //        },
        //        "me_order_id": 0,
        //        "order_type": ""
        //    }
        //
        object put = this.safeValue2(order, "put", "initial");
        object trigger = this.safeValue(order, "trigger");
        object contract = this.safeString(put, "contract");
        object type = this.safeString(put, "type");
        object timeInForce = this.safeStringUpper2(put, "time_in_force", "tif");
        object amount = this.safeString2(put, "amount", "size");
        object side = this.safeString(put, "side");
        object price = this.safeString(put, "price");
        contract = this.safeString(order, "contract", contract);
        type = this.safeString(order, "type", type);
        timeInForce = this.safeStringUpper2(order, "time_in_force", "tif", timeInForce);
        if (isTrue(isEqual(timeInForce, "POC")))
        {
            timeInForce = "PO";
        }
        object postOnly = (isEqual(timeInForce, "PO"));
        amount = this.safeString2(order, "amount", "size", amount);
        side = this.safeString(order, "side", side);
        price = this.safeString(order, "price", price);
        object remainingString = this.safeString(order, "left");
        object filledString = Precise.stringSub(amount, remainingString);
        object cost = this.safeString(order, "filled_total");
        object rawStatus = null;
        object average = this.safeNumber2(order, "avg_deal_price", "fill_price");
        if (isTrue(put))
        {
            remainingString = amount;
            filledString = "0";
            cost = "0";
        }
        if (isTrue(contract))
        {
            object isMarketOrder = isTrue(Precise.stringEquals(price, "0")) && isTrue((isEqual(timeInForce, "IOC")));
            type = ((bool) isTrue(isMarketOrder)) ? "market" : "limit";
            side = ((bool) isTrue(Precise.stringGt(amount, "0"))) ? "buy" : "sell";
            rawStatus = this.safeString(order, "finish_as", "open");
        } else
        {
            rawStatus = this.safeString(order, "status");
        }
        object timestamp = this.safeInteger(order, "create_time_ms");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeTimestamp2(order, "create_time", "ctime");
        }
        object lastTradeTimestamp = this.safeInteger(order, "update_time_ms");
        if (isTrue(isEqual(lastTradeTimestamp, null)))
        {
            lastTradeTimestamp = this.safeTimestamp2(order, "update_time", "finish_time");
        }
        object marketType = ((bool) isTrue((((Dictionary<string,object>)order).ContainsKey(toStringOrNull("currency_pair"))))) ? "spot" : "contract";
        object exchangeSymbol = this.safeString2(order, "currency_pair", "market", contract);
        object symbol = this.safeSymbol(exchangeSymbol, market, "_", marketType);
        // Everything below this(above return) is related to fees
        object fees = new List<object>() {};
        object gtFee = this.safeString(order, "gt_fee");
        if (isTrue(gtFee))
        {
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", "GT" },
                { "cost", gtFee },
            });
        }
        object fee = this.safeString(order, "fee");
        if (isTrue(fee))
        {
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "fee_currency")) },
                { "cost", fee },
            });
        }
        object rebate = this.safeString(order, "rebated_fee");
        if (isTrue(rebate))
        {
            ((List<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "rebated_fee_currency")) },
                { "cost", Precise.stringNeg(rebate) },
            });
        }
        object numFeeCurrencies = getArrayLength(fees);
        object multipleFeeCurrencies = isGreaterThan(numFeeCurrencies, 1);
        object status = this.parseOrderStatus(rawStatus);
        object filled = Precise.stringAbs(filledString);
        object remaining = Precise.stringAbs(remainingString);
        // handle spot market buy
        object account = this.safeString(order, "account"); // using this instead of market type because of the conflicting ids
        if (isTrue(isEqual(account, "spot")))
        {
            object averageString = this.safeString(order, "avg_deal_price");
            average = this.parseNumber(averageString);
            if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
            {
                filled = Precise.stringDiv(filledString, averageString);
                remaining = Precise.stringDiv(remainingString, averageString);
                price = null; // arrives as 0
                cost = amount;
                amount = Precise.stringDiv(amount, averageString);
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "text") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeValue(order, "is_reduce_only") },
            { "side", side },
            { "price", this.parseNumber(price) },
            { "stopPrice", this.safeNumber(trigger, "price") },
            { "triggerPrice", this.safeNumber(trigger, "price") },
            { "average", average },
            { "amount", this.parseNumber(Precise.stringAbs(amount)) },
            { "cost", Precise.stringAbs(cost) },
            { "filled", filled },
            { "remaining", remaining },
            { "fee", ((bool) isTrue(multipleFeeCurrencies)) ? null : this.safeValue(fees, 0) },
            { "fees", ((bool) isTrue(multipleFeeCurrencies)) ? fees : new List<object>() {} },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrder
        * @description Retrieves information on an order
        * @param {string} id Order id
        * @param {string} symbol Unified market symbol, *required for spot and margin*
        * @param {object} params Parameters specified by the exchange api
        * @param {bool} params.stop True if the order being fetched is a trigger order
        * @param {string} params.marginMode 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string} params.type 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
        * @param {string} params.settle 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue2(parameters, "is_stop_order", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"is_stop_order", "stop"});
        object clientOrderId = this.safeString2(parameters, "text", "clientOrderId");
        object orderId = id;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"text", "clientOrderId"});
            if (isTrue(!isEqual(getValue(clientOrderId, 0), "t")))
            {
                clientOrderId = add("t-", clientOrderId);
            }
            orderId = clientOrderId;
        }
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        object contract = isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")));
        var requestrequestParamsVariable = ((bool) isTrue(contract)) ? this.prepareRequest(market, type, query) : this.spotOrderPrepareRequest(market, stop, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        ((Dictionary<string, object>)request)["order_id"] = orderId;
        object methodMiddle = ((bool) isTrue(stop)) ? "PriceOrders" : "Orders";
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", add(add("privateSpotGet", methodMiddle), "OrderId") },
            { "margin", add(add("privateSpotGet", methodMiddle), "OrderId") },
            { "swap", add(add("privateFuturesGetSettle", methodMiddle), "OrderId") },
            { "future", add(add("privateDeliveryGetSettle", methodMiddle), "OrderId") },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {bool} params.stop true for fetching stop orders
        * @param {string} params.type spot, margin, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} params.marginMode 'cross' or 'isolated' - marginMode for type='margin', if not provided this.options['defaultMarginMode'] is used
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return ((object)await this.fetchOrdersByStatus("open", symbol, since, limit, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {bool} params.stop true for fetching stop orders
        * @param {string} params.type spot, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} params.marginMode 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return ((object)await this.fetchOrdersByStatus("finished", symbol, since, limit, parameters));
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, "stop");
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        object spot = isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")));
        var requestrequestParamsVariable = ((bool) isTrue(spot)) ? this.multiOrderSpotPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        if (isTrue(isEqual(status, "closed")))
        {
            status = "finished";
        }
        ((Dictionary<string, object>)request)["status"] = status;
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(spot)))
        {
            ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        object methodTail = ((bool) isTrue(stop)) ? "PriceOrders" : "Orders";
        object openSpotOrders = isTrue(isTrue(spot) && isTrue((isEqual(status, "open")))) && !isTrue(stop);
        if (isTrue(openSpotOrders))
        {
            methodTail = "OpenOrders";
        }
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", add("privateSpotGet", methodTail) },
            { "margin", add("privateSpotGet", methodTail) },
            { "swap", add("privateFuturesGetSettle", methodTail) },
            { "future", add("privateDeliveryGetSettle", methodTail) },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        // SPOT Open Orders
        //
        //    [
        //        {
        //            "currency_pair": "ADA_USDT",
        //            "total": 2,
        //            "orders": [
        //                {
        //                    "id": "155498539874",
        //                    "text": "apiv4",
        //                    "create_time": "1652406843",
        //                    "update_time": "1652406843",
        //                    "create_time_ms": 1652406843295,
        //                    "update_time_ms": 1652406843295,
        //                    "status": "open",
        //                    "currency_pair": "ADA_USDT",
        //                    "type": "limit",
        //                    "account": "spot",
        //                    "side": "buy",
        //                    "amount": "3",
        //                    "price": "0.35",
        //                    "time_in_force": "gtc",
        //                    "iceberg": "0",
        //                    "left": "3",
        //                    "fill_price": "0",
        //                    "filled_total": "0",
        //                    "fee": "0",
        //                    "fee_currency": "ADA",
        //                    "point_fee": "0",
        //                    "gt_fee": "0",
        //                    "gt_discount": false,
        //                    "rebated_fee": "0",
        //                    "rebated_fee_currency": "USDT"
        //                },
        //                ...
        //            ]
        //        },
        //        ...
        //    ]
        //
        // SPOT
        //
        //    [
        //        {
        //           "id": "8834234273",
        //           "text": "3",
        //           "create_time": "1635406193",
        //           "update_time": "1635406193",
        //           "create_time_ms": 1635406193361,
        //           "update_time_ms": 1635406193361,
        //           "status": "closed",
        //           "currency_pair": "BTC_USDT",
        //           "type": "limit",
        //           "account": "spot", // margin for margin orders
        //           "side": "sell",
        //           "amount": "0.0002",
        //           "price": "58904.01",
        //           "time_in_force": "gtc",
        //           "iceberg": "0",
        //           "left": "0.0000",
        //           "fill_price": "11.790516",
        //           "filled_total": "11.790516",
        //           "fee": "0.023581032",
        //           "fee_currency": "USDT",
        //           "point_fee": "0",
        //           "gt_fee": "0",
        //           "gt_discount": false,
        //           "rebated_fee_currency": "BTC"
        //        }
        //    ]
        //
        // Spot Stop
        //
        //    [
        //        {
        //            "market": "ADA_USDT",
        //            "user": 10406147,
        //            "trigger": {
        //                "price": "0.65",
        //                "rule": "\u003c=",
        //                "expiration": 86400
        //            },
        //            "put": {
        //                "type": "limit",
        //                "side": "sell",
        //                "price": "0.65",
        //                "amount": "2.00000000000000000000",
        //                "account": "normal",  // margin for margin orders
        //                "time_in_force": "gtc"
        //            },
        //            "id": 8449909,
        //            "ctime": 1652188982,
        //            "status": "open"
        //        }
        //    ]
        //
        // Perpetual Swap
        //
        //    [
        //        {
        //           "status": "finished",
        //           "size": -1,
        //           "left": 0,
        //           "id": 82750739203,
        //           "is_liq": false,
        //           "is_close": false,
        //           "contract": "BTC_USDT",
        //           "text": "web",
        //           "fill_price": "60721.3",
        //           "finish_as": "filled",
        //           "iceberg": 0,
        //           "tif": "ioc",
        //           "is_reduce_only": true,
        //           "create_time": 1635403475.412,
        //           "finish_time": 1635403475.4127,
        //           "price": "0"
        //        }
        //    ]
        //
        object result = response;
        if (isTrue(openSpotOrders))
        {
            result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object ordersInner = this.safeValue(getValue(response, i), "orders");
                result = this.arrayConcat(result, ordersInner);
            }
        }
        object orders = this.parseOrders(result, market, since, limit);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#cancelOrder
        * @description Cancels an open order
        * @param {string} id Order id
        * @param {string} symbol Unified market symbol
        * @param {object} params Parameters specified by the exchange api
        * @param {bool} params.stop True if the order to be cancelled is a trigger order
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeValue2(parameters, "is_stop_order", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"is_stop_order", "stop"});
        var typequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))) ? this.spotOrderPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        ((Dictionary<string, object>)request)["order_id"] = id;
        object pathMiddle = ((bool) isTrue(stop)) ? "Price" : "";
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", add(add("privateSpotDelete", pathMiddle), "OrdersOrderId") },
            { "margin", add(add("privateSpotDelete", pathMiddle), "OrdersOrderId") },
            { "swap", add(add("privateFuturesDeleteSettle", pathMiddle), "OrdersOrderId") },
            { "future", add(add("privateDeliveryDeleteSettle", pathMiddle), "OrdersOrderId") },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383235",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383235085,
        //         "status": "cancelled",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {
        //         "market": "ETH_USDT",
        //         "user": 2436035,
        //         "trigger": {
        //             "price": "3500",
        //             "rule": "\u003c=",
        //             "expiration": 86400
        //         },
        //         "put": {
        //             "type": "limit",
        //             "side": "buy",
        //             "price": "3500",
        //             "amount": "0.01000000000000000000",
        //             "account": "normal",
        //             "time_in_force": "gtc"
        //         },
        //         "id": 5891843,
        //         "ctime": 1637382379,
        //         "ftime": 1637382673,
        //         "status": "canceled"
        //     }
        //
        // perpetual swaps
        //
        //     {
        //         id: "82241928192",
        //         contract: "BTC_USDT",
        //         mkfr: "0",
        //         tkfr: "0.0005",
        //         tif: "gtc",
        //         is_reduce_only: false,
        //         create_time: "1635196145.06",
        //         finish_time: "1635196233.396",
        //         price: "61000",
        //         size: "4",
        //         refr: "0",
        //         left: "4",
        //         text: "web",
        //         fill_price: "0",
        //         user: "6693577",
        //         finish_as: "cancelled",
        //         status: "finished",
        //         is_liq: false,
        //         refu: "0",
        //         is_close: false,
        //         iceberg: "0",
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, "stop");
        var typequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isEqual(type, "spot")))) ? this.multiOrderSpotPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        object methodTail = ((bool) isTrue(stop)) ? "PriceOrders" : "Orders";
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", add("privateSpotDelete", methodTail) },
            { "margin", add("privateSpotDelete", methodTail) },
            { "swap", add("privateFuturesDeleteSettle", methodTail) },
            { "future", add("privateDeliveryDeleteSettle", methodTail) },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        //    [
        //        {
        //            "id": 139797004085,
        //            "contract": "ADA_USDT",
        //            "mkfr": "0",
        //            "tkfr": "0.0005",
        //            "tif": "gtc",
        //            "is_reduce_only": false,
        //            "create_time": 1647911169.343,
        //            "finish_time": 1647911226.849,
        //            "price": "0.8",
        //            "size": 1,
        //            "refr": "0.3",
        //            "left": 1,
        //            "text": "api",
        //            "fill_price": "0",
        //            "user": 6693577,
        //            "finish_as": "cancelled",
        //            "status": "finished",
        //            "is_liq": false,
        //            "refu": 2436035,
        //            "is_close": false,
        //            "iceberg": 0
        //        }
        //        ...
        //    ]
        //
        return this.parseOrders(response, market);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name gate#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code for currency being transferred
        * @param {float} amount the amount of currency to transfer
        * @param {string} fromAccount the account to transfer currency from
        * @param {string} toAccount the account to transfer currency to
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {string|undefined} params.symbol Unified market symbol *required for type == margin*
        * @returns A [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        object truncated = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", truncated },
        };
        if (!isTrue((((Dictionary<string,object>)getValue(this.options, "accountsByType")).ContainsKey(toStringOrNull(fromId)))))
        {
            ((Dictionary<string, object>)request)["from"] = "margin";
            ((Dictionary<string, object>)request)["currency_pair"] = fromId;
        } else
        {
            ((Dictionary<string, object>)request)["from"] = fromId;
        }
        if (!isTrue((((Dictionary<string,object>)getValue(this.options, "accountsByType")).ContainsKey(toStringOrNull(toId)))))
        {
            ((Dictionary<string, object>)request)["to"] = "margin";
            ((Dictionary<string, object>)request)["currency_pair"] = toId;
        } else
        {
            ((Dictionary<string, object>)request)["to"] = toId;
        }
        if (isTrue(isTrue(isEqual(fromId, "margin")) || isTrue(isEqual(toId, "margin"))))
        {
            object symbol = this.safeString2(parameters, "symbol", "currency_pair");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer requires params[\"symbol\"] for isolated margin transfers")) ;
            }
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
            parameters = this.omit(parameters, "symbol");
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(toId, "futures"))) || isTrue((isEqual(toId, "delivery")))) || isTrue((isEqual(fromId, "futures")))) || isTrue((isEqual(fromId, "delivery")))))
        {
            ((Dictionary<string, object>)request)["settle"] = getValue(currency, "lowerCaseId");
        }
        object response = await this.privateWalletPostTransfers(this.extend(request, parameters));
        //
        // according to the docs (however actual response seems to be an empty string '')
        //
        //    {
        //        "currency": "BTC",
        //        "from": "spot",
        //        "to": "margin",
        //        "amount": "1",
        //        "currency_pair": "BTC_USDT"
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object timestamp = this.milliseconds();
        return new Dictionary<string, object>() {
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
            { "info", transfer },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 0))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 100")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "swap", "privateFuturesPostSettlePositionsContractLeverage" },
            { "future", "privateDeliveryPostSettlePositionsContractLeverage" },
        });
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        object defaultMarginMode = this.safeString2(this.options, "marginMode", "defaultMarginMode");
        object crossLeverageLimit = this.safeString(query, "cross_leverage_limit");
        object marginMode = this.safeString(query, "marginMode", defaultMarginMode);
        if (isTrue(!isEqual(crossLeverageLimit, null)))
        {
            marginMode = "cross";
            leverage = crossLeverageLimit;
        }
        if (isTrue(isTrue(isEqual(marginMode, "cross")) || isTrue(isEqual(marginMode, "cross_margin"))))
        {
            ((Dictionary<string, object>)request)["cross_leverage_limit"] = ((object)leverage).ToString();
            ((Dictionary<string, object>)request)["leverage"] = "0";
        } else
        {
            ((Dictionary<string, object>)request)["leverage"] = ((object)leverage).ToString();
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "value": "0",
        //         "leverage": "5",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "BTC_USDT",
        //         "entry_price": "0",
        //         "mark_price": "62035.86",
        //         "history_point": "0",
        //         "realised_pnl": "0",
        //         "close_order": null,
        //         "size": 0,
        //         "cross_leverage_limit": "0",
        //         "pending_orders": 0,
        //         "adl_ranking": 6,
        //         "maintenance_rate": "0.005",
        //         "unrealised_pnl": "0",
        //         "user": 2436035,
        //         "leverage_max": "100",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "0",
        //         "last_close_pnl": "0",
        //         "liq_price": "0"
        //     }
        //
        return response;
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         value: "12.475572",
        //         leverage: "0",
        //         mode: "single",
        //         realised_point: "0",
        //         contract: "BTC_USDT",
        //         entry_price: "62422.6",
        //         mark_price: "62377.86",
        //         history_point: "0",
        //         realised_pnl: "-0.00624226",
        //         close_order:  null,
        //         size: "2",
        //         cross_leverage_limit: "25",
        //         pending_orders: "0",
        //         adl_ranking: "5",
        //         maintenance_rate: "0.005",
        //         unrealised_pnl: "-0.008948",
        //         user: "663337",
        //         leverage_max: "100",
        //         history_pnl: "14.98868396636",
        //         risk_limit: "1000000",
        //         margin: "0.740721495056",
        //         last_close_pnl: "-0.041996015",
        //         liq_price: "59058.58"
        //     }
        //
        object contract = this.safeString(position, "contract");
        market = this.safeMarket(contract, market, "_", "contract");
        object size = this.safeString(position, "size");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else if (isTrue(Precise.stringLt(size, "0")))
        {
            side = "short";
        }
        object maintenanceRate = this.safeString(position, "maintenance_rate");
        object notional = this.safeString(position, "value");
        object leverage = this.safeString(position, "leverage");
        object marginMode = null;
        if (isTrue(isEqual(leverage, "0")))
        {
            marginMode = "cross";
        } else
        {
            marginMode = "isolated";
        }
        object unrealisedPnl = this.safeString(position, "unrealised_pnl");
        // Initial Position Margin = ( Position Value / Leverage ) + Close Position Fee
        // *The default leverage under the full position is the highest leverage in the market.
        // *Trading fee is charged as Taker Fee Rate (0.075%).
        object takerFee = "0.00075";
        object feePaid = Precise.stringMul(takerFee, notional);
        object initialMarginString = Precise.stringAdd(Precise.stringDiv(notional, leverage), feePaid);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(Precise.stringDiv(initialMarginString, notional)) },
            { "maintenanceMargin", this.parseNumber(Precise.stringMul(maintenanceRate, notional)) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceRate) },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(Precise.stringAbs(size)) },
            { "contractSize", this.safeValue(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "liq_price") },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "lastPrice", null },
            { "collateral", this.safeNumber(position, "margin") },
            { "marginMode", marginMode },
            { "side", side },
            { "percentage", null },
        });
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols Not used by gate, but parsed internally by CCXT
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {string} params.settle 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
        * @param {string} params.type swap or future, if not provided this.options['defaultType'] is used
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                market = this.market(getValue(symbols, 0));
                for (object i = 1; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
                {
                    object checkMarket = this.market(getValue(symbols, i));
                    if (isTrue(!isEqual(getValue(checkMarket, "type"), getValue(market, "type"))))
                    {
                        throw new BadRequest ((string)add(this.id, " fetchPositions() does not support multiple types of positions at the same time")) ;
                    }
                }
            }
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "swap")) && isTrue(!isEqual(type, "future"))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchPositions requires a type parameter, \"swap\" or \"future\"")) ;
        }
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "swap", "privateFuturesGetSettlePositions" },
            { "future", "privateDeliveryGetSettlePositions" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        //     [
        //         {
        //             value: "12.475572",
        //             leverage: "0",
        //             mode: "single",
        //             realised_point: "0",
        //             contract: "BTC_USDT",
        //             entry_price: "62422.6",
        //             mark_price: "62377.86",
        //             history_point: "0",
        //             realised_pnl: "-0.00624226",
        //             close_order:  null,
        //             size: "2",
        //             cross_leverage_limit: "25",
        //             pending_orders: "0",
        //             adl_ranking: "5",
        //             maintenance_rate: "0.005",
        //             unrealised_pnl: "-0.008948",
        //             user: "6693577",
        //             leverage_max: "100",
        //             history_pnl: "14.98868396636",
        //             risk_limit: "1000000",
        //             margin: "0.740721495056",
        //             last_close_pnl: "-0.041996015",
        //             liq_price: "59058.58"
        //         }
        //     ]
        //
        return this.parsePositions(response, symbols);
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the gate api endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var typequeryVariable = this.handleMarketTypeAndParams("fetchLeverageTiers", null, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((List<object>) requestrequestParamsVariable)[0];
        var requestParams = ((List<object>) requestrequestParamsVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "future")) && isTrue(!isEqual(type, "swap"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverageTiers only supports swap and future")) ;
        }
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "swap", "publicFuturesGetSettleContracts" },
            { "future", "publicDeliveryGetSettleContracts" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        // Perpetual swap
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        // Delivery Futures
        //
        //    [
        //        {
        //            "name": "BTC_USDT_20200814",
        //            "underlying": "BTC_USDT",
        //            "cycle": "WEEKLY",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "mark_type": "index",
        //            "last_price": "9017",
        //            "mark_price": "9019",
        //            "index_price": "9005.3",
        //            "basis_rate": "0.185095",
        //            "basis_value": "13.7",
        //            "basis_impact_value": "100000",
        //            "settle_price": "0",
        //            "settle_price_interval": 60,
        //            "settle_price_duration": 1800,
        //            "settle_fee_rate": "0.0015",
        //            "expire_time": 1593763200,
        //            "order_price_round": "0.1",
        //            "mark_price_round": "0.1",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "maintenance_rate": "1000000",
        //            "risk_limit_base": "140.726652109199",
        //            "risk_limit_step": "1000000",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "ref_discount_rate": "0",
        //            "ref_rebate_rate": "0.2",
        //            "order_price_deviate": "0.5",
        //            "order_size_min": 1,
        //            "order_size_max": 1000000,
        //            "orders_limit": 50,
        //            "orderbook_id": 63,
        //            "trade_id": 26,
        //            "trade_size": 435,
        //            "position_size": 130,
        //            "config_change_time": 1593158867,
        //            "in_delisting": false
        //        }
        //    ]
        //
        return this.parseLeverageTiers(response, symbols, "name");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @ignore
         * @method
         * @description https://www.gate.io/help/futures/perpetual/22162/instrctions-of-risk-limit
         * @param {object} info Exchange market response for 1 market
         * @param {object} market CCXT market
         */
        //
        // Perpetual swap
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        // Delivery Futures
        //
        //    {
        //        "name": "BTC_USDT_20200814",
        //        "underlying": "BTC_USDT",
        //        "cycle": "WEEKLY",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "mark_type": "index",
        //        "last_price": "9017",
        //        "mark_price": "9019",
        //        "index_price": "9005.3",
        //        "basis_rate": "0.185095",
        //        "basis_value": "13.7",
        //        "basis_impact_value": "100000",
        //        "settle_price": "0",
        //        "settle_price_interval": 60,
        //        "settle_price_duration": 1800,
        //        "settle_fee_rate": "0.0015",
        //        "expire_time": 1593763200,
        //        "order_price_round": "0.1",
        //        "mark_price_round": "0.1",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "maintenance_rate": "1000000",
        //        "risk_limit_base": "140.726652109199",
        //        "risk_limit_step": "1000000",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "ref_discount_rate": "0",
        //        "ref_rebate_rate": "0.2",
        //        "order_price_deviate": "0.5",
        //        "order_size_min": 1,
        //        "order_size_max": 1000000,
        //        "orders_limit": 50,
        //        "orderbook_id": 63,
        //        "trade_id": 26,
        //        "trade_size": 435,
        //        "position_size": 130,
        //        "config_change_time": 1593158867,
        //        "in_delisting": false
        //    }
        //
        object maintenanceMarginUnit = this.safeString(info, "maintenance_rate"); // '0.005',
        object leverageMax = this.safeString(info, "leverage_max"); // '100',
        object riskLimitStep = this.safeString(info, "risk_limit_step"); // '1000000',
        object riskLimitMax = this.safeString(info, "risk_limit_max"); // '16000000',
        object initialMarginUnit = Precise.stringDiv("1", leverageMax);
        object maintenanceMarginRate = maintenanceMarginUnit;
        object initialMarginRatio = initialMarginUnit;
        object floor = "0";
        object tiers = new List<object>() {};
        while (Precise.stringLt(floor, riskLimitMax))
        {
            object cap = Precise.stringAdd(floor, riskLimitStep);
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.parseNumber(Precise.stringDiv(cap, riskLimitStep)) },
                { "currency", this.safeString(market, "settle") },
                { "minNotional", this.parseNumber(floor) },
                { "maxNotional", this.parseNumber(cap) },
                { "maintenanceMarginRate", this.parseNumber(maintenanceMarginRate) },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMarginRatio)) },
                { "info", info },
            });
            maintenanceMarginRate = Precise.stringAdd(maintenanceMarginRate, maintenanceMarginUnit);
            initialMarginRatio = Precise.stringAdd(initialMarginRatio, initialMarginUnit);
            floor = cap;
        }
        return tiers;
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#repayMargin
        * @description repay borrowed margin and interest
        * @see https://www.gate.io/docs/apiv4/en/#repay-cross-margin-loan
        * @see https://www.gate.io/docs/apiv4/en/#repay-a-loan
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {string} params.mode 'all' or 'partial' payment mode, extra parameter required for isolated margin
        * @param {string} params.id '34267567' loan id, extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = this.safeString(parameters, "marginMode"); // cross or isolated
        parameters = this.omit(parameters, "marginMode");
        this.checkRequiredMarginArgument("repayMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object method = null;
        if (isTrue(isEqual(symbol, null)))
        {
            method = "privateMarginPostCrossRepayments";
        } else
        {
            method = "privateMarginPostLoansLoanIdRepayment";
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["mode"] = "partial";
            object loanId = this.safeString2(parameters, "loan_id", "id");
            if (isTrue(isEqual(loanId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " repayMargin() requires loan_id param for isolated margin")) ;
            }
            ((Dictionary<string, object>)request)["loan_id"] = loanId;
        }
        parameters = this.omit(parameters, new List<object>() {"marginMode", "loan_id", "id"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // Cross
        //
        //     [
        //         {
        //             "id": "17",
        //             "create_time": 1620381696159,
        //             "update_time": 1620381696159,
        //             "currency": "EOS",
        //             "amount": "110.553635",
        //             "text": "web",
        //             "status": 2,
        //             "repaid": "110.506649705159",
        //             "repaid_interest": "0.046985294841",
        //             "unpaid_interest": "0.0000074393366667"
        //         }
        //     ]
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "finished",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "100",
        //         "paid_interest": "0.003333333333",
        //         "unpaid_interest": "0"
        //     }
        //
        if (isTrue(isEqual(marginMode, "cross")))
        {
            response = getValue(response, 0);
        }
        return this.parseMarginLoan(response, currency);
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#borrowMargin
        * @description create a loan to borrow margin
        * @see https://www.gate.io/docs/apiv4/en/#create-a-cross-margin-borrow-loan
        * @see https://www.gate.io/docs/apiv4/en/#lend-or-borrow
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the gate api endpoint
        * @param {string} params.rate '0.0002' or '0.002' extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = this.safeString(parameters, "marginMode"); // cross or isolated
        parameters = this.omit(parameters, "marginMode");
        this.checkRequiredMarginArgument("borrowMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object method = null;
        if (isTrue(isEqual(symbol, null)))
        {
            method = "privateMarginPostCrossLoans";
        } else
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["currency_pair"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["side"] = "borrow";
            // default it to 0.01% since this is a reasonable limit
            // as it is the smallest tick size currently offered by gateio
            ((Dictionary<string, object>)request)["rate"] = this.safeString(parameters, "rate", "0.0001");
            ((Dictionary<string, object>)request)["auto_renew"] = true;
            method = "privateMarginPostLoans";
        }
        parameters = this.omit(parameters, new List<object>() {"marginMode", "rate"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // Cross
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // Cross
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        object marginMode = this.safeString2(this.options, "defaultMarginMode", "marginMode", "cross");
        object timestamp = this.safeInteger(info, "create_time");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            timestamp = this.safeTimestamp(info, "create_time");
        }
        object currencyId = this.safeString(info, "currency");
        object marketId = this.safeString(info, "currency_pair");
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "id") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "amount") },
            { "symbol", this.safeSymbol(marketId, null, "_", "margin") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object authentication = getValue(api, 0); // public, private
        object type = getValue(api, 1); // spot, margin, future, delivery
        object query = this.omit(parameters, this.extractParams(path));
        path = this.implodeParams(path, parameters);
        object endPart = ((bool) isTrue((isEqual(path, "")))) ? "" : (add("/", path));
        object entirePath = add(add("/", type), endPart);
        if (isTrue(isTrue((isEqual(type, "subAccounts"))) || isTrue((isEqual(type, "withdrawals")))))
        {
            entirePath = endPart;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), authentication), type);
        if (isTrue(isEqual(url, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet for the "), type), " market type.")) ;
        }
        url = add(url, entirePath);
        if (isTrue(isEqual(authentication, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object queryString = "";
            object requiresURLEncoding = false;
            if (isTrue(isTrue((isTrue((isEqual(type, "futures"))) || isTrue((isEqual(type, "delivery"))))) && isTrue(isEqual(method, "POST"))))
            {
                object pathParts = ((string)path).Split((string)"/").ToList<object>();
                object secondPart = this.safeString(pathParts, 1, "");
                requiresURLEncoding = isTrue((isGreaterThanOrEqual(getIndexOf(secondPart, "dual"), 0))) || isTrue((isGreaterThanOrEqual(getIndexOf(secondPart, "positions"), 0)));
            }
            if (isTrue(isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue(requiresURLEncoding)) || isTrue((isEqual(method, "PATCH")))))
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    queryString = this.urlencode(query);
                    url = add(url, add("?", queryString));
                }
                if (isTrue(isEqual(method, "PATCH")))
                {
                    body = this.json(query);
                }
            } else
            {
                object urlQueryParams = this.safeValue(query, "query", new Dictionary<string, object>() {});
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)urlQueryParams).Keys))))
                {
                    queryString = this.urlencode(urlQueryParams);
                    url = add(url, add("?", queryString));
                }
                query = this.omit(query, "query");
                body = this.json(query);
            }
            object bodyPayload = ((bool) isTrue((isEqual(body, null)))) ? "" : body;
            object bodySignature = this.hash(this.encode(bodyPayload), sha512);
            object timestamp = this.seconds();
            object timestampString = ((object)timestamp).ToString();
            object signaturePath = add(add("/api/", this.version), entirePath);
            object payloadArray = new List<object> {((string)method).ToUpper(), signaturePath, queryString, bodySignature, timestampString};
            // eslint-disable-next-line quotes
            object payload = String.Join("\n", ((List<object>)payloadArray).ToArray());
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha512);
            headers = new Dictionary<string, object>() {
                { "KEY", this.apiKey },
                { "Timestamp", timestampString },
                { "SIGN", signature },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((List<object>) requestqueryVariable)[0];
        var query = ((List<object>) requestqueryVariable)[1];
        ((Dictionary<string, object>)request)["change"] = this.numberToString(amount);
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "swap", "privateFuturesPostSettlePositionsContractMargin" },
            { "future", "privateDeliveryPostSettlePositionsContractMargin" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseMarginModification(response, market);
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        //
        //     {
        //         "value": "11.9257",
        //         "leverage": "5",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "ETH_USDT",
        //         "entry_price": "1203.45",
        //         "mark_price": "1192.57",
        //         "history_point": "0",
        //         "realised_pnl": "-0.00577656",
        //         "close_order": null,
        //         "size": "1",
        //         "cross_leverage_limit": "0",
        //         "pending_orders": "0",
        //         "adl_ranking": "5",
        //         "maintenance_rate": "0.005",
        //         "unrealised_pnl": "-0.1088",
        //         "user": "1486602",
        //         "leverage_max": "100",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "5.415925875",
        //         "last_close_pnl": "0",
        //         "liq_price": "665.69"
        //     }
        //
        object contract = this.safeString(data, "contract");
        market = this.safeMarket(contract, market, "_", "contract");
        object total = this.safeNumber(data, "margin");
        return new Dictionary<string, object>() {
            { "info", data },
            { "amount", null },
            { "code", this.safeValue(market, "quote") },
            { "symbol", getValue(market, "symbol") },
            { "total", total },
            { "status", "ok" },
        };
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the exmo api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, prefixUnaryNeg(ref amount), parameters);
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the exmo api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, parameters);
    }

    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-stats
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} timeframe "5m", "15m", "30m", "1h", "4h", "1d"
        * @param {int|undefined} since the time(ms) of the earliest record to retrieve as a unix timestamp
        * @param {int|undefined} limit default 30
        * @param {object} params exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        timeframe ??= "5m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "contract", getValue(market, "id") },
            { "settle", getValue(market, "settleId") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = since;
        }
        object response = await this.publicFuturesGetSettleContractStats(this.extend(request, parameters));
        //
        //    [
        //        {
        //            long_liq_size: '0',
        //            short_liq_size: '0',
        //            short_liq_usd: '0',
        //            lsr_account: '3.2808988764045',
        //            mark_price: '0.34619',
        //            top_lsr_size: '0',
        //            time: '1674057000',
        //            short_liq_amount: '0',
        //            long_liq_amount: '0',
        //            open_interest_usd: '9872386.7775',
        //            top_lsr_account: '0',
        //            open_interest: '2851725',
        //            long_liq_usd: '0',
        //            lsr_taker: '9.3765153315902'
        //        },
        //        ...
        //    ]
        //
        return this.parseOpenInterests(response, market, since, limit);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //    {
        //        long_liq_size: '0',
        //        short_liq_size: '0',
        //        short_liq_usd: '0',
        //        lsr_account: '3.2808988764045',
        //        mark_price: '0.34619',
        //        top_lsr_size: '0',
        //        time: '1674057000',
        //        short_liq_amount: '0',
        //        long_liq_amount: '0',
        //        open_interest_usd: '9872386.7775',
        //        top_lsr_account: '0',
        //        open_interest: '2851725',
        //        long_liq_usd: '0',
        //        lsr_taker: '9.3765153315902'
        //    }
        //
        object timestamp = this.safeIntegerProduct(interest, "time", 1000);
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "openInterestAmount", this.safeNumber(interest, "open_interest") },
            { "openInterestValue", this.safeNumber(interest, "open_interest_usd") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //    {"label": "ORDER_NOT_FOUND", "message": "Order not found"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: status"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: Trigger.rule"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: trigger.expiration invalid range"}
        //    {"label": "INVALID_ARGUMENT", "detail": "invalid size"}
        //
        object label = this.safeString(response, "label");
        if (isTrue(!isEqual(label, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), label, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
