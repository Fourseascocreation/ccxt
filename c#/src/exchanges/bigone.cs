using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bigone : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bigone" },
            { "name", "BigONE" },
            { "countries", new List<object>() {"CN"} },
            { "version", "v3" },
            { "rateLimit", 1200 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", null },
                { "future", null },
                { "option", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", false },
                { "fetchWithdrawals", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "min1" },
                { "5m", "min5" },
                { "15m", "min15" },
                { "30m", "min30" },
                { "1h", "hour1" },
                { "3h", "hour3" },
                { "4h", "hour4" },
                { "6h", "hour6" },
                { "12h", "hour12" },
                { "1d", "day1" },
                { "1w", "week1" },
                { "1M", "month1" },
            } },
            { "hostname", "big.one" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://{hostname}/api/v3" },
                    { "private", "https://{hostname}/api/v3/viewer" },
                } },
                { "www", "https://big.one" },
                { "doc", "https://open.big.one/docs/api.html" },
                { "fees", "https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy" },
                { "referral", "https://b1.run/users/new?code=D3LLBVFT" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"ping", "asset_pairs", "asset_pairs/{asset_pair_name}/depth", "asset_pairs/{asset_pair_name}/trades", "asset_pairs/{asset_pair_name}/ticker", "asset_pairs/{asset_pair_name}/candles", "asset_pairs/tickers"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"accounts", "fund/accounts", "assets/{asset_symbol}/address", "orders", "orders/{id}", "orders/multi", "trades", "withdrawals", "deposits"} },
                    { "post", new List<object>() {"orders", "orders/{id}/cancel", "orders/cancel", "withdrawals", "transfer"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.001") },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {} },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "funding", "FUND" },
                    { "future", "CONTRACT" },
                    { "swap", "CONTRACT" },
                } },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "exchangeMillisecondsCorrection", -100 },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "10001", typeof(BadRequest) },
                    { "10005", typeof(ExchangeError) },
                    { "Amount\'s scale must greater than AssetPair\'s base scale", typeof(InvalidOrder) },
                    { "Price mulit with amount should larger than AssetPair\'s min_quote_value", typeof(InvalidOrder) },
                    { "10007", typeof(BadRequest) },
                    { "10011", typeof(ExchangeError) },
                    { "10013", typeof(BadSymbol) },
                    { "10014", typeof(InsufficientFunds) },
                    { "10403", typeof(PermissionDenied) },
                    { "10429", typeof(RateLimitExceeded) },
                    { "40004", typeof(AuthenticationError) },
                    { "40103", typeof(AuthenticationError) },
                    { "40104", typeof(AuthenticationError) },
                    { "40301", typeof(PermissionDenied) },
                    { "40302", typeof(ExchangeError) },
                    { "40601", typeof(ExchangeError) },
                    { "40602", typeof(ExchangeError) },
                    { "40603", typeof(InsufficientFunds) },
                    { "40604", typeof(InvalidOrder) },
                    { "40605", typeof(InvalidOrder) },
                    { "40120", typeof(InvalidOrder) },
                    { "40121", typeof(InvalidOrder) },
                    { "60100", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "CRE", "Cybereits" },
                { "FXT", "FXTTOKEN" },
                { "FREE", "FreeRossDAO" },
                { "MBN", "Mobilian Coin" },
                { "ONE", "BigONE Token" },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchMarkets
        * @description retrieves data on all markets for bigone
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssetPairs(parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
        //                 "name":"PCX-BTC",
        //                 "quote_scale":7,
        //                 "quote_asset":{
        //                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
        //                     "symbol":"BTC",
        //                     "name":"Bitcoin",
        //                 },
        //                 "base_asset":{
        //                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
        //                     "symbol":"PCX",
        //                     "name":"ChainX",
        //                 },
        //                 "base_scale":3,
        //                 "min_quote_value":"0.0001",
        //                 "max_quote_value":"35"
        //             },
        //         ]
        //     }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "name");
            object uuid = this.safeString(market, "id");
            object baseAsset = this.safeValue(market, "base_asset", new Dictionary<string, object>() {});
            object quoteAsset = this.safeValue(market, "quote_asset", new Dictionary<string, object>() {});
            object baseId = this.safeString(baseAsset, "symbol");
            object quoteId = this.safeString(quoteAsset, "symbol");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object entry = new Dictionary<string, object>() {
                { "id", id },
                { "uuid", uuid },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "base_scale"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quote_scale"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_quote_value") },
                        { "max", this.safeNumber(market, "max_quote_value") },
                    } },
                } },
                { "info", market },
            };
            ((List<object>)result).Add(entry);
        }
        return result;
    }

    public async override Task<object> loadMarkets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        object markets = await base.loadMarkets(reload, parameters);
        object marketsByUuid = this.safeValue(this.options, "marketsByUuid");
        if (isTrue(isTrue((isEqual(marketsByUuid, null))) || isTrue(reload)))
        {
            marketsByUuid = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(this.symbols, i);
                object market = getValue(this.markets, symbol);
                object uuid = this.safeString(market, "uuid");
                ((Dictionary<string, object>)marketsByUuid)[(string)uuid] = market;
            }
            ((Dictionary<string, object>)this.options)["marketsByUuid"] = marketsByUuid;
        }
        return markets;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "asset_pair_name":"ETH-BTC",
        //         "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
        //         "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
        //         "open":"0.021795",
        //         "high":"0.021795",
        //         "low":"0.021471",
        //         "close":"0.021613",
        //         "volume":"117078.90431",
        //         "daily_change":"-0.000182"
        //     }
        //
        object marketId = this.safeString(ticker, "asset_pair_name");
        object symbol = this.safeSymbol(marketId, market, "-");
        object timestamp = null;
        object close = this.safeString(ticker, "close");
        object bid = this.safeValue(ticker, "bid", new Dictionary<string, object>() {});
        object ask = this.safeValue(ticker, "ask", new Dictionary<string, object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(bid, "price") },
            { "bidVolume", this.safeString(bid, "quantity") },
            { "ask", this.safeString(ask, "price") },
            { "askVolume", this.safeString(ask, "quantity") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", this.safeString(ticker, "daily_change") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        object response = await this.publicGetAssetPairsAssetPairNameTicker(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":{
        //             "asset_pair_name":"ETH-BTC",
        //             "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
        //             "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
        //             "open":"0.021795",
        //             "high":"0.021795",
        //             "low":"0.021471",
        //             "close":"0.021613",
        //             "volume":"117078.90431",
        //             "daily_change":"-0.000182"
        //         }
        //     }
        //
        object ticker = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        symbols = this.marketSymbols(symbols);
        if (isTrue(!isEqual(symbols, null)))
        {
            object ids = this.marketIds(symbols);
            ((Dictionary<string, object>)request)["pair_names"] = String.Join(",", ids);
        }
        object response = await this.publicGetAssetPairsTickers(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "asset_pair_name":"PCX-BTC",
        //                 "bid":{"price":"0.000234","order_count":1,"quantity":"0.518"},
        //                 "ask":{"price":"0.0002348","order_count":1,"quantity":"2.348"},
        //                 "open":"0.0002343",
        //                 "high":"0.0002348",
        //                 "low":"0.0002162",
        //                 "close":"0.0002348",
        //                 "volume":"12887.016",
        //                 "daily_change":"0.0000005"
        //             },
        //             {
        //                 "asset_pair_name":"GXC-USDT",
        //                 "bid":{"price":"0.5054","order_count":1,"quantity":"40.53"},
        //                 "ask":{"price":"0.5055","order_count":1,"quantity":"38.53"},
        //                 "open":"0.5262",
        //                 "high":"0.5323",
        //                 "low":"0.5055",
        //                 "close":"0.5055",
        //                 "volume":"603963.05",
        //                 "daily_change":"-0.0207"
        //             }
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = getValue(ticker, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPing(parameters);
        //
        //     {
        //         "data": {
        //             "timestamp": 1527665262168391000
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "timestamp");
        return this.parseToInt(divide(timestamp, 1000000));
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 50, max 200
        }
        object response = await this.publicGetAssetPairsAssetPairNameDepth(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data": {
        //             "asset_pair_name": "EOS-BTC",
        //             "bids": [
        //                 { "price": "42", "order_count": 4, "quantity": "23.33363711" }
        //             ],
        //             "asks": [
        //                 { "price": "45", "order_count": 2, "quantity": "4193.3283464" }
        //             ]
        //         }
        //     }
        //
        object orderbook = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), null, "bids", "asks", "price", "quantity");
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id": 38199941,
        //         "price": "3378.67",
        //         "amount": "0.019812",
        //         "taker_side": "ASK",
        //         "created_at": "2019-01-29T06:05:56Z"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "id": 10854280,
        //         "asset_pair_name": "XIN-USDT",
        //         "price": "70",
        //         "amount": "1",
        //         "taker_side": "ASK",
        //         "maker_order_id": 58284908,
        //         "taker_order_id": 58284909,
        //         "maker_fee": "0.0008",
        //         "taker_fee": "0.07",
        //         "side": "SELF_TRADING",
        //         "inserted_at": "2019-04-16T12:00:01Z"
        //     },
        //
        //     {
        //         "id": 10854263,
        //         "asset_pair_name": "XIN-USDT",
        //         "price": "75.7",
        //         "amount": "12.743149",
        //         "taker_side": "BID",
        //         "maker_order_id": null,
        //         "taker_order_id": 58284888,
        //         "maker_fee": null,
        //         "taker_fee": "0.0025486298",
        //         "side": "BID",
        //         "inserted_at": "2019-04-15T06:20:57Z"
        //     }
        //
        object timestamp = this.parse8601(this.safeString2(trade, "created_at", "inserted_at"));
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object marketId = this.safeString(trade, "asset_pair_name");
        market = this.safeMarket(marketId, market, "-");
        object side = this.safeString(trade, "side");
        object takerSide = this.safeString(trade, "taker_side");
        object takerOrMaker = null;
        if (isTrue(isTrue(isTrue((!isEqual(takerSide, null))) && isTrue((!isEqual(side, null)))) && isTrue((!isEqual(side, "SELF_TRADING")))))
        {
            takerOrMaker = ((bool) isTrue((isEqual(takerSide, side)))) ? "taker" : "maker";
        }
        if (isTrue(isEqual(side, null)))
        {
            // taker side is not related to buy/sell side
            // the following code is probably a mistake
            side = ((bool) isTrue((isEqual(takerSide, "ASK")))) ? "sell" : "buy";
        } else
        {
            if (isTrue(isEqual(side, "BID")))
            {
                side = "buy";
            } else if (isTrue(isEqual(side, "ASK")))
            {
                side = "sell";
            }
        }
        object makerOrderId = this.safeString(trade, "maker_order_id");
        object takerOrderId = this.safeString(trade, "taker_order_id");
        object orderId = null;
        if (isTrue(!isEqual(makerOrderId, null)))
        {
            if (isTrue(!isEqual(takerOrderId, null)))
            {
                orderId = new List<object>() {makerOrderId, takerOrderId};
            } else
            {
                orderId = makerOrderId;
            }
        } else if (isTrue(!isEqual(takerOrderId, null)))
        {
            orderId = takerOrderId;
        }
        object id = this.safeString(trade, "id");
        object result = new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", orderId },
            { "type", "limit" },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "info", trade },
        };
        object makerCurrencyCode = null;
        object takerCurrencyCode = null;
        if (isTrue(!isEqual(takerOrMaker, null)))
        {
            if (isTrue(isEqual(side, "buy")))
            {
                if (isTrue(isEqual(takerOrMaker, "maker")))
                {
                    makerCurrencyCode = getValue(market, "base");
                    takerCurrencyCode = getValue(market, "quote");
                } else
                {
                    makerCurrencyCode = getValue(market, "quote");
                    takerCurrencyCode = getValue(market, "base");
                }
            } else
            {
                if (isTrue(isEqual(takerOrMaker, "maker")))
                {
                    makerCurrencyCode = getValue(market, "quote");
                    takerCurrencyCode = getValue(market, "base");
                } else
                {
                    makerCurrencyCode = getValue(market, "base");
                    takerCurrencyCode = getValue(market, "quote");
                }
            }
        } else if (isTrue(isEqual(side, "SELF_TRADING")))
        {
            if (isTrue(isEqual(takerSide, "BID")))
            {
                makerCurrencyCode = getValue(market, "quote");
                takerCurrencyCode = getValue(market, "base");
            } else if (isTrue(isEqual(takerSide, "ASK")))
            {
                makerCurrencyCode = getValue(market, "base");
                takerCurrencyCode = getValue(market, "quote");
            }
        }
        object makerFeeCost = this.safeString(trade, "maker_fee");
        object takerFeeCost = this.safeString(trade, "taker_fee");
        if (isTrue(!isEqual(makerFeeCost, null)))
        {
            if (isTrue(!isEqual(takerFeeCost, null)))
            {
                ((Dictionary<string, object>)result)["fees"] = new List<object>() {new Dictionary<string, object>() {
    { "cost", makerFeeCost },
    { "currency", makerCurrencyCode },
}, new Dictionary<string, object>() {
    { "cost", takerFeeCost },
    { "currency", takerCurrencyCode },
}};
            } else
            {
                ((Dictionary<string, object>)result)["fee"] = new Dictionary<string, object>() {
                    { "cost", makerFeeCost },
                    { "currency", makerCurrencyCode },
                };
            }
        } else if (isTrue(!isEqual(takerFeeCost, null)))
        {
            ((Dictionary<string, object>)result)["fee"] = new Dictionary<string, object>() {
                { "cost", takerFeeCost },
                { "currency", takerCurrencyCode },
            };
        } else
        {
            ((Dictionary<string, object>)result)["fee"] = null;
        }
        return this.safeTrade(((object)result), market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        object response = await this.publicGetAssetPairsAssetPairNameTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 38199941,
        //                 "price": "3378.67",
        //                 "amount": "0.019812",
        //                 "taker_side": "ASK",
        //                 "created_at": "2019-01-29T06:05:56Z"
        //             },
        //             {
        //                 "id": 38199934,
        //                 "price": "3376.14",
        //                 "amount": "0.019384",
        //                 "taker_side": "ASK",
        //                 "created_at": "2019-01-29T06:05:40Z"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         close: '0.021562',
        //         high: '0.021563',
        //         low: '0.02156',
        //         open: '0.021563',
        //         time: '2019-11-21T07:54:00Z',
        //         volume: '59.84376'
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "time")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default 100, max 500
        }
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            // const start = this.parseToInt (since / 1000);
            object duration = this.parseTimeframe(timeframe);
            object end = this.sum(since, multiply(multiply(limit, duration), 1000));
            ((Dictionary<string, object>)request)["time"] = this.iso8601(end);
        }
        object response = await this.publicGetAssetPairsAssetPairNameCandles(this.extend(request, parameters));
        //
        //     {
        //         code: 0,
        //         data: [
        //             {
        //                 close: '0.021656',
        //                 high: '0.021658',
        //                 low: '0.021652',
        //                 open: '0.021652',
        //                 time: '2019-11-21T09:30:00Z',
        //                 volume: '53.08664'
        //             },
        //             {
        //                 close: '0.021652',
        //                 high: '0.021656',
        //                 low: '0.021652',
        //                 open: '0.021656',
        //                 time: '2019-11-21T09:29:00Z',
        //                 volume: '88.39861'
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object symbol = this.safeString(balance, "asset_symbol");
            object code = this.safeCurrencyCode(symbol);
            object account = this.account();
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "balance");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "locked_balance");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = this.safeString(parameters, "type", "");
        parameters = this.omit(parameters, "type");
        object method = add(add("privateGet", this.capitalize(type)), "Accounts");
        object response = await this.callAsync(method, parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {"asset_symbol":"NKC","balance":"0","locked_balance":"0"},
        //             {"asset_symbol":"UBTC","balance":"0","locked_balance":"0"},
        //             {"asset_symbol":"READ","balance":"0","locked_balance":"0"},
        //         ],
        //     }
        //
        return this.parseBalance(response);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //    {
        //        "id": 10,
        //        "asset_pair_name": "EOS-BTC",
        //        "price": "10.00",
        //        "amount": "10.00",
        //        "filled_amount": "9.0",
        //        "avg_deal_price": "12.0",
        //        "side": "ASK",
        //        "state": "FILLED",
        //        "created_at":"2019-01-29T06:05:56Z",
        //        "updated_at":"2019-01-29T06:05:56Z",
        //    }
        //
        object id = this.safeString(order, "id");
        object marketId = this.safeString(order, "asset_pair_name");
        object symbol = this.safeSymbol(marketId, market, "-");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "amount");
        object average = this.safeString(order, "avg_deal_price");
        object filled = this.safeString(order, "filled_amount");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "BID")))
        {
            side = "buy";
        } else
        {
            side = "sell";
        }
        object lastTradeTimestamp = this.parse8601(this.safeString(order, "updated_at"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        side = ((bool) isTrue((isEqual(side, "buy")))) ? "BID" : "ASK";
        object uppercaseType = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
            { "side", side },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "type", uppercaseType },
        };
        if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else
        {
            object isStopLimit = (isEqual(uppercaseType, "STOP_LIMIT"));
            object isStopMarket = (isEqual(uppercaseType, "STOP_MARKET"));
            if (isTrue(isTrue(isStopLimit) || isTrue(isStopMarket)))
            {
                object stopPrice = this.safeNumber2(parameters, "stop_price", "stopPrice");
                if (isTrue(isEqual(stopPrice, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a stop_price parameter")) ;
                }
                ((Dictionary<string, object>)request)["stop_price"] = this.priceToPrecision(symbol, stopPrice);
                parameters = this.omit(parameters, new List<object>() {"stop_price", "stopPrice"});
            }
            if (isTrue(isStopLimit))
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //    {
        //        "id": 10,
        //        "asset_pair_name": "EOS-BTC",
        //        "price": "10.00",
        //        "amount": "10.00",
        //        "filled_amount": "9.0",
        //        "avg_deal_price": "12.0",
        //        "side": "ASK",
        //        "state": "FILLED",
        //        "created_at":"2019-01-29T06:05:56Z",
        //        "updated_at":"2019-01-29T06:05:56Z"
        //    }
        //
        object order = this.safeValue(response, "data");
        return this.parseOrder(order, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol Not used by bigone cancelOrder ()
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privatePostOrdersIdCancel(this.extend(request, parameters));
        //    {
        //        "id": 10,
        //        "asset_pair_name": "EOS-BTC",
        //        "price": "10.00",
        //        "amount": "10.00",
        //        "filled_amount": "9.0",
        //        "avg_deal_price": "12.0",
        //        "side": "ASK",
        //        "state": "CANCELLED",
        //        "created_at":"2019-01-29T06:05:56Z",
        //        "updated_at":"2019-01-29T06:05:56Z"
        //    }
        object order = this.safeValue(response, "data");
        return this.parseOrder(order);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        object response = await this.privatePostOrdersCancel(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data": {
        //             "cancelled":[
        //                 58272370,
        //                 58272377
        //             ],
        //             "failed": []
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol not used by bigone fetchOrder
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrdersId(this.extend(request, parameters));
        object order = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20, max 200
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        //
        //    {
        //        "code":0,
        //        "data": [
        //             {
        //                 "id": 10,
        //                 "asset_pair_name": "ETH-BTC",
        //                 "price": "10.00",
        //                 "amount": "10.00",
        //                 "filled_amount": "9.0",
        //                 "avg_deal_price": "12.0",
        //                 "side": "ASK",
        //                 "state": "FILLED",
        //                 "created_at":"2019-01-29T06:05:56Z",
        //                 "updated_at":"2019-01-29T06:05:56Z",
        //             },
        //         ],
        //        "page_token":"dxzef",
        //    }
        //
        object orders = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20, max 200
        }
        object response = await this.privateGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 10854280,
        //                 "asset_pair_name": "XIN-USDT",
        //                 "price": "70",
        //                 "amount": "1",
        //                 "taker_side": "ASK",
        //                 "maker_order_id": 58284908,
        //                 "taker_order_id": 58284909,
        //                 "maker_fee": "0.0008",
        //                 "taker_fee": "0.07",
        //                 "side": "SELF_TRADING",
        //                 "inserted_at": "2019-04-16T12:00:01Z"
        //             },
        //             {
        //                 "id": 10854263,
        //                 "asset_pair_name": "XIN-USDT",
        //                 "price": "75.7",
        //                 "amount": "12.743149",
        //                 "taker_side": "BID",
        //                 "maker_order_id": null,
        //                 "taker_order_id": 58284888,
        //                 "maker_fee": null,
        //                 "taker_fee": "0.0025486298",
        //                 "side": "BID",
        //                 "inserted_at": "2019-04-15T06:20:57Z"
        //             }
        //         ],
        //         "page_token":"dxfv"
        //     }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "open" },
            { "FILLED", "closed" },
            { "CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "PENDING" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "FILLED" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public override object nonce()
    {
        object exchangeTimeCorrection = multiply(this.safeInteger(this.options, "exchangeMillisecondsCorrection", 0), 1000000);
        return add(multiply(this.microseconds(), 1000), exchangeTimeCorrection);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object baseUrl = this.implodeHostname(getValue(getValue(this.urls, "api"), api));
        object url = add(add(baseUrl, "/"), this.implodeParams(path, parameters));
        headers = new Dictionary<string, object>() {};
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object request = new Dictionary<string, object>() {
                { "type", "OpenAPIV2" },
                { "sub", this.apiKey },
                { "nonce", nonce },
            };
            object token = jwt(request, this.encode(this.secret), sha256);
            ((Dictionary<string, object>)headers)["Authorization"] = add("Bearer ", token);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else if (isTrue(isEqual(method, "POST")))
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
                body = this.json(query);
            }
        }
        ((Dictionary<string, object>)headers)["User-Agent"] = add(add(add("ccxt/", this.id), "-"), this.version);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset_symbol", getValue(currency, "id") },
        };
        object response = await this.privateGetAssetsAssetSymbolAddress(this.extend(request, parameters));
        //
        // the actual response format is not the same as the documented one
        // the data key contains an array in the actual response
        //
        //     {
        //         "code":0,
        //         "message":"",
        //         "data":[
        //             {
        //                 "id":5521878,
        //                 "chain":"Bitcoin",
        //                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
        //                 "memo":""
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object dataLength = getArrayLength(data);
        if (isTrue(isLessThan(dataLength, 1)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchDepositAddress() returned empty address response")) ;
        }
        object firstElement = getValue(data, 0);
        object address = this.safeString(firstElement, "value");
        object tag = this.safeString(firstElement, "memo");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "WITHHOLD", "ok" },
            { "UNCONFIRMED", "pending" },
            { "CONFIRMED", "ok" },
            { "COMPLETED", "ok" },
            { "PENDING", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "amount": "25.0",
        //         "asset_symbol": "BTS"
        //         "confirms": 100,
        //         "id": 5,
        //         "inserted_at": "2018-02-16T11:39:58.000Z",
        //         "is_internal": false,
        //         "kind": "default",
        //         "memo": "",
        //         "state": "WITHHOLD",
        //         "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
        //         "updated_at": "2018-11-09T10:20:09.000Z",
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount": "5",
        //         "asset_symbol": "ETH",
        //         "completed_at": "2018-03-15T16:13:45.610463Z",
        //         "customer_id": "10",
        //         "id": 10,
        //         "inserted_at": "2018-03-15T16:13:45.610463Z",
        //         "is_internal": true,
        //         "note": "2018-03-15T16:13:45.610463Z",
        //         "state": "CONFIRMED",
        //         "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
        //         "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
        //     }
        //
        // withdraw
        //
        //     {
        //         "id":1077391,
        //         "customer_id":1082679,
        //         "amount":"21.9000000000000000",
        //         "txid":"",
        //         "is_internal":false,
        //         "kind":"on_chain",
        //         "state":"PENDING",
        //         "inserted_at":"2020-06-03T00:50:57+00:00",
        //         "updated_at":"2020-06-03T00:50:57+00:00",
        //         "memo":"",
        //         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
        //         "fee":"0.1000000000000000",
        //         "asset_symbol":"XRP"
        //     }
        //
        object currencyId = this.safeString(transaction, "asset_symbol");
        object code = this.safeCurrencyCode(currencyId);
        object id = this.safeInteger(transaction, "id");
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object timestamp = this.parse8601(this.safeString(transaction, "inserted_at"));
        object updated = this.parse8601(this.safeString2(transaction, "updated_at", "completed_at"));
        object txid = this.safeString(transaction, "txid");
        object address = this.safeString(transaction, "target_address");
        object tag = this.safeString(transaction, "memo");
        object type = ((bool) isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("customer_id"))))) ? "deposit" : "withdrawal";
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", address },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", null },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["asset_symbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 50
        }
        object response = await this.privateGetDeposits(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "page_token": "NQ==",
        //         "data": [
        //             {
        //                 "id": 5,
        //                 "amount": "25.0",
        //                 "confirms": 100,
        //                 "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
        //                 "is_internal": false,
        //                 "inserted_at": "2018-02-16T11:39:58.000Z",
        //                 "updated_at": "2018-11-09T10:20:09.000Z",
        //                 "kind": "default",
        //                 "memo": "",
        //                 "state": "WITHHOLD",
        //                 "asset_symbol": "BTS"
        //             }
        //         ]
        //     }
        //
        object deposits = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["asset_symbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 50
        }
        object response = await this.privateGetWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 10,
        //                 "customer_id": "10",
        //                 "asset_symbol": "ETH",
        //                 "amount": "5",
        //                 "state": "CONFIRMED",
        //                 "note": "2018-03-15T16:13:45.610463Z",
        //                 "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
        //                 "completed_at": "2018-03-15T16:13:45.610463Z",
        //                 "inserted_at": "2018-03-15T16:13:45.610463Z",
        //                 "is_internal": true,
        //                 "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
        //             }
        //         ],
        //         "page_token":"dxvf"
        //     }
        //
        object withdrawals = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bigone#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object guid = this.safeString(parameters, "guid", this.uuid());
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "from", fromId },
            { "to", toId },
            { "guid", guid },
        };
        object response = await this.privatePostTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": null
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeValue(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((Dictionary<string, object>)transfer)["fromAccount"] = fromAccount;
            ((Dictionary<string, object>)transfer)["toAccount"] = toAccount;
            ((Dictionary<string, object>)transfer)["amount"] = amount;
            ((Dictionary<string, object>)transfer)["id"] = guid;
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "code": 0,
        //         "data": null
        //     }
        //
        object code = this.safeNumber(transfer, "code");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(code) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
        };
        return this.safeString(statuses, status, "failed");
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bigone#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bigone api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
                var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "target_address", address },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["memo"] = tag;
        }
        // requires write permission on the wallet
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "message":"",
        //         "data":{
        //             "id":1077391,
        //             "customer_id":1082679,
        //             "amount":"21.9000000000000000",
        //             "txid":"",
        //             "is_internal":false,
        //             "kind":"on_chain",
        //             "state":"PENDING",
        //             "inserted_at":"2020-06-03T00:50:57+00:00",
        //             "updated_at":"2020-06-03T00:50:57+00:00",
        //             "memo":"",
        //             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
        //             "fee":"0.1000000000000000",
        //             "asset_symbol":"XRP"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //      {"code":10013,"message":"Resource not found"}
        //      {"code":40004,"message":"invalid jwt"}
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(code, "0")))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
