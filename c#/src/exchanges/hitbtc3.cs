using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class hitbtc3 : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hitbtc3" },
            { "name", "HitBTC" },
            { "countries", new List<object>() {"HK"} },
            { "rateLimit", 3.333 },
            { "version", "3" },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", false },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", null },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRate", null },
                { "fetchBorrowRateHistories", null },
                { "fetchBorrowRateHistory", null },
                { "fetchBorrowRates", null },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", null },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", null },
                { "fetchMarketLeverageTiers", null },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.demo.hitbtc.com/api/3" },
                    { "private", "https://api.demo.hitbtc.com/api/3" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.hitbtc.com/api/3" },
                    { "private", "https://api.hitbtc.com/api/3" },
                } },
                { "www", "https://hitbtc.com" },
                { "referral", "https://hitbtc.com/?ref_id=5a5d39a65d466" },
                { "doc", new List<object>() {"https://api.hitbtc.com", "https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"} },
                { "fees", new List<object>() {"https://hitbtc.com/fees-and-limits", "https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "public/currency", 10 },
                        { "public/symbol", 10 },
                        { "public/ticker", 10 },
                        { "public/price/rate", 10 },
                        { "public/trades", 10 },
                        { "public/orderbook", 10 },
                        { "public/candles", 10 },
                        { "public/futures/info", 10 },
                        { "public/futures/history/funding", 10 },
                        { "public/futures/candles/index_price", 10 },
                        { "public/futures/candles/mark_price", 10 },
                        { "public/futures/candles/premium_index", 10 },
                        { "public/futures/candles/open_interest", 10 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "spot/balance", 15 },
                        { "spot/order", 15 },
                        { "spot/order/{client_order_id}", 15 },
                        { "spot/fee", 15 },
                        { "spot/fee/{symbol}", 15 },
                        { "spot/history/order", 15 },
                        { "spot/history/trade", 15 },
                        { "margin/account", 15 },
                        { "margin/account/isolated/{symbol}", 15 },
                        { "margin/order", 15 },
                        { "margin/order/{client_order_id}", 15 },
                        { "margin/history/clearing", 15 },
                        { "margin/history/order", 15 },
                        { "margin/history/positions", 15 },
                        { "margin/history/trade", 15 },
                        { "futures/balance", 15 },
                        { "futures/account", 15 },
                        { "futures/account/isolated/{symbol}", 15 },
                        { "futures/order", 15 },
                        { "futures/order/{client_order_id}", 15 },
                        { "futures/fee", 15 },
                        { "futures/fee/{symbol}", 15 },
                        { "futures/history/clearing", 15 },
                        { "futures/history/order", 15 },
                        { "futures/history/positions", 15 },
                        { "futures/history/trade", 15 },
                        { "wallet/balance", 15 },
                        { "wallet/crypto/address", 15 },
                        { "wallet/crypto/address/recent-deposit", 15 },
                        { "wallet/crypto/address/recent-withdraw", 15 },
                        { "wallet/crypto/address/check-mine", 15 },
                        { "wallet/transactions", 15 },
                        { "wallet/crypto/check-offchain-available", 15 },
                        { "wallet/crypto/fee/estimate", 15 },
                        { "sub-account", 15 },
                        { "sub-account/acl", 15 },
                        { "sub-account/balance/{subAccID}", 15 },
                        { "sub-account/crypto/address/{subAccID}/{currency}", 15 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "spot/order", 1 },
                        { "margin/order", 1 },
                        { "futures/order", 1 },
                        { "wallet/convert", 15 },
                        { "wallet/crypto/address", 15 },
                        { "wallet/crypto/withdraw", 15 },
                        { "wallet/transfer", 15 },
                        { "sub-account/freeze", 15 },
                        { "sub-account/activate", 15 },
                        { "sub-account/transfer", 15 },
                        { "sub-account/acl", 15 },
                    } },
                    { "patch", new Dictionary<string, object>() {
                        { "spot/order/{client_order_id}", 1 },
                        { "margin/order/{client_order_id}", 1 },
                        { "futures/order/{client_order_id}", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "spot/order", 1 },
                        { "spot/order/{client_order_id}", 1 },
                        { "margin/position", 1 },
                        { "margin/position/isolated/{symbol}", 1 },
                        { "margin/order", 1 },
                        { "margin/order/{client_order_id}", 1 },
                        { "futures/position", 1 },
                        { "futures/position/isolated/{symbol}", 1 },
                        { "futures/order", 1 },
                        { "futures/order/{client_order_id}", 1 },
                        { "wallet/crypto/withdraw/{id}", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "margin/account/isolated/{symbol}", 1 },
                        { "futures/account/isolated/{symbol}", 1 },
                        { "wallet/crypto/withdraw/{id}", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0009") },
                    { "maker", this.parseNumber("0.0009") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0001")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0")}, new List<object> {this.parseNumber("50000"), this.parseNumber("-0.0001")}, new List<object> {this.parseNumber("100000"), this.parseNumber("-0.0001")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0002")}} },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "M1" },
                { "3m", "M3" },
                { "5m", "M5" },
                { "15m", "M15" },
                { "30m", "M30" },
                { "1h", "H1" },
                { "4h", "H4" },
                { "1d", "D1" },
                { "1w", "D7" },
                { "1M", "1M" },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeError) },
                    { "503", typeof(ExchangeNotAvailable) },
                    { "504", typeof(ExchangeNotAvailable) },
                    { "600", typeof(PermissionDenied) },
                    { "800", typeof(ExchangeError) },
                    { "1002", typeof(AuthenticationError) },
                    { "1003", typeof(PermissionDenied) },
                    { "1004", typeof(AuthenticationError) },
                    { "1005", typeof(AuthenticationError) },
                    { "2001", typeof(BadSymbol) },
                    { "2002", typeof(BadRequest) },
                    { "2003", typeof(BadRequest) },
                    { "2010", typeof(BadRequest) },
                    { "2011", typeof(BadRequest) },
                    { "2012", typeof(BadRequest) },
                    { "2020", typeof(BadRequest) },
                    { "2022", typeof(BadRequest) },
                    { "10001", typeof(BadRequest) },
                    { "10021", typeof(AccountSuspended) },
                    { "10022", typeof(BadRequest) },
                    { "20001", typeof(InsufficientFunds) },
                    { "20002", typeof(OrderNotFound) },
                    { "20003", typeof(ExchangeError) },
                    { "20004", typeof(ExchangeError) },
                    { "20005", typeof(ExchangeError) },
                    { "20006", typeof(ExchangeError) },
                    { "20007", typeof(ExchangeError) },
                    { "20008", typeof(InvalidOrder) },
                    { "20009", typeof(InvalidOrder) },
                    { "20010", typeof(OnMaintenance) },
                    { "20011", typeof(ExchangeError) },
                    { "20012", typeof(ExchangeError) },
                    { "20014", typeof(ExchangeError) },
                    { "20016", typeof(ExchangeError) },
                    { "20031", typeof(ExchangeError) },
                    { "20032", typeof(ExchangeError) },
                    { "20033", typeof(ExchangeError) },
                    { "20034", typeof(ExchangeError) },
                    { "20040", typeof(ExchangeError) },
                    { "20041", typeof(ExchangeError) },
                    { "20042", typeof(ExchangeError) },
                    { "20043", typeof(ExchangeError) },
                    { "20044", typeof(PermissionDenied) },
                    { "20045", typeof(InvalidOrder) },
                    { "20080", typeof(ExchangeError) },
                    { "21001", typeof(ExchangeError) },
                    { "21003", typeof(AccountSuspended) },
                    { "21004", typeof(AccountSuspended) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "USDT20" },
                    { "ERC20", "USDT20" },
                    { "TRX", "USDTRX" },
                    { "TRC20", "USDTRX" },
                    { "OMNI", "USDT" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "funding", "wallet" },
                    { "future", "derivatives" },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "AUTO", "Cube" },
                { "BCC", "BCC" },
                { "BDP", "BidiPass" },
                { "BET", "DAO.Casino" },
                { "BIT", "BitRewards" },
                { "BOX", "BOX Token" },
                { "CPT", "Cryptaur" },
                { "GET", "Themis" },
                { "GMT", "GMT Token" },
                { "HSR", "HC" },
                { "IQ", "IQ.Cash" },
                { "LNC", "LinkerCoin" },
                { "PLA", "PlayChip" },
                { "PNT", "Penta" },
                { "SBTC", "Super Bitcoin" },
                { "STEPN", "GMT" },
                { "STX", "STOX" },
                { "TV", "Tokenville" },
                { "USD", "USDT" },
                { "XMT", "MTL" },
                { "XPNT", "PNT" },
            } },
        });
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchMarkets
        * @description retrieves data on all markets for hitbtc3
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPublicSymbol(parameters);
        //
        //     {
        //         "AAVEUSDT_PERP":{
        //             "type":"futures",
        //             "expiry":null,
        //             "underlying":"AAVE",
        //             "base_currency":null,
        //             "quote_currency":"USDT",
        //             "quantity_increment":"0.01",
        //             "tick_size":"0.001",
        //             "take_rate":"0.0005",
        //             "make_rate":"0.0002",
        //             "fee_currency":"USDT",
        //             "margin_trading":true,
        //             "max_initial_leverage":"50.00"
        //         },
        //         "MANAUSDT":{
        //             "type":"spot",
        //             "base_currency":"MANA",
        //             "quote_currency":"USDT",
        //             "quantity_increment":"1",
        //             "tick_size":"0.0000001",
        //             "take_rate":"0.0025",
        //             "make_rate":"0.001",
        //             "fee_currency":"USDT",
        //             "margin_trading":true,
        //             "max_initial_leverage":"5.00"
        //         },
        //     }
        //
        object result = new List<object>() {};
        object ids = new List<object>(((Dictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = this.safeValue(response, id);
            object marketType = this.safeString(market, "type");
            object expiry = this.safeInteger(market, "expiry");
            object contract = (isEqual(marketType, "futures"));
            object spot = (isEqual(marketType, "spot"));
            object marginTrading = this.safeValue(market, "margin_trading", false);
            object margin = isTrue(spot) && isTrue(marginTrading);
            object future = (!isEqual(expiry, null));
            object swap = (isTrue(contract) && !isTrue(future));
            object option = false;
            object baseId = this.safeString2(market, "base_currency", "underlying");
            object quoteId = this.safeString(market, "quote_currency");
            object feeCurrencyId = this.safeString(market, "fee_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            object settleId = null;
            object settle = null;
            object symbol = add(add(bs, "/"), quote);
            object type = "spot";
            object contractSize = null;
            object linear = null;
            object inverse = null;
            if (isTrue(contract))
            {
                contractSize = this.parseNumber("1");
                settleId = feeCurrencyId;
                settle = this.safeCurrencyCode(settleId);
                linear = (isTrue((!isEqual(quote, null))) && isTrue((isEqual(quote, settle))));
                inverse = !isTrue(linear);
                symbol = add(add(symbol, ":"), settle);
                if (isTrue(future))
                {
                    symbol = add(add(symbol, "-"), expiry);
                    type = "future";
                } else
                {
                    type = "swap";
                }
            }
            object lotString = this.safeString(market, "quantity_increment");
            object stepString = this.safeString(market, "tick_size");
            object lot = this.parseNumber(lotString);
            object step = this.parseNumber(stepString);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", margin },
                { "swap", swap },
                { "future", future },
                { "option", option },
                { "active", true },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", this.safeNumber(market, "take_rate") },
                { "maker", this.safeNumber(market, "make_rate") },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "feeCurrency", feeCurrency },
                { "precision", new Dictionary<string, object>() {
                    { "amount", lot },
                    { "price", step },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(market, "max_initial_leverage", 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", lot },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", step },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber(Precise.stringMul(lotString, stepString)) },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPublicCurrency(parameters);
        //
        //     {
        //       "WEALTH": {
        //         "full_name": "ConnectWealth",
        //         "payin_enabled": false,
        //         "payout_enabled": false,
        //         "transfer_enabled": true,
        //         "precision_transfer": "0.001",
        //         "networks": [
        //           {
        //             "network": "ETH",
        //             "protocol": "ERC20",
        //             "default": true,
        //             "payin_enabled": false,
        //             "payout_enabled": false,
        //             "precision_payout": "0.001",
        //             "payout_fee": "0.016800000000",
        //             "payout_is_payment_id": false,
        //             "payin_payment_id": false,
        //             "payin_confirmations": "2"
        //           }
        //         ]
        //       }
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object currencies = new List<object>(((Dictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencies, i);
            object code = this.safeCurrencyCode(currencyId);
            object entry = getValue(response, currencyId);
            object name = this.safeString(entry, "full_name");
            object precision = this.safeNumber(entry, "precision_transfer");
            object payinEnabled = this.safeValue(entry, "payin_enabled", false);
            object payoutEnabled = this.safeValue(entry, "payout_enabled", false);
            object transferEnabled = this.safeValue(entry, "transfer_enabled", false);
            object active = isTrue(isTrue(payinEnabled) && isTrue(payoutEnabled)) && isTrue(transferEnabled);
            object rawNetworks = this.safeValue(entry, "networks", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object fee = null;
            object depositEnabled = null;
            object withdrawEnabled = null;
            for (object j = 0; isLessThan(j, getArrayLength(rawNetworks)); postFixIncrement(ref j))
            {
                object rawNetwork = getValue(rawNetworks, j);
                object networkId = this.safeString2(rawNetwork, "protocol", "network");
                object network = this.safeNetwork(networkId);
                fee = this.safeNumber(rawNetwork, "payout_fee");
                object networkPrecision = this.safeNumber(rawNetwork, "precision_payout");
                object payinEnabledNetwork = this.safeValue(entry, "payin_enabled", false);
                object payoutEnabledNetwork = this.safeValue(entry, "payout_enabled", false);
                object activeNetwork = isTrue(payinEnabledNetwork) && isTrue(payoutEnabledNetwork);
                if (isTrue(isTrue(payinEnabledNetwork) && !isTrue(depositEnabled)))
                {
                    depositEnabled = true;
                } else if (!isTrue(payinEnabledNetwork))
                {
                    depositEnabled = false;
                }
                if (isTrue(isTrue(payoutEnabledNetwork) && !isTrue(withdrawEnabled)))
                {
                    withdrawEnabled = true;
                } else if (!isTrue(payoutEnabledNetwork))
                {
                    withdrawEnabled = false;
                }
                ((Dictionary<string, object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", rawNetwork },
                    { "id", networkId },
                    { "network", network },
                    { "fee", fee },
                    { "active", activeNetwork },
                    { "deposit", payinEnabledNetwork },
                    { "withdraw", payoutEnabledNetwork },
                    { "precision", networkPrecision },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            object networksKeys = new List<object>(((Dictionary<string,object>)networks).Keys);
            object networksLength = getArrayLength(networksKeys);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "id", currencyId },
                { "precision", precision },
                { "name", name },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "networks", networks },
                { "fee", ((bool) isTrue((isLessThanOrEqual(networksLength, 1)))) ? fee : null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public virtual object safeNetwork(object networkId)
    {
        if (isTrue(isEqual(networkId, null)))
        {
            return null;
        } else
        {
            return ((string)networkId).ToUpper();
        }
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the hitbtc api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object network = this.safeStringUpper(parameters, "network");
        if (isTrue(isTrue((!isEqual(network, null))) && isTrue((isEqual(code, "USDT")))))
        {
            object networks = this.safeValue(this.options, "networks");
            object parsedNetwork = this.safeString(networks, network);
            if (isTrue(!isEqual(parsedNetwork, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = parsedNetwork;
            }
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privatePostWalletCryptoAddress(this.extend(request, parameters));
        //
        //  {"currency":"ETH","address":"0xd0d9aea60c41988c3e68417e2616065617b7afd3"}
        //
        object currencyId = this.safeString(response, "currency");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId) },
            { "address", this.safeString(response, "address") },
            { "tag", this.safeString(response, "payment_id") },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object network = this.safeStringUpper(parameters, "network");
        if (isTrue(isTrue((!isEqual(network, null))) && isTrue((isEqual(code, "USDT")))))
        {
            object networks = this.safeValue(this.options, "networks");
            object parsedNetwork = this.safeString(networks, network);
            if (isTrue(!isEqual(parsedNetwork, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = parsedNetwork;
            }
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privateGetWalletCryptoAddress(this.extend(request, parameters));
        //
        //  [{"currency":"ETH","address":"0xd0d9aea60c41988c3e68417e2616065617b7afd3"}]
        //
        object firstAddress = this.safeValue(response, 0);
        object address = this.safeString(firstAddress, "address");
        object currencyId = this.safeString(firstAddress, "currency");
        object tag = this.safeString(firstAddress, "payment_id");
        object parsedCode = this.safeCurrencyCode(currencyId);
        return new Dictionary<string, object>() {
            { "info", response },
            { "address", address },
            { "tag", tag },
            { "code", parsedCode },
            { "currency", parsedCode },
            { "network", null },
        };
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "available");
            ((Dictionary<string, object>)account)["used"] = this.safeString(entry, "reserved");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object type = this.safeStringLower(parameters, "type", "spot");
        parameters = this.omit(parameters, new List<object>() {"type"});
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object account = this.safeString(accountsByType, type, type);
        object response = null;
        if (isTrue(isEqual(account, "wallet")))
        {
            response = await this.privateGetWalletBalance(parameters);
        } else if (isTrue(isEqual(account, "spot")))
        {
            response = await this.privateGetSpotBalance(parameters);
        } else if (isTrue(isEqual(account, "derivatives")))
        {
            response = await this.privateGetFuturesBalance(parameters);
        } else
        {
            object keys = new List<object>(((Dictionary<string,object>)accountsByType).Keys);
            throw new BadRequest ((string)add(add(this.id, " fetchBalance() type parameter must be one of "), String.Join(", ", ((List<object>)keys).ToArray()))) ;
        }
        //
        //     [
        //       {
        //         "currency": "PAXG",
        //         "available": "0",
        //         "reserved": "0",
        //         "reserved_margin": "0",
        //       },
        //       ...
        //     ]
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(response, symbol);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = this.marketIds(symbols);
            object delimited = String.Join(",", ((List<object>)marketIds).ToArray());
            ((Dictionary<string, object>)request)["symbols"] = delimited;
        }
        object response = await this.publicGetPublicTicker(this.extend(request, parameters));
        //
        //     {
        //       "BTCUSDT": {
        //         "ask": "63049.06",
        //         "bid": "63046.41",
        //         "last": "63048.36",
        //         "low": "62010.00",
        //         "high": "66657.99",
        //         "open": "64839.75",
        //         "volume": "15272.13278",
        //         "volume_quote": "976312127.6277998",
        //         "timestamp": "2021-10-22T04:25:47.573Z"
        //       }
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object keys = new List<object>(((Dictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object marketId = getValue(keys, i);
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            object entry = getValue(response, marketId);
            ((Dictionary<string, object>)result)[(string)symbol] = this.parseTicker(entry, market);
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //       "ask": "62756.01",
        //       "bid": "62754.09",
        //       "last": "62755.87",
        //       "low": "62010.00",
        //       "high": "66657.99",
        //       "open": "65089.27",
        //       "volume": "16719.50366",
        //       "volume_quote": "1063422878.8156828",
        //       "timestamp": "2021-10-22T07:29:14.585Z"
        //     }
        //
        object timestamp = this.parse8601(getValue(ticker, "timestamp"));
        object symbol = this.safeSymbol(null, market);
        object baseVolume = this.safeString(ticker, "volume");
        object quoteVolume = this.safeString(ticker, "volume_quote");
        object open = this.safeString(ticker, "open");
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            // symbol is optional for hitbtc fetchTrades
            ((Dictionary<string, object>)request)["symbols"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = since;
        }
        object response = await this.publicGetPublicTrades(this.extend(request, parameters));
        object marketIds = new List<object>(((Dictionary<string,object>)response).Keys);
        object trades = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object marketInner = this.market(marketId);
            object rawTrades = getValue(response, marketId);
            object parsed = this.parseTrades(rawTrades, marketInner);
            trades = this.arrayConcat(trades, parsed);
        }
        return trades;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching margin trades
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = since;
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotHistoryTrade" },
            { "swap", "privateGetFuturesHistoryTrade" },
            { "margin", "privateGetMarginHistoryTrade" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginHistoryTrade";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // createOrder (market)
        //
        //  {
        //      id: '1569252895',
        //      position_id: '0',
        //      quantity: '10',
        //      price: '0.03919424',
        //      fee: '0.000979856000',
        //      timestamp: '2022-01-25T19:38:36.153Z',
        //      taker: true
        //  }
        //
        // fetchTrades
        //
        //  {
        //      id: 974786185,
        //      price: '0.032462',
        //      qty: '0.3673',
        //      side: 'buy',
        //      timestamp: '2020-10-16T12:57:39.846Z'
        //  }
        //
        // fetchMyTrades spot
        //
        //  {
        //      id: 277210397,
        //      clientOrderId: '6e102f3e7f3f4e04aeeb1cdc95592f1a',
        //      orderId: 28102855393,
        //      symbol: 'ETHBTC',
        //      side: 'sell',
        //      quantity: '0.002',
        //      price: '0.073365',
        //      fee: '0.000000147',
        //      timestamp: '2018-04-28T18:39:55.345Z',
        //      taker: true
        //  }
        //
        // fetchMyTrades swap and margin
        //
        //  {
        //      "id": 4718564,
        //      "order_id": 58730811958,
        //      "client_order_id": "475c47d97f867f09726186eb22b4c3d4",
        //      "symbol": "BTCUSDT_PERP",
        //      "side": "sell",
        //      "quantity": "0.0001",
        //      "price": "41118.51",
        //      "fee": "0.002055925500",
        //      "timestamp": "2022-03-17T05:23:17.795Z",
        //      "taker": true,
        //      "position_id": 2350122,
        //      "pnl": "0.002255000000",
        //      "liquidation": false
        //  }
        //
        object timestamp = this.parse8601(getValue(trade, "timestamp"));
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        object taker = this.safeValue(trade, "taker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(taker, null)))
        {
            takerOrMaker = ((bool) isTrue(taker)) ? "taker" : "maker";
        }
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object info = this.safeValue(market, "info", new Dictionary<string, object>() {});
            object feeCurrency = this.safeString(info, "fee_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrency);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        // we use clientOrderId as the order id with this exchange intentionally
        // because most of their endpoints will require clientOrderId
        // explained here: https://github.com/ccxt/ccxt/issues/5674
        object orderId = this.safeString2(trade, "clientOrderId", "client_order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString2(trade, "quantity", "qty");
        object side = this.safeString(trade, "side");
        object id = this.safeString(trade, "id");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async virtual Task<object> fetchTransactionsHelper(object types, object code, object since, object limit, object parameters)
    {
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "types", types },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currencies"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetWalletTransactions(this.extend(request, parameters));
        //
        //     [
        //       {
        //         "id": "101609495",
        //         "created_at": "2018-03-06T22:05:06.507Z",
        //         "updated_at": "2018-03-06T22:11:45.03Z",
        //         "status": "SUCCESS",
        //         "type": "DEPOSIT",
        //         "subtype": "BLOCKCHAIN",
        //         "native": {
        //           "tx_id": "e20b0965-4024-44d0-b63f-7fb8996a6706",
        //           "index": "881652766",
        //           "currency": "ETH",
        //           "amount": "0.01418088",
        //           "hash": "d95dbbff3f9234114f1211ab0ba2a94f03f394866fd5749d74a1edab80e6c5d3",
        //           "address": "0xd9259302c32c0a0295d86a39185c9e14f6ba0a0d",
        //           "confirmations": "20",
        //           "senders": [
        //             "0x243bec9256c9a3469da22103891465b47583d9f1"
        //           ]
        //         }
        //       }
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "pending" },
            { "FAILED", "failed" },
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "DEPOSIT", "deposit" },
            { "WITHDRAW", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // transaction
        //
        //     {
        //       "id": "101609495",
        //       "created_at": "2018-03-06T22:05:06.507Z",
        //       "updated_at": "2018-03-06T22:11:45.03Z",
        //       "status": "SUCCESS",
        //       "type": "DEPOSIT", // DEPOSIT, WITHDRAW, ..
        //       "subtype": "BLOCKCHAIN",
        //       "native": {
        //         "tx_id": "e20b0965-4024-44d0-b63f-7fb8996a6706",
        //         "index": "881652766",
        //         "currency": "ETH",
        //         "amount": "0.01418088",
        //         "hash": "d95dbbff3f9234114f1211ab0ba2a94f03f394866fd5749d74a1edab80e6c5d3",
        //         "address": "0xd9259302c32c0a0295d86a39185c9e14f6ba0a0d",
        //         "confirmations": "20",
        //         "senders": [
        //           "0x243bec9256c9a3469da22103891465b47583d9f1"
        //         ],
        //         "fee": "1.22" // only for WITHDRAW
        //       }
        //     }
        //
        // withdraw
        //
        //     {
        //         "id":"084cfcd5-06b9-4826-882e-fdb75ec3625d"
        //     }
        //
        object id = this.safeString(transaction, "id");
        object timestamp = this.parse8601(this.safeString(transaction, "created_at"));
        object updated = this.parse8601(this.safeString(transaction, "updated_at"));
        object type = this.parseTransactionType(this.safeString(transaction, "type"));
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object native = this.safeValue(transaction, "native", new Dictionary<string, object>() {});
        object currencyId = this.safeString(native, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object txhash = this.safeString(native, "hash");
        object address = this.safeString(native, "address");
        object addressTo = address;
        object tag = this.safeString(native, "payment_id");
        object tagTo = tag;
        object sender = this.safeValue(native, "senders");
        object addressFrom = this.safeString(sender, 0);
        object amount = this.safeNumber(native, "amount");
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        object feeCost = this.safeNumber(native, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            ((Dictionary<string, object>)fee)["currency"] = code;
            ((Dictionary<string, object>)fee)["cost"] = feeCost;
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txhash },
            { "type", type },
            { "code", code },
            { "currency", code },
            { "network", null },
            { "amount", amount },
            { "status", status },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "updated", updated },
            { "comment", null },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTransactions
        * @description fetch history of deposits and withdrawals
        * @param {string|undefined} code unified currency code for the currency of the transactions, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest transaction, default is undefined
        * @param {int|undefined} limit max number of transactions to return, default is undefined
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW", code, since, limit, parameters);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("DEPOSIT", code, since, limit, parameters);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("WITHDRAW", code, since, limit, parameters);
    }

    public async override Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOrderBooks
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
        * @param {[string]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
        * @param {int|undefined} limit max number of entries per orderbook to return, default is undefined
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIdsInner = this.marketIds(symbols);
            ((Dictionary<string, object>)request)["symbols"] = String.Join(",", ((List<object>)marketIdsInner).ToArray());
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["depth"] = limit;
        }
        object response = await this.publicGetPublicOrderbook(this.extend(request, parameters));
        object result = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((Dictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object orderbook = getValue(response, marketId);
            object symbol = this.safeSymbol(marketId);
            object timestamp = this.parse8601(this.safeString(orderbook, "timestamp"));
            ((Dictionary<string, object>)result)[(string)symbol] = this.parseOrderBook(getValue(response, marketId), symbol, timestamp, "bid", "ask");
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object result = await this.fetchOrderBooks(new List<object>() {symbol}, limit, parameters);
        return getValue(result, symbol);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol":"ARVUSDT", // returned from fetchTradingFees only
        //         "take_rate":"0.0009",
        //         "make_rate":"0.0009"
        //     }
        //
        object taker = this.safeNumber(fee, "take_rate");
        object maker = this.safeNumber(fee, "make_rate");
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "taker", taker },
            { "maker", maker },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "privateGetSpotFeeSymbol" },
            { "swap", "privateGetFuturesFeeSymbol" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "take_rate":"0.0009",
        //         "make_rate":"0.0009"
        //     }
        //
        return this.parseTradingFee(response, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotFee" },
            { "swap", "privateGetFuturesFee" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        //
        //     [
        //         {
        //             "symbol":"ARVUSDT",
        //             "take_rate":"0.0009",
        //             "make_rate":"0.0009"
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object fee = this.parseTradingFee(getValue(response, i));
            object symbol = getValue(fee, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object method = "publicGetPublicCandles";
        if (isTrue(isEqual(price, "mark")))
        {
            method = "publicGetPublicFuturesCandlesMarkPrice";
        } else if (isTrue(isEqual(price, "index")))
        {
            method = "publicGetPublicFuturesCandlesIndexPrice";
        } else if (isTrue(isEqual(price, "premiumIndex")))
        {
            method = "publicGetPublicFuturesCandlesPremiumIndex";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // Spot and Swap
        //
        //     {
        //         "ETHUSDT": [
        //             {
        //                 "timestamp": "2021-10-25T07:38:00.000Z",
        //                 "open": "4173.391",
        //                 "close": "4170.923",
        //                 "min": "4170.923",
        //                 "max": "4173.986",
        //                 "volume": "0.1879",
        //                 "volume_quote": "784.2517846"
        //             }
        //         ]
        //     }
        //
        // Mark, Index and Premium Index
        //
        //     {
        //         "BTCUSDT_PERP": [
        //             {
        //                 "timestamp": "2022-04-01T01:28:00.000Z",
        //                 "open": "45146.39",
        //                 "close": "45219.43",
        //                 "min": "45146.39",
        //                 "max": "45219.43"
        //             },
        //         ]
        //     }
        //
        object ohlcvs = this.safeValue(response, getValue(market, "id"));
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // Spot and Swap
        //
        //     {
        //         "timestamp":"2015-08-20T19:01:00.000Z",
        //         "open":"0.006",
        //         "close":"0.006",
        //         "min":"0.006",
        //         "max":"0.006",
        //         "volume":"0.003",
        //         "volume_quote":"0.000018"
        //     }
        //
        // Mark, Index and Premium Index
        //
        //     {
        //         "timestamp": "2022-04-01T01:28:00.000Z",
        //         "open": "45146.39",
        //         "close": "45219.43",
        //         "min": "45146.39",
        //         "max": "45219.43"
        //     },
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "timestamp")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "max"), this.safeNumber(ohlcv, "min"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching margin orders
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotHistoryOrder" },
            { "swap", "privateGetFuturesHistoryOrder" },
            { "margin", "privateGetMarginHistoryOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchClosedOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginHistoryOrder";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        object parsed = this.parseOrders(response, market, since, limit);
        return this.filterByArray(parsed, "status", new List<object>() {"closed", "canceled"}, false);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching a margin order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotHistoryOrder" },
            { "swap", "privateGetFuturesHistoryOrder" },
            { "margin", "privateGetMarginHistoryOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginHistoryOrder";
        }
        object request = new Dictionary<string, object>() {
            { "client_order_id", id },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     [
        //       {
        //         "id": "685965182082",
        //         "client_order_id": "B3CBm9uGg9oYQlw96bBSEt38-6gbgBO0",
        //         "symbol": "BTCUSDT",
        //         "side": "buy",
        //         "status": "new",
        //         "type": "limit",
        //         "time_in_force": "GTC",
        //         "quantity": "0.00010",
        //         "quantity_cumulative": "0",
        //         "price": "50000.00",
        //         "price_average": "0",
        //         "created_at": "2021-10-26T11:40:09.287Z",
        //         "updated_at": "2021-10-26T11:40:09.287Z"
        //       }
        //     ]
        //
        object order = this.safeValue(response, 0);
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching margin trades
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrderTrades", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotHistoryTrade" },
            { "swap", "privateGetFuturesHistoryTrade" },
            { "margin", "privateGetMarginHistoryTrade" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrderTrades", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginHistoryTrade";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot
        //
        //     [
        //       {
        //         "id": 1393448977,
        //         "order_id": 653496804534,
        //         "client_order_id": "065f6f0ff9d54547848454182263d7b4",
        //         "symbol": "DICEETH",
        //         "side": "buy",
        //         "quantity": "1.4",
        //         "price": "0.00261455",
        //         "fee": "0.000003294333",
        //         "timestamp": "2021-09-19T05:35:56.601Z",
        //         "taker": true
        //       }
        //     ]
        //
        // Swap and Margin
        //
        //     [
        //         {
        //             "id": 4718551,
        //             "order_id": 58730748700,
        //             "client_order_id": "dcbcd8549e3445ee922665946002ef67",
        //             "symbol": "BTCUSDT_PERP",
        //             "side": "buy",
        //             "quantity": "0.0001",
        //             "price": "41095.96",
        //             "fee": "0.002054798000",
        //             "timestamp": "2022-03-17T05:23:02.217Z",
        //             "taker": true,
        //             "position_id": 2350122,
        //             "pnl": "0",
        //             "liquidation": false
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching open margin orders
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotOrder" },
            { "swap", "privateGetFuturesOrder" },
            { "margin", "privateGetMarginOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginOrder";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     [
        //       {
        //         "id": "488953123149",
        //         "client_order_id": "103ad305301e4c3590045b13de15b36e",
        //         "symbol": "BTCUSDT",
        //         "side": "buy",
        //         "status": "new",
        //         "type": "limit",
        //         "time_in_force": "GTC",
        //         "quantity": "0.00001",
        //         "quantity_cumulative": "0",
        //         "price": "0.01",
        //         "post_only": false,
        //         "created_at": "2021-04-13T13:06:16.567Z",
        //         "updated_at": "2021-04-13T13:06:16.567Z"
        //       }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchOpenOrder
        * @description fetch an open order by it's id
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for fetching an open margin order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotOrderClientOrderId" },
            { "swap", "privateGetFuturesOrderClientOrderId" },
            { "margin", "privateGetMarginOrderClientOrderId" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOpenOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginOrderClientOrderId";
        }
        object request = new Dictionary<string, object>() {
            { "client_order_id", id },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for canceling margin orders
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateDeleteSpotOrder" },
            { "swap", "privateDeleteFuturesOrder" },
            { "margin", "privateDeleteMarginOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateDeleteMarginOrder";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseOrders(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool|undefined} params.margin true for canceling a margin order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "client_order_id", id },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateDeleteSpotOrderClientOrderId" },
            { "swap", "privateDeleteFuturesOrderClientOrderId" },
            { "margin", "privateDeleteMarginOrderClientOrderId" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateDeleteMarginOrderClientOrderId";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "client_order_id", id },
            { "quantity", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "stopLimit")))))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ExchangeError ((string)add(this.id, " editOrder() limit order requires price")) ;
            }
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("editOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privatePatchSpotOrderClientOrderId" },
            { "swap", "privatePatchFuturesOrderClientOrderId" },
            { "margin", "privatePatchMarginOrderClientOrderId" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("editOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privatePatchMarginOrderClientOrderId";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for creating a margin order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", type },
            { "side", side },
            { "quantity", this.amountToPrecision(symbol, amount) },
            { "symbol", getValue(market, "id") },
        };
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            if (isTrue(isTrue((!isEqual(getValue(market, "type"), "swap"))) && isTrue((!isEqual(getValue(market, "type"), "margin")))))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() does not support reduce_only for "), getValue(market, "type")), " orders, reduce_only orders are supported for swap and margin markets only")) ;
            }
        }
        if (isTrue(isEqual(reduceOnly, true)))
        {
            ((Dictionary<string, object>)request)["reduce_only"] = reduceOnly;
        }
        object timeInForce = this.safeString2(parameters, "timeInForce", "time_in_force");
        object expireTime = this.safeString(parameters, "expire_time");
        object stopPrice = this.safeNumber2(parameters, "stopPrice", "stop_price");
        if (isTrue(isTrue(isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "stopLimit")))) || isTrue((isEqual(type, "takeProfitLimit")))))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder() requires a price argument for limit orders")) ;
            }
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue((isEqual(timeInForce, "GTD"))))
        {
            if (isTrue(isEqual(expireTime, null)))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder() requires an expire_time parameter for a GTD order")) ;
            }
            ((Dictionary<string, object>)request)["expire_time"] = expireTime;
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(type, "stopLimit"))) || isTrue((isEqual(type, "stopMarket")))) || isTrue((isEqual(type, "takeProfitLimit")))) || isTrue((isEqual(type, "takeProfitMarket")))))
        {
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder() requires a stopPrice parameter for stop-loss and take-profit orders")) ;
            }
            ((Dictionary<string, object>)request)["stop_price"] = this.priceToPrecision(symbol, stopPrice);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privatePostSpotOrder" },
            { "swap", "privatePostFuturesOrder" },
            { "margin", "privatePostMarginOrder" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("createOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privatePostMarginOrder";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        return this.parseOrder(response, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "open" },
            { "suspended", "open" },
            { "partiallyFilled", "open" },
            { "filled", "closed" },
            { "canceled", "canceled" },
            { "expired", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // limit
        //     {
        //       "id": 488953123149,
        //       "client_order_id": "103ad305301e4c3590045b13de15b36e",
        //       "symbol": "BTCUSDT",
        //       "side": "buy",
        //       "status": "new",
        //       "type": "limit",
        //       "time_in_force": "GTC",
        //       "quantity": "0.00001",
        //       "quantity_cumulative": "0",
        //       "price": "0.01",
        //       "price_average": "0.01",
        //       "post_only": false,
        //       "created_at": "2021-04-13T13:06:16.567Z",
        //       "updated_at": "2021-04-13T13:06:16.567Z"
        //     }
        //
        // market
        //     {
        //       "id": "685877626834",
        //       "client_order_id": "Yshl7G-EjaREyXQYaGbsmdtVbW-nzQwu",
        //       "symbol": "BTCUSDT",
        //       "side": "buy",
        //       "status": "filled",
        //       "type": "market",
        //       "time_in_force": "GTC",
        //       "quantity": "0.00010",
        //       "quantity_cumulative": "0.00010",
        //       "post_only": false,
        //       "created_at": "2021-10-26T08:55:55.1Z",
        //       "updated_at": "2021-10-26T08:55:55.1Z",
        //       "trades": [
        //         {
        //           "id": "1437229630",
        //           "position_id": "0",
        //           "quantity": "0.00010",
        //           "price": "62884.78",
        //           "fee": "0.005659630200",
        //           "timestamp": "2021-10-26T08:55:55.1Z",
        //           "taker": true
        //         }
        //       ]
        //     }
        //
        // swap and margin
        //
        //     {
        //         "id": 58418961892,
        //         "client_order_id": "r42gdPjNMZN-H_xs8RKl2wljg_dfgdg4",
        //         "symbol": "BTCUSDT_PERP",
        //         "side": "buy",
        //         "status": "new",
        //         "type": "limit",
        //         "time_in_force": "GTC",
        //         "quantity": "0.0005",
        //         "quantity_cumulative": "0",
        //         "price": "30000.00",
        //         "post_only": false,
        //         "reduce_only": false,
        //         "created_at": "2022-03-16T08:16:53.039Z",
        //         "updated_at": "2022-03-16T08:16:53.039Z"
        //     }
        //
        object id = this.safeString(order, "client_order_id");
        // we use clientOrderId as the order id with this exchange intentionally
        // because most of their endpoints will require clientOrderId
        // explained here: https://github.com/ccxt/ccxt/issues/5674
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "type");
        object amount = this.safeString(order, "quantity");
        object price = this.safeString(order, "price");
        object average = this.safeString(order, "price_average");
        object created = this.safeString(order, "created_at");
        object timestamp = this.parse8601(created);
        object updated = this.safeString(order, "updated_at");
        object lastTradeTimestamp = null;
        if (isTrue(!isEqual(updated, created)))
        {
            lastTradeTimestamp = this.parse8601(updated);
        }
        object filled = this.safeString(order, "quantity_cumulative");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object postOnly = this.safeValue(order, "post_only");
        object timeInForce = this.safeString(order, "time_in_force");
        object rawTrades = this.safeValue(order, "trades");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "price", price },
            { "amount", amount },
            { "type", type },
            { "side", side },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeValue(order, "reduce_only") },
            { "filled", filled },
            { "remaining", null },
            { "cost", null },
            { "status", status },
            { "average", average },
            { "trades", rawTrades },
            { "fee", null },
        }, market);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        // account can be "spot", "wallet", or "derivatives"
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object requestAmount = this.currencyToPrecision(code, amount);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        fromAccount = ((string)fromAccount).ToLower();
        toAccount = ((string)toAccount).ToLower();
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        if (isTrue(isEqual(fromId, toId)))
        {
            throw new BadRequest ((string)add(this.id, " transfer() fromAccount and toAccount arguments cannot be the same account")) ;
        }
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", requestAmount },
            { "source", fromId },
            { "destination", toId },
        };
        object response = await this.privatePostWalletTransfer(this.extend(request, parameters));
        //
        //     [
        //         '2db6ebab-fb26-4537-9ef8-1a689472d236'
        //     ]
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     [
        //         '2db6ebab-fb26-4537-9ef8-1a689472d236'
        //     ]
        //
        object timestamp = this.milliseconds();
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, 0) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
            { "info", transfer },
        };
    }

    public async virtual Task<object> convertCurrencyNetwork(object code, object amount, object fromNetwork, object toNetwork, object parameters)
    {
        await this.loadMarkets();
        if (isTrue(!isEqual(code, "USDT")))
        {
            throw new ExchangeError ((string)add(this.id, " convertCurrencyNetwork() only supports USDT currently")) ;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        fromNetwork = ((string)fromNetwork).ToUpper();
        toNetwork = ((string)toNetwork).ToUpper();
        fromNetwork = this.safeString(networks, fromNetwork); // handle ETH>ERC20 alias
        toNetwork = this.safeString(networks, toNetwork); // handle ETH>ERC20 alias
        if (isTrue(isEqual(fromNetwork, toNetwork)))
        {
            throw new BadRequest ((string)add(this.id, " convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork")) ;
        }
        if (isTrue(isTrue((isEqual(fromNetwork, null))) || isTrue((isEqual(toNetwork, null)))))
        {
            object keys = new List<object>(((Dictionary<string,object>)networks).Keys);
            throw new ArgumentsRequired ((string)add(add(this.id, " convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "), String.Join(", ", ((List<object>)keys).ToArray()))) ;
        }
        object request = new Dictionary<string, object>() {
            { "from_currency", fromNetwork },
            { "to_currency", toNetwork },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostWalletConvert(this.extend(request, parameters));
        // {"result":["587a1868-e62d-4d8e-b27c-dbdb2ee96149","e168df74-c041-41f2-b76c-e43e4fed5bc7"]}
        return new Dictionary<string, object>() {
            { "info", response },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["payment_id"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network");
        if (isTrue(isTrue((!isEqual(network, null))) && isTrue((isEqual(code, "USDT")))))
        {
            object parsedNetwork = this.safeString(networks, network);
            if (isTrue(!isEqual(parsedNetwork, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = parsedNetwork;
            }
            parameters = this.omit(parameters, "network");
        }
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        object includeFee = this.safeValue(withdrawOptions, "includeFee", false);
        if (isTrue(includeFee))
        {
            ((Dictionary<string, object>)request)["include_fee"] = true;
        }
        object response = await this.privatePostWalletCryptoWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "id":"084cfcd5-06b9-4826-882e-fdb75ec3625d"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["symbols"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetPublicFuturesHistoryFunding(this.extend(request, parameters));
        //
        //    {
        //        "BTCUSDT_PERP": [
        //            {
        //                "timestamp": "2021-07-29T16:00:00.271Z",
        //                "funding_rate": "0.0001",
        //                "avg_premium_index": "0.000061858585213222",
        //                "next_funding_time": "2021-07-30T00:00:00.000Z",
        //                "interest_rate": "0.0001"
        //            },
        //            ...
        //        ],
        //        ...
        //    }
        //
        object contracts = new List<object>(((Dictionary<string,object>)response).Keys);
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(contracts)); postFixIncrement(ref i))
        {
            object marketId = getValue(contracts, i);
            object marketInner = this.safeMarket(marketId);
            object fundingRateData = getValue(response, marketId);
            for (object j = 0; isLessThan(j, getArrayLength(fundingRateData)); postFixIncrement(ref j))
            {
                object entry = getValue(fundingRateData, j);
                object symbolInner = this.safeSymbol(getValue(marketInner, "symbol"));
                object fundingRate = this.safeNumber(entry, "funding_rate");
                object datetime = this.safeString(entry, "timestamp");
                ((List<object>)rates).Add(new Dictionary<string, object>() {
                    { "info", entry },
                    { "symbol", symbolInner },
                    { "fundingRate", fundingRate },
                    { "timestamp", this.parse8601(datetime) },
                    { "datetime", datetime },
                });
            }
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols not used by hitbtc3 fetchPositions ()
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for fetching spot-margin positions
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "swap", "privateGetFuturesAccount" },
            { "margin", "privateGetMarginAccount" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchPositions", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginAccount";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     [
        //         {
        //             "symbol": "ETHUSDT_PERP",
        //             "type": "isolated",
        //             "leverage": "10.00",
        //             "created_at": "2022-03-19T07:54:35.24Z",
        //             "updated_at": "2022-03-19T07:54:58.922Z",
        //             currencies": [
        //                 {
        //                     "code": "USDT",
        //                     "margin_balance": "7.478100643043",
        //                     "reserved_orders": "0",
        //                     "reserved_positions": "0.303530761300"
        //                 }
        //             ],
        //             "positions": [
        //                 {
        //                     "id": 2470568,
        //                     "symbol": "ETHUSDT_PERP",
        //                     "quantity": "0.001",
        //                     "price_entry": "2927.509",
        //                     "price_margin_call": "0",
        //                     "price_liquidation": "0",
        //                     "pnl": "0",
        //                     "created_at": "2022-03-19T07:54:35.24Z",
        //                     "updated_at": "2022-03-19T07:54:58.922Z"
        //                 }
        //             ]
        //         },
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parsePosition(getValue(response, i)));
        }
        return result;
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchPosition
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for fetching a spot-margin position
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPosition", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "swap", "privateGetFuturesAccountIsolatedSymbol" },
            { "margin", "privateGetMarginAccountIsolatedSymbol" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchPosition", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginAccountIsolatedSymbol";
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     [
        //         {
        //             "symbol": "ETHUSDT_PERP",
        //             "type": "isolated",
        //             "leverage": "10.00",
        //             "created_at": "2022-03-19T07:54:35.24Z",
        //             "updated_at": "2022-03-19T07:54:58.922Z",
        //             currencies": [
        //                 {
        //                     "code": "USDT",
        //                     "margin_balance": "7.478100643043",
        //                     "reserved_orders": "0",
        //                     "reserved_positions": "0.303530761300"
        //                 }
        //             ],
        //             "positions": [
        //                 {
        //                     "id": 2470568,
        //                     "symbol": "ETHUSDT_PERP",
        //                     "quantity": "0.001",
        //                     "price_entry": "2927.509",
        //                     "price_margin_call": "0",
        //                     "price_liquidation": "0",
        //                     "pnl": "0",
        //                     "created_at": "2022-03-19T07:54:35.24Z",
        //                     "updated_at": "2022-03-19T07:54:58.922Z"
        //                 }
        //             ]
        //         },
        //     ]
        //
        return this.parsePosition(response, market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     [
        //         {
        //             "symbol": "ETHUSDT_PERP",
        //             "type": "isolated",
        //             "leverage": "10.00",
        //             "created_at": "2022-03-19T07:54:35.24Z",
        //             "updated_at": "2022-03-19T07:54:58.922Z",
        //             currencies": [
        //                 {
        //                     "code": "USDT",
        //                     "margin_balance": "7.478100643043",
        //                     "reserved_orders": "0",
        //                     "reserved_positions": "0.303530761300"
        //                 }
        //             ],
        //             "positions": [
        //                 {
        //                     "id": 2470568,
        //                     "symbol": "ETHUSDT_PERP",
        //                     "quantity": "0.001",
        //                     "price_entry": "2927.509",
        //                     "price_margin_call": "0",
        //                     "price_liquidation": "0",
        //                     "pnl": "0",
        //                     "created_at": "2022-03-19T07:54:35.24Z",
        //                     "updated_at": "2022-03-19T07:54:58.922Z"
        //                 }
        //             ]
        //         },
        //     ]
        //
        object marginMode = this.safeString(position, "type");
        object leverage = this.safeNumber(position, "leverage");
        object datetime = this.safeString(position, "updated_at");
        object positions = this.safeValue(position, "positions", new List<object>() {});
        object liquidationPrice = null;
        object entryPrice = null;
        object contracts = null;
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object entry = getValue(positions, i);
            liquidationPrice = this.safeNumber(entry, "price_liquidation");
            entryPrice = this.safeNumber(entry, "price_entry");
            contracts = this.safeNumber(entry, "quantity");
        }
        object currencies = this.safeValue(position, "currencies", new List<object>() {});
        object collateral = null;
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object entry = getValue(currencies, i);
            collateral = this.safeNumber(entry, "margin_balance");
        }
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", null },
            { "marginMode", marginMode },
            { "marginType", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", entryPrice },
            { "unrealizedPnl", null },
            { "percentage", null },
            { "contracts", contracts },
            { "contractSize", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", null },
            { "hedged", null },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", collateral },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", leverage },
            { "marginRatio", null },
        });
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["symbols"] = getValue(market, "id");
        }
        object response = await this.publicGetPublicFuturesInfo(this.extend(request, parameters));
        //
        //     {
        //         "BTCUSDT_PERP": {
        //             "contract_type": "perpetual",
        //             "mark_price": "42307.43",
        //             "index_price": "42303.27",
        //             "funding_rate": "0.0001",
        //             "open_interest": "30.9826",
        //             "next_funding_time": "2022-03-22T16:00:00.000Z",
        //             "indicative_funding_rate": "0.0001",
        //             "premium_index": "0",
        //             "avg_premium_index": "0.000029587712038098",
        //             "interest_rate": "0.0001",
        //             "timestamp": "2022-03-22T08:08:26.687Z"
        //         }
        //     }
        //
        object data = this.safeValue(response, getValue(market, "id"), new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "contract_type": "perpetual",
        //         "mark_price": "42307.43",
        //         "index_price": "42303.27",
        //         "funding_rate": "0.0001",
        //         "open_interest": "30.9826",
        //         "next_funding_time": "2022-03-22T16:00:00.000Z",
        //         "indicative_funding_rate": "0.0001",
        //         "premium_index": "0",
        //         "avg_premium_index": "0.000029587712038098",
        //         "interest_rate": "0.0001",
        //         "timestamp": "2022-03-22T08:08:26.687Z"
        //     }
        //
        object fundingDateTime = this.safeString(contract, "next_funding_time");
        object datetime = this.safeString(contract, "timestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(null, market) },
            { "markPrice", this.safeNumber(contract, "mark_price") },
            { "indexPrice", this.safeNumber(contract, "index_price") },
            { "interestRate", this.safeNumber(contract, "interest_rate") },
            { "estimatedSettlePrice", null },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "fundingRate", this.safeNumber(contract, "funding_rate") },
            { "fundingTimestamp", this.parse8601(fundingDateTime) },
            { "fundingDatetime", fundingDateTime },
            { "nextFundingRate", this.safeNumber(contract, "indicative_funding_rate") },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverage = this.safeString(parameters, "leverage");
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            if (isTrue(isEqual(leverage, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " modifyMarginHelper() requires a leverage parameter for swap markets")) ;
            }
        }
        amount = this.amountToPrecision(symbol, amount);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "margin_balance", amount },
        };
        if (isTrue(!isEqual(leverage, null)))
        {
            ((Dictionary<string, object>)request)["leverage"] = leverage;
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("modifyMarginHelper", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "swap", "privatePutFuturesAccountIsolatedSymbol" },
            { "margin", "privatePutMarginAccountIsolatedSymbol" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("modifyMarginHelper", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privatePutMarginAccountIsolatedSymbol";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "symbol": "BTCUSDT_PERP",
        //         "type": "isolated",
        //         "leverage": "8.00",
        //         "created_at": "2022-03-30T23:34:27.161Z",
        //         "updated_at": "2022-03-30T23:34:27.161Z",
        //         "currencies": [
        //             {
        //                 "code": "USDT",
        //                 "margin_balance": "7.000000000000",
        //                 "reserved_orders": "0",
        //                 "reserved_positions": "0"
        //             }
        //         ],
        //         "positions": null
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        object currencies = this.safeValue(data, "currencies", new List<object>() {});
        object currencyInfo = this.safeValue(currencies, 0);
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", null },
            { "amount", null },
            { "code", this.safeString(currencyInfo, "code") },
            { "symbol", getValue(market, "symbol") },
            { "status", null },
        };
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for reducing spot-margin
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(amount, 0)))
        {
            throw new BadRequest ((string)add(this.id, " reduceMargin() on hitbtc3 requires the amount to be 0 and that will remove the entire margin amount")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for adding spot-margin
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async virtual Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchLeverage
        * @description fetch the set leverage for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
        * @param {bool|undefined} params.margin true for fetching spot-margin leverage
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.getSupportedMapping(getValue(market, "type"), new Dictionary<string, object>() {
            { "spot", "privateGetMarginAccountIsolatedSymbol" },
            { "margin", "privateGetMarginAccountIsolatedSymbol" },
            { "swap", "privateGetFuturesAccountIsolatedSymbol" },
        });
        var marginModequeryVariable = this.handleMarginModeAndParams("modifyMarginHelper", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privateGetMarginAccountIsolatedSymbol";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "type": "isolated",
        //         "leverage": "12.00",
        //         "created_at": "2022-03-29T22:31:29.067Z",
        //         "updated_at": "2022-03-30T00:00:00.125Z",
        //         "currencies": [
        //             {
        //                 "code": "USDT",
        //                 "margin_balance": "20.824360374174",
        //                 "reserved_orders": "0",
        //                 "reserved_positions": "0.973330435000"
        //             }
        //         ],
        //         "positions": [
        //             {
        //                 "id": 631301,
        //                 "symbol": "BTCUSDT",
        //                 "quantity": "0.00022",
        //                 "price_entry": "47425.57",
        //                 "price_margin_call": "",
        //                 "price_liquidation": "0",
        //                 "pnl": "0",
        //                 "created_at": "2022-03-29T22:31:29.067Z",
        //                 "updated_at": "2022-03-30T00:00:00.125Z"
        //             }
        //         ]
        //     }
        //
        return this.safeNumber(response, "leverage");
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isEqual(getValue(parameters, "margin_balance"), null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair")) ;
        }
        object market = this.market(symbol);
        object amount = this.safeNumber(parameters, "margin_balance");
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 50);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " setLeverage() leverage should be between 1 and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "margin_balance", this.amountToPrecision(symbol, amount) },
        };
        return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc3#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://api.hitbtc.com/#currencies
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the hitbtc3 api endpoint
        * @returns {[object]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetPublicCurrency(parameters);
        //
        //     {
        //       "WEALTH": {
        //         "full_name": "ConnectWealth",
        //         "payin_enabled": false,
        //         "payout_enabled": false,
        //         "transfer_enabled": true,
        //         "precision_transfer": "0.001",
        //         "networks": [
        //           {
        //             "network": "ETH",
        //             "protocol": "ERC20",
        //             "default": true,
        //             "payin_enabled": false,
        //             "payout_enabled": false,
        //             "precision_payout": "0.001",
        //             "payout_fee": "0.016800000000",
        //             "payout_is_payment_id": false,
        //             "payin_payment_id": false,
        //             "payin_confirmations": "2"
        //           }
        //         ]
        //       }
        //     }
        //
        return this.parseDepositWithdrawFees(response, codes);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //         "full_name": "ConnectWealth",
        //         "payin_enabled": false,
        //         "payout_enabled": false,
        //         "transfer_enabled": true,
        //         "precision_transfer": "0.001",
        //         "networks": [
        //           {
        //             "network": "ETH",
        //             "protocol": "ERC20",
        //             "default": true,
        //             "payin_enabled": false,
        //             "payout_enabled": false,
        //             "precision_payout": "0.001",
        //             "payout_fee": "0.016800000000",
        //             "payout_is_payment_id": false,
        //             "payin_payment_id": false,
        //             "payin_confirmations": "2"
        //           }
        //         ]
        //    }
        //
        object networks = this.safeValue(fee, "networks", new List<object>() {});
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
        {
            object networkEntry = getValue(networks, j);
            object networkId = this.safeString(networkEntry, "network");
            object networkCode = this.networkIdToCode(networkId);
            object withdrawFee = this.safeNumber(networkEntry, "payout_fee");
            object isDefault = this.safeValue(networkEntry, "default");
            object withdrawResult = new Dictionary<string, object>() {
                { "fee", withdrawFee },
                { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
            };
            if (isTrue(isEqual(isDefault, true)))
            {
                ((Dictionary<string, object>)result)["withdraw"] = withdrawResult;
            }
            ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", withdrawResult },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return result;
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[string|undefined, object]} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeValue(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(!isEqual(marginMode, "isolated")))
            {
                throw new NotSupported ((string)add(this.id, " only isolated margin is supported")) ;
            }
        } else
        {
            if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
            {
                marginMode = "isolated";
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        //
        //     {
        //       "error": {
        //         "code": 20001,
        //         "message": "Insufficient funds",
        //         "description": "Check that the funds are sufficient, given commissions"
        //       }
        //     }
        //
        //     {
        //       "error": {
        //         "code": "600",
        //         "message": "Action not allowed"
        //       }
        //     }
        //
        object error = this.safeValue(response, "error");
        object errorCode = this.safeString(error, "code");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString2(error, "message", "description");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object implodedPath = this.implodeParams(path, parameters);
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), implodedPath);
        object getRequest = null;
        object keys = new List<object>(((Dictionary<string,object>)query).Keys);
        object queryLength = getArrayLength(keys);
        headers = new Dictionary<string, object>() {
            { "Content-Type", "application/json" },
        };
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(queryLength))
            {
                getRequest = add("?", this.urlencode(query));
                url = add(url, getRequest);
            }
        } else
        {
            body = this.json(parameters);
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            object payload = new List<object>() {method, add("/api/3/", implodedPath)};
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(!isEqual(getRequest, null)))
                {
                    ((List<object>)payload).Add(getRequest);
                }
            } else
            {
                ((List<object>)payload).Add(body);
            }
            ((List<object>)payload).Add(timestamp);
            object payloadString = String.Join("", ((List<object>)payload).ToArray());
            object signature = this.hmac(this.encode(payloadString), this.encode(this.secret), sha256, "hex");
            object secondPayload = add(add(add(add(this.apiKey, ":"), signature), ":"), timestamp);
            object encoded = this.stringToBase64(secondPayload);
            ((Dictionary<string, object>)headers)["Authorization"] = add("HS256 ", encoded);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
