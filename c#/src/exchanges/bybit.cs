using Main;
namespace Main;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bybit : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bybit" },
            { "name", "Bybit" },
            { "countries", new List<object>() {"VG"} },
            { "version", "v5" },
            { "userAgent", null },
            { "rateLimit", 20 },
            { "hostname", "bybit.com" },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchLedger", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "3m", "3" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "1h", "60" },
                { "2h", "120" },
                { "4h", "240" },
                { "6h", "360" },
                { "12h", "720" },
                { "1d", "D" },
                { "1w", "W" },
                { "1M", "M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "spot", "https://api-testnet.{hostname}" },
                    { "futures", "https://api-testnet.{hostname}" },
                    { "v2", "https://api-testnet.{hostname}" },
                    { "public", "https://api-testnet.{hostname}" },
                    { "private", "https://api-testnet.{hostname}" },
                } },
                { "logo", "https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api.{hostname}" },
                    { "futures", "https://api.{hostname}" },
                    { "v2", "https://api.{hostname}" },
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "www", "https://www.bybit.com" },
                { "doc", new List<object>() {"https://bybit-exchange.github.io/docs/inverse/", "https://bybit-exchange.github.io/docs/linear/", "https://github.com/bybit-exchange"} },
                { "fees", "https://help.bybit.com/hc/en-us/articles/360039261154" },
                { "referral", "https://www.bybit.com/register?affiliate_id=35953" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v2/public/orderBook/L2", 1 },
                        { "v2/public/kline/list", 3 },
                        { "v2/public/tickers", 1 },
                        { "v2/public/trading-records", 1 },
                        { "v2/public/symbols", 1 },
                        { "v2/public/mark-price-kline", 3 },
                        { "v2/public/index-price-kline", 3 },
                        { "v2/public/premium-index-kline", 2 },
                        { "v2/public/open-interest", 1 },
                        { "v2/public/big-deal", 1 },
                        { "v2/public/account-ratio", 1 },
                        { "v2/public/funding-rate", 1 },
                        { "v2/public/elite-ratio", 1 },
                        { "v2/public/funding/prev-funding-rate", 1 },
                        { "v2/public/risk-limit/list", 1 },
                        { "public/linear/kline", 3 },
                        { "public/linear/recent-trading-records", 1 },
                        { "public/linear/risk-limit", 1 },
                        { "public/linear/funding/prev-funding-rate", 1 },
                        { "public/linear/mark-price-kline", 1 },
                        { "public/linear/index-price-kline", 1 },
                        { "public/linear/premium-index-kline", 1 },
                        { "spot/v1/time", 1 },
                        { "spot/v1/symbols", 1 },
                        { "spot/quote/v1/depth", 1 },
                        { "spot/quote/v1/depth/merged", 1 },
                        { "spot/quote/v1/trades", 1 },
                        { "spot/quote/v1/kline", 1 },
                        { "spot/quote/v1/ticker/24hr", 1 },
                        { "spot/quote/v1/ticker/price", 1 },
                        { "spot/quote/v1/ticker/book_ticker", 1 },
                        { "spot/v3/public/symbols", 1 },
                        { "spot/v3/public/quote/depth", 1 },
                        { "spot/v3/public/quote/depth/merged", 1 },
                        { "spot/v3/public/quote/trades", 1 },
                        { "spot/v3/public/quote/kline", 1 },
                        { "spot/v3/public/quote/ticker/24hr", 1 },
                        { "spot/v3/public/quote/ticker/price", 1 },
                        { "spot/v3/public/quote/ticker/bookTicker", 1 },
                        { "spot/v3/public/server-time", 1 },
                        { "spot/v3/public/infos", 1 },
                        { "v2/public/time", 1 },
                        { "v3/public/time", 1 },
                        { "v2/public/announcement", 1 },
                        { "option/usdc/openapi/public/v1/order-book", 1 },
                        { "option/usdc/openapi/public/v1/symbols", 1 },
                        { "option/usdc/openapi/public/v1/tick", 1 },
                        { "option/usdc/openapi/public/v1/delivery-price", 1 },
                        { "option/usdc/openapi/public/v1/query-trade-latest", 1 },
                        { "option/usdc/openapi/public/v1/query-historical-volatility", 1 },
                        { "option/usdc/openapi/public/v1/all-tickers", 1 },
                        { "perpetual/usdc/openapi/public/v1/order-book", 1 },
                        { "perpetual/usdc/openapi/public/v1/symbols", 1 },
                        { "perpetual/usdc/openapi/public/v1/tick", 1 },
                        { "perpetual/usdc/openapi/public/v1/kline/list", 1 },
                        { "perpetual/usdc/openapi/public/v1/mark-price-kline", 1 },
                        { "perpetual/usdc/openapi/public/v1/index-price-kline", 1 },
                        { "perpetual/usdc/openapi/public/v1/premium-index-kline", 1 },
                        { "perpetual/usdc/openapi/public/v1/open-interest", 1 },
                        { "perpetual/usdc/openapi/public/v1/big-deal", 1 },
                        { "perpetual/usdc/openapi/public/v1/account-ratio", 1 },
                        { "perpetual/usdc/openapi/public/v1/prev-funding-rate", 1 },
                        { "perpetual/usdc/openapi/public/v1/risk-limit/list", 1 },
                        { "asset/v1/public/deposit/allowed-deposit-list", 1 },
                        { "contract/v3/public/copytrading/symbol/list", 1 },
                        { "derivatives/v3/public/order-book/L2", 1 },
                        { "derivatives/v3/public/kline", 1 },
                        { "derivatives/v3/public/tickers", 1 },
                        { "derivatives/v3/public/instruments-info", 1 },
                        { "derivatives/v3/public/mark-price-kline", 1 },
                        { "derivatives/v3/public/index-price-kline", 1 },
                        { "derivatives/v3/public/funding/history-funding-rate", 1 },
                        { "derivatives/v3/public/risk-limit/list", 1 },
                        { "derivatives/v3/public/delivery-price", 1 },
                        { "derivatives/v3/public/recent-trade", 1 },
                        { "derivatives/v3/public/open-interest", 1 },
                        { "derivatives/v3/public/insurance", 1 },
                        { "v5/market/kline", 1 },
                        { "v5/market/mark-price-kline", 1 },
                        { "v5/market/index-price-kline", 1 },
                        { "v5/market/premium-index-price-kline", 1 },
                        { "v5/market/instruments-info", 1 },
                        { "v5/market/orderbook", 1 },
                        { "v5/market/tickers", 1 },
                        { "v5/market/funding/history", 1 },
                        { "v5/market/recent-trade", 1 },
                        { "v5/market/open-interest", 1 },
                        { "v5/market/historical-volatility", 1 },
                        { "v5/market/insurance", 1 },
                        { "v5/market/risk-limit", 1 },
                        { "v5/market/delivery-price", 1 },
                        { "v5/spot-lever-token/info", 1 },
                        { "v5/spot-lever-token/reference", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v2/private/order/list", 5 },
                        { "v2/private/order", 5 },
                        { "v2/private/stop-order/list", 5 },
                        { "v2/private/stop-order", 1 },
                        { "v2/private/position/list", 25 },
                        { "v2/private/position/fee-rate", 40 },
                        { "v2/private/execution/list", 25 },
                        { "v2/private/trade/closed-pnl/list", 1 },
                        { "v2/public/risk-limit/list", 1 },
                        { "v2/public/funding/prev-funding-rate", 25 },
                        { "v2/private/funding/prev-funding", 25 },
                        { "v2/private/funding/predicted-funding", 25 },
                        { "v2/private/account/api-key", 5 },
                        { "v2/private/account/lcp", 1 },
                        { "v2/private/wallet/balance", 25 },
                        { "v2/private/wallet/fund/records", 25 },
                        { "v2/private/wallet/withdraw/list", 25 },
                        { "v2/private/exchange-order/list", 1 },
                        { "private/linear/order/list", 5 },
                        { "private/linear/order/search", 5 },
                        { "private/linear/stop-order/list", 5 },
                        { "private/linear/stop-order/search", 5 },
                        { "private/linear/position/list", 25 },
                        { "private/linear/trade/execution/list", 25 },
                        { "private/linear/trade/closed-pnl/list", 25 },
                        { "public/linear/risk-limit", 1 },
                        { "private/linear/funding/predicted-funding", 25 },
                        { "private/linear/funding/prev-funding", 25 },
                        { "futures/private/order/list", 5 },
                        { "futures/private/order", 5 },
                        { "futures/private/stop-order/list", 5 },
                        { "futures/private/stop-order", 5 },
                        { "futures/private/position/list", 25 },
                        { "futures/private/execution/list", 25 },
                        { "futures/private/trade/closed-pnl/list", 1 },
                        { "spot/v1/account", 2.5 },
                        { "spot/v1/order", 2.5 },
                        { "spot/v1/open-orders", 2.5 },
                        { "spot/v1/history-orders", 2.5 },
                        { "spot/v1/myTrades", 2.5 },
                        { "spot/v1/cross-margin/order", 10 },
                        { "spot/v1/cross-margin/accounts/balance", 10 },
                        { "spot/v1/cross-margin/loan-info", 10 },
                        { "spot/v1/cross-margin/repay/history", 10 },
                        { "spot/v3/private/order", 2.5 },
                        { "spot/v3/private/open-orders", 2.5 },
                        { "spot/v3/private/history-orders", 2.5 },
                        { "spot/v3/private/my-trades", 2.5 },
                        { "spot/v3/private/account", 2.5 },
                        { "spot/v3/private/reference", 2.5 },
                        { "spot/v3/private/record", 2.5 },
                        { "spot/v3/private/cross-margin-orders", 10 },
                        { "spot/v3/private/cross-margin-account", 10 },
                        { "spot/v3/private/cross-margin-loan-info", 10 },
                        { "spot/v3/private/cross-margin-repay-history", 10 },
                        { "asset/v1/private/transfer/list", 50 },
                        { "asset/v3/private/transfer/inter-transfer/list/query", 0.84 },
                        { "asset/v1/private/sub-member/transfer/list", 50 },
                        { "asset/v3/private/transfer/sub-member/list/query", 0.84 },
                        { "asset/v3/private/transfer/sub-member-transfer/list/query", 0.84 },
                        { "asset/v3/private/transfer/universal-transfer/list/query", 0.84 },
                        { "asset/v1/private/sub-member/member-ids", 50 },
                        { "asset/v1/private/deposit/record/query", 50 },
                        { "asset/v1/private/withdraw/record/query", 25 },
                        { "asset/v1/private/coin-info/query", 25 },
                        { "asset/v3/private/coin-info/query", 25 },
                        { "asset/v1/private/asset-info/query", 50 },
                        { "asset/v1/private/deposit/address", 100 },
                        { "asset/v3/private/deposit/address/query", 0.17 },
                        { "asset/v1/private/universal/transfer/list", 50 },
                        { "contract/v3/private/copytrading/order/list", 1 },
                        { "contract/v3/private/copytrading/position/list", 1 },
                        { "contract/v3/private/copytrading/wallet/balance", 1 },
                        { "contract/v3/private/position/limit-info", 25 },
                        { "contract/v3/private/order/unfilled-orders", 1 },
                        { "contract/v3/private/order/list", 1 },
                        { "contract/v3/private/position/list", 1 },
                        { "contract/v3/private/execution/list", 1 },
                        { "contract/v3/private/position/closed-pnl", 1 },
                        { "contract/v3/private/account/wallet/balance", 1 },
                        { "contract/v3/private/account/fee-rate", 1 },
                        { "contract/v3/private/account/wallet/fund-records", 1 },
                        { "unified/v3/private/order/unfilled-orders", 1 },
                        { "unified/v3/private/order/list", 1 },
                        { "unified/v3/private/position/list", 1 },
                        { "unified/v3/private/execution/list", 1 },
                        { "unified/v3/private/delivery-record", 1 },
                        { "unified/v3/private/settlement-record", 1 },
                        { "unified/v3/private/account/wallet/balance", 1 },
                        { "unified/v3/private/account/transaction-log", 1 },
                        { "asset/v2/private/exchange/exchange-order-all", 1 },
                        { "unified/v3/private/account/borrow-history", 1 },
                        { "unified/v3/private/account/borrow-rate", 1 },
                        { "unified/v3/private/account/info", 1 },
                        { "user/v3/private/frozen-sub-member", 10 },
                        { "user/v3/private/query-sub-members", 5 },
                        { "user/v3/private/query-api", 5 },
                        { "asset/v3/private/transfer/transfer-coin/list/query", 0.84 },
                        { "asset/v3/private/transfer/account-coin/balance/query", 0.84 },
                        { "asset/v3/private/transfer/account-coins/balance/query", 50 },
                        { "asset/v3/private/transfer/asset-info/query", 0.84 },
                        { "asset/v3/public/deposit/allowed-deposit-list/query", 0.17 },
                        { "asset/v3/private/deposit/record/query", 0.17 },
                        { "asset/v3/private/withdraw/record/query", 0.17 },
                        { "v5/order/history", 2.5 },
                        { "v5/order/spot-borrow-check", 2.5 },
                        { "v5/order/realtime", 2.5 },
                        { "v5/position/list", 2.5 },
                        { "v5/execution/list", 2.5 },
                        { "v5/position/closed-pnl", 2.5 },
                        { "v5/account/wallet-balance", 2.5 },
                        { "v5/account/borrow-history", 2.5 },
                        { "v5/account/collateral-info", 2.5 },
                        { "v5/account/mmp-state", 2.5 },
                        { "v5/asset/coin-greeks", 2.5 },
                        { "v5/account/info", 2.5 },
                        { "v5/account/transaction-log", 2.5 },
                        { "v5/account/fee-rate", 1 },
                        { "v5/asset/exchange/order-record", 2.5 },
                        { "v5/asset/delivery-record", 2.5 },
                        { "v5/asset/settlement-record", 2.5 },
                        { "v5/asset/transfer/query-asset-info", 2.5 },
                        { "v5/asset/transfer/query-account-coin-balance", 2.5 },
                        { "v5/asset/transfer/query-transfer-coin-list", 2.5 },
                        { "v5/asset/transfer/query-inter-transfer-list", 2.5 },
                        { "v5/asset/transfer/query-sub-member-list", 2.5 },
                        { "v5/asset/transfer/query-universal-transfer-list", 1 },
                        { "v5/asset/deposit/query-allowed-list", 2.5 },
                        { "v5/asset/deposit/query-record", 2.5 },
                        { "v5/asset/deposit/query-sub-member-record", 2.5 },
                        { "v5/asset/deposit/query-address", 2.5 },
                        { "v5/asset/deposit/query-sub-member-address", 2.5 },
                        { "v5/asset/deposit/query-internal-record", 2.5 },
                        { "v5/asset/coin/query-info", 2.5 },
                        { "v5/asset/withdraw/query-record", 2.5 },
                        { "v5/asset/withdraw/withdrawable-amount", 2.5 },
                        { "v5/asset/transfer/query-account-coins-balance", 2.5 },
                        { "v5/user/query-sub-members", 10 },
                        { "v5/user/query-api", 10 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "v2/private/order/create", 30 },
                        { "v2/private/order/cancel", 30 },
                        { "v2/private/order/cancelAll", 300 },
                        { "v2/private/order/replace", 30 },
                        { "v2/private/stop-order/create", 30 },
                        { "v2/private/stop-order/cancel", 30 },
                        { "v2/private/stop-order/cancelAll", 300 },
                        { "v2/private/stop-order/replace", 30 },
                        { "v2/private/position/change-position-margin", 40 },
                        { "v2/private/position/trading-stop", 40 },
                        { "v2/private/position/leverage/save", 40 },
                        { "v2/private/tpsl/switch-mode", 40 },
                        { "v2/private/position/switch-isolated", 2.5 },
                        { "v2/private/position/risk-limit", 2.5 },
                        { "v2/private/position/switch-mode", 2.5 },
                        { "private/linear/order/create", 30 },
                        { "private/linear/order/cancel", 30 },
                        { "private/linear/order/cancel-all", 300 },
                        { "private/linear/order/replace", 30 },
                        { "private/linear/stop-order/create", 30 },
                        { "private/linear/stop-order/cancel", 30 },
                        { "private/linear/stop-order/cancel-all", 300 },
                        { "private/linear/stop-order/replace", 30 },
                        { "private/linear/position/set-auto-add-margin", 40 },
                        { "private/linear/position/switch-isolated", 40 },
                        { "private/linear/position/switch-mode", 40 },
                        { "private/linear/tpsl/switch-mode", 2.5 },
                        { "private/linear/position/add-margin", 40 },
                        { "private/linear/position/set-leverage", 40 },
                        { "private/linear/position/trading-stop", 40 },
                        { "private/linear/position/set-risk", 2.5 },
                        { "futures/private/order/create", 30 },
                        { "futures/private/order/cancel", 30 },
                        { "futures/private/order/cancelAll", 30 },
                        { "futures/private/order/replace", 30 },
                        { "futures/private/stop-order/create", 30 },
                        { "futures/private/stop-order/cancel", 30 },
                        { "futures/private/stop-order/cancelAll", 30 },
                        { "futures/private/stop-order/replace", 30 },
                        { "futures/private/position/change-position-margin", 40 },
                        { "futures/private/position/trading-stop", 40 },
                        { "futures/private/position/leverage/save", 40 },
                        { "futures/private/position/switch-mode", 40 },
                        { "futures/private/tpsl/switch-mode", 40 },
                        { "futures/private/position/switch-isolated", 40 },
                        { "futures/private/position/risk-limit", 2.5 },
                        { "spot/v1/order", 2.5 },
                        { "spot/v1/cross-margin/loan", 10 },
                        { "spot/v1/cross-margin/repay", 10 },
                        { "spot/v3/private/order", 2.5 },
                        { "spot/v3/private/cancel-order", 2.5 },
                        { "spot/v3/private/cancel-orders", 2.5 },
                        { "spot/v3/private/cancel-orders-by-ids", 2.5 },
                        { "spot/v3/private/purchase", 2.5 },
                        { "spot/v3/private/redeem", 2.5 },
                        { "spot/v3/private/cross-margin-loan", 10 },
                        { "spot/v3/private/cross-margin-repay", 10 },
                        { "asset/v1/private/transfer", 150 },
                        { "asset/v3/private/transfer/inter-transfer", 2.5 },
                        { "asset/v1/private/sub-member/transfer", 150 },
                        { "asset/v1/private/withdraw", 50 },
                        { "asset/v3/private/withdraw/create", 1 },
                        { "asset/v1/private/withdraw/cancel", 50 },
                        { "asset/v3/private/withdraw/cancel", 0.84 },
                        { "asset/v1/private/transferable-subs/save", 3000 },
                        { "asset/v1/private/universal/transfer", 1500 },
                        { "asset/v3/private/transfer/sub-member-transfer", 2.5 },
                        { "asset/v3/private/transfer/transfer-sub-member-save", 2.5 },
                        { "asset/v3/private/transfer/universal-transfer", 2.5 },
                        { "user/v3/private/create-sub-member", 10 },
                        { "user/v3/private/create-sub-api", 10 },
                        { "user/v3/private/update-api", 10 },
                        { "user/v3/private/delete-api", 10 },
                        { "user/v3/private/update-sub-api", 10 },
                        { "user/v3/private/delete-sub-api", 10 },
                        { "option/usdc/openapi/private/v1/place-order", 2.5 },
                        { "option/usdc/openapi/private/v1/batch-place-order", 2.5 },
                        { "option/usdc/openapi/private/v1/replace-order", 2.5 },
                        { "option/usdc/openapi/private/v1/batch-replace-orders", 2.5 },
                        { "option/usdc/openapi/private/v1/cancel-order", 2.5 },
                        { "option/usdc/openapi/private/v1/batch-cancel-orders", 2.5 },
                        { "option/usdc/openapi/private/v1/cancel-all", 2.5 },
                        { "option/usdc/openapi/private/v1/query-active-orders", 2.5 },
                        { "option/usdc/openapi/private/v1/query-order-history", 2.5 },
                        { "option/usdc/openapi/private/v1/execution-list", 2.5 },
                        { "option/usdc/openapi/private/v1/query-transaction-log", 2.5 },
                        { "option/usdc/openapi/private/v1/query-wallet-balance", 2.5 },
                        { "option/usdc/openapi/private/v1/query-asset-info", 2.5 },
                        { "option/usdc/openapi/private/v1/query-margin-info", 2.5 },
                        { "option/usdc/openapi/private/v1/query-position", 2.5 },
                        { "option/usdc/openapi/private/v1/query-delivery-list", 2.5 },
                        { "option/usdc/openapi/private/v1/query-position-exp-date", 2.5 },
                        { "option/usdc/openapi/private/v1/mmp-modify", 2.5 },
                        { "option/usdc/openapi/private/v1/mmp-reset", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/place-order", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/replace-order", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/cancel-order", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/cancel-all", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/position/leverage/save", 2.5 },
                        { "option/usdc/openapi/private/v1/session-settlement", 2.5 },
                        { "option/usdc/private/asset/account/setMarginMode", 2.5 },
                        { "perpetual/usdc/openapi/public/v1/risk-limit/list", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/position/set-risk-limit", 2.5 },
                        { "perpetual/usdc/openapi/private/v1/predicted-funding", 2.5 },
                        { "contract/v3/private/copytrading/order/create", 2.5 },
                        { "contract/v3/private/copytrading/order/cancel", 2.5 },
                        { "contract/v3/private/copytrading/order/close", 2.5 },
                        { "contract/v3/private/copytrading/position/close", 2.5 },
                        { "contract/v3/private/copytrading/position/set-leverage", 2.5 },
                        { "contract/v3/private/copytrading/wallet/transfer", 2.5 },
                        { "contract/v3/private/copytrading/order/trading-stop", 2.5 },
                        { "contract/v3/private/order/create", 1 },
                        { "contract/v3/private/order/cancel", 1 },
                        { "contract/v3/private/order/cancel-all", 1 },
                        { "contract/v3/private/order/replace", 1 },
                        { "contract/v3/private/position/set-auto-add-margin", 1 },
                        { "contract/v3/private/position/switch-isolated", 1 },
                        { "contract/v3/private/position/switch-mode", 1 },
                        { "contract/v3/private/position/switch-tpsl-mode", 1 },
                        { "contract/v3/private/position/set-leverage", 1 },
                        { "contract/v3/private/position/trading-stop", 1 },
                        { "contract/v3/private/position/set-risk-limit", 1 },
                        { "contract/v3/private/account/setMarginMode", 1 },
                        { "unified/v3/private/order/create", 2.5 },
                        { "unified/v3/private/order/replace", 2.5 },
                        { "unified/v3/private/order/cancel", 2.5 },
                        { "unified/v3/private/order/create-batch", 2.5 },
                        { "unified/v3/private/order/replace-batch", 2.5 },
                        { "unified/v3/private/order/cancel-batch", 2.5 },
                        { "unified/v3/private/order/cancel-all", 2.5 },
                        { "unified/v3/private/position/set-leverage", 2.5 },
                        { "unified/v3/private/position/tpsl/switch-mode", 2.5 },
                        { "unified/v3/private/position/set-risk-limit", 2.5 },
                        { "unified/v3/private/position/trading-stop", 2.5 },
                        { "unified/v3/private/account/upgrade-unified-account", 2.5 },
                        { "unified/v3/private/account/setMarginMode", 2.5 },
                        { "fht/compliance/tax/v3/private/registertime", 50 },
                        { "fht/compliance/tax/v3/private/create", 50 },
                        { "fht/compliance/tax/v3/private/status", 50 },
                        { "fht/compliance/tax/v3/private/url", 50 },
                        { "v5/order/create", 2.5 },
                        { "v5/order/amend", 2.5 },
                        { "v5/order/cancel", 2.5 },
                        { "v5/order/cancel-all", 2.5 },
                        { "v5/order/create-batch", 2.5 },
                        { "v5/order/amend-batch", 2.5 },
                        { "v5/order/cancel-batch", 2.5 },
                        { "v5/order/disconnected-cancel-all", 2.5 },
                        { "v5/position/set-leverage", 2.5 },
                        { "v5/position/set-tpsl-mode", 2.5 },
                        { "v5/position/set-risk-limit", 2.5 },
                        { "v5/position/trading-stop", 2.5 },
                        { "v5/account/upgrade-to-uta", 2.5 },
                        { "v5/account/set-margin-mode", 2.5 },
                        { "v5/asset/transfer/inter-transfer", 2.5 },
                        { "v5/asset/transfer/save-transfer-sub-member", 2.5 },
                        { "v5/asset/transfer/universal-transfer", 2.5 },
                        { "v5/asset/deposit/deposit-to-account", 2.5 },
                        { "v5/asset/withdraw/create", 2.5 },
                        { "v5/asset/withdraw/cancel", 2.5 },
                        { "v5/spot-lever-token/purchase", 2.5 },
                        { "v5/spot-lever-token/redeem", 2.5 },
                        { "v5/spot-lever-token/order-record", 2.5 },
                        { "v5/spot-margin-trade/switch-mode", 2.5 },
                        { "v5/spot-margin-trade/set-leverage", 2.5 },
                        { "v5/user/create-sub-member", 10 },
                        { "v5/user/create-sub-api", 10 },
                        { "v5/user/frozen-sub-member", 10 },
                        { "v5/user/update-api", 10 },
                        { "v5/user/update-sub-api", 10 },
                        { "v5/user/delete-api", 10 },
                        { "v5/user/delete-sub-api", 10 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "spot/v1/order", 2.5 },
                        { "spot/v1/order/fast", 2.5 },
                        { "spot/order/batch-cancel", 2.5 },
                        { "spot/order/batch-fast-cancel", 2.5 },
                        { "spot/order/batch-cancel-by-ids", 2.5 },
                    } },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "403", typeof(RateLimitExceeded) },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-10009", typeof(BadRequest) },
                    { "-1004", typeof(BadRequest) },
                    { "-1021", typeof(BadRequest) },
                    { "-1103", typeof(BadRequest) },
                    { "-1140", typeof(InvalidOrder) },
                    { "-1197", typeof(InvalidOrder) },
                    { "-2013", typeof(InvalidOrder) },
                    { "-2015", typeof(AuthenticationError) },
                    { "-6017", typeof(BadRequest) },
                    { "-6025", typeof(BadRequest) },
                    { "-6029", typeof(BadRequest) },
                    { "5004", typeof(ExchangeError) },
                    { "7001", typeof(BadRequest) },
                    { "10001", typeof(BadRequest) },
                    { "10002", typeof(InvalidNonce) },
                    { "10003", typeof(AuthenticationError) },
                    { "10004", typeof(AuthenticationError) },
                    { "10005", typeof(PermissionDenied) },
                    { "10006", typeof(RateLimitExceeded) },
                    { "10007", typeof(AuthenticationError) },
                    { "10008", typeof(AuthenticationError) },
                    { "10009", typeof(AuthenticationError) },
                    { "10010", typeof(PermissionDenied) },
                    { "10014", typeof(BadRequest) },
                    { "10016", typeof(ExchangeError) },
                    { "10017", typeof(BadRequest) },
                    { "10018", typeof(RateLimitExceeded) },
                    { "10020", typeof(PermissionDenied) },
                    { "10024", typeof(PermissionDenied) },
                    { "10027", typeof(PermissionDenied) },
                    { "10028", typeof(PermissionDenied) },
                    { "10029", typeof(PermissionDenied) },
                    { "12201", typeof(BadRequest) },
                    { "100028", typeof(PermissionDenied) },
                    { "110001", typeof(InvalidOrder) },
                    { "110003", typeof(InvalidOrder) },
                    { "110004", typeof(InsufficientFunds) },
                    { "110005", typeof(InvalidOrder) },
                    { "110006", typeof(InsufficientFunds) },
                    { "110007", typeof(InsufficientFunds) },
                    { "110008", typeof(InvalidOrder) },
                    { "110009", typeof(InvalidOrder) },
                    { "110010", typeof(InvalidOrder) },
                    { "110011", typeof(InvalidOrder) },
                    { "110012", typeof(InsufficientFunds) },
                    { "110013", typeof(BadRequest) },
                    { "110014", typeof(InsufficientFunds) },
                    { "110015", typeof(BadRequest) },
                    { "110016", typeof(InvalidOrder) },
                    { "110017", typeof(InvalidOrder) },
                    { "110018", typeof(BadRequest) },
                    { "110019", typeof(InvalidOrder) },
                    { "110020", typeof(InvalidOrder) },
                    { "110021", typeof(InvalidOrder) },
                    { "110022", typeof(InvalidOrder) },
                    { "110023", typeof(InvalidOrder) },
                    { "110024", typeof(InvalidOrder) },
                    { "110025", typeof(InvalidOrder) },
                    { "110026", typeof(InvalidOrder) },
                    { "110027", typeof(InvalidOrder) },
                    { "110028", typeof(InvalidOrder) },
                    { "110029", typeof(InvalidOrder) },
                    { "110030", typeof(InvalidOrder) },
                    { "110031", typeof(InvalidOrder) },
                    { "110032", typeof(InvalidOrder) },
                    { "110033", typeof(InvalidOrder) },
                    { "110034", typeof(InvalidOrder) },
                    { "110035", typeof(InvalidOrder) },
                    { "110036", typeof(InvalidOrder) },
                    { "110037", typeof(InvalidOrder) },
                    { "110038", typeof(InvalidOrder) },
                    { "110039", typeof(InvalidOrder) },
                    { "110040", typeof(InvalidOrder) },
                    { "110041", typeof(InvalidOrder) },
                    { "110042", typeof(InvalidOrder) },
                    { "110043", typeof(BadRequest) },
                    { "110044", typeof(InsufficientFunds) },
                    { "110045", typeof(InsufficientFunds) },
                    { "110046", typeof(BadRequest) },
                    { "110047", typeof(BadRequest) },
                    { "110048", typeof(BadRequest) },
                    { "110049", typeof(BadRequest) },
                    { "110050", typeof(BadRequest) },
                    { "110051", typeof(InsufficientFunds) },
                    { "110052", typeof(InsufficientFunds) },
                    { "110053", typeof(InsufficientFunds) },
                    { "110054", typeof(InvalidOrder) },
                    { "110055", typeof(InvalidOrder) },
                    { "110056", typeof(InvalidOrder) },
                    { "110057", typeof(InvalidOrder) },
                    { "110058", typeof(InvalidOrder) },
                    { "110059", typeof(InvalidOrder) },
                    { "110060", typeof(BadRequest) },
                    { "110061", typeof(BadRequest) },
                    { "110062", typeof(BadRequest) },
                    { "110063", typeof(ExchangeError) },
                    { "110064", typeof(InvalidOrder) },
                    { "110065", typeof(PermissionDenied) },
                    { "110066", typeof(ExchangeError) },
                    { "110067", typeof(PermissionDenied) },
                    { "110068", typeof(PermissionDenied) },
                    { "110069", typeof(PermissionDenied) },
                    { "110070", typeof(InvalidOrder) },
                    { "110071", typeof(ExchangeError) },
                    { "110072", typeof(InvalidOrder) },
                    { "110073", typeof(ExchangeError) },
                    { "130006", typeof(InvalidOrder) },
                    { "130021", typeof(InsufficientFunds) },
                    { "130074", typeof(InvalidOrder) },
                    { "131001", typeof(InsufficientFunds) },
                    { "131084", typeof(ExchangeError) },
                    { "131200", typeof(ExchangeError) },
                    { "131201", typeof(ExchangeError) },
                    { "131202", typeof(BadRequest) },
                    { "131203", typeof(BadRequest) },
                    { "131204", typeof(BadRequest) },
                    { "131205", typeof(BadRequest) },
                    { "131206", typeof(ExchangeError) },
                    { "131207", typeof(BadRequest) },
                    { "131208", typeof(ExchangeError) },
                    { "131209", typeof(BadRequest) },
                    { "131210", typeof(BadRequest) },
                    { "131211", typeof(BadRequest) },
                    { "131212", typeof(InsufficientFunds) },
                    { "131213", typeof(BadRequest) },
                    { "131214", typeof(BadRequest) },
                    { "131215", typeof(BadRequest) },
                    { "131216", typeof(ExchangeError) },
                    { "131217", typeof(ExchangeError) },
                    { "131002", typeof(BadRequest) },
                    { "131003", typeof(ExchangeError) },
                    { "131004", typeof(AuthenticationError) },
                    { "131085", typeof(InsufficientFunds) },
                    { "131086", typeof(BadRequest) },
                    { "131088", typeof(BadRequest) },
                    { "131089", typeof(BadRequest) },
                    { "131090", typeof(ExchangeError) },
                    { "131091", typeof(ExchangeError) },
                    { "131092", typeof(ExchangeError) },
                    { "131093", typeof(ExchangeError) },
                    { "131094", typeof(BadRequest) },
                    { "131095", typeof(BadRequest) },
                    { "131096", typeof(BadRequest) },
                    { "131097", typeof(ExchangeError) },
                    { "131098", typeof(ExchangeError) },
                    { "131099", typeof(ExchangeError) },
                    { "140003", typeof(InvalidOrder) },
                    { "140004", typeof(InsufficientFunds) },
                    { "140005", typeof(InvalidOrder) },
                    { "140006", typeof(InsufficientFunds) },
                    { "140007", typeof(InsufficientFunds) },
                    { "140008", typeof(InvalidOrder) },
                    { "140009", typeof(InvalidOrder) },
                    { "140010", typeof(InvalidOrder) },
                    { "140011", typeof(InvalidOrder) },
                    { "140012", typeof(InsufficientFunds) },
                    { "140013", typeof(BadRequest) },
                    { "140014", typeof(InsufficientFunds) },
                    { "140015", typeof(InvalidOrder) },
                    { "140016", typeof(InvalidOrder) },
                    { "140017", typeof(InvalidOrder) },
                    { "140018", typeof(BadRequest) },
                    { "140019", typeof(InvalidOrder) },
                    { "140020", typeof(InvalidOrder) },
                    { "140021", typeof(InvalidOrder) },
                    { "140022", typeof(InvalidOrder) },
                    { "140023", typeof(InvalidOrder) },
                    { "140024", typeof(BadRequest) },
                    { "140025", typeof(BadRequest) },
                    { "140026", typeof(BadRequest) },
                    { "140027", typeof(BadRequest) },
                    { "140028", typeof(InvalidOrder) },
                    { "140029", typeof(BadRequest) },
                    { "140030", typeof(InvalidOrder) },
                    { "140031", typeof(BadRequest) },
                    { "140032", typeof(InvalidOrder) },
                    { "140033", typeof(InvalidOrder) },
                    { "140034", typeof(InvalidOrder) },
                    { "140035", typeof(InvalidOrder) },
                    { "140036", typeof(BadRequest) },
                    { "140037", typeof(InvalidOrder) },
                    { "140038", typeof(BadRequest) },
                    { "140039", typeof(BadRequest) },
                    { "140040", typeof(InvalidOrder) },
                    { "140041", typeof(InvalidOrder) },
                    { "140042", typeof(InvalidOrder) },
                    { "140043", typeof(BadRequest) },
                    { "140044", typeof(InsufficientFunds) },
                    { "140045", typeof(InsufficientFunds) },
                    { "140046", typeof(BadRequest) },
                    { "140047", typeof(BadRequest) },
                    { "140048", typeof(BadRequest) },
                    { "140049", typeof(BadRequest) },
                    { "140050", typeof(InvalidOrder) },
                    { "140051", typeof(InsufficientFunds) },
                    { "140052", typeof(InsufficientFunds) },
                    { "140053", typeof(InsufficientFunds) },
                    { "140054", typeof(InvalidOrder) },
                    { "140055", typeof(InvalidOrder) },
                    { "140056", typeof(InvalidOrder) },
                    { "140057", typeof(InvalidOrder) },
                    { "140058", typeof(InvalidOrder) },
                    { "140059", typeof(InvalidOrder) },
                    { "140060", typeof(BadRequest) },
                    { "140061", typeof(BadRequest) },
                    { "140062", typeof(BadRequest) },
                    { "140063", typeof(ExchangeError) },
                    { "140064", typeof(InvalidOrder) },
                    { "140065", typeof(PermissionDenied) },
                    { "140066", typeof(ExchangeError) },
                    { "140067", typeof(PermissionDenied) },
                    { "140068", typeof(PermissionDenied) },
                    { "140069", typeof(PermissionDenied) },
                    { "140070", typeof(InvalidOrder) },
                    { "170001", typeof(ExchangeError) },
                    { "170007", typeof(RequestTimeout) },
                    { "170005", typeof(InvalidOrder) },
                    { "170031", typeof(ExchangeError) },
                    { "170032", typeof(ExchangeError) },
                    { "170033", typeof(InsufficientFunds) },
                    { "170034", typeof(InsufficientFunds) },
                    { "170035", typeof(BadRequest) },
                    { "170036", typeof(BadRequest) },
                    { "170037", typeof(BadRequest) },
                    { "170105", typeof(BadRequest) },
                    { "170115", typeof(InvalidOrder) },
                    { "170116", typeof(InvalidOrder) },
                    { "170117", typeof(InvalidOrder) },
                    { "170121", typeof(InvalidOrder) },
                    { "170130", typeof(BadRequest) },
                    { "170131", typeof(InsufficientFunds) },
                    { "170132", typeof(InvalidOrder) },
                    { "170133", typeof(InvalidOrder) },
                    { "170134", typeof(InvalidOrder) },
                    { "170135", typeof(InvalidOrder) },
                    { "170136", typeof(InvalidOrder) },
                    { "170137", typeof(InvalidOrder) },
                    { "170139", typeof(InvalidOrder) },
                    { "170140", typeof(InvalidOrder) },
                    { "170124", typeof(InvalidOrder) },
                    { "170141", typeof(InvalidOrder) },
                    { "170142", typeof(InvalidOrder) },
                    { "170143", typeof(InvalidOrder) },
                    { "170144", typeof(InvalidOrder) },
                    { "170145", typeof(InvalidOrder) },
                    { "170146", typeof(InvalidOrder) },
                    { "170147", typeof(InvalidOrder) },
                    { "170148", typeof(InvalidOrder) },
                    { "170149", typeof(ExchangeError) },
                    { "170150", typeof(ExchangeError) },
                    { "170151", typeof(InvalidOrder) },
                    { "170157", typeof(InvalidOrder) },
                    { "170159", typeof(InvalidOrder) },
                    { "170190", typeof(InvalidOrder) },
                    { "170191", typeof(InvalidOrder) },
                    { "170192", typeof(InvalidOrder) },
                    { "170193", typeof(InvalidOrder) },
                    { "170194", typeof(InvalidOrder) },
                    { "170195", typeof(InvalidOrder) },
                    { "170196", typeof(InvalidOrder) },
                    { "170197", typeof(InvalidOrder) },
                    { "170198", typeof(InvalidOrder) },
                    { "170199", typeof(InvalidOrder) },
                    { "170200", typeof(InvalidOrder) },
                    { "170221", typeof(BadRequest) },
                    { "170222", typeof(RateLimitExceeded) },
                    { "170223", typeof(InsufficientFunds) },
                    { "170224", typeof(PermissionDenied) },
                    { "170226", typeof(InsufficientFunds) },
                    { "170227", typeof(ExchangeError) },
                    { "170228", typeof(InvalidOrder) },
                    { "170229", typeof(InvalidOrder) },
                    { "170234", typeof(ExchangeError) },
                    { "170210", typeof(InvalidOrder) },
                    { "170213", typeof(OrderNotFound) },
                    { "170217", typeof(InvalidOrder) },
                    { "170218", typeof(InvalidOrder) },
                    { "170010", typeof(InvalidOrder) },
                    { "170011", typeof(InvalidOrder) },
                    { "170019", typeof(InvalidOrder) },
                    { "170201", typeof(PermissionDenied) },
                    { "170202", typeof(InvalidOrder) },
                    { "170203", typeof(InvalidOrder) },
                    { "170204", typeof(InvalidOrder) },
                    { "170206", typeof(InvalidOrder) },
                    { "175000", typeof(InvalidOrder) },
                    { "175001", typeof(InvalidOrder) },
                    { "175002", typeof(InvalidOrder) },
                    { "175003", typeof(InsufficientFunds) },
                    { "175004", typeof(InvalidOrder) },
                    { "175005", typeof(InvalidOrder) },
                    { "175006", typeof(InsufficientFunds) },
                    { "175007", typeof(InvalidOrder) },
                    { "175008", typeof(InvalidOrder) },
                    { "175009", typeof(InvalidOrder) },
                    { "175010", typeof(PermissionDenied) },
                    { "175012", typeof(InvalidOrder) },
                    { "175013", typeof(InvalidOrder) },
                    { "175014", typeof(InvalidOrder) },
                    { "175015", typeof(InvalidOrder) },
                    { "175016", typeof(InvalidOrder) },
                    { "175017", typeof(InvalidOrder) },
                    { "175027", typeof(ExchangeError) },
                    { "176002", typeof(BadRequest) },
                    { "176004", typeof(BadRequest) },
                    { "176003", typeof(BadRequest) },
                    { "176006", typeof(BadRequest) },
                    { "176005", typeof(BadRequest) },
                    { "176008", typeof(BadRequest) },
                    { "176007", typeof(BadRequest) },
                    { "176010", typeof(BadRequest) },
                    { "176009", typeof(BadRequest) },
                    { "176012", typeof(BadRequest) },
                    { "176011", typeof(BadRequest) },
                    { "176014", typeof(BadRequest) },
                    { "176013", typeof(BadRequest) },
                    { "176015", typeof(InsufficientFunds) },
                    { "176016", typeof(BadRequest) },
                    { "176017", typeof(BadRequest) },
                    { "176018", typeof(BadRequest) },
                    { "176019", typeof(BadRequest) },
                    { "176020", typeof(BadRequest) },
                    { "176021", typeof(BadRequest) },
                    { "176022", typeof(BadRequest) },
                    { "176023", typeof(BadRequest) },
                    { "176024", typeof(BadRequest) },
                    { "176025", typeof(BadRequest) },
                    { "176026", typeof(BadRequest) },
                    { "176027", typeof(BadRequest) },
                    { "176028", typeof(BadRequest) },
                    { "176029", typeof(BadRequest) },
                    { "176030", typeof(BadRequest) },
                    { "176031", typeof(BadRequest) },
                    { "176034", typeof(BadRequest) },
                    { "176035", typeof(PermissionDenied) },
                    { "176036", typeof(PermissionDenied) },
                    { "176037", typeof(PermissionDenied) },
                    { "176038", typeof(BadRequest) },
                    { "176039", typeof(BadRequest) },
                    { "176040", typeof(BadRequest) },
                    { "181000", typeof(BadRequest) },
                    { "181001", typeof(BadRequest) },
                    { "181002", typeof(InvalidOrder) },
                    { "181003", typeof(InvalidOrder) },
                    { "181004", typeof(InvalidOrder) },
                    { "182000", typeof(InvalidOrder) },
                    { "20001", typeof(OrderNotFound) },
                    { "20003", typeof(InvalidOrder) },
                    { "20004", typeof(InvalidOrder) },
                    { "20005", typeof(InvalidOrder) },
                    { "20006", typeof(InvalidOrder) },
                    { "20007", typeof(InvalidOrder) },
                    { "20008", typeof(InvalidOrder) },
                    { "20009", typeof(InvalidOrder) },
                    { "20010", typeof(InvalidOrder) },
                    { "20011", typeof(InvalidOrder) },
                    { "20012", typeof(InvalidOrder) },
                    { "20013", typeof(InvalidOrder) },
                    { "20014", typeof(InvalidOrder) },
                    { "20015", typeof(InvalidOrder) },
                    { "20016", typeof(InvalidOrder) },
                    { "20017", typeof(InvalidOrder) },
                    { "20018", typeof(InvalidOrder) },
                    { "20019", typeof(InvalidOrder) },
                    { "20020", typeof(InvalidOrder) },
                    { "20021", typeof(InvalidOrder) },
                    { "20022", typeof(BadRequest) },
                    { "20023", typeof(BadRequest) },
                    { "20031", typeof(BadRequest) },
                    { "20070", typeof(BadRequest) },
                    { "20071", typeof(BadRequest) },
                    { "20084", typeof(BadRequest) },
                    { "30001", typeof(BadRequest) },
                    { "30003", typeof(InvalidOrder) },
                    { "30004", typeof(InvalidOrder) },
                    { "30005", typeof(InvalidOrder) },
                    { "30007", typeof(InvalidOrder) },
                    { "30008", typeof(InvalidOrder) },
                    { "30009", typeof(ExchangeError) },
                    { "30010", typeof(InsufficientFunds) },
                    { "30011", typeof(PermissionDenied) },
                    { "30012", typeof(PermissionDenied) },
                    { "30013", typeof(PermissionDenied) },
                    { "30014", typeof(InvalidOrder) },
                    { "30015", typeof(InvalidOrder) },
                    { "30016", typeof(ExchangeError) },
                    { "30017", typeof(InvalidOrder) },
                    { "30018", typeof(InvalidOrder) },
                    { "30019", typeof(InvalidOrder) },
                    { "30020", typeof(InvalidOrder) },
                    { "30021", typeof(InvalidOrder) },
                    { "30022", typeof(InvalidOrder) },
                    { "30023", typeof(InvalidOrder) },
                    { "30024", typeof(InvalidOrder) },
                    { "30025", typeof(InvalidOrder) },
                    { "30026", typeof(InvalidOrder) },
                    { "30027", typeof(InvalidOrder) },
                    { "30028", typeof(InvalidOrder) },
                    { "30029", typeof(InvalidOrder) },
                    { "30030", typeof(InvalidOrder) },
                    { "30031", typeof(InsufficientFunds) },
                    { "30032", typeof(InvalidOrder) },
                    { "30033", typeof(RateLimitExceeded) },
                    { "30034", typeof(OrderNotFound) },
                    { "30035", typeof(RateLimitExceeded) },
                    { "30036", typeof(ExchangeError) },
                    { "30037", typeof(InvalidOrder) },
                    { "30041", typeof(ExchangeError) },
                    { "30042", typeof(InsufficientFunds) },
                    { "30043", typeof(InvalidOrder) },
                    { "30044", typeof(InvalidOrder) },
                    { "30045", typeof(InvalidOrder) },
                    { "30049", typeof(InsufficientFunds) },
                    { "30050", typeof(ExchangeError) },
                    { "30051", typeof(ExchangeError) },
                    { "30052", typeof(ExchangeError) },
                    { "30054", typeof(ExchangeError) },
                    { "30057", typeof(ExchangeError) },
                    { "30063", typeof(ExchangeError) },
                    { "30067", typeof(InsufficientFunds) },
                    { "30068", typeof(ExchangeError) },
                    { "30074", typeof(InvalidOrder) },
                    { "30075", typeof(InvalidOrder) },
                    { "30078", typeof(ExchangeError) },
                    { "33004", typeof(AuthenticationError) },
                    { "34026", typeof(ExchangeError) },
                    { "34036", typeof(BadRequest) },
                    { "35015", typeof(BadRequest) },
                    { "340099", typeof(ExchangeError) },
                    { "3400045", typeof(ExchangeError) },
                    { "3100116", typeof(BadRequest) },
                    { "3100198", typeof(BadRequest) },
                    { "3200300", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Request timeout", typeof(RequestTimeout) },
                    { "unknown orderInfo", typeof(OrderNotFound) },
                    { "invalid api_key", typeof(AuthenticationError) },
                    { "oc_diff", typeof(InsufficientFunds) },
                    { "new_oc", typeof(InsufficientFunds) },
                    { "openapi sign params error!", typeof(AuthenticationError) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "enableUnifiedMargin", null },
                { "enableUnifiedAccount", null },
                { "createMarketBuyOrderRequiresPrice", true },
                { "createUnifiedMarginAccount", false },
                { "defaultType", "swap" },
                { "defaultSubType", "linear" },
                { "defaultSettle", "USDT" },
                { "code", "BTC" },
                { "recvWindow", multiply(5, 1000) },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "brokerId", "CCXT" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "margin", "SPOT" },
                    { "future", "CONTRACT" },
                    { "swap", "CONTRACT" },
                    { "option", "OPTION" },
                    { "investment", "INVESTMENT" },
                    { "unified", "UNIFIED" },
                    { "funding", "FUND" },
                    { "fund", "FUND" },
                    { "contract", "CONTRACT" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "SPOT", "spot" },
                    { "MARGIN", "spot" },
                    { "CONTRACT", "contract" },
                    { "OPTION", "option" },
                    { "INVESTMENT", "investment" },
                    { "UNIFIED", "unified" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "TRC20", "TRX" },
                    { "BEP20", "BSC" },
                    { "OMNI", "OMNI" },
                    { "SPL", "SOL" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "TRX", "TRC20" },
                    { "BSC", "BEP20" },
                    { "OMNI", "OMNI" },
                    { "SPL", "SOL" },
                } },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "TRC20" },
                } },
                { "intervals", new Dictionary<string, object>() {
                    { "5m", "5min" },
                    { "15m", "15min" },
                    { "30m", "30min" },
                    { "1h", "1h" },
                    { "4h", "4h" },
                    { "1d", "1d" },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", 0.00075 },
                    { "maker", 0.0001 },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "GAS", "GASDAO" },
            } },
        });
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public async virtual Task<object> isUnifiedEnabled(object parameters = null)
    {
        // The API key of user id must own one of permissions will be allowed to call following API endpoints.
        // SUB UID: "Account Transfer"
        // MASTER UID: "Account Transfer", "Subaccount Transfer", "Withdrawal"
        parameters ??= new Dictionary<string, object>();
        object enableUnifiedMargin = this.safeValue(this.options, "enableUnifiedMargin");
        object enableUnifiedAccount = this.safeValue(this.options, "enableUnifiedAccount");
        if (isTrue(isTrue(isEqual(enableUnifiedMargin, null)) || isTrue(isEqual(enableUnifiedAccount, null))))
        {
            object response = await this.privateGetUserV3PrivateQueryApi(parameters);
            //
            //     {
            //         "retCode":0,
            //         "retMsg":"OK",
            //         "result":{
            //             "id":"88888888",
            //             "note":"ccxt-moon",
            //             "apiKey":"8s8c808v8u8",
            //             "readOnly":0,
            //             "secret":"",
            //             "permissions":{
            //                 "ContractTrade":[""],
            //                 "Spot":[""],
            //                 "Wallet":[""],
            //                 "Options":[""],
            //                 "Derivatives":[""],
            //                 "CopyTrading":[""],
            //                 "BlockTrade":[],
            //                 "Exchange":[""],
            //                 "NFT":[""]
            //             },
            //             "ips":[""],
            //             "type":1,
            //             "deadlineDay":27,
            //             "expiredAt":"",
            //             "createdAt":"",
            //             "unified":1,
            //             "uta": 1
            //         },
            //         "retExtInfo":null,
            //         "time":1669735171649
            //     }
            //
            object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)this.options)["enableUnifiedMargin"] = isEqual(this.safeInteger(result, "unified"), 1);
            ((Dictionary<string, object>)this.options)["enableUnifiedAccount"] = isEqual(this.safeInteger(result, "uta"), 1);
        }
        return new List<object>() {getValue(this.options, "enableUnifiedMargin"), getValue(this.options, "enableUnifiedAccount")};
    }

    public async virtual Task<object> upgradeUnifiedAccount(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object createUnifiedMarginAccount = this.safeValue(this.options, "createUnifiedMarginAccount");
        if (!isTrue(createUnifiedMarginAccount))
        {
            throw new NotSupported ((string)add(this.id, " upgradeUnifiedAccount() warning this method can only be called once, it is not reverseable and you will be stuck with a unified margin account, you also need at least 5000 USDT in your bybit account to do this. If you want to disable this warning set exchange.options[\"createUnifiedMarginAccount\"]=true.")) ;
        }
        return await this.privatePostUnifiedV3PrivateAccountUpgradeUnifiedAccount(parameters);
    }

    public async virtual Task<object> upgradeUnifiedTradeAccount(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.privatePostV5AccountUpgradeToUta(parameters);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://bybit-exchange.github.io/docs/v3/server-time
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV3PublicTime(parameters);
        //
        //    {
        //         "retCode": "0",
        //         "retMsg": "OK",
        //         "result": {
        //             "timeSecond": "1666879482",
        //             "timeNano": "1666879482792685914"
        //         },
        //         "retExtInfo": {},
        //         "time": "1666879482792"
        //     }
        //
        return this.safeInteger(response, "time");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://bybit-exchange.github.io/docs/v5/asset/coin-info
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return null;
        }
        object response = await this.privateGetV5AssetCoinQueryInfo(parameters);
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "",
        //         "result": {
        //             "rows": [
        //                 {
        //                     "name": "BTC",
        //                     "coin": "BTC",
        //                     "remainAmount": "150",
        //                     "chains": [
        //                         {
        //                             "chainType": "BTC",
        //                             "confirmation": "10000",
        //                             "withdrawFee": "0.0005",
        //                             "depositMin": "0.0005",
        //                             "withdrawMin": "0.001",
        //                             "chain": "BTC",
        //                             "chainDeposit": "1",
        //                             "chainWithdraw": "1",
        //                             "minAccuracy": "8"
        //                         }
        //                     ]
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672194582264
        //     }
        //
        object data = this.safeValue(response, "result", new List<object>() {});
        object rows = this.safeValue(data, "rows", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object currency = getValue(rows, i);
            object currencyId = this.safeString(currency, "coin");
            object code = this.safeCurrencyCode(currencyId);
            object name = this.safeString(currency, "name");
            object chains = this.safeValue(currency, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object minPrecision = null;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chain");
                object networkCode = this.networkIdToCode(networkId);
                object precision = this.parseNumber(this.parsePrecision(this.safeString(chain, "minAccuracy")));
                minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : mathMin(minPrecision, precision);
                object depositAllowed = isEqual(this.safeInteger(chain, "chainDeposit"), 1);
                object withdrawAllowed = isEqual(this.safeInteger(chain, "chainWithdraw"), 1);
                ((Dictionary<string, object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", networkCode },
                    { "active", null },
                    { "deposit", depositAllowed },
                    { "withdraw", withdrawAllowed },
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "withdrawMin") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "depositMin") },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", currency },
                { "code", code },
                { "id", currencyId },
                { "name", name },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", minPrecision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchMarkets
        * @description retrieves data on all markets for bybit
        * @see https://bybit-exchange.github.io/docs/v5/market/instrument
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object promisesUnresolved = new List<object> {this.fetchSpotMarkets(parameters), this.fetchDerivativesMarkets(new Dictionary<string, object>() {
    { "category", "linear" },
}), this.fetchDerivativesMarkets(new Dictionary<string, object>() {
    { "category", "inverse" },
})};
        object promises = await promiseAll(promisesUnresolved);
        object spotMarkets = getValue(promises, 0);
        object linearMarkets = getValue(promises, 1);
        object inverseMarkets = getValue(promises, 2);
        object markets = spotMarkets;
        markets = this.arrayConcat(markets, linearMarkets);
        return this.arrayConcat(markets, inverseMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object request = new Dictionary<string, object>() {
            { "category", "spot" },
        };
        object response = await this.publicGetV5MarketInstrumentsInfo(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "spot",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "baseCoin": "BTC",
        //                     "quoteCoin": "USDT",
        //                     "innovation": "0",
        //                     "status": "Trading",
        //                     "lotSizeFilter": {
        //                         "basePrecision": "0.000001",
        //                         "quotePrecision": "0.00000001",
        //                         "minOrderQty": "0.00004",
        //                         "maxOrderQty": "63.01197227",
        //                         "minOrderAmt": "1",
        //                         "maxOrderAmt": "100000"
        //                     },
        //                     "priceFilter": {
        //                         "tickSize": "0.01"
        //                     }
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672712468011
        //     }
        //
        object responseResult = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object markets = this.safeValue(responseResult, "list", new List<object>() {});
        object result = new List<object>() {};
        object takerFee = this.parseNumber("0.001");
        object makerFee = this.parseNumber("0.001");
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseCoin");
            object quoteId = this.safeString(market, "quoteCoin");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object status = this.safeString(market, "status");
            object active = (isEqual(status, "Trading"));
            object lotSizeFilter = this.safeValue(market, "lotSizeFilter");
            object priceFilter = this.safeValue(market, "priceFilter");
            object quotePrecision = this.safeNumber(lotSizeFilter, "quotePrecision");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", active },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", takerFee },
                { "maker", makerFee },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(lotSizeFilter, "basePrecision") },
                    { "price", this.safeNumber(priceFilter, "tickSize", quotePrecision) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(lotSizeFilter, "minOrderQty") },
                        { "max", this.safeNumber(lotSizeFilter, "maxOrderQty") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(lotSizeFilter, "minOrderAmt") },
                        { "max", this.safeNumber(lotSizeFilter, "maxOrderAmt") },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchDerivativesMarkets(object parameters)
    {
        ((Dictionary<string, object>)parameters)["limit"] = 1000; // minimize number of requests
        object response = await this.publicGetV5MarketInstrumentsInfo(parameters);
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object markets = this.safeValue(data, "list", new List<object>() {});
        object paginationCursor = this.safeString(data, "nextPageCursor");
        if (isTrue(!isEqual(paginationCursor, null)))
        {
            while (!isEqual(paginationCursor, null))
            {
                ((Dictionary<string, object>)parameters)["cursor"] = paginationCursor;
                object responseInner = await this.publicGetDerivativesV3PublicInstrumentsInfo(parameters);
                object dataNew = this.safeValue(responseInner, "result", new Dictionary<string, object>() {});
                object rawMarkets = this.safeValue(dataNew, "list", new List<object>() {});
                object rawMarketsLength = getArrayLength(rawMarkets);
                if (isTrue(isEqual(rawMarketsLength, 0)))
                {
                    break;
                }
                markets = this.arrayConcat(rawMarkets, markets);
                paginationCursor = this.safeString(dataNew, "nextPageCursor");
            }
        }
        //
        // linear response
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "contractType": "LinearPerpetual",
        //                     "status": "Trading",
        //                     "baseCoin": "BTC",
        //                     "quoteCoin": "USDT",
        //                     "launchTime": "1585526400000",
        //                     "deliveryTime": "0",
        //                     "deliveryFeeRate": "",
        //                     "priceScale": "2",
        //                     "leverageFilter": {
        //                         "minLeverage": "1",
        //                         "maxLeverage": "100.00",
        //                         "leverageStep": "0.01"
        //                     },
        //                     "priceFilter": {
        //                         "minPrice": "0.50",
        //                         "maxPrice": "999999.00",
        //                         "tickSize": "0.50"
        //                     },
        //                     "lotSizeFilter": {
        //                         "maxOrderQty": "100.000",
        //                         "minOrderQty": "0.001",
        //                         "qtyStep": "0.001",
        //                         "postOnlyMaxOrderQty": "1000.000"
        //                     },
        //                     "unifiedMarginTrade": true,
        //                     "fundingInterval": 480,
        //                     "settleCoin": "USDT"
        //                 }
        //             ],
        //             "nextPageCursor": ""
        //         },
        //         "retExtInfo": {},
        //         "time": 1672712495660
        //     }
        //
        // option response
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "option",
        //             "nextPageCursor": "",
        //             "list": [
        //                 {
        //                     "category": "option",
        //                     "symbol": "ETH-3JAN23-1250-P",
        //                     "status": "ONLINE",
        //                     "baseCoin": "ETH",
        //                     "quoteCoin": "USD",
        //                     "settleCoin": "USDC",
        //                     "optionsType": "Put",
        //                     "launchTime": "1672560000000",
        //                     "deliveryTime": "1672732800000",
        //                     "deliveryFeeRate": "0.00015",
        //                     "priceFilter": {
        //                         "minPrice": "0.1",
        //                         "maxPrice": "10000000",
        //                         "tickSize": "0.1"
        //                     },
        //                     "lotSizeFilter": {
        //                         "maxOrderQty": "1500",
        //                         "minOrderQty": "0.1",
        //                         "qtyStep": "0.1"
        //                     }
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672712537130
        //     }
        //
        object result = new List<object>() {};
        object category = this.safeString(data, "category");
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            if (isTrue(isEqual(category, null)))
            {
                category = this.safeString(market, "category");
            }
            object linear = (isEqual(category, "linear"));
            object inverse = (isEqual(category, "inverse"));
            object contractType = this.safeString(market, "contractType");
            object inverseFutures = (isEqual(contractType, "InverseFutures"));
            object linearFutures = (isEqual(contractType, "LinearFutures"));
            object linearPerpetual = (isEqual(contractType, "LinearPerpetual"));
            object inversePerpetual = (isEqual(contractType, "InversePerpetual"));
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseCoin");
            object quoteId = this.safeString(market, "quoteCoin");
            object defaultSettledId = ((bool) isTrue(linear)) ? quoteId : baseId;
            object settleId = this.safeString(market, "settleCoin", defaultSettledId);
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = null;
            if (isTrue(isTrue(linearPerpetual) && isTrue((isEqual(settleId, "USD")))))
            {
                settle = "USDC";
            } else
            {
                settle = this.safeCurrencyCode(settleId);
            }
            object symbol = add(add(bs, "/"), quote);
            object lotSizeFilter = this.safeValue(market, "lotSizeFilter", new Dictionary<string, object>() {});
            object priceFilter = this.safeValue(market, "priceFilter", new Dictionary<string, object>() {});
            object leverage = this.safeValue(market, "leverageFilter", new Dictionary<string, object>() {});
            object status = this.safeString(market, "status");
            object active = (isEqual(status, "Trading"));
            object swap = isTrue(linearPerpetual) || isTrue(inversePerpetual);
            object future = isTrue(inverseFutures) || isTrue(linearFutures);
            object option = (isEqual(category, "option"));
            object type = null;
            if (isTrue(swap))
            {
                type = "swap";
            } else if (isTrue(future))
            {
                type = "future";
            } else if (isTrue(option))
            {
                type = "option";
            }
            object expiry = this.omitZero(this.safeString(market, "deliveryTime"));
            if (isTrue(!isEqual(expiry, null)))
            {
                expiry = parseInt(expiry);
            }
            object expiryDatetime = this.iso8601(expiry);
            object strike = null;
            object optionType = null;
            symbol = add(add(symbol, ":"), settle);
            if (isTrue(!isEqual(expiry, null)))
            {
                symbol = add(add(symbol, "-"), this.yymmdd(expiry));
                if (isTrue(option))
                {
                    object splitId = ((string)id).Split((string)"-").ToList<object>();
                    strike = this.safeString(splitId, 2);
                    object optionLetter = this.safeString(splitId, 3);
                    symbol = add(add(add(add(symbol, "-"), strike), "-"), optionLetter);
                    if (isTrue(isEqual(optionLetter, "P")))
                    {
                        optionType = "put";
                    } else if (isTrue(isEqual(optionLetter, "C")))
                    {
                        optionType = "call";
                    }
                }
            }
            object contractSize = ((bool) isTrue(inverse)) ? this.safeNumber2(lotSizeFilter, "minTradingQty", "minOrderQty") : this.parseNumber("1");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", false },
                { "margin", null },
                { "swap", swap },
                { "future", future },
                { "option", option },
                { "active", active },
                { "contract", true },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", this.safeNumber(market, "takerFee", this.parseNumber("0.0006")) },
                { "maker", this.safeNumber(market, "makerFee", this.parseNumber("0.0001")) },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", expiryDatetime },
                { "strike", strike },
                { "optionType", optionType },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(lotSizeFilter, "qtyStep") },
                    { "price", this.safeNumber(priceFilter, "tickSize") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(leverage, "minLeverage") },
                        { "max", this.safeNumber(leverage, "maxLeverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber2(lotSizeFilter, "minTradingQty", "minOrderQty") },
                        { "max", this.safeNumber2(lotSizeFilter, "maxTradingQty", "maxOrderQty") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(priceFilter, "minPrice") },
                        { "max", this.safeNumber(priceFilter, "maxPrice") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "bid1Price": "20517.96",
        //         "bid1Size": "2",
        //         "ask1Price": "20527.77",
        //         "ask1Size": "1.862172",
        //         "lastPrice": "20533.13",
        //         "prevPrice24h": "20393.48",
        //         "price24hPcnt": "0.0068",
        //         "highPrice24h": "21128.12",
        //         "lowPrice24h": "20318.89",
        //         "turnover24h": "243765620.65899866",
        //         "volume24h": "11801.27771",
        //         "usdIndexPrice": "20784.12009279"
        //     }
        //
        // linear/inverse
        //
        //     {
        //         "symbol": "BTCUSD",
        //         "lastPrice": "16597.00",
        //         "indexPrice": "16598.54",
        //         "markPrice": "16596.00",
        //         "prevPrice24h": "16464.50",
        //         "price24hPcnt": "0.008047",
        //         "highPrice24h": "30912.50",
        //         "lowPrice24h": "15700.00",
        //         "prevPrice1h": "16595.50",
        //         "openInterest": "373504107",
        //         "openInterestValue": "22505.67",
        //         "turnover24h": "2352.94950046",
        //         "volume24h": "49337318",
        //         "fundingRate": "-0.001034",
        //         "nextFundingTime": "1672387200000",
        //         "predictedDeliveryPrice": "",
        //         "basisRate": "",
        //         "deliveryFeeRate": "",
        //         "deliveryTime": "0",
        //         "ask1Size": "1",
        //         "bid1Price": "16596.00",
        //         "ask1Price": "16597.50",
        //         "bid1Size": "1"
        //     }
        //
        // option
        //
        //     {
        //         "symbol": "BTC-30DEC22-18000-C",
        //         "bid1Price": "0",
        //         "bid1Size": "0",
        //         "bid1Iv": "0",
        //         "ask1Price": "435",
        //         "ask1Size": "0.66",
        //         "ask1Iv": "5",
        //         "lastPrice": "435",
        //         "highPrice24h": "435",
        //         "lowPrice24h": "165",
        //         "markPrice": "0.00000009",
        //         "indexPrice": "16600.55",
        //         "markIv": "0.7567",
        //         "underlyingPrice": "16590.42",
        //         "openInterest": "6.3",
        //         "turnover24h": "2482.73",
        //         "volume24h": "0.15",
        //         "totalVolume": "99",
        //         "totalTurnover": "1967653",
        //         "delta": "0.00000001",
        //         "gamma": "0.00000001",
        //         "vega": "0.00000004",
        //         "theta": "-0.00000152",
        //         "predictedDeliveryPrice": "0",
        //         "change24h": "86"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "time");
        object marketId = this.safeString(ticker, "symbol");
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        market = this.safeMarket(marketId, market, null, defaultType);
        object symbol = this.safeSymbol(marketId, market, null, defaultType);
        object last = this.safeString(ticker, "lastPrice");
        object open = this.safeString(ticker, "prevPrice24h");
        object percentage = this.safeString(ticker, "price24hPcnt");
        percentage = Precise.stringMul(percentage, "100");
        object quoteVolume = this.safeString(ticker, "turnover24h");
        object baseVolume = this.safeString(ticker, "volume24h");
        object bid = this.safeString(ticker, "bid1Price");
        object ask = this.safeString(ticker, "ask1Price");
        object high = this.safeString(ticker, "highPrice24h");
        object low = this.safeString(ticker, "lowPrice24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", this.safeString2(ticker, "bidSize", "bid1Size") },
            { "ask", ask },
            { "askVolume", this.safeString2(ticker, "askSize", "ask1Size") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bybit-exchange.github.io/docs/v5/market/tickers
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchTicker", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else
        {
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            }
        }
        object response = await this.publicGetV5MarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "inverse",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSD",
        //                     "lastPrice": "16597.00",
        //                     "indexPrice": "16598.54",
        //                     "markPrice": "16596.00",
        //                     "prevPrice24h": "16464.50",
        //                     "price24hPcnt": "0.008047",
        //                     "highPrice24h": "30912.50",
        //                     "lowPrice24h": "15700.00",
        //                     "prevPrice1h": "16595.50",
        //                     "openInterest": "373504107",
        //                     "openInterestValue": "22505.67",
        //                     "turnover24h": "2352.94950046",
        //                     "volume24h": "49337318",
        //                     "fundingRate": "-0.001034",
        //                     "nextFundingTime": "1672387200000",
        //                     "predictedDeliveryPrice": "",
        //                     "basisRate": "",
        //                     "deliveryFeeRate": "",
        //                     "deliveryTime": "0",
        //                     "ask1Size": "1",
        //                     "bid1Price": "16596.00",
        //                     "ask1Price": "16597.50",
        //                     "bid1Size": "1"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672376496682
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object tickers = this.safeValue(result, "list", new List<object>() {});
        object rawTicker = this.safeValue(tickers, 0);
        return this.parseTicker(rawTicker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://bybit-exchange.github.io/docs/v5/market/tickers
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            market = this.market(getValue(symbols, 0));
        }
        object request = new Dictionary<string, object>() {};
        object type = null;
        object isTypeInParams = (((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("type")));
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else if (isTrue(isTrue(isEqual(type, "swap")) || isTrue(isEqual(type, "future"))))
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = subType;
        } else if (isTrue(isEqual(type, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        }
        object response = await this.publicGetV5MarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "inverse",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSD",
        //                     "lastPrice": "16597.00",
        //                     "indexPrice": "16598.54",
        //                     "markPrice": "16596.00",
        //                     "prevPrice24h": "16464.50",
        //                     "price24hPcnt": "0.008047",
        //                     "highPrice24h": "30912.50",
        //                     "lowPrice24h": "15700.00",
        //                     "prevPrice1h": "16595.50",
        //                     "openInterest": "373504107",
        //                     "openInterestValue": "22505.67",
        //                     "turnover24h": "2352.94950046",
        //                     "volume24h": "49337318",
        //                     "fundingRate": "-0.001034",
        //                     "nextFundingTime": "1672387200000",
        //                     "predictedDeliveryPrice": "",
        //                     "basisRate": "",
        //                     "deliveryFeeRate": "",
        //                     "deliveryTime": "0",
        //                     "ask1Size": "1",
        //                     "bid1Price": "16596.00",
        //                     "ask1Price": "16597.50",
        //                     "bid1Size": "1"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672376496682
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object tickerList = this.safeValue(result, "list", new List<object>() {});
        object tickers = new Dictionary<string, object>() {};
        if (isTrue(isTrue(isEqual(market, null)) && isTrue(isTypeInParams)))
        {
            // create a "fake" market for the type
            market = new Dictionary<string, object>() {
                { "type", ((bool) isTrue((isTrue(isEqual(type, "swap")) || isTrue(isEqual(type, "future"))))) ? "swap" : type },
            };
        }
        for (object i = 0; isLessThan(i, getArrayLength(tickerList)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickerList, i), market);
            object symbol = getValue(ticker, "symbol");
            // this is needed because bybit returns
            // futures with type = swap
            object marketInner = this.market(symbol);
            if (isTrue(isEqual(getValue(marketInner, "type"), type)))
            {
                ((Dictionary<string, object>)tickers)[(string)symbol] = ticker;
            }
        }
        return this.filterByArray(tickers, "symbol", symbols);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1621162800",
        //         "49592.43",
        //         "49644.91",
        //         "49342.37",
        //         "49349.42",
        //         "1451.59",
        //         "2.4343353100000003"
        //     ]
        //
        object volumeIndex = ((bool) isTrue((getValue(market, "inverse")))) ? 6 : 5;
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, volumeIndex)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://bybit-exchange.github.io/docs/v5/market/kline
        * @see https://bybit-exchange.github.io/docs/v5/market/mark-kline
        * @see https://bybit-exchange.github.io/docs/v5/market/index-kline
        * @see https://bybit-exchange.github.io/docs/v5/market/preimum-index-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOHLCV", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 200; // default is 200 when requested with `since`
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // max 1000, default 1000
        }
        ((Dictionary<string, object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        object method = null;
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
            method = "publicGetV5MarketKline";
        } else
        {
            object price = this.safeString(parameters, "price");
            parameters = this.omit(parameters, "price");
            object methods = new Dictionary<string, object>() {
                { "mark", "publicGetV5MarketMarkPriceKline" },
                { "index", "publicGetV5MarketIndexPriceKline" },
                { "premiumIndex", "publicGetV5MarketPremiumIndexPriceKline" },
            };
            method = this.safeValue(methods, price, "publicGetV5MarketKline");
            if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchOHLCV() is not supported for option markets")) ;
            }
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "symbol": "BTCUSD",
        //             "category": "inverse",
        //             "list": [
        //                 [
        //                     "1670608800000",
        //                     "17071",
        //                     "17073",
        //                     "17027",
        //                     "17055.5",
        //                     "268611",
        //                     "15.74462667"
        //                 ],
        //                 [
        //                     "1670605200000",
        //                     "17071.5",
        //                     "17071.5",
        //                     "17061",
        //                     "17071",
        //                     "4177",
        //                     "0.24469757"
        //                 ],
        //                 [
        //                     "1670601600000",
        //                     "17086.5",
        //                     "17088",
        //                     "16978",
        //                     "17071.5",
        //                     "6356",
        //                     "0.37288112"
        //                 ]
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672025956592
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ohlcvs = this.safeValue(result, "list", new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseFundingRate(object ticker, object market = null)
    {
        //     {
        //         "symbol": "BTCUSDT",
        //         "bidPrice": "19255",
        //         "askPrice": "19255.5",
        //         "lastPrice": "19255.50",
        //         "lastTickDirection": "ZeroPlusTick",
        //         "prevPrice24h": "18634.50",
        //         "price24hPcnt": "0.033325",
        //         "highPrice24h": "19675.00",
        //         "lowPrice24h": "18610.00",
        //         "prevPrice1h": "19278.00",
        //         "markPrice": "19255.00",
        //         "indexPrice": "19260.68",
        //         "openInterest": "48069.549",
        //         "turnover24h": "4686694853.047006",
        //         "volume24h": "243730.252",
        //         "fundingRate": "0.0001",
        //         "nextFundingTime": "1663689600000",
        //         "predictedDeliveryPrice": "",
        //         "basisRate": "",
        //         "deliveryFeeRate": "",
        //         "deliveryTime": "0"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "timestamp"); // added artificially to avoid changing the signature
        ticker = this.omit(ticker, "timestamp");
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "swap");
        object fundingRate = this.safeNumber(ticker, "fundingRate");
        object fundingTimestamp = this.safeInteger(ticker, "nextFundingTime");
        object markPrice = this.safeNumber(ticker, "markPrice");
        object indexPrice = this.safeNumber(ticker, "indexPrice");
        return new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", symbol },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchFundingRates
        * @description fetches funding rates for multiple markets
        * @see https://bybit-exchange.github.io/docs/v5/market/tickers
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the funding rates for, all market funding rates are returned if not assigned
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            market = this.market(getValue(symbols, 0));
            if (isTrue(isEqual(getArrayLength(symbols), 1)))
            {
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchFundingRates", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchFundingRates() does not support "), type), " markets")) ;
        } else
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRates", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = subType;
        }
        object response = await this.publicGetV5MarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "bidPrice": "19255",
        //                     "askPrice": "19255.5",
        //                     "lastPrice": "19255.50",
        //                     "lastTickDirection": "ZeroPlusTick",
        //                     "prevPrice24h": "18634.50",
        //                     "price24hPcnt": "0.033325",
        //                     "highPrice24h": "19675.00",
        //                     "lowPrice24h": "18610.00",
        //                     "prevPrice1h": "19278.00",
        //                     "markPrice": "19255.00",
        //                     "indexPrice": "19260.68",
        //                     "openInterest": "48069.549",
        //                     "turnover24h": "4686694853.047006",
        //                     "volume24h": "243730.252",
        //                     "fundingRate": "0.0001",
        //                     "nextFundingTime": "1663689600000",
        //                     "predictedDeliveryPrice": "",
        //                     "basisRate": "",
        //                     "deliveryFeeRate": "",
        //                     "deliveryTime": "0"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": null,
        //         "time": 1663670053454
        //     }
        //
        object tickerList = this.safeValue(response, "result", new List<object>() {});
        object timestamp = this.safeInteger(response, "time");
        tickerList = this.safeValue(tickerList, "list");
        object fundingRates = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickerList)); postFixIncrement(ref i))
        {
            object rawTicker = getValue(tickerList, i);
            ((Dictionary<string, object>)rawTicker)["timestamp"] = timestamp; // will be removed inside the parser
            object ticker = this.parseFundingRate(getValue(tickerList, i), null);
            object symbol = getValue(ticker, "symbol");
            ((Dictionary<string, object>)fundingRates)[(string)symbol] = ticker;
        }
        return this.filterByArray(fundingRates, "symbol", symbols);
    }

    public async virtual Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://bybit-exchange.github.io/docs/v5/market/history-fund-rate
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @param {int|undefined} params.until timestamp in ms of the latest funding rate
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchFundingRateHistory", symbol);
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        if (isTrue(getValue(market, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRateHistory() is not supported for option markets")) ;
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else if (isTrue(getValue(market, "inverse")))
        {
            ((Dictionary<string, object>)request)["category"] = "inverse";
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object until = this.safeInteger2(parameters, "until", "till"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"endTime", "till", "until"});
        if (isTrue(!isEqual(endTime, null)))
        {
            ((Dictionary<string, object>)request)["endTime"] = endTime;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetV5MarketFundingHistory(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHPERP",
        //                     "fundingRate": "0.0001",
        //                     "fundingRateTimestamp": "1672041600000"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672051897447
        //     }
        //
        object rates = new List<object>() {};
        object result = this.safeValue(response, "result");
        object resultList = this.safeValue(result, "list");
        for (object i = 0; isLessThan(i, getArrayLength(resultList)); postFixIncrement(ref i))
        {
            object entry = getValue(resultList, i);
            object timestamp = this.safeInteger(entry, "fundingRateTimestamp");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(this.safeString(entry, "symbol"), null, null, "swap") },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object isSpotTrade = isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isBuyerMaker")))) || isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("feeTokenId"))));
        if (isTrue(isSpotTrade))
        {
            return this.parseSpotTrade(trade, market);
        } else
        {
            return this.parseContractTrade(trade, market);
        }
    }

    public virtual object parseSpotTrade(object trade, object market = null)
    {
        //
        //   public:
        //     {
        //        "price": "39548.68",
        //        "time": "1651748717850",
        //        "qty": "0.166872",
        //        "isBuyerMaker": 0
        //     }
        //
        //   private:
        //     {
        //         "orderPrice": "82.5",
        //         "creatTime": "1666702226326",
        //         "orderQty": "0.016",
        //         "isBuyer": "0",
        //         "isMaker": "0",
        //         "symbol": "AAVEUSDT",
        //         "id": "1274785101965716992",
        //         "orderId": "1274784252359089664",
        //         "tradeId": "2270000000031365639",
        //         "execFee": "0",
        //         "feeTokenId": "AAVE",
        //         "matchOrderId": "1274785101865076224",
        //         "makerRebate": "0",
        //         "executionTime": "1666702226335"
        //     }
        //
        object timestamp = this.safeIntegerN(trade, new List<object>() {"time", "creatTime"});
        object takerOrMaker = null;
        object side = null;
        object isBuyerMaker = this.safeInteger(trade, "isBuyerMaker");
        if (isTrue(!isEqual(isBuyerMaker, null)))
        {
            // if public response
            side = ((bool) isTrue((isEqual(isBuyerMaker, 1)))) ? "buy" : "sell";
        } else
        {
            // if private response
            object isBuyer = this.safeInteger(trade, "isBuyer");
            object isMaker = this.safeInteger(trade, "isMaker");
            takerOrMaker = ((bool) isTrue((isEqual(isMaker, 0)))) ? "maker" : "taker";
            side = ((bool) isTrue((isEqual(isBuyer, 0)))) ? "buy" : "sell";
        }
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, null, "spot");
        object fee = null;
        object feeCost = this.safeString(trade, "execFee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeToken = this.safeString(trade, "feeTokenId");
            object feeCurrency = this.safeCurrencyCode(feeToken);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "tradeId") },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", this.safeString(trade, "orderId") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", this.safeString2(trade, "price", "orderPrice") },
            { "amount", this.safeString2(trade, "qty", "orderQty") },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public virtual object parseContractTrade(object trade, object market = null)
    {
        //
        // public contract
        //
        //     {
        //         "execId": "666042b4-50c6-58f3-bd9c-89b2088663ff",
        //         "symbol": "ETHUSD",
        //         "price": "1162.95",
        //         "size": "1",
        //         "side": "Sell",
        //         "time": "1669191277315",
        //         "isBlockTrade": false
        //     }
        //
        // public unified margin
        //
        //     {
        //         "execId": "da66abbc-f358-5864-8d34-84ef7274d853",
        //         "symbol": "BTCUSDT",
        //         "price": "20802.50",
        //         "size": "0.200",
        //         "side": "Sell",
        //         "time": "1657870316630"
        //     }
        //
        // private contract trades
        //
        //     {
        //         "symbol": "ETHUSD",
        //         "execFee": "0.00005484",
        //         "execId": "acf78206-d464-589b-b888-51bd130821c1",
        //         "execPrice": "1367.80",
        //         "execQty": "100",
        //         "execType": "Trade",
        //         "execValue": "0.0731101",
        //         "feeRate": "0.00075",
        //         "lastLiquidityInd": "RemovedLiquidity",
        //         "leavesQty": "0",
        //         "orderId": "fdc584c3-be5d-41ff-8f54-5be7649b1d1c",
        //         "orderLinkId": "",
        //         "orderPrice": "1299.50",
        //         "orderQty": "100",
        //         "orderType": "Market",
        //         "stopOrderType": "UNKNOWN",
        //         "side": "Sell",
        //         "execTime": "1611528105547",
        //         "closedSize": "100"
        //     }
        //
        // private unified margin
        //
        //     {
        //         "symbol": "AAVEUSDT",
        //         "id": "1274785101965716992",
        //         "orderId": "1274784252359089664",
        //         "tradeId": "2270000000031365639",
        //         "orderPrice": "82.5",
        //         "orderQty": "0.016",
        //         "execFee": "0",
        //         "feeTokenId": "AAVE",
        //         "creatTime": "1666702226326",
        //         "isBuyer": "0",
        //         "isMaker": "0",
        //         "matchOrderId": "1274785101865076224",
        //         "makerRebate": "0",
        //         "executionTime": "1666702226335"
        //     }
        //
        // private USDC settled trades
        //
        //     {
        //         "symbol": "ETHPERP",
        //         "orderLinkId": "",
        //         "side": "Buy",
        //         "orderId": "aad0ee44-ce12-4112-aeee-b7829f6c3a26",
        //         "execFee": "0.0210",
        //         "feeRate": "0.000600",
        //         "blockTradeId": "",
        //         "tradeTime": "1669196417930",
        //         "execPrice": "1162.15",
        //         "lastLiquidityInd": "TAKER",
        //         "execValue": "34.8645",
        //         "execType": "Trade",
        //         "execQty": "0.030",
        //         "tradeId": "0e94eaf5-b08e-5505-b43f-7f1f30b1ca80"
        //     }
        //
        object id = this.safeStringN(trade, new List<object>() {"execId", "id", "tradeId"});
        object marketId = this.safeString(trade, "symbol");
        object marketType = "contract";
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
        }
        object category = this.safeString(trade, "category");
        if (isTrue(!isEqual(category, null)))
        {
            if (isTrue(isEqual(category, "spot")))
            {
                marketType = "spot";
            }
        }
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = getValue(market, "symbol");
        object amountString = this.safeStringN(trade, new List<object>() {"execQty", "orderQty", "size"});
        object priceString = this.safeStringN(trade, new List<object>() {"execPrice", "orderPrice", "price"});
        object costString = this.safeString(trade, "execValue");
        object timestamp = this.safeIntegerN(trade, new List<object>() {"time", "execTime", "tradeTime"});
        object side = this.safeStringLower(trade, "side");
        if (isTrue(isEqual(side, null)))
        {
            object isBuyer = this.safeInteger(trade, "isBuyer");
            if (isTrue(!isEqual(isBuyer, null)))
            {
                side = ((bool) isTrue(isBuyer)) ? "buy" : "sell";
            }
        }
        object isMaker = this.safeValue(trade, "isMaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(isMaker, null)))
        {
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        } else
        {
            object lastLiquidityInd = this.safeString(trade, "lastLiquidityInd");
            if (isTrue(isEqual(lastLiquidityInd, "UNKNOWN")))
            {
                lastLiquidityInd = null;
            }
            if (isTrue(!isEqual(lastLiquidityInd, null)))
            {
                if (isTrue(isTrue((isEqual(lastLiquidityInd, "TAKER"))) || isTrue((isEqual(lastLiquidityInd, "MAKER")))))
                {
                    takerOrMaker = ((string)lastLiquidityInd).ToLower();
                } else
                {
                    takerOrMaker = ((bool) isTrue((isEqual(lastLiquidityInd, "AddedLiquidity")))) ? "maker" : "taker";
                }
            }
        }
        object orderType = this.safeStringLower(trade, "orderType");
        if (isTrue(isEqual(orderType, "unknown")))
        {
            orderType = null;
        }
        object feeCostString = this.safeString(trade, "execFee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyCode = null;
            if (isTrue(getValue(market, "spot")))
            {
                feeCurrencyCode = this.safeString(trade, "commissionAsset");
            } else
            {
                feeCurrencyCode = ((bool) isTrue(getValue(market, "inverse"))) ? getValue(market, "base") : getValue(market, "settle");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", this.safeString(trade, "orderId") },
            { "type", orderType },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://bybit-exchange.github.io/docs/v5/market/recent-trade
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchTrades", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            // spot: [1,60], default: 60.
            // others: [1,1000], default: 500
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(isEqual(getValue(market, "type"), "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else
        {
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            }
        }
        object response = await this.publicGetV5MarketRecentTrade(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "spot",
        //             "list": [
        //                 {
        //                     "execId": "2100000000007764263",
        //                     "symbol": "BTCUSDT",
        //                     "price": "16618.49",
        //                     "size": "0.00012",
        //                     "side": "Buy",
        //                     "time": "1672052955758",
        //                     "isBlockTrade": false
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672053054358
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(result, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bybit-exchange.github.io/docs/v5/market/orderbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOrderBook", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object defaultLimit = 25;
        if (isTrue(getValue(market, "spot")))
        {
            // limit: [1, 50]. Default: 1
            defaultLimit = 50;
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else
        {
            if (isTrue(getValue(market, "option")))
            {
                // limit: [1, 25]. Default: 1
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                // limit: [1, 200]. Default: 25
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                // limit: [1, 200]. Default: 25
                ((Dictionary<string, object>)request)["category"] = "inverse";
            }
        }
        ((Dictionary<string, object>)request)["limit"] = ((bool) isTrue((!isEqual(limit, null)))) ? limit : defaultLimit;
        object response = await this.publicGetV5MarketOrderbook(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "s": "BTCUSDT",
        //             "a": [
        //                 [
        //                     "16638.64",
        //                     "0.008479"
        //                 ]
        //             ],
        //             "b": [
        //                 [
        //                     "16638.27",
        //                     "0.305749"
        //                 ]
        //             ],
        //             "ts": 1672765737733,
        //             "u": 5277055
        //         },
        //         "retExtInfo": {},
        //         "time": 1672765737734
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object timestamp = this.safeInteger(result, "ts");
        return this.parseOrderBook(result, symbol, timestamp, "b", "a");
    }

    public virtual object parseBalance(object response)
    {
        //
        // margin wallet
        //     [
        //         {
        //             "free": "0.001143855",
        //             "interest": "0",
        //             "loan": "0",
        //             "locked": "0",
        //             "tokenId": "BTC",
        //             "total": "0.001143855"
        //         },
        //         {
        //             "free": "200.00005568",
        //             "interest": "0.0008391",
        //             "loan": "200",
        //             "locked": "0",
        //             "tokenId": "USDT",
        //             "total": "200.00005568"
        //         },
        //     ]
        //
        // usdc wallet
        //    {
        //      "result": {
        //           "walletBalance": "10.0000",
        //           "accountMM": "0.0000",
        //           "bonus": "0.0000",
        //           "accountIM": "0.0000",
        //           "totalSessionRPL": "0.0000",
        //           "equity": "10.0000",
        //           "totalRPL": "0.0000",
        //           "marginBalance": "10.0000",
        //           "availableBalance": "10.0000",
        //           "totalSessionUPL": "0.0000"
        //       },
        //       "retCode": "0",
        //       "retMsg": "Success."
        //    }
        //
        // Unified Margin
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //             "totalEquity": "112.21267421",
        //             "accountIMRate": "0.6895",
        //             "totalMarginBalance": "80.37711012",
        //             "totalInitialMargin": "55.42180254",
        //             "totalAvailableBalance": "24.95530758",
        //             "accountMMRate": "0.0459",
        //             "totalPerpUPL": "-16.69586570",
        //             "totalWalletBalance": "97.07311619",
        //             "totalMaintenanceMargin": "3.68580537",
        //             "coin": [
        //                 {
        //                     "currencyCoin": "ETH",
        //                     "availableToBorrow": "0.00000000",
        //                     "borrowSize": "0.00000000",
        //                     "bonus": "0.00000000",
        //                     "accruedInterest": "0.00000000",
        //                     "availableBalanceWithoutConvert": "0.00000000",
        //                     "totalOrderIM": "",
        //                     "equity": "0.00000000",
        //                     "totalPositionMM": "",
        //                     "usdValue": "0.00000000",
        //                     "availableBalance": "0.02441165",
        //                     "unrealisedPnl": "",
        //                     "totalPositionIM": "",
        //                     "marginBalanceWithoutConvert": "0.00000000",
        //                     "walletBalance": "0.00000000",
        //                     "cumRealisedPnl": "",
        //                     "marginBalance": "0.07862610"
        //                 }
        //             ]
        //         },
        //         "time": 1657716037033
        //     }
        //
        // contract v3
        //
        //     [
        //         {
        //             "coin": "BTC",
        //             "equity": "0.00000002",
        //             "walletBalance": "0.00000002",
        //             "positionMargin": "0",
        //             "availableBalance": "0.00000002",
        //             "orderMargin": "0",
        //             "occClosingFee": "0",
        //             "occFundingFee": "0",
        //             "unrealisedPnl": "0",
        //             "cumRealisedPnl": "-0.00010941",
        //             "givenCash": "0",
        //             "serviceCash": "0"
        //         },
        //         {
        //             "coin": "USDT",
        //             "equity": "3662.81038535",
        //             "walletBalance": "3662.81038535",
        //             "positionMargin": "0",
        //             "availableBalance": "3662.81038535",
        //             "orderMargin": "0",
        //             "occClosingFee": "0",
        //             "occFundingFee": "0",
        //             "unrealisedPnl": "0",
        //             "cumRealisedPnl": "-36.01761465",
        //             "givenCash": "0",
        //             "serviceCash": "0"
        //         }
        //     ]
        // spot
        //     {
        //       retCode: '0',
        //       retMsg: 'OK',
        //       result: {
        //         balances: [
        //           {
        //             coin: 'BTC',
        //             coinId: 'BTC',
        //             total: '0.00977041118',
        //             free: '0.00877041118',
        //             locked: '0.001'
        //           },
        //           {
        //             coin: 'EOS',
        //             coinId: 'EOS',
        //             total: '2000',
        //             free: '2000',
        //             locked: '0'
        //           }
        //         ]
        //       },
        //       retExtInfo: {},
        //       time: '1670002625754'
        //  }
        //
        // Unified trade account
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "totalEquity": "18070.32797922",
        //                     "accountIMRate": "0.0101",
        //                     "totalMarginBalance": "18070.32797922",
        //                     "totalInitialMargin": "182.60183684",
        //                     "accountType": "UNIFIED",
        //                     "totalAvailableBalance": "17887.72614237",
        //                     "accountMMRate": "0",
        //                     "totalPerpUPL": "-0.11001349",
        //                     "totalWalletBalance": "18070.43799271",
        //                     "totalMaintenanceMargin": "0.38106773",
        //                     "coin": [
        //                         {
        //                             "availableToBorrow": "2.5",
        //                             "accruedInterest": "0",
        //                             "availableToWithdraw": "0.805994",
        //                             "totalOrderIM": "0",
        //                             "equity": "0.805994",
        //                             "totalPositionMM": "0",
        //                             "usdValue": "12920.95352538",
        //                             "unrealisedPnl": "0",
        //                             "borrowAmount": "0",
        //                             "totalPositionIM": "0",
        //                             "walletBalance": "0.805994",
        //                             "cumRealisedPnl": "0",
        //                             "coin": "BTC"
        //                         }
        //                     ]
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672125441042
        //     }
        //
        // funding v5
        //    {
        //        retCode: '0',
        //        retMsg: 'success',
        //        result: {
        //          memberId: '452265',
        //          accountType: 'FUND',
        //          balance: [
        //            {
        //              coin: 'BTC',
        //              transferBalance: '0.2',
        //              walletBalance: '0.2',
        //              bonus: ''
        //            }
        //          ]
        //        },
        //        retExtInfo: {},
        //        time: '1677781902858'
        //    }
        //
        // all coins balance
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "memberId": "533285",
        //             "accountType": "FUND",
        //             "balance": [
        //                 {
        //                     "coin": "USDT",
        //                     "transferBalance": "1010",
        //                     "walletBalance": "1010",
        //                     "bonus": ""
        //                 },
        //                 {
        //                     "coin": "USDC",
        //                     "transferBalance": "0",
        //                     "walletBalance": "0",
        //                     "bonus": ""
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1675865290069
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object responseResult = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object currencyList = this.safeValueN(responseResult, new List<object>() {"loanAccountList", "list", "coin", "balances", "balance"});
        if (isTrue(isEqual(currencyList, null)))
        {
            // usdc wallet
            object code = "USDC";
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(responseResult, "availableBalance");
            ((Dictionary<string, object>)account)["total"] = this.safeString(responseResult, "walletBalance");
            ((Dictionary<string, object>)result)[(string)code] = account;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(currencyList)); postFixIncrement(ref i))
            {
                object entry = getValue(currencyList, i);
                object accountType = this.safeString(entry, "accountType");
                if (isTrue(isTrue(isEqual(accountType, "UNIFIED")) || isTrue(isEqual(accountType, "CONTRACT"))))
                {
                    object coins = this.safeValue(entry, "coin");
                    for (object j = 0; isLessThan(j, getArrayLength(coins)); postFixIncrement(ref j))
                    {
                        object account = this.account();
                        object coinEntry = getValue(coins, j);
                        object loan = this.safeString(coinEntry, "borrowAmount");
                        object interest = this.safeString(coinEntry, "accruedInterest");
                        if (isTrue(isTrue((!isEqual(loan, null))) && isTrue((!isEqual(interest, null)))))
                        {
                            ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(loan, interest);
                        }
                        ((Dictionary<string, object>)account)["total"] = this.safeString(coinEntry, "walletBalance");
                        ((Dictionary<string, object>)account)["free"] = this.safeString(coinEntry, "availableToWithdraw");
                        // account['used'] = this.safeString (coinEntry, 'locked');
                        object currencyId = this.safeString(coinEntry, "coin");
                        object code = this.safeCurrencyCode(currencyId);
                        ((Dictionary<string, object>)result)[(string)code] = account;
                    }
                } else
                {
                    object account = this.account();
                    object loan = this.safeString(entry, "loan");
                    object interest = this.safeString(entry, "interest");
                    if (isTrue(isTrue((!isEqual(loan, null))) && isTrue((!isEqual(interest, null)))))
                    {
                        ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(loan, interest);
                    }
                    ((Dictionary<string, object>)account)["total"] = this.safeString2(entry, "total", "walletBalance");
                    ((Dictionary<string, object>)account)["free"] = this.safeStringN(entry, new List<object>() {"free", "availableBalanceWithoutConvert", "availableBalance", "transferBalance"});
                    ((Dictionary<string, object>)account)["used"] = this.safeString(entry, "locked");
                    object currencyId = this.safeStringN(entry, new List<object>() {"tokenId", "coin", "currencyCoin"});
                    object code = this.safeCurrencyCode(currencyId);
                    ((Dictionary<string, object>)result)[(string)code] = account;
                }
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object method = null;
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        if (isTrue(isSpot))
        {
            if (isTrue(isTrue(enableUnifiedAccount) || isTrue(enableUnifiedMargin)))
            {
                method = "privateGetSpotV3PrivateAccount";
            } else
            {
                object marginMode = null;
                                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
                marginMode = ((List<object>)marginModeparametersVariable)[0];
                parameters = ((List<object>)marginModeparametersVariable)[1];
                if (isTrue(!isEqual(marginMode, null)))
                {
                    method = "privateGetSpotV3PrivateCrossMarginAccount";
                } else
                {
                    method = "privateGetSpotV3PrivateAccount";
                }
            }
        } else if (isTrue(isTrue(enableUnifiedAccount) || isTrue(enableUnifiedMargin)))
        {
            if (isTrue(isEqual(type, "swap")))
            {
                type = "unified";
            }
        } else
        {
            if (isTrue(isEqual(type, "swap")))
            {
                type = "contract";
            }
        }
        if (!isTrue(isSpot))
        {
            object accountTypes = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
            object unifiedType = this.safeStringUpper(accountTypes, type, type);
            if (isTrue(isEqual(unifiedType, "FUND")))
            {
                // use this endpoint only we have no other choice
                // because it requires transfer permission
                method = "privateGetAssetV3PrivateTransferAccountCoinsBalanceQuery";
            } else
            {
                if (isTrue(enableUnifiedAccount))
                {
                    method = "privateGetV5AccountWalletBalance";
                } else
                {
                    method = "privateGetContractV3PrivateAccountWalletBalance";
                }
            }
            ((Dictionary<string, object>)request)["accountType"] = unifiedType;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // spot wallet
        //     {
        //       retCode: '0',
        //       retMsg: 'OK',
        //       result: {
        //         balances: [
        //           {
        //             coin: 'BTC',
        //             coinId: 'BTC',
        //             total: '0.00977041118',
        //             free: '0.00877041118',
        //             locked: '0.001'
        //           },
        //           {
        //             coin: 'EOS',
        //             coinId: 'EOS',
        //             total: '2000',
        //             free: '2000',
        //             locked: '0'
        //           }
        //         ]
        //       },
        //       retExtInfo: {},
        //       time: '1670002625754'
        //     }
        // cross
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "acctBalanceSum": "0.122995614474732872",
        //             "debtBalanceSum": "0.011734191124529754",
        //             "loanAccountList": [
        //                 {
        //                     "free": "0.001143855",
        //                     "interest": "0",
        //                     "loan": "0",
        //                     "locked": "0",
        //                     "tokenId": "BTC",
        //                     "total": "0.001143855"
        //                 },
        //                 {
        //                     "free": "200.00005568",
        //                     "interest": "0.0008391",
        //                     "loan": "200",
        //                     "locked": "0",
        //                     "tokenId": "USDT",
        //                     "total": "200.00005568"
        //                 },
        //             ],
        //             "riskRate": "0.0954",
        //             "status": 1
        //         },
        //         "retExtInfo": {},
        //         "time": 1669843584123
        //     }
        //
        // all coins balance
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "memberId": "533285",
        //             "accountType": "FUND",
        //             "balance": [
        //                 {
        //                     "coin": "USDT",
        //                     "transferBalance": "1010",
        //                     "walletBalance": "1010",
        //                     "bonus": ""
        //                 },
        //                 {
        //                     "coin": "USDC",
        //                     "transferBalance": "0",
        //                     "walletBalance": "0",
        //                     "bonus": ""
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1675865290069
        //     }
        //
        return this.parseBalance(response);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "PENDING_CANCEL", "open" },
            { "PENDING_NEW", "open" },
            { "REJECTED", "rejected" },
            { "PARTIALLY_FILLED_CANCELLED", "canceled" },
            { "Created", "open" },
            { "New", "open" },
            { "Rejected", "rejected" },
            { "PartiallyFilled", "open" },
            { "PartiallyFilledCanceled", "canceled" },
            { "Filled", "closed" },
            { "PendingCancel", "open" },
            { "Cancelled", "canceled" },
            { "Untriggered", "open" },
            { "Deactivated", "canceled" },
            { "Triggered", "open" },
            { "Active", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GoodTillCancel", "GTC" },
            { "ImmediateOrCancel", "IOC" },
            { "FillOrKill", "FOK" },
            { "PostOnly", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public override object parseOrder(object order, object market = null)
    {
        object orderCategoryExists = (((Dictionary<string,object>)order).ContainsKey(toStringOrNull("orderCategory")));
        if (isTrue(orderCategoryExists))
        {
            return this.parseSpotOrder(order, market);
        }
        return this.parseContractOrder(order, market);
    }

    public virtual object parseContractOrder(object order, object market = null)
    {
        //
        // contract v3
        //
        //     {
        //         "symbol": "XRPUSDT",
        //         "side": "Buy",
        //         "orderType": "Market",
        //         "price": "0.3431",
        //         "qty": "65",
        //         "reduceOnly": true,
        //         "timeInForce": "ImmediateOrCancel",
        //         "orderStatus": "Filled",
        //         "leavesQty": "0",
        //         "leavesValue": "0",
        //         "cumExecQty": "65",
        //         "cumExecValue": "21.3265",
        //         "cumExecFee": "0.0127959",
        //         "lastPriceOnCreated": "0.0000",
        //         "rejectReason": "EC_NoError",
        //         "orderLinkId": "",
        //         "createdTime": "1657526321499",
        //         "updatedTime": "1657526321504",
        //         "orderId": "ac0a8134-acb3-4ee1-a2d4-41891c9c46d7",
        //         "stopOrderType": "UNKNOWN",
        //         "takeProfit": "0.0000",
        //         "stopLoss": "0.0000",
        //         "tpTriggerBy": "UNKNOWN",
        //         "slTriggerBy": "UNKNOWN",
        //         "triggerPrice": "0.0000",
        //         "closeOnTrigger": true,
        //         "triggerDirection": 0,
        //         "positionIdx": 2
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        object marketType = "contract";
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
        }
        object category = this.safeString(order, "category");
        if (isTrue(!isEqual(category, null)))
        {
            if (isTrue(isEqual(category, "spot")))
            {
                marketType = "spot";
            }
        }
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(order, "createdTime");
        object id = this.safeString(order, "orderId");
        object type = this.safeStringLower(order, "orderType");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "qty");
        object cost = this.safeString(order, "cumExecValue");
        object filled = this.safeString(order, "cumExecQty");
        object remaining = this.safeString(order, "leavesQty");
        object lastTradeTimestamp = this.safeInteger(order, "updateTime");
        object rawStatus = this.safeString(order, "orderStatus");
        object status = this.parseOrderStatus(rawStatus);
        object side = this.safeStringLower(order, "side");
        object fee = null;
        object feeCostString = this.safeString(order, "cumExecFee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", getValue(market, "settle") },
            };
        }
        object clientOrderId = this.safeString(order, "orderLinkId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null;
        }
        object rawTimeInForce = this.safeString(order, "timeInForce");
        object timeInForce = this.parseTimeInForce(rawTimeInForce);
        object stopPrice = this.omitZero(this.safeString(order, "triggerPrice"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", null },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseSpotOrder(object order, object market = null)
    {
        //
        //  createOrder, cancelOrer
        //
        //     {
        //         "orderId": "1274754916287346280",
        //         "orderLinkId": "1666798627015730",
        //         "symbol": "AAVEUSDT",
        //         "createTime": "1666698629821",
        //         "orderPrice": "80",
        //         "orderQty": "0.11",
        //         "orderType": "LIMIT",
        //         "side": "BUY",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "accountId": "13380434",
        //         "execQty": "0",
        //         "orderCategory": "0"
        //     }
        //
        //     fetchOrder, fetchOpenOrders, fetchClosedOrders (and also for conditional orders) there are also present these additional fields:
        //     {
        //         "cummulativeQuoteQty": "0",
        //         "avgPrice": "0",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "updateTime": "1666733357444",
        //         "isWorking": "1",
        //         "locked": "8.8",
        //         "executedOrderId": "1279094037543962113", // in conditional order
        //         "triggerPrice": "0.99", // in conditional order
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market, null, "spot");
        object timestamp = this.safeInteger(order, "createTime");
        object type = this.safeStringLower(order, "orderType");
        object price = this.safeString(order, "orderPrice");
        if (isTrue(isTrue(isEqual(price, "0")) && isTrue(isEqual(type, "market"))))
        {
            price = null;
        }
        object filled = this.safeString(order, "execQty");
        object side = this.safeStringLower(order, "side");
        object timeInForce = this.parseTimeInForce(this.safeString(order, "timeInForce"));
        object triggerPrice = this.safeString(order, "triggerPrice");
        object postOnly = (isEqual(timeInForce, "PO"));
        object amount = null;
        if (isTrue(isTrue(isTrue(getValue(market, "spot")) && isTrue(isEqual(type, "market"))) && isTrue(isEqual(side, "buy"))))
        {
            amount = filled;
        } else
        {
            amount = this.safeString(order, "orderQty");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "orderLinkId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "updateTime") },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "stopPrice", triggerPrice },
            { "amount", amount },
            { "cost", this.safeString(order, "cummulativeQuoteQty") },
            { "average", this.safeString(order, "avgPrice") },
            { "filled", filled },
            { "remaining", null },
            { "status", this.parseOrderStatus(this.safeString(order, "status")) },
            { "fee", null },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object accounts = await this.isUnifiedEnabled();
        object isUnifiedAccount = this.safeValue(accounts, 1, false);
        if (isTrue(isUnifiedAccount))
        {
            throw new NotSupported ((string)add(this.id, " fetchOrder() does not support unified account. Please consider using fetchOpenOrders() or fetchClosedOrders()")) ;
        }
        if (isTrue(isEqual(type, "spot")))
        {
            // only spot markets have a dedicated endpoint for fetching a order
            object request = new Dictionary<string, object>() {
                { "orderId", id },
            };
            object response = await this.privateGetSpotV3PrivateOrder(this.extend(parameters, request));
            //
            //    {
            //        "retCode": "0",
            //        "retMsg": "OK",
            //        "result": {
            //            "accountId": "13380434",
            //            "symbol": "AAVEUSDT",
            //            "orderLinkId": "1666733357434617",
            //            "orderId": "1275046248585414144",
            //            "orderPrice": "80",
            //            "orderQty": "0.11",
            //            "execQty": "0",
            //            "cummulativeQuoteQty": "0",
            //            "avgPrice": "0",
            //            "status": "NEW",
            //            "timeInForce": "GTC",
            //            "orderType": "LIMIT",
            //            "side": "BUY",
            //            "stopPrice": "0.0",
            //            "icebergQty": "0.0",
            //            "createTime": "1666733357438",
            //            "updateTime": "1666733357444",
            //            "isWorking": "1",
            //            "locked": "8.8",
            //            "orderCategory": "0"
            //        },
            //        "retExtMap": {},
            //        "retExtInfo": null,
            //        "time": "1666733357744"
            //    }
            //
            object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
            return this.parseOrder(result, market);
        } else
        {
            this.checkRequiredSymbol("fetchOrder", symbol);
            object request = new Dictionary<string, object>() {
                { "orderId", id },
            };
            object result = await this.fetchOrders(symbol, null, null, this.extend(request, parameters));
            object length = getArrayLength(result);
            if (isTrue(isEqual(length, 0)))
            {
                throw new OrderNotFound ((string)add(add("Order ", id), " does not exist.")) ;
            }
            if (isTrue(isGreaterThan(length, 1)))
            {
                throw new InvalidOrder ((string)add(this.id, " returned more than one order")) ;
            }
            return this.safeValue(result, 0);
        }
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#createOrder
        * @description create a trade order
        * @see https://bybit-exchange.github.io/docs/v5/order/create-order
        * @see https://bybit-exchange.github.io/docs/spot/trade/place-order
        * @see https://bybit-exchange.github.io/docs/derivatives/unified/place-order
        * @see https://bybit-exchange.github.io/docs/derivatives/contract/place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbol("createOrder", symbol);
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        object isUSDCSettled = isEqual(getValue(market, "settle"), "USDC");
        if (isTrue(isTrue(enableUnifiedAccount) && !isTrue(getValue(market, "inverse"))))
        {
            return await this.createUnifiedAccountOrder(symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "spot")))
        {
            return await this.createSpotOrder(symbol, type, side, amount, price, parameters);
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(getValue(market, "inverse"))))
        {
            return await this.createUnifiedMarginOrder(symbol, type, side, amount, price, parameters);
        } else if (isTrue(isUSDCSettled))
        {
            return await this.createUsdcOrder(symbol, type, side, amount, price, parameters);
        } else
        {
            return await this.createContractV3Order(symbol, type, side, amount, price, parameters);
        }
    }

    public async virtual Task<object> createUnifiedAccountOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object lowerCaseType = ((string)type).ToLower();
        if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(lowerCaseType, "limit")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder requires a price argument for limit orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", this.capitalize(lowerCaseType) },
        };
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else if (isTrue(getValue(market, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder does not allow inverse market orders for "), symbol), " markets")) ;
        }
        if (isTrue(isTrue(isTrue(getValue(market, "spot")) && isTrue((isEqual(type, "market")))) && isTrue((isEqual(side, "buy")))))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(getValue(this.options, "createMarketBuyOrderRequiresPrice")))
            {
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(isTrue(isEqual(price, null)) && isTrue(isEqual(cost, null))))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\'createMarketBuyOrderRequiresPrice\'] = false to supply the cost in the amount argument (the exchange-specific behaviour)")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object quoteAmount = Precise.stringMul(amountString, priceString);
                    amount = ((bool) isTrue((!isEqual(cost, null)))) ? cost : this.parseNumber(quoteAmount);
                    ((Dictionary<string, object>)request)["qty"] = this.costToPrecision(symbol, amount);
                }
            }
        } else
        {
            ((Dictionary<string, object>)request)["qty"] = this.amountToPrecision(symbol, amount);
        }
        object isMarket = isEqual(lowerCaseType, "market");
        object isLimit = isEqual(lowerCaseType, "limit");
        if (isTrue(isLimit))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object exchangeSpecificParam = this.safeString(parameters, "time_in_force");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, isEqual(exchangeSpecificParam, "PostOnly"), parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "gtc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "GTC";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "FOK";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "IOC";
        }
        object triggerPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
        object stopLoss = this.safeNumber(parameters, "stopLoss");
        object takeProfit = this.safeNumber(parameters, "takeProfit");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        object isBuy = isEqual(side, "buy");
        object ascending = ((bool) isTrue(stopLossTriggerPrice)) ? !isTrue(isBuy) : isBuy;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerDirection"] = ((bool) isTrue(ascending)) ? 2 : 1;
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
        {
            ((Dictionary<string, object>)request)["triggerDirection"] = ((bool) isTrue(ascending)) ? 2 : 1;
            triggerPrice = ((bool) isTrue(isStopLossTriggerOrder)) ? stopLossTriggerPrice : takeProfitTriggerPrice;
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((Dictionary<string, object>)request)["reduceOnly"] = true;
        } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            if (isTrue(isStopLoss))
            {
                ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLoss);
            }
            if (isTrue(isTakeProfit))
            {
                ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfit);
            }
        }
        if (isTrue(getValue(market, "spot")))
        {
            // only works for spot market
            if (isTrue(isTrue(isTrue(isTrue(isTrue(!isEqual(triggerPrice, null)) || isTrue(!isEqual(stopLossTriggerPrice, null))) || isTrue(!isEqual(takeProfitTriggerPrice, null))) || isTrue(isStopLoss)) || isTrue(isTakeProfit)))
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "tpslOrder";
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        } else if (isTrue(getValue(market, "option")))
        {
            // mandatory field for options
            ((Dictionary<string, object>)request)["orderLinkId"] = this.uuid16();
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "timeInForce", "stopLossPrice", "takeProfitPrice", "postOnly", "clientOrderId"});
        object response = await this.privatePostV5OrderCreate(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "1321003749386327552",
        //             "orderLinkId": "spot-test-postonly"
        //         },
        //         "retExtInfo": {},
        //         "time": 1672211918471
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> createSpotOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object upperCaseType = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", upperCaseType },
            { "timeInForce", "GTC" },
        };
        if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(getValue(this.options, "createMarketBuyOrderRequiresPrice")))
            {
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(isTrue(isEqual(price, null)) && isTrue(isEqual(cost, null))))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\'createMarketBuyOrderRequiresPrice\'] = false to supply the cost in the amount argument (the exchange-specific behaviour)")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object quoteAmount = Precise.stringMul(amountString, priceString);
                    amount = ((bool) isTrue((!isEqual(cost, null)))) ? cost : this.parseNumber(quoteAmount);
                    ((Dictionary<string, object>)request)["orderQty"] = this.costToPrecision(symbol, amount);
                }
            }
        } else
        {
            ((Dictionary<string, object>)request)["orderQty"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(isTrue((isEqual(upperCaseType, "LIMIT"))) || isTrue((isEqual(upperCaseType, "LIMIT_MAKER")))))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder requires a price argument for a "), type), " order")) ;
            }
            ((Dictionary<string, object>)request)["orderPrice"] = this.priceToPrecision(symbol, price);
        }
        object isPostOnly = this.isPostOnly(isEqual(upperCaseType, "MARKET"), isEqual(type, "LIMIT_MAKER"), parameters);
        if (isTrue(isPostOnly))
        {
            ((Dictionary<string, object>)request)["orderType"] = "LIMIT_MAKER";
        }
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "orderLinkId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "orderLinkId", "postOnly"});
        object brokerId = this.safeString(this.options, "brokerId");
        if (isTrue(!isEqual(brokerId, null)))
        {
            ((Dictionary<string, object>)request)["agentSource"] = brokerId;
        }
        object triggerPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        parameters = this.omit(parameters, "stopPrice");
        object response = await this.privatePostSpotV3PrivateOrder(this.extend(request, parameters));
        //
        //    {
        //        "retCode": "0",
        //        "retMsg": "OK",
        //        "result": {
        //            "orderId": "1274754916287346280",
        //            "orderLinkId": "1666798627015730",
        //            "symbol": "AAVEUSDT",
        //            "createTime": "1666698629821",
        //            "orderPrice": "80",
        //            "orderQty": "0.11",
        //            "orderType": "LIMIT",
        //            "side": "BUY",
        //            "status": "NEW",
        //            "timeInForce": "GTC",
        //            "accountId": "13380434",
        //            "execQty": "0",
        //            "orderCategory": "0"
        //        },
        //        "retExtMap": {},
        //        "retExtInfo": null,
        //        "time": "1666698627926"
        //    }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> createUnifiedMarginOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isTrue(getValue(market, "linear")) && !isTrue(getValue(market, "option"))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder does not allow inverse market orders for "), symbol), " markets")) ;
        }
        object lowerCaseType = ((string)type).ToLower();
        if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(lowerCaseType, "limit")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder requires a price argument for limit orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", this.capitalize(lowerCaseType) },
            { "timeInForce", "GoodTillCancel" },
            { "qty", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        }
        object isMarket = isEqual(lowerCaseType, "market");
        object isLimit = isEqual(lowerCaseType, "limit");
        if (isTrue(isLimit))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object exchangeSpecificParam = this.safeString(parameters, "time_in_force");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, isEqual(exchangeSpecificParam, "PostOnly"), parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "gtc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "GoodTillCancel";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "FillOrKill";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "ImmediateOrCancel";
        }
        object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice", triggerPrice);
        object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
        object stopLoss = this.safeNumber(parameters, "stopLoss");
        object takeProfit = this.safeNumber(parameters, "takeProfit");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
        {
            ((Dictionary<string, object>)request)["triggerBy"] = "LastPrice";
            object triggerAt = ((bool) isTrue(isStopLossTriggerOrder)) ? stopLossTriggerPrice : takeProfitTriggerPrice;
            object preciseTriggerPrice = this.priceToPrecision(symbol, triggerAt);
            ((Dictionary<string, object>)request)["triggerPrice"] = preciseTriggerPrice;
            object isBuy = isEqual(side, "buy");
            // logical xor
            object ascending = ((bool) isTrue(stopLossTriggerPrice)) ? !isTrue(isBuy) : isBuy;
            object delta = this.numberToString(getValue(getValue(market, "precision"), "price"));
            ((Dictionary<string, object>)request)["basePrice"] = ((bool) isTrue(ascending)) ? Precise.stringAdd(preciseTriggerPrice, delta) : Precise.stringSub(preciseTriggerPrice, delta);
        } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            if (isTrue(isStopLoss))
            {
                ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLoss);
            }
            if (isTrue(isTakeProfit))
            {
                ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfit);
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        } else if (isTrue(getValue(market, "option")))
        {
            // mandatory field for options
            ((Dictionary<string, object>)request)["orderLinkId"] = this.uuid16();
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "postOnly", "clientOrderId"});
        object response = await this.privatePostUnifiedV3PrivateOrderCreate(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "e10b0716-7c91-4091-b98a-1fa0f401c7d5",
        //             "orderLinkId": "test0000003"
        //         },
        //         "retExtInfo": null,
        //         "time": 1664441344238
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> createContractV3Order(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object lowerCaseType = ((string)type).ToLower();
        if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(lowerCaseType, "limit")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createContractV3Order requires a price argument for limit orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", this.capitalize(lowerCaseType) },
            { "timeInForce", "GoodTillCancel" },
            { "qty", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(getValue(market, "future")))
        {
            object positionIdx = this.safeInteger(parameters, "position_idx", 0); // 0 One-Way Mode, 1 Buy-side, 2 Sell-side
            ((Dictionary<string, object>)request)["position_idx"] = positionIdx;
            parameters = this.omit(parameters, "position_idx");
        }
        object isMarket = isEqual(lowerCaseType, "market");
        object isLimit = isEqual(lowerCaseType, "limit");
        if (isTrue(isLimit))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object exchangeSpecificParam = this.safeString(parameters, "time_in_force");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, isEqual(exchangeSpecificParam, "PostOnly"), parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "gtc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "GoodTillCancel";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "FillOrKill";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "ImmediateOrCancel";
        }
        object triggerPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
        object stopLoss = this.safeNumber(parameters, "stopLoss");
        object takeProfit = this.safeNumber(parameters, "takeProfit");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        object isBuy = isEqual(side, "buy");
        object ascending = ((bool) isTrue(stopLossTriggerPrice)) ? !isTrue(isBuy) : isBuy;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerDirection"] = ((bool) isTrue(ascending)) ? 2 : 1;
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
        {
            ((Dictionary<string, object>)request)["triggerDirection"] = ((bool) isTrue(ascending)) ? 2 : 1;
            triggerPrice = ((bool) isTrue(isStopLossTriggerOrder)) ? stopLossTriggerPrice : takeProfitTriggerPrice;
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((Dictionary<string, object>)request)["reduceOnly"] = true;
        } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            if (isTrue(isStopLoss))
            {
                ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLoss);
            }
            if (isTrue(isTakeProfit))
            {
                ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfit);
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        } else if (isTrue(getValue(market, "option")))
        {
            // mandatory field for options
            ((Dictionary<string, object>)request)["orderLinkId"] = this.uuid16();
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "timeInForce", "stopLossPrice", "takeProfitPrice", "postOnly", "clientOrderId"});
        object response = await this.privatePostContractV3PrivateOrderCreate(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "e10b0716-7c91-4091-b98a-1fa0f401c7d5",
        //             "orderLinkId": "test0000003"
        //         },
        //         "retExtInfo": null,
        //         "time": 1664441344238
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> createUsdcOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(type, "market")))
        {
            throw new NotSupported ((string)add(add(add(this.id, "createOrder does not allow market orders for "), symbol), " markets")) ;
        }
        object lowerCaseType = ((string)type).ToLower();
        if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(lowerCaseType, "limit")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder requires a price argument for limit orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", this.capitalize(lowerCaseType) },
            { "timeInForce", "GoodTillCancel" },
            { "orderQty", this.amountToPrecision(symbol, amount) },
        };
        object isMarket = isEqual(lowerCaseType, "market");
        object isLimit = isEqual(lowerCaseType, "limit");
        if (isTrue(!isEqual(isLimit, null)))
        {
            ((Dictionary<string, object>)request)["orderPrice"] = this.priceToPrecision(symbol, price);
        }
        object exchangeSpecificParam = this.safeString(parameters, "time_in_force");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, isEqual(exchangeSpecificParam, "PostOnly"), parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["time_in_force"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "gtc")))
        {
            ((Dictionary<string, object>)request)["time_in_force"] = "GoodTillCancel";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["time_in_force"] = "FillOrKill";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["time_in_force"] = "ImmediateOrCancel";
        }
        if (isTrue(getValue(market, "swap")))
        {
            object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
            object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice", triggerPrice);
            object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
            object stopLoss = this.safeNumber(parameters, "stopLoss");
            object takeProfit = this.safeNumber(parameters, "takeProfit");
            object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
            object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
            object isStopLoss = !isEqual(stopLoss, null);
            object isTakeProfit = !isEqual(takeProfit, null);
            object isStopOrder = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
            if (isTrue(isStopOrder))
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
                ((Dictionary<string, object>)request)["trigger_by"] = "LastPrice";
                object stopPx = ((bool) isTrue(isStopLossTriggerOrder)) ? stopLossTriggerPrice : takeProfitTriggerPrice;
                object preciseStopPrice = this.priceToPrecision(symbol, stopPx);
                ((Dictionary<string, object>)request)["triggerPrice"] = preciseStopPrice;
                object delta = this.numberToString(getValue(getValue(market, "precision"), "price"));
                ((Dictionary<string, object>)request)["basePrice"] = ((bool) isTrue(isStopLossTriggerOrder)) ? Precise.stringSub(preciseStopPrice, delta) : Precise.stringAdd(preciseStopPrice, delta);
            } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                if (isTrue(isStopLoss))
                {
                    ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLoss);
                }
                if (isTrue(isTakeProfit))
                {
                    ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfit);
                }
            } else
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "Order";
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        } else if (isTrue(getValue(market, "option")))
        {
            // mandatory field for options
            ((Dictionary<string, object>)request)["orderLinkId"] = this.uuid16();
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "postOnly", "clientOrderId"});
        object method = ((bool) isTrue(getValue(market, "option"))) ? "privatePostOptionUsdcOpenapiPrivateV1PlaceOrder" : "privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder";
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"",
        //         "result":{
        //            "orderId":"34450a59-325e-4296-8af0-63c7c524ae33",
        //            "orderLinkId":"",
        //            "mmp":false,
        //            "symbol":"BTCPERP",
        //            "orderType":"Limit",
        //            "side":"Buy",
        //            "orderQty":"0.00100000",
        //            "orderPrice":"20000.00",
        //            "iv":"0",
        //            "timeInForce":"GoodTillCancel",
        //            "orderStatus":"Created",
        //            "createdAt":"1652261746007873",
        //            "basePrice":"0.00",
        //            "triggerPrice":"0.00",
        //            "takeProfit":"0.00",
        //            "stopLoss":"0.00",
        //            "slTriggerBy":"UNKNOWN",
        //            "tpTriggerBy":"UNKNOWN"
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> editUnifiedAccountOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isTrue(getValue(market, "linear")) && !isTrue(getValue(market, "option"))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder does not allow inverse market orders for "), symbol), " markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
            { "qty", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        if (isTrue(isStopLossOrder))
        {
            ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        if (isTrue(isTakeProfitOrder))
        {
            ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        object response = await this.privatePostV5OrderAmend(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "c6f055d9-7f21-4079-913d-e6523a9cfffa",
        //             "orderLinkId": "linear-004"
        //         },
        //         "retExtInfo": {},
        //         "time": 1672217093461
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(result, "orderId") },
        };
    }

    public async virtual Task<object> editUnifiedMarginOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isTrue(getValue(market, "linear")) && !isTrue(getValue(market, "option"))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder does not allow inverse market orders for "), symbol), " markets")) ;
        }
        object lowerCaseType = ((string)type).ToLower();
        if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(lowerCaseType, "limit")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder requires a price argument for limit orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderType", this.capitalize(lowerCaseType) },
            { "timeInForce", "GoodTillCancel" },
            { "qty", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        }
        object isMarket = isEqual(lowerCaseType, "market");
        object isLimit = isEqual(lowerCaseType, "limit");
        if (isTrue(isLimit))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object exchangeSpecificParam = this.safeString(parameters, "time_in_force");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, isEqual(exchangeSpecificParam, "PostOnly"), parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "gtc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "GoodTillCancel";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "FillOrKill";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "ImmediateOrCancel";
        }
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        if (isTrue(isStopLossOrder))
        {
            ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        if (isTrue(isTakeProfitOrder))
        {
            ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerBy"] = "LastPrice";
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["orderLinkId"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "postOnly", "clientOrderId"});
        object response = await this.privatePostUnifiedV3PrivateOrderReplace(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "42c86d66331e41998d12c2440ce90c1a",
        //             "orderLinkId": "e80d558e-ed"
        //         }
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async virtual Task<object> editContractV3Order(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
            { "qty", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        if (isTrue(isStopLossOrder))
        {
            ((Dictionary<string, object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        if (isTrue(isTakeProfitOrder))
        {
            ((Dictionary<string, object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        object response = await this.privatePostContractV3PrivateOrderReplace(this.extend(request, parameters));
        //
        // contract v3
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "db8b74b3-72d3-4264-bf3f-52d39b41956e",
        //             "orderLinkId": "x002"
        //         },
        //         "retExtInfo": {},
        //         "time": 1658902610749
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(result, "orderId") },
        };
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        if (isTrue(enableUnifiedAccount))
        {
            return await this.editUnifiedAccountOrder(id, symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " editOrder() does not support spot markets")) ;
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(getValue(market, "inverse"))))
        {
            return await this.editUnifiedMarginOrder(id, symbol, type, side, amount, price, parameters);
        }
        return await this.editContractV3Order(id, symbol, type, side, amount, price, parameters);
    }

    public async virtual Task<object> cancelUnifiedAccountOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "spot")))
        {
            // only works for spot market
            object isStop = this.safeValue(parameters, "stop", false);
            parameters = this.omit(parameters, new List<object>() {"stop"});
            ((Dictionary<string, object>)request)["orderFilter"] = ((bool) isTrue(isStop)) ? "tpslOrder" : "Order";
        }
        if (isTrue(!isEqual(id, null)))
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else if (isTrue(getValue(market, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not allow inverse market orders for "), symbol), " markets")) ;
        }
        object response = await this.privatePostV5OrderCancel(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "c6f055d9-7f21-4079-913d-e6523a9cfffa",
        //             "orderLinkId": "linear-004"
        //         },
        //         "retExtInfo": {},
        //         "time": 1672217377164
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public async virtual Task<object> cancelSpotOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(id, null)))
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        object response = await this.privatePostSpotV3PrivateCancelOrder(this.extend(request, parameters));
        //
        //     {
        //         "retCode": "0",
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "1275046248585414144",
        //             "orderLinkId": "1666733357434617",
        //             "symbol": "AAVEUSDT",
        //             "status": "NEW",
        //             "accountId": "13380434",
        //             "createTime": "1666733357438",
        //             "orderPrice": "80",
        //             "orderQty": "0.11",
        //             "execQty": "0",
        //             "timeInForce": "GTC",
        //             "orderType": "LIMIT",
        //             "side": "BUY",
        //             "orderCategory": "0"
        //         },
        //         "retExtMap": {},
        //         "retExtInfo": null,
        //         "time": "1666733839493"
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public async virtual Task<object> cancelUnifiedMarginOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelUnifiedMarginOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        ((Dictionary<string, object>)request)["orderFilter"] = ((bool) isTrue(isStop)) ? "StopOrder" : "Order";
        if (isTrue(!isEqual(id, null)))
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        if (isTrue(getValue(market, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        } else if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelUnifiedMarginOrder() does not allow inverse market orders for "), symbol), " markets")) ;
        }
        object response = await this.privatePostUnifiedV3PrivateOrderCancel(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "orderId": "42c86d66331e41998d12c2440ce90c1a",
        //             "orderLinkId": "e80d558e-ed"
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public async virtual Task<object> cancelUSDCOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelUSDCOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        object method = null;
        if (isTrue(!isEqual(id, null)))
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        if (isTrue(getValue(market, "option")))
        {
            method = "privatePostOptionUsdcOpenapiPrivateV1CancelOrder";
        } else
        {
            method = "privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder";
            ((Dictionary<string, object>)request)["orderFilter"] = ((bool) isTrue(isStop)) ? "StopOrder" : "Order";
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "outRequestId": "",
        //             "symbol": "BTC-13MAY22-40000-C",
        //             "orderId": "8c65df91-91fc-461d-9b14-786379ef138c",
        //             "orderLinkId": ""
        //         },
        //         "retExtMap": {}
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public async virtual Task<object> cancelDerivativesOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelDerivativesOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object response = await this.privatePostContractV3PrivateOrderCancel(this.extend(request, parameters));
        //
        // contract v3
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"OK",
        //         "result":{
        //             "orderId": "4030430d-1dba-4134-ac77-3d81c14aaa00",
        //             "orderLinkId": ""
        //         },
        //         "retExtInfo":null,
        //         "time":1658850321861
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        object isUsdcSettled = isEqual(getValue(market, "settle"), "USDC");
        if (isTrue(enableUnifiedAccount))
        {
            return await this.cancelUnifiedAccountOrder(id, symbol, parameters);
        } else if (isTrue(getValue(market, "spot")))
        {
            return await this.cancelSpotOrder(id, symbol, parameters);
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(getValue(market, "inverse"))))
        {
            return await this.cancelUnifiedMarginOrder(id, symbol, parameters);
        } else if (isTrue(isUsdcSettled))
        {
            return await this.cancelUSDCOrder(id, symbol, parameters);
        }
        return await this.cancelDerivativesOrder(id, symbol, parameters);
    }

    public async virtual Task<object> cancelAllUnifiedAccountOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = null;
        object type = null;
        object subType = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        } else
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "settle", "USDT");
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
                var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
                var subTypeparametersVariable = this.handleSubTypeAndParams("cancelAllOrders", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else if (isTrue(isEqual(type, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        } else if (isTrue(isEqual(subType, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() does not allow inverse market orders for "), type), " markets")) ;
        }
        ((Dictionary<string, object>)request)["settleCoin"] = settle;
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "tpslOrder";
        }
        object response = await this.privatePostV5OrderCancelAll(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "orderId": "f6a73e1f-39b5-4dee-af21-1460b2e3b27c",
        //                     "orderLinkId": "a001"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672219780463
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object orders = this.safeValue(result, "list");
        if (!isTrue((orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return response;
        }
        return this.parseOrders(orders, market);
    }

    public async virtual Task<object> cancelAllSpotOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllSpotOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateDeleteSpotOrderBatchCancel(this.extend(request, parameters));
        //
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": {
        //            "success": true
        //        }
        //    }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        if (!isTrue((result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return response;
        }
        return this.parseOrders(result, market);
    }

    public async virtual Task<object> cancelAllUnifiedMarginOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("cancelAllOrders", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = subType;
                var settleparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "settle", settle);
        settle = ((List<object>)settleparametersVariable)[0];
        parameters = ((List<object>)settleparametersVariable)[1];
        if (isTrue(!isEqual(settle, null)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
        }
        object response = await this.privatePostUnifiedV3PrivateOrderCancelAll(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [{
        //                     "category": "option",
        //                     "symbol": "BTC-24JUN22-45000-P",
        //                     "orderId": "bd5f3b34-d64d-4b60-8188-438fbea4c552",
        //                     "orderLinkId": "ac4e3b34-d64d-4b60-8188-438fbea4c552",
        //                 }, {
        //                     "category": "option",
        //                     "symbol": "BTC-24JUN22-45000-P",
        //                     "orderId": "4ddd727a-2af8-430e-a293-42895e594d18",
        //                     "orderLinkId": "5cee727a-2af8-430e-a293-42895e594d18",
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {
        //             "list": [{
        //                 "code": 0,
        //                 "msg": "OK"
        //             }, {
        //                 "code": 0,
        //                 "msg": "OK"
        //             }]
        //         },
        //         "time": 1657200736570
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object orders = this.safeValue(result, "list");
        if (!isTrue((orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return response;
        }
        return this.parseOrders(orders, market);
    }

    public async virtual Task<object> cancelAllUSDCOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllUSDCOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = null;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "option")))
        {
            method = "privatePostOptionUsdcOpenapiPrivateV1CancelAll";
        } else
        {
            method = "privatePostPerpetualUsdcOpenapiPrivateV1CancelAll";
            object isStop = this.safeValue(parameters, "stop", false);
            if (isTrue(isStop))
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
            } else
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "Order";
            }
            parameters = this.omit(parameters, new List<object>() {"stop"});
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "retExtMap": {},
        //         "result": [
        //             {
        //                 "outRequestId": "cancelAll-290119-1652176443114-0",
        //                 "symbol": "BTC-13MAY22-40000-C",
        //                 "orderId": "fa6cd740-56ed-477d-9385-90ccbfee49ca",
        //                 "orderLinkId": "",
        //                 "errorCode": 0,
        //                 "errorDesc": ""
        //             }
        //         ]
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        if (!isTrue((result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return response;
        }
        return this.parseOrders(result, market);
    }

    public async virtual Task<object> cancelAllDerivativesOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
                var settleparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "settle", settle);
        settle = ((List<object>)settleparametersVariable)[0];
        parameters = ((List<object>)settleparametersVariable)[1];
        if (isTrue(!isEqual(settle, null)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        object response = await this.privatePostContractV3PrivateOrderCancelAll(this.extend(request, parameters));
        //
        // contract v3
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "orderId": "4030430d-1dba-4134-ac77-3d81c14aaa00",
        //                     "orderLinkId": "x001"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1658901359225
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object orders = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(orders, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = this.safeString(parameters, "settleCoin");
        if (isTrue(isEqual(settle, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "settle", settle);
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("cancelAllOrders", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object isUsdcSettled = isEqual(settle, "USDC");
        object isInverse = isEqual(subType, "inverse");
        object isLinearSettle = isTrue(isUsdcSettled) || isTrue((isEqual(settle, "USDT")));
        if (isTrue(isTrue(isInverse) && isTrue(isLinearSettle)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders with inverse subType requires settle to not be USDT or USDC")) ;
        }
        var typequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        if (isTrue(enableUnifiedAccount))
        {
            return await this.cancelAllUnifiedAccountOrders(symbol, query);
        } else if (isTrue(isEqual(type, "spot")))
        {
            return await this.cancelAllSpotOrders(symbol, query);
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(isInverse)))
        {
            return await this.cancelAllUnifiedMarginOrders(symbol, query);
        } else if (isTrue(isUsdcSettled))
        {
            return await this.cancelAllUSDCOrders(symbol, query);
        } else
        {
            return await this.cancelAllDerivativesOrders(symbol, query);
        }
    }

    public async virtual Task<object> fetchUnifiedAccountOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(isEqual(symbol, null)))
        {
            object type = null;
                        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
            type = ((List<object>)typeparametersVariable)[0];
            parameters = ((List<object>)typeparametersVariable)[1];
            // option, spot
            ((Dictionary<string, object>)request)["category"] = type;
            if (isTrue(isEqual(type, "swap")))
            {
                object subType = null;
                                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrders", market, parameters, "linear");
                subType = ((List<object>)subTypeparametersVariable)[0];
                parameters = ((List<object>)subTypeparametersVariable)[1];
                ((Dictionary<string, object>)request)["category"] = subType;
            }
        } else
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "spot")))
            {
                ((Dictionary<string, object>)request)["category"] = "spot";
            } else if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchOrders() does not allow inverse market orders for "), symbol), " markets")) ;
            }
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            if (isTrue(getValue(market, "spot")))
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "tpslOrder";
            } else
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5OrderHistory(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "03234de9-1332-41eb-b805-4a9f42c136a3%3A1672220109387%2C03234de9-1332-41eb-b805-4a9f42c136a3%3A1672220109387",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "Limit",
        //                     "orderLinkId": "test-001",
        //                     "orderId": "03234de9-1332-41eb-b805-4a9f42c136a3",
        //                     "cancelType": "CancelByUser",
        //                     "avgPrice": "0",
        //                     "stopOrderType": "UNKNOWN",
        //                     "lastPriceOnCreated": "16656.5",
        //                     "orderStatus": "Cancelled",
        //                     "takeProfit": "",
        //                     "cumExecValue": "0",
        //                     "triggerDirection": 0,
        //                     "blockTradeId": "",
        //                     "rejectReason": "EC_PerCancelRequest",
        //                     "isLeverage": "",
        //                     "price": "18000",
        //                     "orderIv": "",
        //                     "createdTime": "1672220109387",
        //                     "tpTriggerBy": "UNKNOWN",
        //                     "positionIdx": 0,
        //                     "timeInForce": "GoodTillCancel",
        //                     "leavesValue": "0",
        //                     "updatedTime": "1672220114123",
        //                     "side": "Sell",
        //                     "triggerPrice": "",
        //                     "cumExecFee": "0",
        //                     "slTriggerBy": "UNKNOWN",
        //                     "leavesQty": "0",
        //                     "closeOnTrigger": false,
        //                     "cumExecQty": "0",
        //                     "reduceOnly": false,
        //                     "qty": "0.1",
        //                     "stopLoss": "",
        //                     "triggerBy": "UNKNOWN"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672221263862
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchUnifiedMarginOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(isEqual(symbol, null)))
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchUnifiedMarginOrders", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = subType;
        } else
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchUnifiedMarginOrders() does not allow inverse market orders for "), symbol), " markets")) ;
            }
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetUnifiedV3PrivateOrderList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //         "nextPageCursor": "7d17d359-4e38-4d3a-9a31-29791ef2dfd7%3A1657711949928%2C7d17d359-4e38-4d3a-9a31-29791ef2dfd7%3A1657711949928",
        //         "category": "linear",
        //         "list": [
        //             {
        //                 "symbol": "ETHUSDT",
        //                 "orderType": "Market",
        //                 "orderLinkId": "",
        //                 "orderId": "7d17d359-4e38-4d3a-9a31-29791ef2dfd7",
        //                 "stopOrderType": "UNKNOWN",
        //                 "orderStatus": "Filled",
        //                 "takeProfit": "",
        //                 "cumExecValue": "536.92500000",
        //                 "blockTradeId": "",
        //                 "rejectReason": "EC_NoError",
        //                 "price": "1127.10000000",
        //                 "createdTime": 1657711949928,
        //                 "tpTriggerBy": "UNKNOWN",
        //                 "timeInForce": "ImmediateOrCancel",
        //                 "basePrice": "",
        //                 "leavesValue": "0.00000000",
        //                 "updatedTime": 1657711949945,
        //                 "side": "Buy",
        //                 "triggerPrice": "",
        //                 "cumExecFee": "0.32215500",
        //                 "slTriggerBy": "UNKNOWN",
        //                 "leavesQty": "0.0000",
        //                 "closeOnTrigger": false,
        //                 "cumExecQty": "0.5000",
        //                 "reduceOnly": false,
        //                 "qty": "0.5000",
        //                 "stopLoss": "",
        //                 "triggerBy": "UNKNOWN",
        //                 "orderIM": ""
        //             }]
        //         },
        //         "time": 1657713451741
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchDerivativesOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(symbol, null)))
        {
            object type = null;
                        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
            type = ((List<object>)typeparametersVariable)[0];
            parameters = ((List<object>)typeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = type;
            if (isTrue(isEqual(type, "swap")))
            {
                object subType = null;
                                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrders", market, parameters, "linear");
                subType = ((List<object>)subTypeparametersVariable)[0];
                parameters = ((List<object>)subTypeparametersVariable)[1];
                ((Dictionary<string, object>)request)["category"] = subType;
            }
        } else
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            }
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5OrderHistory(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "03234de9-1332-41eb-b805-4a9f42c136a3%3A1672220109387%2C03234de9-1332-41eb-b805-4a9f42c136a3%3A1672220109387",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "Limit",
        //                     "orderLinkId": "test-001",
        //                     "orderId": "03234de9-1332-41eb-b805-4a9f42c136a3",
        //                     "cancelType": "CancelByUser",
        //                     "avgPrice": "0",
        //                     "stopOrderType": "UNKNOWN",
        //                     "lastPriceOnCreated": "16656.5",
        //                     "orderStatus": "Cancelled",
        //                     "takeProfit": "",
        //                     "cumExecValue": "0",
        //                     "triggerDirection": 0,
        //                     "blockTradeId": "",
        //                     "rejectReason": "EC_PerCancelRequest",
        //                     "isLeverage": "",
        //                     "price": "18000",
        //                     "orderIv": "",
        //                     "createdTime": "1672220109387",
        //                     "tpTriggerBy": "UNKNOWN",
        //                     "positionIdx": 0,
        //                     "timeInForce": "GoodTillCancel",
        //                     "leavesValue": "0",
        //                     "updatedTime": "1672220114123",
        //                     "side": "Sell",
        //                     "triggerPrice": "",
        //                     "cumExecFee": "0",
        //                     "slTriggerBy": "UNKNOWN",
        //                     "leavesQty": "0",
        //                     "closeOnTrigger": false,
        //                     "cumExecQty": "0",
        //                     "reduceOnly": false,
        //                     "qty": "0.1",
        //                     "stopLoss": "",
        //                     "triggerBy": "UNKNOWN"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672221263862
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = this.safeString(parameters, "settleCoin");
        if (isTrue(isEqual(settle, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "settle", settle);
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrders", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object isInverse = isEqual(subType, "inverse");
        object isUsdcSettled = isEqual(settle, "USDC");
        object isLinearSettle = isTrue(isUsdcSettled) || isTrue((isEqual(settle, "USDT")));
        if (isTrue(isTrue(isInverse) && isTrue(isLinearSettle)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders with inverse subType requires settle to not be USDT or USDC")) ;
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        if (isTrue(isTrue(enableUnifiedAccount) && !isTrue(isInverse)))
        {
            return await this.fetchUnifiedAccountOrders(symbol, since, limit, query);
        } else if (isTrue(isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrders() only support "), type), " markets for unified trade account, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead")) ;
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(isInverse)))
        {
            return await this.fetchUnifiedMarginOrders(symbol, since, limit, query);
        } else
        {
            return await this.fetchDerivativesOrders(symbol, since, limit, query);
        }
    }

    public async virtual Task<object> fetchSpotClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object response = await this.privateGetSpotV3PrivateHistoryOrders(this.extend(request, parameters));
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        //
        //    {
        //        "retCode": "0",
        //        "retMsg": "OK",
        //        "result": {
        //            "list": [
        //                {
        //                    "accountId": "13380434",
        //                    "symbol": "AAVEUSDT",
        //                    "orderLinkId": "1666697847966604",
        //                    "orderId": "1274748373594828288",
        //                    "orderPrice": "80",
        //                    "orderQty": "0.11",
        //                    "execQty": "0",
        //                    "cummulativeQuoteQty": "0",
        //                    "avgPrice": "0",
        //                    "status": "CANCELED",
        //                    "timeInForce": "GTC",
        //                    "orderType": "LIMIT",
        //                    "side": "BUY",
        //                    "stopPrice": "0.0",
        //                    "icebergQty": "0.0",
        //                    "createTime": "1666697847972",
        //                    "updateTime": "1666697865809",
        //                    "isWorking": "1",
        //                    "orderCategory": "0"
        //                },
        //            ]
        //        },
        //        "retExtInfo": null,
        //        "time": "1666732287588"
        //    }
        //
        object orders = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object enableUnified = await this.isUnifiedEnabled();
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue((isEqual(type, "spot"))) && !isTrue(getValue(enableUnified, 1))))
        {
            return await this.fetchSpotClosedOrders(symbol, since, limit, parameters);
        } else
        {
            ((Dictionary<string, object>)request)["orderStatus"] = "Filled";
        }
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since timestamp in ms of the earliest order, default is undefined
        * @param {int|undefined} limit max number of orders to return, default is undefined
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchCanceledOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object enableUnified = await this.isUnifiedEnabled();
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue((isEqual(type, "spot"))) && !isTrue(getValue(enableUnified, 1))))
        {
            throw new NotSupported ((string)add(this.id, " fetchCanceledOrders() only allow spot market orders for unified trade account, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead")) ;
        } else
        {
            ((Dictionary<string, object>)request)["orderStatus"] = "Cancelled";
        }
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchUnifiedAccountOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(isEqual(symbol, null)))
        {
            object type = null;
                        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
            type = ((List<object>)typeparametersVariable)[0];
            parameters = ((List<object>)typeparametersVariable)[1];
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = type;
            if (isTrue(isEqual(type, "swap")))
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    this.checkRequiredSymbol("fetchOpenOrders", symbol);
                } else if (isTrue(isEqual(subType, "inverse")))
                {
                    throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() does not allow inverse market orders for "), symbol), " markets")) ;
                }
                ((Dictionary<string, object>)request)["category"] = subType;
            }
        } else
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "spot")))
            {
                ((Dictionary<string, object>)request)["category"] = "spot";
            } else if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() does not allow inverse market orders for "), symbol), " markets")) ;
            }
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            if (isTrue(getValue(market, "spot")))
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "tpslOrder";
            } else
            {
                ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5OrderRealtime(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "1321052653536515584%3A1672217748287%2C1321052653536515584%3A1672217748287",
        //             "category": "spot",
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "orderType": "Limit",
        //                     "orderLinkId": "1672217748277652",
        //                     "orderId": "1321052653536515584",
        //                     "cancelType": "UNKNOWN",
        //                     "avgPrice": "",
        //                     "stopOrderType": "tpslOrder",
        //                     "lastPriceOnCreated": "",
        //                     "orderStatus": "Cancelled",
        //                     "takeProfit": "",
        //                     "cumExecValue": "0",
        //                     "triggerDirection": 0,
        //                     "isLeverage": "0",
        //                     "rejectReason": "",
        //                     "price": "1000",
        //                     "orderIv": "",
        //                     "createdTime": "1672217748287",
        //                     "tpTriggerBy": "",
        //                     "positionIdx": 0,
        //                     "timeInForce": "GTC",
        //                     "leavesValue": "500",
        //                     "updatedTime": "1672217748287",
        //                     "side": "Buy",
        //                     "triggerPrice": "1500",
        //                     "cumExecFee": "0",
        //                     "leavesQty": "0",
        //                     "slTriggerBy": "",
        //                     "closeOnTrigger": false,
        //                     "cumExecQty": "0",
        //                     "reduceOnly": false,
        //                     "qty": "0.5",
        //                     "stopLoss": "",
        //                     "triggerBy": "1192.5"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672219526294
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchSpotOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetSpotV3PrivateOpenOrders(this.extend(request, parameters));
        //
        //    {
        //         "retCode": "0",
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "accountId": "13380434",
        //                     "symbol": "AAVEUSDT",
        //                     "orderLinkId": "1666734005300717",
        //                     "orderId": "1275051683279281664",
        //                     "orderPrice": "80",
        //                     "orderQty": "0.11",
        //                     "execQty": "0",
        //                     "cummulativeQuoteQty": "0",
        //                     "avgPrice": "0",
        //                     "status": "NEW",
        //                     "timeInForce": "GTC",
        //                     "orderType": "LIMIT",
        //                     "side": "BUY",
        //                     "stopPrice": "0.0",
        //                     "icebergQty": "0.0",
        //                     "createTime": "1666734005304",
        //                     "updateTime": "1666734005309",
        //                     "isWorking": "1",
        //                     "orderCategory": "0"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": null,
        //         "time": "1666734031592"
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchUnifiedMarginOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(isEqual(symbol, null)))
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchUnifiedMarginOrders", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = subType;
        } else
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchUnifiedMarginOpenOrders() does not allow inverse market orders for "), symbol), " markets")) ;
            }
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchUnifiedMarginOpenOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object isStop = this.safeValue(parameters, "stop", false);
        object isConditional = isTrue(isTrue(isStop) || isTrue((isEqual(type, "stop")))) || isTrue((isEqual(type, "conditional")));
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isConditional))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetUnifiedV3PrivateOrderUnfilledOrders(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //             "nextPageCursor": "135ccc0d-8136-4e1b-8af3-07b11ee158d1%3A1665565610526%2C135ccc0d-8136-4e1b-8af3-07b11ee158d1%3A1665565610526",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "orderType": "Limit",
        //                     "orderLinkId": "test0000005",
        //                     "orderId": "135ccc0d-8136-4e1b-8af3-07b11ee158d1",
        //                     "stopOrderType": "UNKNOWN",
        //                     "orderStatus": "New",
        //                     "takeProfit": "",
        //                     "cumExecValue": "0.00000000",
        //                     "blockTradeId": "",
        //                     "price": "700.00000000",
        //                     "createdTime": 1665565610526,
        //                     "tpTriggerBy": "UNKNOWN",
        //                     "timeInForce": "GoodTillCancel",
        //                     "basePrice": "",
        //                     "updatedTime": 1665565610533,
        //                     "side": "Buy",
        //                     "triggerPrice": "",
        //                     "cumExecFee": "0.00000000",
        //                     "slTriggerBy": "UNKNOWN",
        //                     "leavesQty": "0.1000",
        //                     "closeOnTrigger": false,
        //                     "cumExecQty": "0.00000000",
        //                     "reduceOnly": false,
        //                     "qty": "0.1000",
        //                     "stopLoss": "",
        //                     "triggerBy": "UNKNOWN",
        //                     "orderIM": "0.00000000"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": null,
        //         "time": 1665565614320
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchDerivativesOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            }
        } else
        {
            object type = null;
                        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
            type = ((List<object>)typeparametersVariable)[0];
            parameters = ((List<object>)typeparametersVariable)[1];
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            ((Dictionary<string, object>)request)["category"] = type;
            if (isTrue(isEqual(type, "swap")))
            {
                ((Dictionary<string, object>)request)["category"] = subType;
            }
        }
                var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "settle", settle);
        settle = ((List<object>)settleparametersVariable)[0];
        parameters = ((List<object>)settleparametersVariable)[1];
        if (isTrue(!isEqual(settle, null)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        object isStop = this.safeValue(parameters, "stop", false);
        parameters = this.omit(parameters, new List<object>() {"stop"});
        if (isTrue(isStop))
        {
            ((Dictionary<string, object>)request)["orderFilter"] = "StopOrder";
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5OrderRealtime(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "1321052653536515584%3A1672217748287%2C1321052653536515584%3A1672217748287",
        //             "category": "spot",
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "orderType": "Limit",
        //                     "orderLinkId": "1672217748277652",
        //                     "orderId": "1321052653536515584",
        //                     "cancelType": "UNKNOWN",
        //                     "avgPrice": "",
        //                     "stopOrderType": "tpslOrder",
        //                     "lastPriceOnCreated": "",
        //                     "orderStatus": "Cancelled",
        //                     "takeProfit": "",
        //                     "cumExecValue": "0",
        //                     "triggerDirection": 0,
        //                     "isLeverage": "0",
        //                     "rejectReason": "",
        //                     "price": "1000",
        //                     "orderIv": "",
        //                     "createdTime": "1672217748287",
        //                     "tpTriggerBy": "",
        //                     "positionIdx": 0,
        //                     "timeInForce": "GTC",
        //                     "leavesValue": "500",
        //                     "updatedTime": "1672217748287",
        //                     "side": "Buy",
        //                     "triggerPrice": "1500",
        //                     "cumExecFee": "0",
        //                     "leavesQty": "0",
        //                     "slTriggerBy": "",
        //                     "closeOnTrigger": false,
        //                     "cumExecQty": "0",
        //                     "reduceOnly": false,
        //                     "qty": "0.5",
        //                     "stopLoss": "",
        //                     "triggerBy": "1192.5"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672219526294
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchUSDCOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchUSDCOpenOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = ((bool) isTrue((isEqual(type, "swap")))) ? "perpetual" : "option";
        object response = await this.privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders(this.extend(request, parameters));
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "dataList", new List<object>() {});
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "resultTotalSize": 1,
        //             "cursor": "id%3D1662019818569%23df31e03b-fc00-4b4c-bd1c-b97fd72b5c5c",
        //             "dataList": [
        //                 {
        //                     "orderId": "df31e03b-fc00-4b4c-bd1c-b97fd72b5c5c",
        //                     "orderLinkId": "",
        //                     "symbol": "BTC-2SEP22-18000-C",
        //                     "orderStatus": "New",
        //                     "orderPrice": "500",
        //                     "side": "Buy",
        //                     "remainingQty": "0.1",
        //                     "orderType": "Limit",
        //                     "qty": "0.1",
        //                     "iv": "0.0000",
        //                     "cancelType": "",
        //                     "updateTimestamp": "1662019818579"
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = this.safeString(parameters, "settleCoin");
        if (isTrue(isEqual(settle, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "settle", settle);
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object isInverse = isEqual(subType, "inverse");
        object isUsdcSettled = isEqual(settle, "USDC");
        object isLinearSettle = isTrue(isUsdcSettled) || isTrue((isEqual(settle, "USDT")));
        if (isTrue(isTrue(isInverse) && isTrue(isLinearSettle)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders with inverse subType requires settle to not be USDT or USDC")) ;
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        if (isTrue(isTrue(enableUnifiedAccount) && !isTrue(isInverse)))
        {
            return await this.fetchUnifiedAccountOpenOrders(symbol, since, limit, query);
        } else if (isTrue(isEqual(type, "spot")))
        {
            return await this.fetchSpotOpenOrders(symbol, since, limit, query);
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(isInverse)))
        {
            return await this.fetchUnifiedMarginOpenOrders(symbol, since, limit, query);
        } else if (isTrue(isUsdcSettled))
        {
            return await this.fetchUSDCOpenOrders(symbol, since, limit, query);
        } else
        {
            return await this.fetchDerivativesOpenOrders(symbol, since, limit, query);
        }
    }

    public async virtual Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchMyUnifiedTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            ((Dictionary<string, object>)request)["category"] = "spot";
        } else
        {
            object subType = null;
                        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters);
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            if (isTrue(isEqual(subType, "inverse")))
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), subType), " markets.")) ;
            }
            ((Dictionary<string, object>)request)["category"] = subType;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20, max 50
        }
        object response = await this.privateGetV5ExecutionList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "132766%3A2%2C132766%3A2",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHPERP",
        //                     "orderType": "Market",
        //                     "underlyingPrice": "",
        //                     "orderLinkId": "",
        //                     "side": "Buy",
        //                     "indexPrice": "",
        //                     "orderId": "8c065341-7b52-4ca9-ac2c-37e31ac55c94",
        //                     "stopOrderType": "UNKNOWN",
        //                     "leavesQty": "0",
        //                     "execTime": "1672282722429",
        //                     "isMaker": false,
        //                     "execFee": "0.071409",
        //                     "feeRate": "0.0006",
        //                     "execId": "e0cbe81d-0f18-5866-9415-cf319b5dab3b",
        //                     "tradeIv": "",
        //                     "blockTradeId": "",
        //                     "markPrice": "1183.54",
        //                     "execPrice": "1190.15",
        //                     "markIv": "",
        //                     "orderQty": "0.1",
        //                     "orderPrice": "1236.9",
        //                     "execValue": "119.015",
        //                     "execType": "Trade",
        //                     "execQty": "0.1"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672283754510
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(result, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async virtual Task<object> fetchMySpotTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMySpotTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20, max 50
        }
        object response = await this.privateGetSpotV3PrivateMyTrades(this.extend(request, parameters));
        //
        //    {
        //         "retCode": "0",
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "symbol": "AAVEUSDT",
        //                     "id": "1274785101965716992",
        //                     "orderId": "1274784252359089664",
        //                     "tradeId": "2270000000031365639",
        //                     "orderPrice": "82.5",
        //                     "orderQty": "0.016",
        //                     "execFee": "0",
        //                     "feeTokenId": "AAVE",
        //                     "creatTime": "1666702226326",
        //                     "isBuyer": "0",
        //                     "isMaker": "0",
        //                     "matchOrderId": "1274785101865076224",
        //                     "makerRebate": "0",
        //                     "executionTime": "1666702226335"
        //                 },
        //             ]
        //         },
        //         "retExtMap": {},
        //         "retExtInfo": null,
        //         "time": "1666768215157"
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(result, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async virtual Task<object> fetchMyUnifiedMarginTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = subType;
                var settleparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "settle", settle);
        settle = ((List<object>)settleparametersVariable)[0];
        parameters = ((List<object>)settleparametersVariable)[1];
        if (isTrue(!isEqual(settle, null)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 20, max 50
        }
        object response = await this.privateGetUnifiedV3PrivateExecutionList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //             "nextPageCursor": "1565%3A0%2C1565%3A0",
        //             "category": "option",
        //             "list": [
        //                 {
        //                     "orderType": "Limit",
        //                     "symbol": "BTC-14JUL22-17500-C",
        //                     "orderLinkId": "188889689-yuanzhen-558998998899",
        //                     "side": "Buy",
        //                     "orderId": "09c5836f-81ef-4208-a5b4-43135d3e02a2",
        //                     "leavesQty": "0.0000",
        //                     "execTime": 1657714122417,
        //                     "execFee": "0.11897082",
        //                     "feeRate": "0.000300",
        //                     "execId": "6e492560-78b4-5d2b-b331-22921d3173c9",
        //                     "blockTradeId": "",
        //                     "execPrice": "2360.00000000",
        //                     "lastLiquidityInd": "TAKER",
        //                     "orderQty": "0.0200",
        //                     "orderPrice": "2360.00000000",
        //                     "execValue": "47.20000000",
        //                     "execType": "Trade",
        //                     "execQty": "0.0200"
        //                 }
        //             ]
        //         },
        //         "time": 1657714292783
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(result, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async virtual Task<object> fetchMyContractTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyContractTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = subType;
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 50, max 100
        }
        object response = await this.privateGetV5ExecutionList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "132766%3A2%2C132766%3A2",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHPERP",
        //                     "orderType": "Market",
        //                     "underlyingPrice": "",
        //                     "orderLinkId": "",
        //                     "side": "Buy",
        //                     "indexPrice": "",
        //                     "orderId": "8c065341-7b52-4ca9-ac2c-37e31ac55c94",
        //                     "stopOrderType": "UNKNOWN",
        //                     "leavesQty": "0",
        //                     "execTime": "1672282722429",
        //                     "isMaker": false,
        //                     "execFee": "0.071409",
        //                     "feeRate": "0.0006",
        //                     "execId": "e0cbe81d-0f18-5866-9415-cf319b5dab3b",
        //                     "tradeIv": "",
        //                     "blockTradeId": "",
        //                     "markPrice": "1183.54",
        //                     "execPrice": "1190.15",
        //                     "markIv": "",
        //                     "orderQty": "0.1",
        //                     "orderPrice": "1236.9",
        //                     "execValue": "119.015",
        //                     "execType": "Trade",
        //                     "execQty": "0.1"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672283754510
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(result, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async virtual Task<object> fetchMyUsdcTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["category"] = ((bool) isTrue(getValue(market, "option"))) ? "OPTION" : "PERPETUAL";
        } else
        {
            ((Dictionary<string, object>)request)["category"] = "PERPETUAL";
        }
        object response = await this.privatePostOptionUsdcOpenapiPrivateV1ExecutionList(this.extend(request, parameters));
        //
        //     {
        //       "result": {
        //         "cursor": "29%3A1%2C28%3A1",
        //         "resultTotalSize": 2,
        //         "dataList": [
        //           {
        //             "symbol": "ETHPERP",
        //             "orderLinkId": "",
        //             "side": "Sell",
        //             "orderId": "d83f8b4d-2f60-4e04-a64a-a3f207989dc6",
        //             "execFee": "0.0210",
        //             "feeRate": "0.000600",
        //             "blockTradeId": "",
        //             "tradeTime": "1669196423581",
        //             "execPrice": "1161.45",
        //             "lastLiquidityInd": "TAKER",
        //             "execValue": "34.8435",
        //             "execType": "Trade",
        //             "execQty": "0.030",
        //             "tradeId": "d9aa8590-9e6a-575e-a1be-d6261e6ed2e5"
        //           }, ...
        //         ]
        //       },
        //       "retCode": 0,
        //       "retMsg": "Success."
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object dataList = this.safeValue(result, "dataList", new List<object>() {});
        return this.parseTrades(dataList, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object settle = this.safeString(parameters, "settleCoin");
        if (isTrue(isEqual(settle, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "settle", settle);
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            settle = getValue(market, "settle");
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object isInverse = isEqual(subType, "inverse");
        object isUsdcSettled = isEqual(settle, "USDC");
        object isLinearSettle = isTrue(isUsdcSettled) || isTrue((isEqual(settle, "USDT")));
        if (isTrue(isTrue(isInverse) && isTrue(isLinearSettle)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades with inverse subType requires settle to not be USDT or USDC")) ;
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        if (isTrue(isTrue(enableUnifiedAccount) && !isTrue(isInverse)))
        {
            object orderId = this.safeString(parameters, "orderId");
            if (isTrue(isTrue(isEqual(orderId, null)) && isTrue(!isEqual(type, "spot"))))
            {
                this.checkRequiredSymbol("fetchMyTrades", symbol);
            }
            return await this.fetchMyUnifiedTrades(symbol, since, limit, query);
        } else if (isTrue(isEqual(type, "spot")))
        {
            return await this.fetchMySpotTrades(symbol, since, limit, query);
        } else if (isTrue(isTrue(enableUnifiedMargin) && !isTrue(isInverse)))
        {
            return await this.fetchMyUnifiedMarginTrades(symbol, since, limit, query);
        } else if (isTrue(isUsdcSettled))
        {
            return await this.fetchMyUsdcTrades(symbol, since, limit, query);
        } else
        {
            return await this.fetchMyContractTrades(symbol, since, limit, query);
        }
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         chainType: 'ERC20',
        //         addressDeposit: '0xf56297c6717c1d1c42c30324468ed50a9b7402ee',
        //         tagDeposit: '',
        //         chain: 'ETH'
        //     }
        //
        object address = this.safeString(depositAddress, "addressDeposit");
        object tag = this.safeString(depositAddress, "tagDeposit");
        object code = this.safeString(currency, "code");
        object chain = this.safeString(depositAddress, "chain");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", chain },
            { "info", depositAddress },
        };
    }

    public async virtual Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchDepositAddressesByNetwork
        * @description fetch a dictionary of addresses for a currency, indexed by network
        * @see https://bybit-exchange.github.io/docs/v5/asset/master-deposit-addr
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object response = await this.privateGetV5AssetDepositQueryAddress(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "coin": "USDT",
        //             "chains": [
        //                 {
        //                     "chainType": "ERC20",
        //                     "addressDeposit": "0xd9e1cd77afa0e50b452a62fbb68a3340602286c3",
        //                     "tagDeposit": "",
        //                     "chain": "ETH"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672192792860
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object chains = this.safeValue(result, "chains", new List<object>() {});
        object coin = this.safeString(result, "coin");
        currency = this.currency(coin);
        object parsed = this.parseDepositAddresses(chains, new List<object>() {getValue(currency, "code")}, false, new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        });
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://bybit-exchange.github.io/docs/v5/asset/master-deposit-addr
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var networkCodequeryVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((List<object>) networkCodequeryVariable)[0];
        var query = ((List<object>) networkCodequeryVariable)[1];
        object networkId = this.networkCodeToId(networkCode);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(networkId, null)))
        {
            ((Dictionary<string, object>)request)["chainType"] = networkId;
        }
        object response = await this.privateGetV5AssetDepositQueryAddress(this.extend(request, query));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "coin": "USDT",
        //             "chains": [
        //                 {
        //                     "chainType": "ERC20",
        //                     "addressDeposit": "0xd9e1cd77afa0e50b452a62fbb68a3340602286c3",
        //                     "tagDeposit": "",
        //                     "chain": "ETH"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672192792860
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object chains = this.safeValue(result, "chains", new List<object>() {});
        object chainsIndexedById = this.indexBy(chains, "chain");
        object selectedNetworkId = this.selectNetworkIdFromRawNetworks(code, networkCode, chainsIndexedById);
        object addressObject = this.safeValue(chainsIndexedById, selectedNetworkId, new Dictionary<string, object>() {});
        return this.parseDepositAddress(addressObject, currency);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://bybit-exchange.github.io/docs/v5/asset/deposit-record
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for, default = 30 days before the current time
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve, default = 50, max = 50
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @param {int|undefined} params.until the latest time in ms to fetch deposits for, default = 30 days after since
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string|undefined} params.cursor used for pagination
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5AssetDepositQueryRecord(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "rows": [
        //                 {
        //                     "coin": "USDT",
        //                     "chain": "ETH",
        //                     "amount": "10000",
        //                     "txID": "skip-notification-scene-test-amount-202212270944-533285-USDT",
        //                     "status": 3,
        //                     "toAddress": "test-amount-address",
        //                     "tag": "",
        //                     "depositFee": "",
        //                     "successAt": "1672134274000",
        //                     "confirmations": "10000",
        //                     "txIndex": "",
        //                     "blockHash": ""
        //                 }
        //             ],
        //             "nextPageCursor": "eyJtaW5JRCI6MTA0NjA0MywibWF4SUQiOjEwNDYwNDN9"
        //         },
        //         "retExtInfo": {},
        //         "time": 1672191992512
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "rows", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://bybit-exchange.github.io/docs/v5/asset/withdraw-record
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5AssetWithdrawQueryRecord(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "rows": [
        //                 {
        //                     "coin": "USDT",
        //                     "chain": "ETH",
        //                     "amount": "77",
        //                     "txID": "",
        //                     "status": "SecurityCheck",
        //                     "toAddress": "0x99ced129603abc771c0dabe935c326ff6c86645d",
        //                     "tag": "",
        //                     "withdrawFee": "10",
        //                     "createTime": "1670922217000",
        //                     "updateTime": "1670922217000",
        //                     "withdrawId": "9976",
        //                     "withdrawType": 0
        //                 },
        //                 {
        //                     "coin": "USDT",
        //                     "chain": "ETH",
        //                     "amount": "26",
        //                     "txID": "",
        //                     "status": "success",
        //                     "toAddress": "15638072681@163.com",
        //                     "tag": "",
        //                     "withdrawFee": "0",
        //                     "createTime": "1669711121000",
        //                     "updateTime": "1669711380000",
        //                     "withdrawId": "9801",
        //                     "withdrawType": 1
        //                 }
        //             ],
        //             "nextPageCursor": "eyJtaW5JRCI6OTgwMSwibWF4SUQiOjk5NzZ9"
        //         },
        //         "retExtInfo": {},
        //         "time": 1672194949928
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "rows", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "ToBeConfirmed", "pending" },
            { "UnderReview", "pending" },
            { "Success", "ok" },
            { "Expire", "expired" },
            { "0", "unknown" },
            { "1", "pending" },
            { "2", "processing" },
            { "3", "ok" },
            { "4", "fail" },
            { "SecurityCheck", "pending" },
            { "Pending", "pending" },
            { "success", "ok" },
            { "CancelByUser", "canceled" },
            { "Reject", "rejected" },
            { "Fail", "failed" },
            { "BlockchainConfirmed", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchWithdrawals
        //
        //     {
        //         "coin": "USDT",
        //         "chain": "TRX",
        //         "amount": "12.34",
        //         "txID": "de5ea0a2f2e59dc9a714837dd3ddc6d5e151b56ec5d786d351c4f52336f80d3c",
        //         "status": "success",
        //         "toAddress": "TQdmFKUoe1Lk2iwZuwRJEHJreTUBoN3BAw",
        //         "tag": "",
        //         "withdrawFee": "0.5",
        //         "createTime": "1665144183000",
        //         "updateTime": "1665144256000",
        //         "withdrawId": "8839035"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "coin": "USDT",
        //         "chain": "TRX",
        //         "amount": "44",
        //         "txID": "0b038ea12fa1575e2d66693db3c346b700d4b28347afc39f80321cf089acc960",
        //         "status": "3",
        //         "toAddress": "TC6NCAC5WSVCCiaD3kWZXyW91ZKKhLm53b",
        //         "tag": "",
        //         "depositFee": "",
        //         "successAt": "1665142507000",
        //         "confirmations": "100",
        //         "txIndex": "0",
        //         "blockHash": "0000000002ac3b1064aee94bca1bd0b58c4c09c65813b084b87a2063d961129e"
        //     }
        //
        // withdraw
        //
        //     {
        //         "id": "9377266"
        //     }
        //
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger2(transaction, "createTime", "successAt");
        object updated = this.safeInteger(transaction, "updateTime");
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object feeCost = this.safeNumber2(transaction, "depositFee", "withdrawFee", 0);
        object type = ((bool) isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("depositFee"))))) ? "deposit" : "withdrawal";
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        object toAddress = this.safeString(transaction, "toAddress");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdrawId") },
            { "txid", this.safeString(transaction, "txID") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(this.safeString(transaction, "chain")) },
            { "address", null },
            { "addressTo", toAddress },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "tag") },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", fee },
        };
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://bybit-exchange.github.io/docs/v5/account/transaction-log
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object enableUnified = await this.isUnifiedEnabled();
        object currency = null;
        object currencyKey = "coin";
        if (isTrue(getValue(enableUnified, 1)))
        {
            currencyKey = "currency";
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = since;
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["start_date"] = this.yyyymmdd(since);
            }
        }
        object method = ((bool) isTrue((getValue(enableUnified, 1)))) ? "privateGetV5AccountTransactionLog" : "privateGetV2PrivateWalletFundRecords";
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)[(string)currencyKey] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": {
        //             "data": [
        //                 {
        //                     "id": 234467,
        //                     "user_id": 1,
        //                     "coin": "BTC",
        //                     "wallet_id": 27913,
        //                     "type": "Realized P&L",
        //                     "amount": "-0.00000006",
        //                     "tx_id": "",
        //                     "address": "BTCUSD",
        //                     "wallet_balance": "0.03000330",
        //                     "exec_time": "2019-12-09T00:00:25.000Z",
        //                     "cross_seq": 0
        //                 }
        //             ]
        //         },
        //         "ext_info": null,
        //         "time_now": "1577481867.115552",
        //         "rate_limit_status": 119,
        //         "rate_limit_reset_ms": 1577481867122,
        //         "rate_limit": 120
        //     }
        //
        // v5 transaction log
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "21963%3A1%2C14954%3A1",
        //             "list": [
        //                 {
        //                     "symbol": "XRPUSDT",
        //                     "side": "Buy",
        //                     "funding": "-0.003676",
        //                     "orderLinkId": "",
        //                     "orderId": "1672128000-8-592324-1-2",
        //                     "fee": "0.00000000",
        //                     "change": "-0.003676",
        //                     "cashFlow": "0",
        //                     "transactionTime": "1672128000000",
        //                     "type": "SETTLEMENT",
        //                     "feeRate": "0.0001",
        //                     "size": "100",
        //                     "qty": "100",
        //                     "cashBalance": "5086.55825002",
        //                     "currency": "USDT",
        //                     "category": "linear",
        //                     "tradePrice": "0.3676",
        //                     "tradeId": "534c0003-4bf7-486f-aa02-78cee36825e4"
        //                 },
        //                 {
        //                     "symbol": "XRPUSDT",
        //                     "side": "Buy",
        //                     "funding": "",
        //                     "orderLinkId": "linear-order",
        //                     "orderId": "592b7e41-78fd-42e2-9aa3-91e1835ef3e1",
        //                     "fee": "0.01908720",
        //                     "change": "-0.0190872",
        //                     "cashFlow": "0",
        //                     "transactionTime": "1672121182224",
        //                     "type": "TRADE",
        //                     "feeRate": "0.0006",
        //                     "size": "100",
        //                     "qty": "88",
        //                     "cashBalance": "5086.56192602",
        //                     "currency": "USDT",
        //                     "category": "linear",
        //                     "tradePrice": "0.3615",
        //                     "tradeId": "5184f079-88ec-54c7-8774-5173cafd2b4e"
        //                 },
        //                 {
        //                     "symbol": "XRPUSDT",
        //                     "side": "Buy",
        //                     "funding": "",
        //                     "orderLinkId": "linear-order",
        //                     "orderId": "592b7e41-78fd-42e2-9aa3-91e1835ef3e1",
        //                     "fee": "0.00260280",
        //                     "change": "-0.0026028",
        //                     "cashFlow": "0",
        //                     "transactionTime": "1672121182224",
        //                     "type": "TRADE",
        //                     "feeRate": "0.0006",
        //                     "size": "12",
        //                     "qty": "12",
        //                     "cashBalance": "5086.58101322",
        //                     "currency": "USDT",
        //                     "category": "linear",
        //                     "tradePrice": "0.3615",
        //                     "tradeId": "8569c10f-5061-5891-81c4-a54929847eb3"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672132481405
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue2(result, "data", "list", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": 234467,
        //         "user_id": 1,
        //         "coin": "BTC",
        //         "wallet_id": 27913,
        //         "type": "Realized P&L",
        //         "amount": "-0.00000006",
        //         "tx_id": "",
        //         "address": "BTCUSD",
        //         "wallet_balance": "0.03000330",
        //         "exec_time": "2019-12-09T00:00:25.000Z",
        //         "cross_seq": 0
        //     }
        //
        //     {
        //         "symbol": "XRPUSDT",
        //         "side": "Buy",
        //         "funding": "",
        //         "orderLinkId": "linear-order",
        //         "orderId": "592b7e41-78fd-42e2-9aa3-91e1835ef3e1",
        //         "fee": "0.00260280",
        //         "change": "-0.0026028",
        //         "cashFlow": "0",
        //         "transactionTime": "1672121182224",
        //         "type": "TRADE",
        //         "feeRate": "0.0006",
        //         "size": "12",
        //         "qty": "12",
        //         "cashBalance": "5086.58101322",
        //         "currency": "USDT",
        //         "category": "linear",
        //         "tradePrice": "0.3615",
        //         "tradeId": "8569c10f-5061-5891-81c4-a54929847eb3"
        //     }
        //
        object currencyId = this.safeString2(item, "coin", "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeString2(item, "amount", "change");
        object after = this.safeString2(item, "wallet_balance", "cashBalance");
        object direction = ((bool) isTrue(Precise.stringLt(amount, "0"))) ? "out" : "in";
        object before = null;
        if (isTrue(isTrue(!isEqual(after, null)) && isTrue(!isEqual(amount, null))))
        {
            object difference = ((bool) isTrue((isEqual(direction, "out")))) ? amount : Precise.stringNeg(amount);
            before = Precise.stringAdd(after, difference);
        }
        object timestamp = this.parse8601(this.safeString(item, "exec_time"));
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(item, "transactionTime");
        }
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object id = this.safeString(item, "id");
        object referenceId = this.safeString(item, "tx_id");
        return new Dictionary<string, object>() {
            { "id", id },
            { "currency", code },
            { "account", this.safeString(item, "wallet_id") },
            { "referenceAccount", null },
            { "referenceId", referenceId },
            { "status", null },
            { "amount", this.parseNumber(amount) },
            { "before", this.parseNumber(before) },
            { "after", this.parseNumber(after) },
            { "fee", this.parseNumber(this.safeString(item, "fee")) },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", type },
            { "info", item },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Deposit", "transaction" },
            { "Withdraw", "transaction" },
            { "RealisedPNL", "trade" },
            { "Commission", "fee" },
            { "Refund", "cashback" },
            { "Prize", "prize" },
            { "ExchangeOrderWithdraw", "transaction" },
            { "ExchangeOrderDeposit", "transaction" },
            { "TRANSFER_IN", "transaction" },
            { "TRANSFER_OUT", "transaction" },
            { "TRADE", "trade" },
            { "SETTLEMENT", "trade" },
            { "DELIVERY", "trade" },
            { "LIQUIDATION", "trade" },
            { "BONUS", "Prize" },
            { "FEE_REFUND", "cashback" },
            { "INTEREST", "transaction" },
            { "CURRENCY_BUY", "trade" },
            { "CURRENCY_SELL", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#withdraw
        * @description make a withdrawal
        * @see https://bybit-exchange.github.io/docs/v5/asset/withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
                var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "amount", this.numberToString(amount) },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["tag"] = tag;
        }
        var networkCodequeryVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((List<object>) networkCodequeryVariable)[0];
        var query = ((List<object>) networkCodequeryVariable)[1];
        object networkId = this.networkCodeToId(networkCode);
        if (isTrue(!isEqual(networkId, null)))
        {
            ((Dictionary<string, object>)request)["chain"] = ((string)networkId).ToUpper();
        }
        object enableUnified = await this.isUnifiedEnabled();
        object method = ((bool) isTrue((getValue(enableUnified, 1)))) ? "privatePostV5AssetWithdrawCreate" : "privatePostAssetV3PrivateWithdrawCreate";
        object response = await this.callAsync(method, this.extend(request, query));
        //
        //    {
        //         "retCode": "0",
        //         "retMsg": "success",
        //         "result": {
        //             "id": "9377266"
        //         },
        //         "retExtInfo": {},
        //         "time": "1666892894902"
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseTransaction(result, currency);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchPosition
        * @description fetch data on a single open contract trade position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchPosition", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = null;
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        object isUsdcSettled = isEqual(getValue(market, "settle"), "USDC");
        if (isTrue(isTrue(enableUnifiedMargin) || isTrue(enableUnifiedAccount)))
        {
            method = ((bool) isTrue((enableUnifiedAccount))) ? "privateGetV5PositionList" : "privateGetUnifiedV3PrivatePositionList";
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "option";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchPosition() does not allow inverse market orders for "), symbol), " markets")) ;
            }
        } else if (isTrue(isUsdcSettled))
        {
            method = "privatePostOptionUsdcOpenapiPrivateV1QueryPosition";
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["category"] = "OPTION";
            } else if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "PERPETUAL";
            }
        } else
        {
            if (isTrue(getValue(market, "linear")))
            {
                ((Dictionary<string, object>)request)["category"] = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                ((Dictionary<string, object>)request)["category"] = "inverse";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " fetchPosition() does not allow option market orders for "), symbol), " markets")) ;
            }
            method = "privateGetV5PositionList";
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // unified account
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "updateAt%3D1672279322668",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "XRPUSDT",
        //                     "leverage": "10",
        //                     "avgPrice": "0.3615",
        //                     "liqPrice": "0.0001",
        //                     "riskLimitValue": "200000",
        //                     "takeProfit": "",
        //                     "positionValue": "36.15",
        //                     "tpslMode": "Full",
        //                     "riskId": 41,
        //                     "trailingStop": "0",
        //                     "unrealisedPnl": "-1.83",
        //                     "markPrice": "0.3432",
        //                     "cumRealisedPnl": "0.48805876",
        //                     "positionMM": "0.381021",
        //                     "createdTime": "1672121182216",
        //                     "positionIdx": 0,
        //                     "positionIM": "3.634521",
        //                     "updatedTime": "1672279322668",
        //                     "side": "Buy",
        //                     "bustPrice": "",
        //                     "size": "100",
        //                     "positionStatus": "Normal",
        //                     "stopLoss": "",
        //                     "tradeMode": 0
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672280219169
        //     }
        //
        // unified margin
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //             "nextPageCursor": "0%3A1657711949945%2C0%3A1657711949945",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "leverage": "10",
        //                     "updatedTime": 1657711949945,
        //                     "side": "Buy",
        //                     "positionValue": "536.92500000",
        //                     "takeProfit": "",
        //                     "tpslMode": "Full",
        //                     "riskId": 11,
        //                     "trailingStop": "",
        //                     "entryPrice": "1073.85000000",
        //                     "unrealisedPnl": "",
        //                     "markPrice": "1080.65000000",
        //                     "size": "0.5000",
        //                     "positionStatus": "normal",
        //                     "stopLoss": "",
        //                     "cumRealisedPnl": "-0.32215500",
        //                     "positionMM": "2.97456450",
        //                     "createdTime": 1657711949928,
        //                     "positionIdx": 0,
        //                     "positionIM": "53.98243950"
        //                 }
        //             ]
        //         },
        //         "time": 1657713693182
        //     }
        //
        // contract v3
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "positionIdx": 1,
        //                     "riskId": "41",
        //                     "symbol": "XRPUSDT",
        //                     "side": "Buy",
        //                     "size": "0",
        //                     "positionValue": "0",
        //                     "entryPrice": "0",
        //                     "tradeMode": 0,
        //                     "autoAddMargin": 0,
        //                     "leverage": "10",
        //                     "positionBalance": "0",
        //                     "liqPrice": "0.0000",
        //                     "bustPrice": "0.0000",
        //                     "takeProfit": "0.0000",
        //                     "stopLoss": "0.0000",
        //                     "trailingStop": "0.0000",
        //                     "unrealisedPnl": "0",
        //                     "createdTime": "1658827444328",
        //                     "updatedTime": "1658904863412",
        //                     "tpSlMode": "Full",
        //                     "riskLimitValue": "200000",
        //                     "activePrice": "0.0000"
        //                 },
        //                 {
        //                     "positionIdx": 2,
        //                     "riskId": "41",
        //                     "symbol": "XRPUSDT",
        //                     "side": "Sell",
        //                     "size": "50",
        //                     "positionValue": "16.68",
        //                     "entryPrice": "0.3336",
        //                     "tradeMode": 0,
        //                     "autoAddMargin": 0,
        //                     "leverage": "10",
        //                     "positionBalance": "1.6790088",
        //                     "liqPrice": "12.4835",
        //                     "bustPrice": "12.4869",
        //                     "takeProfit": "0.0000",
        //                     "stopLoss": "0.0000",
        //                     "trailingStop": "0.0000",
        //                     "unrealisedPnl": "0",
        //                     "createdTime": "1658827444328",
        //                     "updatedTime": "1658904863412",
        //                     "tpSlMode": "Full",
        //                     "riskLimitValue": "200000",
        //                     "activePrice": "0.0000"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": null,
        //         "time": 1658904877942
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object positions = this.safeValue2(result, "list", "dataList", new List<object>() {});
        object timestamp = this.safeInteger(response, "time");
        object first = this.safeValue(positions, 0);
        object position = this.parsePosition(first, market);
        return this.extend(position, new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public async virtual Task<object> fetchUnifiedPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object type = null;
        object settle = null;
        object enableUnified = await this.isUnifiedEnabled();
        if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 1)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() does not accept an array with more than one symbol")) ;
            }
            object market = this.market(getValue(symbols, 0));
            settle = getValue(market, "settle");
        } else if (isTrue(!isEqual(symbols, null)))
        {
            symbols = new List<object>() {symbols};
        }
        symbols = this.marketSymbols(symbols);
        if (isTrue(isEqual(symbols, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "settle", "USDT");
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        } else
        {
            object first = this.safeValue(symbols, 0);
            object market = this.market(first);
            settle = getValue(market, "settle");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(getValue(enableUnified, 1)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        // market undefined
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", null, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", null, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = subType;
        if (isTrue(isEqual(type, "option")))
        {
            ((Dictionary<string, object>)request)["category"] = "option";
        }
        object method = ((bool) isTrue((getValue(enableUnified, 1)))) ? "privateGetV5PositionList" : "privateGetUnifiedV3PrivatePositionList";
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "Success",
        //         "result": {
        //             "nextPageCursor": "0%3A1657711949945%2C0%3A1657711949945",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "leverage": "10",
        //                     "updatedTime": 1657711949945,
        //                     "side": "Buy",
        //                     "positionValue": "536.92500000",
        //                     "takeProfit": "",
        //                     "tpslMode": "Full",
        //                     "riskId": 11,
        //                     "trailingStop": "",
        //                     "entryPrice": "1073.85000000",
        //                     "unrealisedPnl": "",
        //                     "markPrice": "1080.65000000",
        //                     "size": "0.5000",
        //                     "positionStatus": "normal",
        //                     "stopLoss": "",
        //                     "cumRealisedPnl": "-0.32215500",
        //                     "positionMM": "2.97456450",
        //                     "createdTime": 1657711949928,
        //                     "positionIdx": 0,
        //                     "positionIM": "53.98243950"
        //                 }
        //             ]
        //         },
        //         "time": 1657713693182
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object positions = this.safeValue(result, "list", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(positions, i);
            if (isTrue(isTrue((((Dictionary<string,object>)rawPosition).ContainsKey(toStringOrNull("data")))) && isTrue((((Dictionary<string,object>)rawPosition).ContainsKey(toStringOrNull("is_valid"))))))
            {
                // futures only
                rawPosition = this.safeValue(rawPosition, "data");
            }
            ((List<object>)results).Add(this.parsePosition(rawPosition));
        }
        return this.filterByArray(results, "symbol", symbols, false);
    }

    public async virtual Task<object> fetchUSDCPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object market = null;
        object type = null;
        if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            object length = getArrayLength(symbols);
            if (isTrue(!isEqual(length, 1)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchUSDCPositions() takes an array with exactly one symbol")) ;
            }
            object symbol = this.safeString(symbols, 0);
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        } else if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(symbols);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchUSDCPositions", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = ((bool) isTrue((isEqual(type, "option")))) ? "OPTION" : "PERPETUAL";
        object response = await this.privatePostOptionUsdcOpenapiPrivateV1QueryPosition(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "cursor": "BTC-31DEC21-24000-P%3A1640834421431%2CBTC-31DEC21-24000-P%3A1640834421431",
        //             "resultTotalSize": 1,
        //             "dataList": [
        //                 {
        //                 "symbol": "BTC-31DEC21-24000-P",
        //                 "leverage": "",
        //                 "occClosingFee": "",
        //                 "liqPrice": "",
        //                 "positionValue": "",
        //                 "takeProfit": "",
        //                 "riskId": "",
        //                 "trailingStop": "",
        //                 "unrealisedPnl": "",
        //                 "createdAt": "1640834421431",
        //                 "markPrice": "0.00",
        //                 "cumRealisedPnl": "",
        //                 "positionMM": "359.5271",
        //                 "positionIM": "467.0633",
        //                 "updatedAt": "1640834421431",
        //                 "tpSLMode": "",
        //                 "side": "Sell",
        //                 "bustPrice": "",
        //                 "deleverageIndicator": 0,
        //                 "entryPrice": "1.4",
        //                 "size": "-0.100",
        //                 "sessionRPL": "",
        //                 "positionStatus": "",
        //                 "sessionUPL": "",
        //                 "stopLoss": "",
        //                 "orderMargin": "",
        //                 "sessionAvgPrice": "1.5"
        //                 }
        //             ]
        //         },
        //         "retCode": 0,
        //         "retMsg": "Success."
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object positions = this.safeValue(result, "dataList", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(positions, i);
            if (isTrue(isTrue((((Dictionary<string,object>)rawPosition).ContainsKey(toStringOrNull("data")))) && isTrue((((Dictionary<string,object>)rawPosition).ContainsKey(toStringOrNull("is_valid"))))))
            {
                // futures only
                rawPosition = this.safeValue(rawPosition, "data");
            }
            ((List<object>)results).Add(this.parsePosition(rawPosition, market));
        }
        return this.filterByArray(results, "symbol", symbols, false);
    }

    public async virtual Task<object> fetchDerivativesPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object settle = null;
        if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 1)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() does not accept an array with more than one symbol")) ;
            }
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                market = this.market(getValue(symbols, 0));
                settle = getValue(market, "settle");
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            }
        }
                var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "settle", settle);
        settle = ((List<object>)settleparametersVariable)[0];
        parameters = ((List<object>)settleparametersVariable)[1];
        if (isTrue(!isEqual(settle, null)))
        {
            ((Dictionary<string, object>)request)["settleCoin"] = settle;
        }
        object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        ((Dictionary<string, object>)request)["category"] = subType;
        object response = await this.privateGetV5PositionList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "nextPageCursor": "updateAt%3D1672279322668",
        //             "category": "linear",
        //             "list": [
        //                 {
        //                     "symbol": "XRPUSDT",
        //                     "leverage": "10",
        //                     "avgPrice": "0.3615",
        //                     "liqPrice": "0.0001",
        //                     "riskLimitValue": "200000",
        //                     "takeProfit": "",
        //                     "positionValue": "36.15",
        //                     "tpslMode": "Full",
        //                     "riskId": 41,
        //                     "trailingStop": "0",
        //                     "unrealisedPnl": "-1.83",
        //                     "markPrice": "0.3432",
        //                     "cumRealisedPnl": "0.48805876",
        //                     "positionMM": "0.381021",
        //                     "createdTime": "1672121182216",
        //                     "positionIdx": 0,
        //                     "positionIM": "3.634521",
        //                     "updatedTime": "1672279322668",
        //                     "side": "Buy",
        //                     "bustPrice": "",
        //                     "size": "100",
        //                     "positionStatus": "Normal",
        //                     "stopLoss": "",
        //                     "tradeMode": 0
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672280219169
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object positions = this.safeValue(result, "list", new List<object>() {});
        return this.parsePositions(positions, symbols, parameters);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 1)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() does not accept an array with more than one symbol")) ;
            }
        } else if (isTrue(!isEqual(symbols, null)))
        {
            symbols = new List<object>() {symbols};
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        object settle = this.safeString(parameters, "settleCoin");
        if (isTrue(isEqual(settle, null)))
        {
                        var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "settle", settle);
            settle = ((List<object>)settleparametersVariable)[0];
            parameters = ((List<object>)settleparametersVariable)[1];
        }
        object isUsdcSettled = isEqual(settle, "USDC");
        var subTypequeryVariable = this.handleSubTypeAndParams("fetchPositions", null, parameters);
        var subType = ((List<object>) subTypequeryVariable)[0];
        var query = ((List<object>) subTypequeryVariable)[1];
        object isInverse = isEqual(subType, "inverse");
        object isLinearSettle = isTrue(isUsdcSettled) || isTrue((isEqual(settle, "USDT")));
        if (isTrue(isTrue(isInverse) && isTrue(isLinearSettle)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchPositions with inverse subType requires settle to not be USDT or USDC")) ;
        }
        if (isTrue(isTrue((isTrue(enableUnifiedMargin) || isTrue(enableUnifiedAccount))) && !isTrue(isInverse)))
        {
            return await this.fetchUnifiedPositions(symbols, query);
        } else if (isTrue(isUsdcSettled))
        {
            return await this.fetchUSDCPositions(symbols, query);
        } else
        {
            return await this.fetchDerivativesPositions(symbols, query);
        }
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // linear swap
        //
        //     {
        //         "positionIdx": 0,
        //         "riskId": "11",
        //         "symbol": "ETHUSDT",
        //         "side": "Buy",
        //         "size": "0.10",
        //         "positionValue": "119.845",
        //         "entryPrice": "1198.45",
        //         "tradeMode": 1,
        //         "autoAddMargin": 0,
        //         "leverage": "4.2",
        //         "positionBalance": "28.58931118",
        //         "liqPrice": "919.10",
        //         "bustPrice": "913.15",
        //         "takeProfit": "0.00",
        //         "stopLoss": "0.00",
        //         "trailingStop": "0.00",
        //         "unrealisedPnl": "0.083",
        //         "createdTime": "1669097244192",
        //         "updatedTime": "1669413126190",
        //         "tpSlMode": "Full",
        //         "riskLimitValue": "900000",
        //         "activePrice": "0.00"
        //     }
        //
        // usdc
        //    {
        //       "symbol":"BTCPERP",
        //       "leverage":"1.00",
        //       "occClosingFee":"0.0000",
        //       "liqPrice":"",
        //       "positionValue":"30.8100",
        //       "takeProfit":"0.0",
        //       "riskId":"10001",
        //       "trailingStop":"0.0000",
        //       "unrealisedPnl":"0.0000",
        //       "createdAt":"1652451795305",
        //       "markPrice":"30809.41",
        //       "cumRealisedPnl":"0.0000",
        //       "positionMM":"0.1541",
        //       "positionIM":"30.8100",
        //       "updatedAt":"1652451795305",
        //       "tpSLMode":"UNKNOWN",
        //       "side":"Buy",
        //       "bustPrice":"",
        //       "deleverageIndicator":"0",
        //       "entryPrice":"30810.0",
        //       "size":"0.001",
        //       "sessionRPL":"0.0000",
        //       "positionStatus":"NORMAL",
        //       "sessionUPL":"-0.0006",
        //       "stopLoss":"0.0",
        //       "orderMargin":"0.0000",
        //       "sessionAvgPrice":"30810.0"
        //    }
        //
        // unified margin
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "leverage": "10",
        //         "updatedTime": 1657711949945,
        //         "side": "Buy",
        //         "positionValue": "536.92500000",
        //         "takeProfit": "",
        //         "tpslMode": "Full",
        //         "riskId": 11,
        //         "trailingStop": "",
        //         "entryPrice": "1073.85000000",
        //         "unrealisedPnl": "",
        //         "markPrice": "1080.65000000",
        //         "size": "0.5000",
        //         "positionStatus": "normal",
        //         "stopLoss": "",
        //         "cumRealisedPnl": "-0.32215500",
        //         "positionMM": "2.97456450",
        //         "createdTime": 1657711949928,
        //         "positionIdx": 0,
        //         "positionIM": "53.98243950"
        //     }
        //
        // unified account
        //
        //     {
        //         "symbol": "XRPUSDT",
        //         "leverage": "10",
        //         "avgPrice": "0.3615",
        //         "liqPrice": "0.0001",
        //         "riskLimitValue": "200000",
        //         "takeProfit": "",
        //         "positionValue": "36.15",
        //         "tpslMode": "Full",
        //         "riskId": 41,
        //         "trailingStop": "0",
        //         "unrealisedPnl": "-1.83",
        //         "markPrice": "0.3432",
        //         "cumRealisedPnl": "0.48805876",
        //         "positionMM": "0.381021",
        //         "createdTime": "1672121182216",
        //         "positionIdx": 0,
        //         "positionIM": "3.634521",
        //         "updatedTime": "1672279322668",
        //         "side": "Buy",
        //         "bustPrice": "",
        //         "size": "100",
        //         "positionStatus": "Normal",
        //         "stopLoss": "",
        //         "tradeMode": 0
        //     }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market, null, "contract");
        object size = Precise.stringAbs(this.safeString(position, "size"));
        object side = this.safeString(position, "side");
        if (isTrue(!isEqual(side, null)))
        {
            if (isTrue(isEqual(side, "Buy")))
            {
                side = "long";
            } else if (isTrue(isEqual(side, "Sell")))
            {
                side = "short";
            } else
            {
                side = null;
            }
        }
        object notional = this.safeString(position, "positionValue");
        object unrealisedPnl = this.omitZero(this.safeString(position, "unrealisedPnl"));
        object initialMarginString = this.safeString(position, "positionIM");
        object maintenanceMarginString = this.safeString(position, "positionMM");
        object timestamp = this.parse8601(this.safeString(position, "updated_at"));
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(position, "updatedAt");
        }
        // default to cross of USDC margined positions
        object tradeMode = this.safeInteger(position, "tradeMode", 0);
        object marginMode = ((bool) isTrue(tradeMode)) ? "isolated" : "cross";
        object collateralString = this.safeString(position, "positionBalance");
        object entryPrice = this.omitZero(this.safeString2(position, "entryPrice", "avgPrice"));
        object liquidationPrice = this.omitZero(this.safeString(position, "liqPrice"));
        object leverage = this.safeString(position, "leverage");
        if (isTrue(!isEqual(liquidationPrice, null)))
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDC")))
            {
                //  (Entry price - Liq price) * Contracts + Maintenance Margin + (unrealised pnl) = Collateral
                object difference = Precise.stringAbs(Precise.stringSub(entryPrice, liquidationPrice));
                collateralString = Precise.stringAdd(Precise.stringAdd(Precise.stringMul(difference, size), maintenanceMarginString), unrealisedPnl);
            } else
            {
                object bustPrice = this.safeString(position, "bustPrice");
                if (isTrue(getValue(market, "linear")))
                {
                    // derived from the following formulas
                    //  (Entry price - Bust price) * Contracts = Collateral
                    //  (Entry price - Liq price) * Contracts = Collateral - Maintenance Margin
                    // Maintenance Margin = (Bust price - Liq price) x Contracts
                    object maintenanceMarginPriceDifference = Precise.stringAbs(Precise.stringSub(liquidationPrice, bustPrice));
                    maintenanceMarginString = Precise.stringMul(maintenanceMarginPriceDifference, size);
                    // Initial Margin = Contracts x Entry Price / Leverage
                    if (isTrue(!isEqual(entryPrice, null)))
                    {
                        initialMarginString = Precise.stringDiv(Precise.stringMul(size, entryPrice), leverage);
                    }
                } else
                {
                    // Contracts * (1 / Entry price - 1 / Bust price) = Collateral
                    // Contracts * (1 / Entry price - 1 / Liq price) = Collateral - Maintenance Margin
                    // Maintenance Margin = Contracts * (1 / Liq price - 1 / Bust price)
                    // Maintenance Margin = Contracts * (Bust price - Liq price) / (Liq price x Bust price)
                    object difference = Precise.stringAbs(Precise.stringSub(bustPrice, liquidationPrice));
                    object multiply = Precise.stringMul(bustPrice, liquidationPrice);
                    maintenanceMarginString = Precise.stringDiv(Precise.stringMul(size, difference), multiply);
                    // Initial Margin = Leverage x Contracts / EntryPrice
                    if (isTrue(!isEqual(entryPrice, null)))
                    {
                        initialMarginString = Precise.stringDiv(size, Precise.stringMul(entryPrice, leverage));
                    }
                }
            }
        }
        object maintenanceMarginPercentage = Precise.stringDiv(maintenanceMarginString, notional);
        object percentage = Precise.stringMul(Precise.stringDiv(unrealisedPnl, initialMarginString), "100");
        object marginRatio = Precise.stringDiv(maintenanceMarginString, collateralString, 4);
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(Precise.stringDiv(initialMarginString, notional)) },
            { "maintenanceMargin", this.parseNumber(maintenanceMarginString) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.parseNumber(leverage) },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "liquidationPrice", this.parseNumber(liquidationPrice) },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "collateral", this.parseNumber(collateralString) },
            { "marginMode", marginMode },
            { "side", side },
            { "percentage", this.parseNumber(percentage) },
        };
    }

    public async virtual Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object values = await this.isUnifiedEnabled();
        object isUnifiedAccount = this.safeValue(values, 1);
        if (isTrue(isUnifiedAccount))
        {
            return await this.setUnifiedMarginMode(marginMode, symbol, parameters);
        }
        return await this.setDerivativesMarginMode(marginMode, symbol, parameters);
    }

    public async virtual Task<object> setUnifiedMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue((!isEqual(marginMode, "REGULAR_MARGIN"))) && isTrue((!isEqual(marginMode, "PORTFOLIO_MARGIN")))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode must be either REGULAR_MARGIN or PORTFOLIO_MARGIN")) ;
        }
        object request = new Dictionary<string, object>() {
            { "setMarginMode", marginMode },
        };
        object response = await this.privatePostV5AccountSetMarginMode(this.extend(request, parameters));
        //
        //  {
        //      "setMarginMode": "PORTFOLIO_MARGIN"
        //  }
        //
        return response;
    }

    public async virtual Task<object> setDerivativesMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("setMarginMode", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(getValue(market, "settle"), "USDC")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " setMarginMode() does not support market "), symbol), "")) ;
        }
        marginMode = ((string)marginMode).ToUpper();
        if (isTrue(isTrue((!isEqual(marginMode, "ISOLATED"))) && isTrue((!isEqual(marginMode, "CROSS")))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode must be either isolated or cross")) ;
        }
        object leverage = this.safeString(parameters, "leverage");
        object sellLeverage = null;
        object buyLeverage = null;
        if (isTrue(isEqual(leverage, null)))
        {
            sellLeverage = this.safeString2(parameters, "sell_leverage", "sellLeverage");
            buyLeverage = this.safeString2(parameters, "buy_leverage", "buyLeverage");
            if (isTrue(isTrue(isEqual(sellLeverage, null)) && isTrue(isEqual(buyLeverage, null))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters")) ;
            }
            if (isTrue(isEqual(buyLeverage, null)))
            {
                buyLeverage = sellLeverage;
            }
            if (isTrue(isEqual(sellLeverage, null)))
            {
                sellLeverage = buyLeverage;
            }
            parameters = this.omit(parameters, new List<object>() {"buy_leverage", "sell_leverage", "sellLeverage", "buyLeverage"});
        } else
        {
            parameters = this.omit(parameters, "leverage");
            sellLeverage = leverage;
            buyLeverage = leverage;
        }
        object tradeMode = ((bool) isTrue((isEqual(marginMode, "ISOLATED")))) ? 1 : 0;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "tradeMode", tradeMode },
            { "buyLeverage", buyLeverage },
            { "sellLeverage", sellLeverage },
        };
        object response = await this.privatePostContractV3PrivatePositionSwitchIsolated(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {},
        //         "retExtInfo": null,
        //         "time": 1658908532580
        //     }
        //
        return response;
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("setLeverage", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        object isUsdcSettled = isEqual(getValue(market, "settle"), "USDC");
        var enableUnifiedMarginenableUnifiedAccountVariable = await this.isUnifiedEnabled();
        var enableUnifiedMargin = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[0];
        var enableUnifiedAccount = ((List<object>) enableUnifiedMarginenableUnifiedAccountVariable)[1];
        // engage in leverage setting
        // we reuse the code here instead of having two methods
        leverage = this.numberToString(leverage);
        object method = null;
        object request = null;
        if (isTrue(isTrue(isTrue(enableUnifiedMargin) || isTrue(enableUnifiedAccount)) || !isTrue(isUsdcSettled)))
        {
            request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "buyLeverage", leverage },
                { "sellLeverage", leverage },
            };
            if (isTrue(enableUnifiedAccount))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    ((Dictionary<string, object>)request)["category"] = "linear";
                } else
                {
                    throw new NotSupported ((string)add(this.id, " setUnifiedMarginLeverage() leverage doesn\'t support inverse and option market in unified account")) ;
                }
                method = "privatePostV5PositionSetLeverage";
            } else if (isTrue(enableUnifiedMargin))
            {
                if (isTrue(getValue(market, "option")))
                {
                    ((Dictionary<string, object>)request)["category"] = "option";
                } else if (isTrue(getValue(market, "linear")))
                {
                    ((Dictionary<string, object>)request)["category"] = "linear";
                } else
                {
                    throw new NotSupported ((string)add(this.id, " setUnifiedMarginLeverage() leverage doesn\'t support inverse market in unified margin")) ;
                }
                method = "privatePostUnifiedV3PrivatePositionSetLeverage";
            } else
            {
                method = "privatePostContractV3PrivatePositionSetLeverage";
            }
        } else
        {
            request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "leverage", leverage },
            };
            method = "privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave";
        }
        return await this.callAsync(method, this.extend(request, parameters));
    }

    public async virtual Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object mode = null;
        if (isTrue(hedged))
        {
            mode = 3;
        } else
        {
            mode = 0;
        }
        object request = new Dictionary<string, object>() {
            { "mode", mode },
        };
        if (isTrue(isEqual(symbol, null)))
        {
            ((Dictionary<string, object>)request)["coin"] = "USDT";
        } else
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": null,
        //         "ext_info": null,
        //         "time_now": "1577477968.175013",
        //         "rate_limit_status": 74,
        //         "rate_limit_reset_ms": 1577477968183,
        //         "rate_limit": 75
        //     }
        //
        return await this.privatePostContractV3PrivatePositionSwitchMode(this.extend(request, parameters));
    }

    public async virtual Task<object> fetchDerivativesOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object subType = ((bool) isTrue(getValue(market, "linear"))) ? "linear" : "inverse";
        object category = this.safeString(parameters, "category", subType);
        object intervals = this.safeValue(this.options, "intervals");
        object interval = this.safeString(intervals, timeframe); // 5min,15min,30min,1h,4h,1d
        if (isTrue(isEqual(interval, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " fetchOpenInterestHistory() cannot use the "), timeframe), " timeframe")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "intervalTime", interval },
            { "category", category },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetV5MarketOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "symbol": "BTCUSD",
        //             "category": "inverse",
        //             "list": [
        //                 {
        //                     "openInterest": "461134384.00000000",
        //                     "timestamp": "1669571400000"
        //                 },
        //                 {
        //                     "openInterest": "461134292.00000000",
        //                     "timestamp": "1669571100000"
        //                 }
        //             ],
        //             "nextPageCursor": ""
        //         },
        //         "retExtInfo": {},
        //         "time": 1672053548579
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object id = this.safeString(result, "symbol");
        market = this.safeMarket(id, market, null, "contract");
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOpenInterests(data, market, since, limit);
    }

    public async virtual Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOpenInterest
        * @description Retrieves the open interest of a derivative trading pair
        * @see https://bybit-exchange.github.io/docs/v5/market/open-interest
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} params exchange specific parameters
        * @param {string|undefined} params.interval 5m, 15m, 30m, 1h, 4h, 1d
        * @param {string|undefined} params.category "linear" or "inverse"
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object timeframe = this.safeString(parameters, "interval", "1h");
        object intervals = this.safeValue(this.options, "intervals");
        object interval = this.safeString(intervals, timeframe); // 5min,15min,30min,1h,4h,1d
        if (isTrue(isEqual(interval, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " fetchOpenInterest() cannot use the "), timeframe), " timeframe")) ;
        }
        object subType = ((bool) isTrue(getValue(market, "linear"))) ? "linear" : "inverse";
        object category = this.safeString(parameters, "category", subType);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "intervalTime", interval },
            { "category", category },
        };
        object response = await this.publicGetV5MarketOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "symbol": "BTCUSD",
        //             "category": "inverse",
        //             "list": [
        //                 {
        //                     "openInterest": "461134384.00000000",
        //                     "timestamp": "1669571400000"
        //                 },
        //                 {
        //                     "openInterest": "461134292.00000000",
        //                     "timestamp": "1669571100000"
        //                 }
        //             ],
        //             "nextPageCursor": ""
        //         },
        //         "retExtInfo": {},
        //         "time": 1672053548579
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object id = this.safeString(result, "symbol");
        market = this.safeMarket(id, market, null, "contract");
        object data = this.safeValue(result, "list", new List<object>() {});
        return this.parseOpenInterest(getValue(data, 0), market);
    }

    public async virtual Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchOpenInterestHistory
        * @description Gets the total amount of unsettled contracts. In other words, the total number of contracts held in open positions
        * @see https://bybit-exchange.github.io/docs/v5/market/open-interest
        * @param {string} symbol Unified market symbol
        * @param {string} timeframe "5m", 15m, 30m, 1h, 4h, 1d
        * @param {int} since Not used by Bybit
        * @param {int} limit The number of open interest structures to return. Max 200, default 50
        * @param {object} params Exchange specific parameters
        * @returns An array of open interest structures
        */
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(timeframe, "1m")))
        {
            throw new BadRequest ((string)add(this.id, "fetchOpenInterestHistory cannot use the 1m timeframe")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(getValue(market, "option"))))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchOpenInterestHistory() symbol does not support market "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        return await this.fetchDerivativesOpenInterestHistory(symbol, timeframe, since, limit, parameters);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //    {
        //        "openInterest": 64757.62400000,
        //        "timestamp": 1665784800000,
        //    }
        //
        object timestamp = this.safeInteger(interest, "timestamp");
        object value = this.safeNumber2(interest, "open_interest", "openInterest");
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "openInterestAmount", null },
            { "openInterestValue", value },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://bybit-exchange.github.io/docs/spot/v3/#t-queryinterestquota
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object response = await this.privateGetSpotV3PrivateCrossMarginLoanInfo(this.extend(request, parameters));
        //
        //    {
        //         "retCode": "0",
        //         "retMsg": "success",
        //         "result": {
        //             "coin": "USDT",
        //             "interestRate": "0.000107000000",
        //             "loanAbleAmount": "",
        //             "maxLoanAmount": "79999.999"
        //         },
        //         "retExtInfo": null,
        //         "time": "1666734490778"
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseBorrowRate(data, currency);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "coin": "USDT",
        //         "interestRate": "0.000107000000",
        //         "loanAbleAmount": "",
        //         "maxLoanAmount": "79999.999"
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyId = this.safeString(info, "coin");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber(info, "interestRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @param {string|undefined} code unified currency code
        * @param {string|undefined} symbol unified market symbol when fetch interest in isolated markets
        * @param {number|undefined} since the earliest time in ms to fetch borrrow interest for
        * @param {number|undefined} limit the maximum number of structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.privateGetSpotV3PrivateCrossMarginAccount(this.extend(request, parameters));
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "",
        //         "ext_code": null,
        //         "ext_info": null,
        //         "result": {
        //             "status": "1",
        //             "riskRate": "0",
        //             "acctBalanceSum": "0.000486213817680857",
        //             "debtBalanceSum": "0",
        //             "loanAccountList": [
        //                 {
        //                     "tokenId": "BTC",
        //                     "total": "0.00048621",
        //                     "locked": "0",
        //                     "loan": "0",
        //                     "interest": "0",
        //                     "free": "0.00048621"
        //                 },
        //                 ...
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "loanAccountList", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, null);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "tokenId": "BTC",
        //         "total": "0.00048621",
        //         "locked": "0",
        //         "loan": "0",
        //         "interest": "0",
        //         "free": "0.00048621"
        //     },
        //
        return new Dictionary<string, object>() {
            { "symbol", null },
            { "marginMode", "cross" },
            { "currency", this.safeCurrencyCode(this.safeString(info, "tokenId")) },
            { "interest", this.safeNumber(info, "interest") },
            { "interestRate", null },
            { "amountBorrowed", this.safeNumber(info, "loan") },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bybit#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://bybit-exchange.github.io/docs/account_asset/#t-createinternaltransfer
        * @see https://bybit-exchange.github.io/docs/account_asset/v3/#t-createinternaltransfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @param {string} params.transferId UUID, which is unique across the platform
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object transferId = this.safeString(parameters, "transferId", this.uuid());
        object accountTypes = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountTypes, fromAccount, fromAccount);
        object toId = this.safeString(accountTypes, toAccount, toAccount);
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object method = null;
                var methodparametersVariable = this.handleOptionAndParams(parameters, "transfer", "method", "privatePostAssetV1PrivateTransfer");
        method = ((List<object>)methodparametersVariable)[0];
        parameters = ((List<object>)methodparametersVariable)[1]; // v1 preferred atm, because it supports funding
        object request = null;
        if (isTrue(isTrue(isEqual(method, "privatePostAssetV3PrivateTransferInterTransfer")) || isTrue(isEqual(method, "privatePostV5AssetTransferInterTransfer"))))
        {
            request = new Dictionary<string, object>() {
                { "transferId", transferId },
                { "fromAccountType", fromId },
                { "toAccountType", toId },
                { "coin", getValue(currency, "id") },
                { "amount", amountToPrecision },
            };
        } else
        {
            request = new Dictionary<string, object>() {
                { "transfer_id", transferId },
                { "from_account_type", fromId },
                { "to_account_type", toId },
                { "coin", getValue(currency, "id") },
                { "amount", amountToPrecision },
            };
        }
        object response = await this.callAsync(method, this.extend(request, parameters));
        //
        // {
        //     "retCode": 0,
        //     "retMsg": "success",
        //     "result": {
        //         "transferId": "4244af44-f3b0-4cf6-a743-b56560e987bc" // transfer_id in v1
        //     },
        //     "retExtInfo": {},
        //     "time": 1666875857205
        // }
        //
        object timestamp = this.safeInteger2(response, "time", "time_now");
        object transfer = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object statusRaw = this.safeStringN(response, new List<object>() {"retCode", "retMsg", "ret_code", "ret_msg"});
        object status = this.parseTransferStatus(statusRaw);
        return this.extend(this.parseTransfer(transfer, currency), new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", status },
        });
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://bybit-exchange.github.io/docs/v5/asset/inter-transfer-list
        * @param {string|undefined} code unified currency code of the currency transferred
        * @param {int|undefined} since the earliest time in ms to fetch transfers for
        * @param {int|undefined} limit the maximum number of  transfers structures to retrieve
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {[object]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.safeCurrencyCode(code);
            ((Dictionary<string, object>)request)["coin"] = currency;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV5AssetTransferQueryInterTransferList(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "list": [
        //                 {
        //                     "transferId": "selfTransfer_a1091cc7-9364-4b74-8de1-18f02c6f2d5c",
        //                     "coin": "USDT",
        //                     "amount": "5000",
        //                     "fromAccountType": "SPOT",
        //                     "toAccountType": "UNIFIED",
        //                     "timestamp": "1667283263000",
        //                     "status": "SUCCESS"
        //                 }
        //             ],
        //             "nextPageCursor": "eyJtaW5JRCI6MTM1ODQ2OCwibWF4SUQiOjEzNTg0Njh9"
        //         },
        //         "retExtInfo": {},
        //         "time": 1670988271677
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object transfers = this.safeValue(data, "list", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#borrowMargin
        * @description create a loan to borrow margin
        * @see https://bybit-exchange.github.io/docs/spot/v3/#t-borrowmarginloan
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol not used by bybit.borrowMargin ()
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        var marginModequeryVariable = this.handleMarginModeAndParams("borrowMargin", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            throw new NotSupported ((string)add(this.id, " borrowMargin () cannot use isolated margin")) ;
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "qty", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostSpotV3PrivateCrossMarginLoan(this.extend(request, query));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //             "transactId": "14143"
        //         },
        //         "retExtInfo": null,
        //         "time": 1662617848970
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(result, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "symbol", symbol },
            { "amount", amount },
        });
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#repayMargin
        * @description repay borrowed margin and interest
        * @see https://bybit-exchange.github.io/docs/spot/v3/#t-repaymarginloan
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol not used by bybit.repayMargin ()
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        var marginModequeryVariable = this.handleMarginModeAndParams("repayMargin", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            throw new NotSupported ((string)add(this.id, " repayMargin () cannot use isolated margin")) ;
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "qty", this.numberToString(amount) },
        };
        object response = await this.privatePostSpotV3PrivateCrossMarginRepay(this.extend(request, query));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "success",
        //         "result": {
        //            "repayId": "12128"
        //         },
        //         "retExtInfo": null,
        //         "time": 1662618298452
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(result, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "symbol", symbol },
            { "amount", amount },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "transactId": "14143"
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId": "12128"
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "transactId", "repayId") },
            { "currency", this.safeString(currency, "code") },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
            { "OK", "ok" },
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transferId": "22c2bc11-ed5b-49a4-8647-c4e0f5f6f2b2" // transfer_id in v1
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "transferId": "e9c421c4-b010-4b16-abd6-106179f27702", // transfer_id in v1
        //         "coin": "USDT",
        //         "amount": "8",
        //         "fromAccountType": "FUND", // from_account_type in v1
        //         "toAccountType": "SPOT", // to_account_type in v1
        //         "timestamp": "1666879426000",
        //         "status": "SUCCESS"
        //      }
        //
        object currencyId = this.safeString(transfer, "coin");
        object timestamp = this.safeInteger(transfer, "timestamp");
        object fromAccountId = this.safeString2(transfer, "fromAccountType", "from_account_type");
        object toAccountId = this.safeString2(transfer, "toAccountType", "to_account_type");
        object accountIds = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(accountIds, fromAccountId, fromAccountId);
        object toAccount = this.safeString(accountIds, toAccountId, toAccountId);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString2(transfer, "transferId", "transfer_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status")) },
        };
    }

    public async virtual Task<object> fetchDerivativesMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "linear")))
        {
            ((Dictionary<string, object>)request)["category"] = "linear";
        } else if (isTrue(getValue(market, "inverse")))
        {
            ((Dictionary<string, object>)request)["category"] = "inverse";
        }
        object response = await this.publicGetV5MarketRiskLimit(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "category": "inverse",
        //             "list": [
        //                 {
        //                     "id": 1,
        //                     "symbol": "BTCUSD",
        //                     "riskLimitValue": "150",
        //                     "maintenanceMargin": "0.5",
        //                     "initialMargin": "1",
        //                     "isLowestRisk": 1,
        //                     "maxLeverage": "100.00"
        //                 },
        //             ....
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1672054488010
        //     }
        //
        object result = this.safeValue(response, "result");
        object tiers = this.safeValue(result, "list");
        return this.parseMarketLeverageTiers(tiers, market);
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchMarketLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
        * @see https://bybit-exchange.github.io/docs/v5/market/risk-limit
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        market = this.market(symbol);
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(getValue(market, "option"))))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchMarketLeverageTiers() symbol does not support market "), symbol)) ;
        }
        ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        return await this.fetchDerivativesMarketLeverageTiers(symbol, parameters);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     {
        //         "id": 1,
        //         "symbol": "BTCUSD",
        //         "riskLimitValue": "150",
        //         "maintenanceMargin": "0.5",
        //         "initialMargin": "1",
        //         "isLowestRisk": 1,
        //         "maxLeverage": "100.00"
        //     }
        //
        object minNotional = 0;
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object item = getValue(info, i);
            object maxNotional = this.safeNumber(item, "riskLimitValue");
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "base") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(item, "maintenanceMargin") },
                { "maxLeverage", this.safeNumber(item, "maxLeverage") },
                { "info", item },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "makerFeeRate": 0.001,
        //         "takerFeeRate": 0.001
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId, null, null, "contract");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "makerFeeRate") },
            { "taker", this.safeNumber(fee, "takerFeeRate") },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://bybit-exchange.github.io/docs/v5/account/fee-rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFee() is not supported for spot market")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetV5AccountFeeRate(this.extend(request, parameters));
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "takerFeeRate": "0.0006",
        //                     "makerFeeRate": "0.0001"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1676360412576
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object fees = this.safeValue(result, "list", new List<object>() {});
        object first = this.safeValue(fees, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bybit#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://bybit-exchange.github.io/docs/v5/account/fee-rate
        * @param {object} params extra parameters specific to the bybit api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
                var typeparametersVariable = this.handleOptionAndParams(parameters, "fetchTradingFees", "type", "future");
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFees() is not supported for spot market")) ;
        }
        object response = await this.privateGetV5AccountFeeRate(parameters);
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "OK",
        //         "result": {
        //             "list": [
        //                 {
        //                     "symbol": "ETHUSDT",
        //                     "takerFeeRate": "0.0006",
        //                     "makerFeeRate": "0.0001"
        //                 }
        //             ]
        //         },
        //         "retExtInfo": {},
        //         "time": 1676360412576
        //     }
        //
        object fees = this.safeValue(response, "result", new Dictionary<string, object>() {});
        fees = this.safeValue(fees, "list", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = this.parseTradingFee(getValue(fees, i));
            object symbol = getValue(fee, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.rawencode(parameters)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object isOpenapi = isGreaterThanOrEqual(getIndexOf(url, "openapi"), 0);
            object isV3UnifiedMargin = isGreaterThanOrEqual(getIndexOf(url, "unified/v3"), 0);
            object isV3Contract = isGreaterThanOrEqual(getIndexOf(url, "contract/v3"), 0);
            object isV5UnifiedAccount = isGreaterThanOrEqual(getIndexOf(url, "v5"), 0);
            object timestamp = ((object)this.nonce()).ToString();
            if (isTrue(isOpenapi))
            {
                if (isTrue(getArrayLength(new List<string>(((Dictionary<string,object>)parameters).Keys))))
                {
                    body = this.json(parameters);
                } else
                {
                    // this fix for PHP is required otherwise it generates
                    // '[]' on empty arrays even when forced to use objects
                    body = "{}";
                }
                object payload = add(add(timestamp, this.apiKey), body);
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "hex");
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json" },
                    { "X-BAPI-API-KEY", this.apiKey },
                    { "X-BAPI-TIMESTAMP", timestamp },
                    { "X-BAPI-SIGN", signature },
                };
            } else if (isTrue(isTrue(isTrue(isV3UnifiedMargin) || isTrue(isV3Contract)) || isTrue(isV5UnifiedAccount)))
            {
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json" },
                    { "X-BAPI-API-KEY", this.apiKey },
                    { "X-BAPI-TIMESTAMP", timestamp },
                    { "X-BAPI-RECV-WINDOW", ((object)getValue(this.options, "recvWindow")).ToString() },
                };
                if (isTrue(isTrue(isV3UnifiedMargin) || isTrue(isV3Contract)))
                {
                    ((Dictionary<string, object>)headers)["X-BAPI-SIGN-TYPE"] = "2";
                }
                object query = this.extend(new Dictionary<string, object>() {}, parameters);
                object queryEncoded = this.rawencode(query);
                object auth_base = add(add(((object)timestamp).ToString(), this.apiKey), ((object)getValue(this.options, "recvWindow")).ToString());
                object authFull = null;
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    authFull = add(auth_base, body);
                } else
                {
                    authFull = add(auth_base, queryEncoded);
                    url = add(url, add("?", this.rawencode(query)));
                }
                ((Dictionary<string, object>)headers)["X-BAPI-SIGN"] = this.hmac(this.encode(authFull), this.encode(this.secret), sha256);
            } else
            {
                object query = this.extend(parameters, new Dictionary<string, object>() {
                    { "api_key", this.apiKey },
                    { "recv_window", getValue(this.options, "recvWindow") },
                    { "timestamp", timestamp },
                });
                object sortedQuery = this.keysort(query);
                object auth = this.rawencode(sortedQuery);
                object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
                if (isTrue(isEqual(method, "POST")))
                {
                    object isSpot = isGreaterThanOrEqual(getIndexOf(url, "spot"), 0);
                    object extendedQuery = this.extend(query, new Dictionary<string, object>() {
                        { "sign", signature },
                    });
                    if (isTrue(isSpot))
                    {
                        body = this.urlencode(extendedQuery);
                        headers = new Dictionary<string, object>() {
                            { "Content-Type", "application/x-www-form-urlencoded" },
                        };
                    } else
                    {
                        body = this.json(extendedQuery);
                        headers = new Dictionary<string, object>() {
                            { "Content-Type", "application/json" },
                        };
                    }
                } else
                {
                    url = add(url, add("?", this.rawencode(sortedQuery)));
                    url = add(url, add("&sign=", signature));
                }
            }
        }
        if (isTrue(isEqual(method, "POST")))
        {
            object brokerId = this.safeString(this.options, "brokerId");
            if (isTrue(!isEqual(brokerId, null)))
            {
                ((Dictionary<string, object>)headers)["Referer"] = brokerId;
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {
        //         ret_code: 10001,
        //         ret_msg: 'ReadMapCB: expect { or n, but found \u0000, error ' +
        //         'found in #0 byte of ...||..., bigger context ' +
        //         '...||...',
        //         ext_code: '',
        //         ext_info: '',
        //         result: null,
        //         time_now: '1583934106.590436'
        //     }
        //
        //     {
        //         "retCode":10001,
        //         "retMsg":"symbol params err",
        //         "result":{"symbol":"","bid":"","bidIv":"","bidSize":"","ask":"","askIv":"","askSize":"","lastPrice":"","openInterest":"","indexPrice":"","markPrice":"","markPriceIv":"","change24h":"","high24h":"","low24h":"","volume24h":"","turnover24h":"","totalVolume":"","totalTurnover":"","fundingRate":"","predictedFundingRate":"","nextFundingTime":"","countdownHour":"0","predictedDeliveryPrice":"","underlyingPrice":"","delta":"","gamma":"","vega":"","theta":""}
        //     }
        //
        object errorCode = this.safeString2(response, "ret_code", "retCode");
        if (isTrue(!isEqual(errorCode, "0")))
        {
            if (isTrue(isEqual(errorCode, "30084")))
            {
                // not an error
                // https://github.com/ccxt/ccxt/issues/11268
                // https://github.com/ccxt/ccxt/pull/11624
                // POST https://api.bybit.com/v2/private/position/switch-isolated 200 OK
                // {"ret_code":30084,"ret_msg":"Isolated not modified","ext_code":"","ext_info":"","result":null,"time_now":"1642005219.937988","rate_limit_status":73,"rate_limit_reset_ms":1642005219894,"rate_limit":75}
                return null;
            }
            object feedback = null;
            if (isTrue(isEqual(errorCode, "10005")))
            {
                feedback = add(add(this.id, " private api uses /user/v3/private/query-api to check if you have a unified account. The API key of user id must own one of permissions: \"Account Transfer\", \"Subaccount Transfer\", \"Withdrawal\" "), body);
            } else
            {
                feedback = add(add(this.id, " "), body);
            }
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
