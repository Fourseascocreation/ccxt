using ccxt;
namespace ccxt;
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class Exchange
{


    public virtual object filterByLimit(object array, object limit = null, object key = null)
    {
        key ??= "timestamp";
        if (isTrue(this.valueIsDefined(limit)))
        {
            object arrayLength = getArrayLength(array);
            if (isTrue(isGreaterThan(arrayLength, 0)))
            {
                object ascending = true;
                if (isTrue((inOp(getValue(array, 0), key))))
                {
                    object first = getValue(getValue(array, 0), key);
                    object last = getValue(getValue(array, subtract(arrayLength, 1)), key);
                    if (isTrue(isTrue(!isEqual(first, null)) && isTrue(!isEqual(last, null))))
                    {
                        ascending = isLessThan(first, last); // true if array is sorted in ascending order based on 'timestamp'
                    }
                }
                array = ((bool) isTrue(ascending)) ? this.arraySlice(array, prefixUnaryNeg(ref limit)) : this.arraySlice(array, 0, limit);
            }
        }
        return array;
    }

    public virtual object filterBySinceLimit(object array, object since = null, object limit = null, object key = null)
    {
        key ??= "timestamp";
        object sinceIsDefined = this.valueIsDefined(since);
        object parsedArray = ((object)this.toArray(array));
        if (isTrue(sinceIsDefined))
        {
            object result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(parsedArray)); postFixIncrement(ref i))
            {
                object entry = getValue(parsedArray, i);
                if (isTrue(isGreaterThanOrEqual(getValue(entry, key), since)))
                {
                    ((List<object>)result).Add(entry);
                }
            }
            return this.filterByLimit(result, limit, key);
        }
        return this.filterByLimit(parsedArray, limit, key);
    }

    public virtual object filterByValueSinceLimit(object array, object field, object value = null, object since = null, object limit = null, object key = null)
    {
        key ??= "timestamp";
        object valueIsDefined = this.valueIsDefined(value);
        object sinceIsDefined = this.valueIsDefined(since);
        object parsedArray = ((object)this.toArray(array));
        // single-pass filter for both symbol and since
        if (isTrue(isTrue(valueIsDefined) || isTrue(sinceIsDefined)))
        {
            object result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(parsedArray)); postFixIncrement(ref i))
            {
                object entry = getValue(parsedArray, i);
                object entryFiledEqualValue = isEqual(getValue(entry, field), value);
                object firstCondition = ((bool) isTrue(valueIsDefined)) ? entryFiledEqualValue : true;
                object entryKeyGESince = isTrue(isTrue(getValue(entry, key)) && isTrue(since)) && isTrue((isGreaterThanOrEqual(getValue(entry, key), since)));
                object secondCondition = ((bool) isTrue(sinceIsDefined)) ? entryKeyGESince : true;
                if (isTrue(isTrue(firstCondition) && isTrue(secondCondition)))
                {
                    ((List<object>)result).Add(entry);
                }
            }
            return this.filterByLimit(result, limit, key);
        }
        return this.filterByLimit(parsedArray, limit, key);
    }

    public virtual object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        return new Dictionary<string, object>() {};
    }

    public async virtual Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchAccounts() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTrades() is not supported yet")) ;
    }

    public async virtual Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDepositAddresses() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderBook() is not supported yet")) ;
    }

    public async virtual Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOrderBook() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTime() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingLimits(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTradingLimits() is not supported yet")) ;
    }

    public virtual object parseTicker(object ticker, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTicker() is not supported yet")) ;
    }

    public virtual object parseDepositAddress(object depositAddress, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseDepositAddress() is not supported yet")) ;
    }

    public virtual object parseTrade(object trade, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTrade() is not supported yet")) ;
    }

    public virtual object parseTransaction(object transaction, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTransaction() is not supported yet")) ;
    }

    public virtual object parseTransfer(object transfer, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTransfer() is not supported yet")) ;
    }

    public virtual object parseAccount(object account)
    {
        throw new NotSupported ((string)add(this.id, " parseAccount() is not supported yet")) ;
    }

    public virtual object parseLedgerEntry(object item, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseLedgerEntry() is not supported yet")) ;
    }

    public virtual object parseOrder(object order, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseOrder() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBorrowRates(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBorrowRates() is not supported yet")) ;
    }

    public virtual object parseMarketLeverageTiers(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseMarketLeverageTiers() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLeverageTiers() is not supported yet")) ;
    }

    public virtual object parsePosition(object position, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parsePosition() is not supported yet")) ;
    }

    public virtual object parseFundingRateHistory(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseFundingRateHistory() is not supported yet")) ;
    }

    public virtual object parseBorrowInterest(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseBorrowInterest() is not supported yet")) ;
    }

    public async virtual Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchFundingRates() is not supported yet")) ;
    }

    public async virtual Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " transfer() is not supported yet")) ;
    }

    public async virtual Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " withdraw() is not supported yet")) ;
    }

    public async virtual Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " createDepositAddress() is not supported yet")) ;
    }

    public async virtual Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " setLeverage() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenInterestHistory() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenInterest() is not supported yet")) ;
    }

    public async virtual Task<object> signIn(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " signIn() is not supported yet")) ;
    }

    public virtual object parseToInt(object number)
    {
        // Solve Common parseInt misuse ex: parseInt ((since / 1000).toString ())
        // using a number as parameter which is not valid in ts
        object stringifiedNumber = ((object)number).ToString();
        object convertedNumber = ((object)parseFloat(stringifiedNumber));
        return parseInt(convertedNumber);
    }

    public virtual object getDefaultOptions()
    {
        return new Dictionary<string, object>() {
            { "defaultNetworkCodeReplacements", new Dictionary<string, object>() {
                { "ETH", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                } },
                { "TRX", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                } },
                { "CRO", new Dictionary<string, object>() {
                    { "CRC20", "CRONOS" },
                } },
            } },
        };
    }

    public virtual object safeLedgerEntry(object entry, object currency = null)
    {
        currency = this.safeCurrency(null, currency);
        object direction = this.safeString(entry, "direction");
        object before = this.safeString(entry, "before");
        object after = this.safeString(entry, "after");
        object amount = this.safeString(entry, "amount");
        if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(isTrue(isEqual(before, null)) && isTrue(!isEqual(after, null))))
            {
                before = Precise.stringSub(after, amount);
            } else if (isTrue(isTrue(!isEqual(before, null)) && isTrue(isEqual(after, null))))
            {
                after = Precise.stringAdd(before, amount);
            }
        }
        if (isTrue(isTrue(!isEqual(before, null)) && isTrue(!isEqual(after, null))))
        {
            if (isTrue(isEqual(direction, null)))
            {
                if (isTrue(Precise.stringGt(before, after)))
                {
                    direction = "out";
                }
                if (isTrue(Precise.stringGt(after, before)))
                {
                    direction = "in";
                }
            }
        }
        object fee = this.safeValue(entry, "fee");
        if (isTrue(!isEqual(fee, null)))
        {
            ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
        }
        object timestamp = this.safeInteger(entry, "timestamp");
        return new Dictionary<string, object>() {
            { "id", this.safeString(entry, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", this.safeString(entry, "account") },
            { "referenceId", this.safeString(entry, "referenceId") },
            { "referenceAccount", this.safeString(entry, "referenceAccount") },
            { "type", this.safeString(entry, "type") },
            { "currency", getValue(currency, "code") },
            { "amount", this.parseNumber(amount) },
            { "before", this.parseNumber(before) },
            { "after", this.parseNumber(after) },
            { "status", this.safeString(entry, "status") },
            { "fee", fee },
            { "info", entry },
        };
    }

    public virtual object safeCurrencyStructure(object currency)
    {
        return this.extend(new Dictionary<string, object>() {
            { "info", null },
            { "id", null },
            { "numericId", null },
            { "code", null },
            { "precision", null },
            { "type", null },
            { "name", null },
            { "active", null },
            { "deposit", null },
            { "withdraw", null },
            { "fee", null },
            { "fees", new Dictionary<string, object>() {} },
            { "networks", new Dictionary<string, object>() {} },
            { "limits", new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
        }, currency);
    }

    public virtual object setMarkets(object markets, object currencies = null)
    {
        object values = new List<object>() {};
        this.markets_by_id = new Dictionary<string, object>() {};
        // handle marketId conflicts
        // we insert spot markets first
        object marketValues = this.sortBy(this.toArray(markets), "spot", true);
        for (object i = 0; isLessThan(i, getArrayLength(marketValues)); postFixIncrement(ref i))
        {
            object value = getValue(marketValues, i);
            if (isTrue(inOp(this.markets_by_id, getValue(value, "id"))))
            {
                ((List<object>)((object)getValue(this.markets_by_id, getValue(value, "id")))).Add(value);
            } else
            {
                ((Dictionary<string, object>)this.markets_by_id)[(string)getValue(value, "id")] = ((object)new List<object>() {value});
            }
            object market = this.deepExtend(this.safeMarket(), new Dictionary<string, object>() {
                { "precision", this.precision },
                { "limits", this.limits },
            }, getValue(this.fees, "trading"), value);
            ((List<object>)values).Add(market);
        }
        this.markets = ((object)this.indexBy(values, "symbol"));
        object marketsSortedBySymbol = this.keysort(this.markets);
        object marketsSortedById = this.keysort(this.markets_by_id);
        this.symbols = new List<object>(((Dictionary<string,object>)marketsSortedBySymbol).Keys);
        this.ids = new List<object>(((Dictionary<string,object>)marketsSortedById).Keys);
        if (isTrue(!isEqual(currencies, null)))
        {
            // currencies is always undefined when called in constructor but not when called from loadMarkets
            this.currencies = this.deepExtend(this.currencies, currencies);
        } else
        {
            object baseCurrencies = new List<object>() {};
            object quoteCurrencies = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(values)); postFixIncrement(ref i))
            {
                object market = getValue(values, i);
                object defaultCurrencyPrecision = ((bool) isTrue((isEqual(this.precisionMode, DECIMAL_PLACES)))) ? 8 : this.parseNumber("1e-8");
                object marketPrecision = this.safeValue(market, "precision", new Dictionary<string, object>() {});
                if (isTrue(inOp(market, "base")))
                {
                    object currency = this.safeCurrencyStructure(new Dictionary<string, object>() {
                        { "id", this.safeString2(market, "baseId", "base") },
                        { "numericId", this.safeInteger(market, "baseNumericId") },
                        { "code", this.safeString(market, "base") },
                        { "precision", this.safeValue2(marketPrecision, "base", "amount", defaultCurrencyPrecision) },
                    });
                    ((List<object>)baseCurrencies).Add(currency);
                }
                if (isTrue(inOp(market, "quote")))
                {
                    object currency = this.safeCurrencyStructure(new Dictionary<string, object>() {
                        { "id", this.safeString2(market, "quoteId", "quote") },
                        { "numericId", this.safeInteger(market, "quoteNumericId") },
                        { "code", this.safeString(market, "quote") },
                        { "precision", this.safeValue2(marketPrecision, "quote", "price", defaultCurrencyPrecision) },
                    });
                    ((List<object>)quoteCurrencies).Add(currency);
                }
            }
            baseCurrencies = this.sortBy(baseCurrencies, "code");
            quoteCurrencies = this.sortBy(quoteCurrencies, "code");
            this.baseCurrencies = this.indexBy(baseCurrencies, "code");
            this.quoteCurrencies = this.indexBy(quoteCurrencies, "code");
            object allCurrencies = this.arrayConcat(baseCurrencies, quoteCurrencies);
            object groupedCurrencies = this.groupBy(allCurrencies, "code");
            object codes = new List<object>(((Dictionary<string,object>)groupedCurrencies).Keys);
            object resultingCurrencies = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
            {
                object code = getValue(codes, i);
                object groupedCurrenciesCode = this.safeValue(groupedCurrencies, code, new List<object>() {});
                object highestPrecisionCurrency = this.safeValue(groupedCurrenciesCode, 0);
                for (object j = 1; isLessThan(j, getArrayLength(groupedCurrenciesCode)); postFixIncrement(ref j))
                {
                    object currentCurrency = getValue(groupedCurrenciesCode, j);
                    if (isTrue(isEqual(this.precisionMode, TICK_SIZE)))
                    {
                        highestPrecisionCurrency = ((bool) isTrue((isLessThan(getValue(currentCurrency, "precision"), getValue(highestPrecisionCurrency, "precision"))))) ? currentCurrency : highestPrecisionCurrency;
                    } else
                    {
                        highestPrecisionCurrency = ((bool) isTrue((isGreaterThan(getValue(currentCurrency, "precision"), getValue(highestPrecisionCurrency, "precision"))))) ? currentCurrency : highestPrecisionCurrency;
                    }
                }
                ((List<object>)resultingCurrencies).Add(highestPrecisionCurrency);
            }
            object sortedCurrencies = this.sortBy(resultingCurrencies, "code");
            this.currencies = this.deepExtend(this.currencies, this.indexBy(sortedCurrencies, "code"));
        }
        this.currencies_by_id = this.indexBy(this.currencies, "id");
        object currenciesSortedByCode = this.keysort(this.currencies);
        this.codes = new List<object>(((Dictionary<string,object>)currenciesSortedByCode).Keys);
        return this.markets;
    }

    public virtual object safeBalance(object balance)
    {
        object balances = this.omit(balance, new List<object>() {"info", "timestamp", "datetime", "free", "used", "total"});
        object codes = new List<object>(((Dictionary<string,object>)balances).Keys);
        ((Dictionary<string, object>)balance)["free"] = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)balance)["used"] = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)balance)["total"] = new Dictionary<string, object>() {};
        object debtBalance = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            object code = getValue(codes, i);
            object total = this.safeString(getValue(balance, code), "total");
            object free = this.safeString(getValue(balance, code), "free");
            object used = this.safeString(getValue(balance, code), "used");
            object debt = this.safeString(getValue(balance, code), "debt");
            if (isTrue(isTrue(isTrue((isEqual(total, null))) && isTrue((!isEqual(free, null)))) && isTrue((!isEqual(used, null)))))
            {
                total = Precise.stringAdd(free, used);
            }
            if (isTrue(isTrue(isTrue((isEqual(free, null))) && isTrue((!isEqual(total, null)))) && isTrue((!isEqual(used, null)))))
            {
                free = Precise.stringSub(total, used);
            }
            if (isTrue(isTrue(isTrue((isEqual(used, null))) && isTrue((!isEqual(total, null)))) && isTrue((!isEqual(free, null)))))
            {
                used = Precise.stringSub(total, free);
            }
            ((Dictionary<string, object>)getValue(balance, code))["free"] = this.parseNumber(free);
            ((Dictionary<string, object>)getValue(balance, code))["used"] = this.parseNumber(used);
            ((Dictionary<string, object>)getValue(balance, code))["total"] = this.parseNumber(total);
            ((Dictionary<string, object>)getValue(balance, "free"))[(string)code] = getValue(getValue(balance, code), "free");
            ((Dictionary<string, object>)getValue(balance, "used"))[(string)code] = getValue(getValue(balance, code), "used");
            ((Dictionary<string, object>)getValue(balance, "total"))[(string)code] = getValue(getValue(balance, code), "total");
            if (isTrue(!isEqual(debt, null)))
            {
                ((Dictionary<string, object>)getValue(balance, code))["debt"] = this.parseNumber(debt);
                ((Dictionary<string, object>)debtBalance)[(string)code] = getValue(getValue(balance, code), "debt");
            }
        }
        object debtBalanceArray = new List<object>(((Dictionary<string,object>)debtBalance).Keys);
        object length = getArrayLength(debtBalanceArray);
        if (isTrue(length))
        {
            ((Dictionary<string, object>)balance)["debt"] = debtBalance;
        }
        return ((object)balance);
    }

    public virtual object safeOrder(object order, object market = null)
    {
        // parses numbers as strings
        // * it is important pass the trades as unparsed rawTrades
        object amount = this.omitZero(this.safeString(order, "amount"));
        object remaining = this.safeString(order, "remaining");
        object filled = this.safeString(order, "filled");
        object cost = this.safeString(order, "cost");
        object average = this.omitZero(this.safeString(order, "average"));
        object price = this.omitZero(this.safeString(order, "price"));
        object lastTradeTimeTimestamp = this.safeInteger(order, "lastTradeTimestamp");
        object symbol = this.safeString(order, "symbol");
        object side = this.safeString(order, "side");
        object parseFilled = (isEqual(filled, null));
        object parseCost = (isEqual(cost, null));
        object parseLastTradeTimeTimestamp = (isEqual(lastTradeTimeTimestamp, null));
        object fee = this.safeValue(order, "fee");
        object parseFee = (isEqual(fee, null));
        object parseFees = isEqual(this.safeValue(order, "fees"), null);
        object parseSymbol = isEqual(symbol, null);
        object parseSide = isEqual(side, null);
        object shouldParseFees = isTrue(parseFee) || isTrue(parseFees);
        object fees = this.safeValue(order, "fees", new List<object>() {});
        object trades = new List<object>() {};
        if (isTrue(isTrue(isTrue(parseFilled) || isTrue(parseCost)) || isTrue(shouldParseFees)))
        {
            object rawTrades = this.safeValue(order, "trades", trades);
            object oldNumber = this.number;
            // we parse trades as strings here!
            this.number = typeof(String);
            trades = this.parseTrades(rawTrades, market);
            this.number = oldNumber;
            object tradesLength = 0;
            object isArray = (trades.GetType().IsGenericType && trades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)));
            if (isTrue(isArray))
            {
                tradesLength = getArrayLength(trades);
            }
            if (isTrue(isTrue(isArray) && isTrue((isGreaterThan(tradesLength, 0)))))
            {
                // move properties that are defined in trades up into the order
                if (isTrue(isEqual(getValue(order, "symbol"), null)))
                {
                    ((Dictionary<string, object>)order)["symbol"] = getValue(getValue(trades, 0), "symbol");
                }
                if (isTrue(isEqual(getValue(order, "side"), null)))
                {
                    ((Dictionary<string, object>)order)["side"] = getValue(getValue(trades, 0), "side");
                }
                if (isTrue(isEqual(getValue(order, "type"), null)))
                {
                    ((Dictionary<string, object>)order)["type"] = getValue(getValue(trades, 0), "type");
                }
                if (isTrue(isEqual(getValue(order, "id"), null)))
                {
                    ((Dictionary<string, object>)order)["id"] = getValue(getValue(trades, 0), "order");
                }
                if (isTrue(parseFilled))
                {
                    filled = "0";
                }
                if (isTrue(parseCost))
                {
                    cost = "0";
                }
                for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
                {
                    object trade = getValue(trades, i);
                    object tradeAmount = this.safeString(trade, "amount");
                    if (isTrue(isTrue(parseFilled) && isTrue((!isEqual(tradeAmount, null)))))
                    {
                        filled = Precise.stringAdd(filled, tradeAmount);
                    }
                    object tradeCost = this.safeString(trade, "cost");
                    if (isTrue(isTrue(parseCost) && isTrue((!isEqual(tradeCost, null)))))
                    {
                        cost = Precise.stringAdd(cost, tradeCost);
                    }
                    if (isTrue(parseSymbol))
                    {
                        symbol = this.safeString(trade, "symbol");
                    }
                    if (isTrue(parseSide))
                    {
                        side = this.safeString(trade, "side");
                    }
                    object tradeTimestamp = this.safeValue(trade, "timestamp");
                    if (isTrue(isTrue(parseLastTradeTimeTimestamp) && isTrue((!isEqual(tradeTimestamp, null)))))
                    {
                        if (isTrue(isEqual(lastTradeTimeTimestamp, null)))
                        {
                            lastTradeTimeTimestamp = tradeTimestamp;
                        } else
                        {
                            lastTradeTimeTimestamp = mathMax(lastTradeTimeTimestamp, tradeTimestamp);
                        }
                    }
                    if (isTrue(shouldParseFees))
                    {
                        object tradeFees = this.safeValue(trade, "fees");
                        if (isTrue(!isEqual(tradeFees, null)))
                        {
                            for (object j = 0; isLessThan(j, getArrayLength(tradeFees)); postFixIncrement(ref j))
                            {
                                object tradeFee = getValue(tradeFees, j);
                                ((List<object>)fees).Add(this.extend(new Dictionary<string, object>() {}, tradeFee));
                            }
                        } else
                        {
                            object tradeFee = this.safeValue(trade, "fee");
                            if (isTrue(!isEqual(tradeFee, null)))
                            {
                                ((List<object>)fees).Add(this.extend(new Dictionary<string, object>() {}, tradeFee));
                            }
                        }
                    }
                }
            }
        }
        if (isTrue(shouldParseFees))
        {
            object reducedFees = ((bool) isTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees;
            object reducedLength = getArrayLength(reducedFees);
            for (object i = 0; isLessThan(i, reducedLength); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)getValue(reducedFees, i))["cost"] = this.safeNumber(getValue(reducedFees, i), "cost");
                if (isTrue(inOp(getValue(reducedFees, i), "rate")))
                {
                    ((Dictionary<string, object>)getValue(reducedFees, i))["rate"] = this.safeNumber(getValue(reducedFees, i), "rate");
                }
            }
            if (isTrue(!isTrue(parseFee) && isTrue((isEqual(reducedLength, 0)))))
            {
                ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
                if (isTrue(inOp(fee, "rate")))
                {
                    ((Dictionary<string, object>)fee)["rate"] = this.safeNumber(fee, "rate");
                }
                ((List<object>)reducedFees).Add(fee);
            }
            ((Dictionary<string, object>)order)["fees"] = reducedFees;
            if (isTrue(isTrue(parseFee) && isTrue((isEqual(reducedLength, 1)))))
            {
                ((Dictionary<string, object>)order)["fee"] = getValue(reducedFees, 0);
            }
        }
        if (isTrue(isEqual(amount, null)))
        {
            // ensure amount = filled + remaining
            if (isTrue(isTrue(!isEqual(filled, null)) && isTrue(!isEqual(remaining, null))))
            {
                amount = Precise.stringAdd(filled, remaining);
            } else if (isTrue(isEqual(this.safeString(order, "status"), "closed")))
            {
                amount = filled;
            }
        }
        if (isTrue(isEqual(filled, null)))
        {
            if (isTrue(isTrue(!isEqual(amount, null)) && isTrue(!isEqual(remaining, null))))
            {
                filled = Precise.stringSub(amount, remaining);
            }
        }
        if (isTrue(isEqual(remaining, null)))
        {
            if (isTrue(isTrue(!isEqual(amount, null)) && isTrue(!isEqual(filled, null))))
            {
                remaining = Precise.stringSub(amount, filled);
            }
        }
        // ensure that the average field is calculated correctly
        object inverse = this.safeValue(market, "inverse", false);
        object contractSize = this.numberToString(this.safeValue(market, "contractSize", 1));
        // inverse
        // price = filled * contract size / cost
        //
        // linear
        // price = cost / (filled * contract size)
        if (isTrue(isEqual(average, null)))
        {
            if (isTrue(isTrue(isTrue((!isEqual(filled, null))) && isTrue((!isEqual(cost, null)))) && isTrue(Precise.stringGt(filled, "0"))))
            {
                object filledTimesContractSize = Precise.stringMul(filled, contractSize);
                if (isTrue(inverse))
                {
                    average = Precise.stringDiv(filledTimesContractSize, cost);
                } else
                {
                    average = Precise.stringDiv(cost, filledTimesContractSize);
                }
            }
        }
        // similarly
        // inverse
        // cost = filled * contract size / price
        //
        // linear
        // cost = filled * contract size * price
        object costPriceExists = isTrue((!isEqual(average, null))) || isTrue((!isEqual(price, null)));
        if (isTrue(isTrue(isTrue(parseCost) && isTrue((!isEqual(filled, null)))) && isTrue(costPriceExists)))
        {
            object multiplyPrice = null;
            if (isTrue(isEqual(average, null)))
            {
                multiplyPrice = price;
            } else
            {
                multiplyPrice = average;
            }
            // contract trading
            object filledTimesContractSize = Precise.stringMul(filled, contractSize);
            if (isTrue(inverse))
            {
                cost = Precise.stringDiv(filledTimesContractSize, multiplyPrice);
            } else
            {
                cost = Precise.stringMul(filledTimesContractSize, multiplyPrice);
            }
        }
        // support for market orders
        object orderType = this.safeValue(order, "type");
        object emptyPrice = isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"));
        if (isTrue(isTrue(emptyPrice) && isTrue((isEqual(orderType, "market")))))
        {
            price = average;
        }
        // we have trades with string values at this point so we will mutate them
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object entry = getValue(trades, i);
            ((Dictionary<string, object>)entry)["amount"] = this.safeNumber(entry, "amount");
            ((Dictionary<string, object>)entry)["price"] = this.safeNumber(entry, "price");
            ((Dictionary<string, object>)entry)["cost"] = this.safeNumber(entry, "cost");
            object feeNew = this.safeValue(entry, "fee", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)feeNew)["cost"] = this.safeNumber(feeNew, "cost");
            if (isTrue(inOp(feeNew, "rate")))
            {
                ((Dictionary<string, object>)feeNew)["rate"] = this.safeNumber(feeNew, "rate");
            }
            ((Dictionary<string, object>)entry)["fee"] = feeNew;
        }
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = this.safeValue(order, "postOnly");
        // timeInForceHandling
        if (isTrue(isEqual(timeInForce, null)))
        {
            if (isTrue(isEqual(this.safeString(order, "type"), "market")))
            {
                timeInForce = "IOC";
            }
            // allow postOnly override
            if (isTrue(postOnly))
            {
                timeInForce = "PO";
            }
        } else if (isTrue(isEqual(postOnly, null)))
        {
            // timeInForce is not undefined here
            postOnly = isEqual(timeInForce, "PO");
        }
        object timestamp = this.safeInteger(order, "timestamp");
        object datetime = this.safeString(order, "datetime");
        if (isTrue(isEqual(datetime, null)))
        {
            datetime = this.iso8601(timestamp);
        }
        object triggerPrice = this.parseNumber(this.safeString2(order, "triggerPrice", "stopPrice"));
        return this.extend(order, new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "symbol", symbol },
            { "type", this.safeString(order, "type") },
            { "side", side },
            { "lastTradeTimestamp", lastTradeTimeTimestamp },
            { "price", this.parseNumber(price) },
            { "amount", this.parseNumber(amount) },
            { "cost", this.parseNumber(cost) },
            { "average", this.parseNumber(average) },
            { "filled", this.parseNumber(filled) },
            { "remaining", this.parseNumber(remaining) },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "trades", trades },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "status", this.safeString(order, "status") },
            { "fee", this.safeValue(order, "fee") },
        });
    }

    public virtual object parseOrders(object orders, object market = null, object since = null, object limit = null, object parameters = null)
    {
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object order = this.extend(this.parseOrder(getValue(orders, i), market), parameters);
                ((List<object>)results).Add(order);
            }
        } else
        {
            object ids = new List<object>(((Dictionary<string,object>)orders).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                object id = getValue(ids, i);
                object order = this.extend(this.parseOrder(this.extend(new Dictionary<string, object>() {
                    { "id", id },
                }, getValue(orders, id)), market), parameters);
                ((List<object>)results).Add(order);
            }
        }
        results = this.sortBy(results, "timestamp");
        object symbol = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "symbol") : null;
        return this.filterBySymbolSinceLimit(results, symbol, since, limit);
    }

    public virtual object calculateFee(object symbol, object type, object side, object amount, object price, object takerOrMaker = null, object parameters = null)
    {
        takerOrMaker ??= "taker";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(type, "market")) && isTrue(isEqual(takerOrMaker, "maker"))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " calculateFee() - you have provided incompatible arguments - \"market\" type order can not be \"maker\". Change either the \"type\" or the \"takerOrMaker\" argument to calculate the fee.")) ;
        }
        object market = getValue(this.markets, symbol);
        object feeSide = this.safeString(market, "feeSide", "quote");
        object useQuote = null;
        if (isTrue(isEqual(feeSide, "get")))
        {
            // the fee is always in the currency you get
            useQuote = isEqual(side, "sell");
        } else if (isTrue(isEqual(feeSide, "give")))
        {
            // the fee is always in the currency you give
            useQuote = isEqual(side, "buy");
        } else
        {
            // the fee is always in feeSide currency
            useQuote = isEqual(feeSide, "quote");
        }
        object cost = this.numberToString(amount);
        object key = null;
        if (isTrue(useQuote))
        {
            object priceString = this.numberToString(price);
            cost = Precise.stringMul(cost, priceString);
            key = "quote";
        } else
        {
            key = "base";
        }
        // for derivatives, the fee is in 'settle' currency
        if (!isTrue(getValue(market, "spot")))
        {
            key = "settle";
        }
        // even if `takerOrMaker` argument was set to 'maker', for 'market' orders we should forcefully override it to 'taker'
        if (isTrue(isEqual(type, "market")))
        {
            takerOrMaker = "taker";
        }
        object rate = this.safeString(market, takerOrMaker);
        cost = Precise.stringMul(cost, rate);
        return new Dictionary<string, object>() {
            { "type", takerOrMaker },
            { "currency", getValue(market, key) },
            { "rate", this.parseNumber(rate) },
            { "cost", this.parseNumber(cost) },
        };
    }

    public virtual object safeTrade(object trade, object market = null)
    {
        object amount = this.safeString(trade, "amount");
        object price = this.safeString(trade, "price");
        object cost = this.safeString(trade, "cost");
        if (isTrue(isEqual(cost, null)))
        {
            // contract trading
            object contractSize = this.safeString(market, "contractSize");
            object multiplyPrice = price;
            if (isTrue(!isEqual(contractSize, null)))
            {
                object inverse = this.safeValue(market, "inverse", false);
                if (isTrue(inverse))
                {
                    multiplyPrice = Precise.stringDiv("1", price);
                }
                multiplyPrice = Precise.stringMul(multiplyPrice, contractSize);
            }
            cost = Precise.stringMul(multiplyPrice, amount);
        }
        object parseFee = isEqual(this.safeValue(trade, "fee"), null);
        object parseFees = isEqual(this.safeValue(trade, "fees"), null);
        object shouldParseFees = isTrue(parseFee) || isTrue(parseFees);
        object fees = new List<object>() {};
        object fee = this.safeValue(trade, "fee");
        if (isTrue(shouldParseFees))
        {
            object reducedFees = ((bool) isTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees;
            object reducedLength = getArrayLength(reducedFees);
            for (object i = 0; isLessThan(i, reducedLength); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)getValue(reducedFees, i))["cost"] = this.safeNumber(getValue(reducedFees, i), "cost");
                if (isTrue(inOp(getValue(reducedFees, i), "rate")))
                {
                    ((Dictionary<string, object>)getValue(reducedFees, i))["rate"] = this.safeNumber(getValue(reducedFees, i), "rate");
                }
            }
            if (isTrue(!isTrue(parseFee) && isTrue((isEqual(reducedLength, 0)))))
            {
                ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
                if (isTrue(inOp(fee, "rate")))
                {
                    ((Dictionary<string, object>)fee)["rate"] = this.safeNumber(fee, "rate");
                }
                ((List<object>)reducedFees).Add(fee);
            }
            if (isTrue(parseFees))
            {
                ((Dictionary<string, object>)trade)["fees"] = reducedFees;
            }
            if (isTrue(isTrue(parseFee) && isTrue((isEqual(reducedLength, 1)))))
            {
                ((Dictionary<string, object>)trade)["fee"] = getValue(reducedFees, 0);
            }
            object tradeFee = this.safeValue(trade, "fee");
            if (isTrue(!isEqual(tradeFee, null)))
            {
                ((Dictionary<string, object>)tradeFee)["cost"] = this.safeNumber(tradeFee, "cost");
                if (isTrue(inOp(tradeFee, "rate")))
                {
                    ((Dictionary<string, object>)tradeFee)["rate"] = this.safeNumber(tradeFee, "rate");
                }
                ((Dictionary<string, object>)trade)["fee"] = tradeFee;
            }
        }
        ((Dictionary<string, object>)trade)["amount"] = this.parseNumber(amount);
        ((Dictionary<string, object>)trade)["price"] = this.parseNumber(price);
        ((Dictionary<string, object>)trade)["cost"] = this.parseNumber(cost);
        return trade;
    }

    public virtual object reduceFeesByCurrency(object fees)
    {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        object reduced = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = getValue(fees, i);
            object feeCurrencyCode = this.safeString(fee, "currency");
            if (isTrue(!isEqual(feeCurrencyCode, null)))
            {
                object rate = this.safeString(fee, "rate");
                object cost = this.safeValue(fee, "cost");
                if (isTrue(Precise.stringEq(cost, "0")))
                {
                    continue;
                }
                if (!isTrue((inOp(reduced, feeCurrencyCode))))
                {
                    ((Dictionary<string, object>)reduced)[(string)feeCurrencyCode] = new Dictionary<string, object>() {};
                }
                object rateKey = ((bool) isTrue((isEqual(rate, null)))) ? "" : rate;
                if (isTrue(inOp(getValue(reduced, feeCurrencyCode), rateKey)))
                {
                    ((Dictionary<string, object>)getValue(getValue(reduced, feeCurrencyCode), rateKey))["cost"] = Precise.stringAdd(getValue(getValue(getValue(reduced, feeCurrencyCode), rateKey), "cost"), cost);
                } else
                {
                    ((Dictionary<string, object>)getValue(reduced, feeCurrencyCode))[(string)rateKey] = new Dictionary<string, object>() {
                        { "currency", feeCurrencyCode },
                        { "cost", cost },
                    };
                    if (isTrue(!isEqual(rate, null)))
                    {
                        ((Dictionary<string, object>)getValue(getValue(reduced, feeCurrencyCode), rateKey))["rate"] = rate;
                    }
                }
            }
        }
        object result = new List<object>() {};
        object feeValues = new List<object>(((Dictionary<string,object>)reduced).Values);
        for (object i = 0; isLessThan(i, getArrayLength(feeValues)); postFixIncrement(ref i))
        {
            object reducedFeeValues = new List<object>(((Dictionary<string,object>)getValue(feeValues, i)).Values);
            result = this.arrayConcat(result, reducedFeeValues);
        }
        return result;
    }

    public virtual object safeTicker(object ticker, object market = null)
    {
        object open = this.safeValue(ticker, "open");
        object close = this.safeValue(ticker, "close");
        object last = this.safeValue(ticker, "last");
        object change = this.safeValue(ticker, "change");
        object percentage = this.safeValue(ticker, "percentage");
        object average = this.safeValue(ticker, "average");
        object vwap = this.safeValue(ticker, "vwap");
        object baseVolume = this.safeValue(ticker, "baseVolume");
        object quoteVolume = this.safeValue(ticker, "quoteVolume");
        if (isTrue(isEqual(vwap, null)))
        {
            vwap = Precise.stringDiv(quoteVolume, baseVolume);
        }
        if (isTrue(isTrue((!isEqual(last, null))) && isTrue((isEqual(close, null)))))
        {
            close = last;
        } else if (isTrue(isTrue((isEqual(last, null))) && isTrue((!isEqual(close, null)))))
        {
            last = close;
        }
        if (isTrue(isTrue((!isEqual(last, null))) && isTrue((!isEqual(open, null)))))
        {
            if (isTrue(isEqual(change, null)))
            {
                change = Precise.stringSub(last, open);
            }
            if (isTrue(isEqual(average, null)))
            {
                average = Precise.stringDiv(Precise.stringAdd(last, open), "2");
            }
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(percentage, null))) && isTrue((!isEqual(change, null)))) && isTrue((!isEqual(open, null)))) && isTrue(Precise.stringGt(open, "0"))))
        {
            percentage = Precise.stringMul(Precise.stringDiv(change, open), "100");
        }
        if (isTrue(isTrue(isTrue((isEqual(change, null))) && isTrue((!isEqual(percentage, null)))) && isTrue((!isEqual(open, null)))))
        {
            change = Precise.stringDiv(Precise.stringMul(percentage, open), "100");
        }
        if (isTrue(isTrue(isTrue((isEqual(open, null))) && isTrue((!isEqual(last, null)))) && isTrue((!isEqual(change, null)))))
        {
            open = Precise.stringSub(last, change);
        }
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return this.extend(ticker, new Dictionary<string, object>() {
            { "bid", this.omitZero(this.safeNumber(ticker, "bid")) },
            { "bidVolume", this.safeNumber(ticker, "bidVolume") },
            { "ask", this.omitZero(this.safeNumber(ticker, "ask")) },
            { "askVolume", this.safeNumber(ticker, "askVolume") },
            { "high", this.omitZero(this.safeNumber(ticker, "high")) },
            { "low", this.omitZero(this.safeNumber(ticker, "low")) },
            { "open", this.omitZero(this.parseNumber(open)) },
            { "close", this.omitZero(this.parseNumber(close)) },
            { "last", this.omitZero(this.parseNumber(last)) },
            { "change", this.parseNumber(change) },
            { "percentage", this.parseNumber(percentage) },
            { "average", this.omitZero(this.parseNumber(average)) },
            { "vwap", this.omitZero(this.parseNumber(vwap)) },
            { "baseVolume", this.parseNumber(baseVolume) },
            { "quoteVolume", this.parseNumber(quoteVolume) },
            { "previousClose", this.safeNumber(ticker, "previousClose") },
        });
    }

    public async virtual Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTrades")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOHLCV() is not supported yet")) ;
        }
        object trades = await this.fetchTrades(symbol, since, limit, parameters);
        object ohlcvc = this.buildOHLCVC(trades, timeframe, since, limit);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvc)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(new List<object> {this.safeInteger(getValue(ohlcvc, i), 0), this.safeNumber(getValue(ohlcvc, i), 1), this.safeNumber(getValue(ohlcvc, i), 2), this.safeNumber(getValue(ohlcvc, i), 3), this.safeNumber(getValue(ohlcvc, i), 4), this.safeNumber(getValue(ohlcvc, i), 5)});
        }
        return result;
    }

    public async virtual Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOHLCV() is not supported yet")) ;
    }

    public virtual object convertTradingViewToOHLCV(object ohlcvs, object timestamp = null, object open = null, object high = null, object low = null, object close = null, object volume = null, object ms = null)
    {
        timestamp ??= "t";
        open ??= "o";
        high ??= "h";
        low ??= "l";
        close ??= "c";
        volume ??= "v";
        ms ??= false;
        object result = new List<object>() {};
        object timestamps = this.safeValue(ohlcvs, timestamp, new List<object>() {});
        object opens = this.safeValue(ohlcvs, open, new List<object>() {});
        object highs = this.safeValue(ohlcvs, high, new List<object>() {});
        object lows = this.safeValue(ohlcvs, low, new List<object>() {});
        object closes = this.safeValue(ohlcvs, close, new List<object>() {});
        object volumes = this.safeValue(ohlcvs, volume, new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(timestamps)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(new List<object>() {((bool) isTrue(ms)) ? this.safeInteger(timestamps, i) : this.safeTimestamp(timestamps, i), this.safeValue(opens, i), this.safeValue(highs, i), this.safeValue(lows, i), this.safeValue(closes, i), this.safeValue(volumes, i)});
        }
        return result;
    }

    public virtual object convertOHLCVToTradingView(object ohlcvs, object timestamp = null, object open = null, object high = null, object low = null, object close = null, object volume = null, object ms = null)
    {
        timestamp ??= "t";
        open ??= "o";
        high ??= "h";
        low ??= "l";
        close ??= "c";
        volume ??= "v";
        ms ??= false;
        object result = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)result)[(string)timestamp] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)open] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)high] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)low] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)close] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)volume] = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            object ts = ((bool) isTrue(ms)) ? getValue(getValue(ohlcvs, i), 0) : this.parseToInt(divide(getValue(getValue(ohlcvs, i), 0), 1000));
            ((List<object>)getValue(result, timestamp)).Add(ts);
            ((List<object>)getValue(result, open)).Add(getValue(getValue(ohlcvs, i), 1));
            ((List<object>)getValue(result, high)).Add(getValue(getValue(ohlcvs, i), 2));
            ((List<object>)getValue(result, low)).Add(getValue(getValue(ohlcvs, i), 3));
            ((List<object>)getValue(result, close)).Add(getValue(getValue(ohlcvs, i), 4));
            ((List<object>)getValue(result, volume)).Add(getValue(getValue(ohlcvs, i), 5));
        }
        return result;
    }

    public virtual object marketIds(object symbols)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return symbols;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.marketId(getValue(symbols, i)));
        }
        return result;
    }

    public virtual object marketSymbols(object symbols)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return symbols;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.symbol(getValue(symbols, i)));
        }
        return result;
    }

    public virtual object marketCodes(object codes)
    {
        if (isTrue(isEqual(codes, null)))
        {
            return codes;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.commonCurrencyCode(getValue(codes, i)));
        }
        return result;
    }

    public virtual object parseBidsAsks(object bidasks, object priceKey = null, object amountKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        bidasks = this.toArray(bidasks);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(bidasks)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseBidAsk(getValue(bidasks, i), priceKey, amountKey));
        }
        return result;
    }

    public async virtual Task<object> fetchL2OrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderbook = await this.fetchOrderBook(symbol, limit, parameters);
        return this.extend(orderbook, new Dictionary<string, object>() {
            { "asks", this.sortBy(this.aggregate(getValue(orderbook, "asks")), 0) },
            { "bids", this.sortBy(this.aggregate(getValue(orderbook, "bids")), 0, true) },
        });
    }

    public virtual object filterBySymbol(object objects, object symbol = null)
    {
        if (isTrue(isEqual(symbol, null)))
        {
            return objects;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(objects)); postFixIncrement(ref i))
        {
            object objectSymbol = this.safeString(getValue(objects, i), "symbol");
            if (isTrue(isEqual(objectSymbol, symbol)))
            {
                ((List<object>)result).Add(getValue(objects, i));
            }
        }
        return result;
    }

    public virtual object parseOHLCV(object ohlcv, object market = null)
    {
        if (isTrue((ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        }
        return ohlcv;
    }

    public virtual object getNetwork(object network, object code)
    {
        network = ((string)network).ToUpper();
        object aliases = new Dictionary<string, object>() {
            { "ETHEREUM", "ETH" },
            { "ETHER", "ETH" },
            { "ERC20", "ETH" },
            { "ETH", "ETH" },
            { "TRC20", "TRX" },
            { "TRON", "TRX" },
            { "TRX", "TRX" },
            { "BEP20", "BSC" },
            { "BSC", "BSC" },
            { "HRC20", "HT" },
            { "HECO", "HT" },
            { "SPL", "SOL" },
            { "SOL", "SOL" },
            { "TERRA", "LUNA" },
            { "LUNA", "LUNA" },
            { "POLYGON", "MATIC" },
            { "MATIC", "MATIC" },
            { "EOS", "EOS" },
            { "WAVES", "WAVES" },
            { "AVALANCHE", "AVAX" },
            { "AVAX", "AVAX" },
            { "QTUM", "QTUM" },
            { "CHZ", "CHZ" },
            { "NEO", "NEO" },
            { "ONT", "ONT" },
            { "RON", "RON" },
        };
        if (isTrue(isEqual(network, code)))
        {
            return network;
        } else if (isTrue(inOp(aliases, network)))
        {
            return getValue(aliases, network);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " network "), network), " is not yet supported")) ;
        }
    }

    public virtual object networkCodeToId(object networkCode, object currencyCode = null)
    {
        /**
         * @ignore
         * @method
         * @name exchange#networkCodeToId
         * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
         * @param {string} networkCode unified network code
         * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
         * @returns {[string|undefined]} exchange-specific network id
         */
        object networkIdsByCodes = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object networkId = this.safeString(networkIdsByCodes, networkCode);
        // for example, if 'ETH' is passed for networkCode, but 'ETH' key not defined in `options->networks` object
        if (isTrue(isEqual(networkId, null)))
        {
            if (isTrue(isEqual(currencyCode, null)))
            {
                // if currencyCode was not provided, then we just set passed value to networkId
                networkId = networkCode;
            } else
            {
                // if currencyCode was provided, then we try to find if that currencyCode has a replacement (i.e. ERC20 for ETH)
                object defaultNetworkCodeReplacements = this.safeValue(this.options, "defaultNetworkCodeReplacements", new Dictionary<string, object>() {});
                if (isTrue(inOp(defaultNetworkCodeReplacements, currencyCode)))
                {
                    // if there is a replacement for the passed networkCode, then we use it to find network-id in `options->networks` object
                    object replacementObject = getValue(defaultNetworkCodeReplacements, currencyCode); // i.e. { 'ERC20': 'ETH' }
                    object keys = new List<object>(((Dictionary<string,object>)replacementObject).Keys);
                    for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                    {
                        object key = getValue(keys, i);
                        object value = getValue(replacementObject, key);
                        // if value matches to provided unified networkCode, then we use it's key to find network-id in `options->networks` object
                        if (isTrue(isEqual(value, networkCode)))
                        {
                            networkId = this.safeString(networkIdsByCodes, key);
                            break;
                        }
                    }
                }
                // if it wasn't found, we just set the provided value to network-id
                if (isTrue(isEqual(networkId, null)))
                {
                    networkId = networkCode;
                }
            }
        }
        return networkId;
    }

    public virtual object networkIdToCode(object networkId, object currencyCode = null)
    {
        /**
         * @ignore
         * @method
         * @name exchange#networkIdToCode
         * @description tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve this, derived class needs to have 'options->networksById' defined.
         * @param {string} networkId unified network code
         * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
         * @returns {[string|undefined]} unified network code
         */
        object networkCodesByIds = this.safeValue(this.options, "networksById", new Dictionary<string, object>() {});
        object networkCode = this.safeString(networkCodesByIds, networkId, networkId);
        // replace mainnet network-codes (i.e. ERC20->ETH)
        if (isTrue(!isEqual(currencyCode, null)))
        {
            object defaultNetworkCodeReplacements = this.safeValue(this.options, "defaultNetworkCodeReplacements", new Dictionary<string, object>() {});
            if (isTrue(inOp(defaultNetworkCodeReplacements, currencyCode)))
            {
                object replacementObject = this.safeValue(defaultNetworkCodeReplacements, currencyCode, new Dictionary<string, object>() {});
                networkCode = this.safeString(replacementObject, networkCode, networkCode);
            }
        }
        return networkCode;
    }

    public virtual object networkCodesToIds(object networkCodes = null)
    {
        /**
         * @ignore
         * @method
         * @name exchange#networkCodesToIds
         * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
         * @param {[string]|undefined} networkCodes unified network codes
         * @returns {[string|undefined]} exchange-specific network ids
         */
        if (isTrue(isEqual(networkCodes, null)))
        {
            return null;
        }
        object ids = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(networkCodes)); postFixIncrement(ref i))
        {
            object networkCode = getValue(networkCodes, i);
            ((List<object>)ids).Add(this.networkCodeToId(networkCode));
        }
        return ids;
    }

    public virtual object handleNetworkCodeAndParams(object parameters)
    {
        object networkCodeInParams = this.safeString2(parameters, "networkCode", "network");
        if (isTrue(!isEqual(networkCodeInParams, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"networkCode", "network"});
        }
        // if it was not defined by user, we should not set it from 'defaultNetworks', because handleNetworkCodeAndParams is for only request-side and thus we do not fill it with anything. We can only use 'defaultNetworks' after parsing response-side
        return new List<object>() {networkCodeInParams, parameters};
    }

    public virtual object defaultNetworkCode(object currencyCode)
    {
        object defaultNetworkCode = null;
        object defaultNetworks = this.safeValue(this.options, "defaultNetworks", new Dictionary<string, object>() {});
        if (isTrue(inOp(defaultNetworks, currencyCode)))
        {
            // if currency had set its network in "defaultNetworks", use it
            defaultNetworkCode = getValue(defaultNetworks, currencyCode);
        } else
        {
            // otherwise, try to use the global-scope 'defaultNetwork' value (even if that network is not supported by currency, it doesn't make any problem, this will be just used "at first" if currency supports this network at all)
            object defaultNetwork = this.safeValue(this.options, "defaultNetwork");
            if (isTrue(!isEqual(defaultNetwork, null)))
            {
                defaultNetworkCode = defaultNetwork;
            }
        }
        return defaultNetworkCode;
    }

    public virtual object selectNetworkCodeFromUnifiedNetworks(object currencyCode, object networkCode, object indexedNetworkEntries)
    {
        return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, true);
    }

    public virtual object selectNetworkIdFromRawNetworks(object currencyCode, object networkCode, object indexedNetworkEntries)
    {
        return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, false);
    }

    public virtual object selectNetworkKeyFromNetworks(object currencyCode, object networkCode, object indexedNetworkEntries, object isIndexedByUnifiedNetworkCode = null)
    {
        // this method is used against raw & unparse network entries, which are just indexed by network id
        isIndexedByUnifiedNetworkCode ??= false;
        object chosenNetworkId = null;
        object availableNetworkIds = new List<object>(((Dictionary<string,object>)indexedNetworkEntries).Keys);
        object responseNetworksLength = getArrayLength(availableNetworkIds);
        if (isTrue(!isEqual(networkCode, null)))
        {
            if (isTrue(isEqual(responseNetworksLength, 0)))
            {
                throw new NotSupported ((string)add(add(add(add(this.id, " - "), networkCode), " network did not return any result for "), currencyCode)) ;
            } else
            {
                // if networkCode was provided by user, we should check it after response, as the referenced exchange doesn't support network-code during request
                object networkId = ((bool) isTrue(isIndexedByUnifiedNetworkCode)) ? networkCode : this.networkCodeToId(networkCode, currencyCode);
                if (isTrue(inOp(indexedNetworkEntries, networkId)))
                {
                    chosenNetworkId = networkId;
                } else
                {
                    throw new NotSupported ((string)add(add(add(add(add(add(this.id, " - "), networkId), " network was not found for "), currencyCode), ", use one of "), String.Join(", ", ((List<object>)availableNetworkIds).ToArray()))) ;
                }
            }
        } else
        {
            if (isTrue(isEqual(responseNetworksLength, 0)))
            {
                throw new NotSupported ((string)add(add(this.id, " - no networks were returned for "), currencyCode)) ;
            } else
            {
                // if networkCode was not provided by user, then we try to use the default network (if it was defined in "defaultNetworks"), otherwise, we just return the first network entry
                object defaultNetworkCode = this.defaultNetworkCode(currencyCode);
                object defaultNetworkId = ((bool) isTrue(isIndexedByUnifiedNetworkCode)) ? defaultNetworkCode : this.networkCodeToId(defaultNetworkCode, currencyCode);
                chosenNetworkId = ((bool) isTrue((inOp(indexedNetworkEntries, defaultNetworkId)))) ? defaultNetworkId : getValue(availableNetworkIds, 0);
            }
        }
        return chosenNetworkId;
    }

    public virtual object safeNumber2(object dictionary, object key1, object key2, object d = null)
    {
        object value = this.safeString2(dictionary, key1, key2);
        return this.parseNumber(value, d);
    }

    public virtual object parseOrderBook(object orderbook, object symbol, object timestamp = null, object bidsKey = null, object asksKey = null, object priceKey = null, object amountKey = null)
    {
        bidsKey ??= "bids";
        asksKey ??= "asks";
        priceKey ??= 0;
        amountKey ??= 1;
        object bids = this.parseBidsAsks(this.safeValue(orderbook, bidsKey, new List<object>() {}), priceKey, amountKey);
        object asks = this.parseBidsAsks(this.safeValue(orderbook, asksKey, new List<object>() {}), priceKey, amountKey);
        return ((object)new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", this.sortBy(bids, 0, true) },
            { "asks", this.sortBy(asks, 0) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", null },
        });
    }

    public virtual object parseOHLCVs(object ohlcvs, object market = null, object timeframe = null, object since = null, object limit = null)
    {
        timeframe ??= "1m";
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            ((List<object>)results).Add(this.parseOHLCV(getValue(ohlcvs, i), market));
        }
        object sorted = this.sortBy(results, 0);
        return ((object)this.filterBySinceLimit(sorted, since, limit, 0));
    }

    public virtual object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = this.marketSymbols(symbols);
        object tiers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object id = this.safeString(item, marketIdKey);
            object market = this.safeMarket(id, null, null, this.safeString(this.options, "defaultType"));
            object symbol = getValue(market, "symbol");
            object contract = this.safeValue(market, "contract", false);
            if (isTrue(isTrue(contract) && isTrue((isTrue((isEqual(symbols, null))) || isTrue(this.inArray(symbol, symbols))))))
            {
                ((Dictionary<string, object>)tiers)[(string)symbol] = this.parseMarketLeverageTiers(item, market);
            }
        }
        return tiers;
    }

    public async virtual Task<object> loadTradingLimits(object symbols = null, object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTradingLimits")))
        {
            if (isTrue(isTrue(reload) || !isTrue((inOp(this.options, "limitsLoaded")))))
            {
                object response = await this.fetchTradingLimits(symbols);
                for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
                {
                    object symbol = getValue(symbols, i);
                    ((Dictionary<string, object>)this.markets)[(string)symbol] = this.deepExtend(getValue(this.markets, symbol), getValue(response, symbol));
                }
                ((Dictionary<string, object>)this.options)["limitsLoaded"] = this.milliseconds();
            }
        }
        return this.markets;
    }

    public virtual object safePosition(object position)
    {
        // simplified version of: /pull/12765/
        object unrealizedPnlString = this.safeString(position, "unrealisedPnl");
        object initialMarginString = this.safeString(position, "initialMargin");
        //
        // PERCENTAGE
        //
        object percentage = this.safeValue(position, "percentage");
        if (isTrue(isTrue(isTrue((isEqual(percentage, null))) && isTrue((!isEqual(unrealizedPnlString, null)))) && isTrue((!isEqual(initialMarginString, null)))))
        {
            // as it was done in all implementations ( aax, btcex, bybit, deribit, ftx, gate, kucoinfutures, phemex )
            object percentageString = Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100");
            ((Dictionary<string, object>)position)["percentage"] = this.parseNumber(percentageString);
        }
        return position;
    }

    public virtual object parsePositions(object positions, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols);
        positions = this.toArray(positions);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = this.extend(this.parsePosition(getValue(positions, i), null), parameters);
            ((List<object>)result).Add(position);
        }
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public virtual object parseAccounts(object accounts, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        accounts = this.toArray(accounts);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
        {
            object account = this.extend(this.parseAccount(getValue(accounts, i)), parameters);
            ((List<object>)result).Add(account);
        }
        return result;
    }

    public virtual object parseTrades(object trades, object market = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        trades = this.toArray(trades);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = this.extend(this.parseTrade(getValue(trades, i), market), parameters);
            ((List<object>)result).Add(trade);
        }
        result = this.sortBy2(result, "timestamp", "id");
        object symbol = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "symbol") : null;
        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
    }

    public virtual object parseTransactions(object transactions, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        transactions = this.toArray(transactions);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = this.extend(this.parseTransaction(getValue(transactions, i), currency), parameters);
            ((List<object>)result).Add(transaction);
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object parseTransfers(object transfers, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        transfers = this.toArray(transfers);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transfers)); postFixIncrement(ref i))
        {
            object transfer = this.extend(this.parseTransfer(getValue(transfers, i), currency), parameters);
            ((List<object>)result).Add(transfer);
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object parseLedger(object data, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object arrayData = this.toArray(data);
        for (object i = 0; isLessThan(i, getArrayLength(arrayData)); postFixIncrement(ref i))
        {
            object itemOrItems = this.parseLedgerEntry(getValue(arrayData, i), currency);
            if (isTrue((itemOrItems.GetType().IsGenericType && itemOrItems.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                for (object j = 0; isLessThan(j, getArrayLength(itemOrItems)); postFixIncrement(ref j))
                {
                    ((List<object>)result).Add(this.extend(getValue(itemOrItems, j), parameters));
                }
            } else
            {
                ((List<object>)result).Add(this.extend(itemOrItems, parameters));
            }
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object nonce()
    {
        return this.seconds();
    }

    public virtual object setHeaders(object headers)
    {
        return headers;
    }

    public virtual object marketId(object symbol)
    {
        object market = this.market(symbol);
        if (isTrue(!isEqual(market, null)))
        {
            return getValue(market, "id");
        }
        return symbol;
    }

    public virtual object symbol(object symbol)
    {
        object market = this.market(symbol);
        return this.safeString(market, "symbol", symbol);
    }

    public virtual object resolvePath(object path, object parameters)
    {
        return new List<object> {this.implodeParams(path, parameters), this.omit(parameters, this.extractParams(path))};
    }

    public virtual object filterByArray(object objects, object key, object values = null, object indexed = null)
    {
        indexed ??= true;
        objects = this.toArray(objects);
        // return all of them if no values were passed
        if (isTrue(isTrue(isEqual(values, null)) || !isTrue(values)))
        {
            return ((bool) isTrue(indexed)) ? this.indexBy(objects, key) : objects;
        }
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(objects)); postFixIncrement(ref i))
        {
            if (isTrue(this.inArray(getValue(getValue(objects, i), key), values)))
            {
                ((List<object>)results).Add(getValue(objects, i));
            }
        }
        return ((bool) isTrue(indexed)) ? this.indexBy(results, key) : results;
    }

    public async virtual Task<object> fetch2(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        if (isTrue(this.enableRateLimit))
        {
            object cost = this.calculateRateLimiterCost(api, method, path, parameters, config);
            await this.throttle(cost);
        }
        this.lastRestRequestTimestamp = this.milliseconds();
        object request = this.sign(path, api, method, parameters, headers, body);
        return await this.fetch(getValue(request, "url"), getValue(request, "method"), getValue(request, "headers"), getValue(request, "body"));
    }

    public async virtual Task<object> request(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        return await this.fetch2(path, api, method, parameters, headers, body, config);
    }

    public async virtual Task<object> loadAccounts(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(reload))
        {
            this.accounts = await this.fetchAccounts(parameters);
        } else
        {
            if (isTrue(this.accounts))
            {
                return this.accounts;
            } else
            {
                this.accounts = await this.fetchAccounts(parameters);
            }
        }
        this.accountsById = ((object)this.indexBy(this.accounts, "id"));
        return this.accounts;
    }

    public async virtual Task<object> fetchOHLCVC(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTrades")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOHLCV() is not supported yet")) ;
        }
        await this.loadMarkets();
        object trades = await this.fetchTrades(symbol, since, limit, parameters);
        return this.buildOHLCVC(trades, timeframe, since, limit);
    }

    public virtual object parseTradingViewOHLCV(object ohlcvs, object market = null, object timeframe = null, object since = null, object limit = null)
    {
        timeframe ??= "1m";
        object result = this.convertTradingViewToOHLCV(ohlcvs);
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    public async virtual Task<object> editLimitBuyOrder(object id, object symbol, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editLimitOrder(id, symbol, "buy", amount, price, parameters);
    }

    public async virtual Task<object> editLimitSellOrder(object id, object symbol, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editLimitOrder(id, symbol, "sell", amount, price, parameters);
    }

    public async virtual Task<object> editLimitOrder(object id, object symbol, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editOrder(id, symbol, "limit", side, amount, price, parameters);
    }

    public async virtual Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.cancelOrder(id, symbol);
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    public async virtual Task<object> fetchPermissions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPermissions() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPosition() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPositions() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPositionsRisk(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPositionsRisk() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBidsAsks() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBorrowInterest() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderBooks() is not supported yet")) ;
    }

    public async virtual Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchFundingRateHistory() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLedger() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLedgerEntry(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLedgerEntry() is not supported yet")) ;
    }

    public virtual object parseBidAsk(object bidask, object priceKey = null, object amountKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        return new List<object>() {price, amount};
    }

    public virtual object safeCurrency(object currencyId, object currency = null)
    {
        if (isTrue(isTrue(isEqual(currencyId, null)) && isTrue(isEqual(currency, null))))
        {
            return new Dictionary<string, object>() {
                { "id", null },
                { "code", null },
            };
        }
        if (isTrue(isTrue((isEqual(currencyId, null))) && isTrue((!isEqual(currency, null)))))
        {
            return currency;
        }
        if (isTrue(isTrue(isTrue(isTrue((!isEqual(currency, null))) && isTrue((!isEqual(this.currencies_by_id, null)))) && isTrue((inOp(this.currencies_by_id, currencyId)))) && isTrue((!isEqual(getValue(this.currencies_by_id, currencyId), null)))))
        {
            return getValue(this.currencies_by_id, currencyId);
        }
        object code = currencyId;
        if (isTrue(!isEqual(currencyId, null)))
        {
            code = this.commonCurrencyCode(((string)currencyId).ToUpper());
        }
        return new Dictionary<string, object>() {
            { "id", currencyId },
            { "code", code },
        };
    }

    public virtual object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object result = new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", marketId },
            { "base", null },
            { "quote", null },
            { "baseId", null },
            { "quoteId", null },
            { "active", null },
            { "type", null },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "margin", false },
            { "contract", false },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "optionType", null },
            { "strike", null },
            { "settle", null },
            { "settleId", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
        if (isTrue(!isEqual(marketId, null)))
        {
            if (isTrue(isTrue((!isEqual(this.markets_by_id, null))) && isTrue((inOp(this.markets_by_id, marketId)))))
            {
                object markets = getValue(this.markets_by_id, marketId);
                object numMarkets = getArrayLength(markets);
                if (isTrue(isEqual(numMarkets, 1)))
                {
                    return getValue(markets, 0);
                } else
                {
                    if (isTrue(isTrue((isEqual(marketType, null))) && isTrue((isEqual(market, null)))))
                    {
                        throw new ArgumentsRequired ((string)add(add(add(this.id, " safeMarket() requires a fourth argument for "), marketId), " to disambiguate between different markets with the same market id")) ;
                    }
                    object inferredMarketType = ((bool) isTrue((isEqual(marketType, null)))) ? getValue(market, "type") : marketType;
                    for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
                    {
                        object marketInner = getValue(markets, i);
                        if (isTrue(getValue(marketInner, inferredMarketType)))
                        {
                            return marketInner;
                        }
                    }
                }
            } else if (isTrue(!isEqual(delimiter, null)))
            {
                object parts = ((string)marketId).Split(new [] {((string)delimiter)}, StringSplitOptions.None).ToList<object>();
                object partsLength = getArrayLength(parts);
                if (isTrue(isEqual(partsLength, 2)))
                {
                    ((Dictionary<string, object>)result)["baseId"] = this.safeString(parts, 0);
                    ((Dictionary<string, object>)result)["quoteId"] = this.safeString(parts, 1);
                    ((Dictionary<string, object>)result)["base"] = this.safeCurrencyCode(getValue(result, "baseId"));
                    ((Dictionary<string, object>)result)["quote"] = this.safeCurrencyCode(getValue(result, "quoteId"));
                    ((Dictionary<string, object>)result)["symbol"] = add(add(getValue(result, "base"), "/"), getValue(result, "quote"));
                    return result;
                } else
                {
                    return result;
                }
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            return market;
        }
        return result;
    }

    public virtual object checkRequiredCredentials(object error = null)
    {
        error ??= true;
        object keys = new List<object>(((Dictionary<string,object>)this.requiredCredentials).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isTrue(getValue(this.requiredCredentials, key)) && !isTrue(getValue(this, key))))
            {
                if (isTrue(error))
                {
                    throw new AuthenticationError ((string)add(add(add(this.id, " requires \""), key), "\" credential")) ;
                } else
                {
                    return false;
                }
            }
        }
        return true;
    }

    public virtual object oath()
    {
        if (isTrue(!isEqual(this.twofa, null)))
        {
            return totp(this.twofa);
        } else
        {
            throw new ExchangeError ((string)add(this.id, " exchange.twofa has not been set for 2FA Two-Factor Authentication")) ;
        }
    }

    public async virtual Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBalance() is not supported yet")) ;
    }

    public async virtual Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchBalance() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPartialBalance(object part, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object balance = await this.fetchBalance(parameters);
        return getValue(balance, part);
    }

    public async virtual Task<object> fetchFreeBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("free", parameters);
    }

    public async virtual Task<object> fetchUsedBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("used", parameters);
    }

    public async virtual Task<object> fetchTotalBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("total", parameters);
    }

    public async virtual Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTime")))
        {
            object time = await this.fetchTime(parameters);
            this.status = this.extend(this.status, new Dictionary<string, object>() {
                { "updated", time },
                { "info", time },
            });
        }
        if (!isTrue((inOp(this.status, "info"))))
        {
            ((Dictionary<string, object>)this.status)["info"] = null;
        }
        return this.status;
    }

    public async virtual Task<object> fetchFundingFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object warnOnFetchFundingFee = this.safeValue(this.options, "warnOnFetchFundingFee", true);
        if (isTrue(warnOnFetchFundingFee))
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options[\"warnOnFetchFundingFee\"] = false to suppress this warning")) ;
        }
        return await this.fetchTransactionFee(code, parameters);
    }

    public async virtual Task<object> fetchFundingFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object warnOnFetchFundingFees = this.safeValue(this.options, "warnOnFetchFundingFees", true);
        if (isTrue(warnOnFetchFundingFees))
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options[\"warnOnFetchFundingFees\"] = false to suppress this warning")) ;
        }
        return await this.fetchTransactionFees(codes, parameters);
    }

    public async virtual Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTransactionFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTransactionFee() is not supported yet")) ;
        }
        return await this.fetchTransactionFees(new List<object>() {code}, parameters);
    }

    public async virtual Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTransactionFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDepositWithdrawFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchDepositWithdrawFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchDepositWithdrawFee() is not supported yet")) ;
        }
        object fees = await this.fetchDepositWithdrawFees(new List<object>() {code}, parameters);
        return this.safeValue(fees, code);
    }

    public virtual object getSupportedMapping(object key, object mapping = null)
    {
        mapping ??= new Dictionary<string, object>();
        if (isTrue(inOp(mapping, key)))
        {
            return getValue(mapping, key);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), key), " does not have a value in mapping")) ;
        }
    }

    public async virtual Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (!isTrue(getValue(this.has, "fetchBorrowRates")))
        {
            throw new NotSupported ((string)add(this.id, " fetchBorrowRate() is not supported yet")) ;
        }
        object borrowRates = await this.fetchBorrowRates(parameters);
        object rate = this.safeValue(borrowRates, code);
        if (isTrue(isEqual(rate, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchBorrowRate() could not find the borrow rate for currency code "), code)) ;
        }
        return rate;
    }

    public virtual object handleOptionAndParams(object parameters, object methodName, object optionName, object defaultValue = null)
    {
        // This method can be used to obtain method specific properties, i.e: this.handleOptionAndParams (params, 'fetchPosition', 'marginMode', 'isolated')
        object defaultOptionName = add("default", this.capitalize(optionName)); // we also need to check the 'defaultXyzWhatever'
        // check if params contain the key
        object value = this.safeValue2(parameters, optionName, defaultOptionName);
        if (isTrue(!isEqual(value, null)))
        {
            parameters = this.omit(parameters, new List<object>() {optionName, defaultOptionName});
        } else
        {
            // check if exchange has properties for this method
            object exchangeWideMethodOptions = this.safeValue(this.options, methodName);
            if (isTrue(!isEqual(exchangeWideMethodOptions, null)))
            {
                // check if the option is defined in this method's props
                value = this.safeValue2(exchangeWideMethodOptions, optionName, defaultOptionName);
            }
            if (isTrue(isEqual(value, null)))
            {
                // if it's still undefined, check if global exchange-wide option exists
                value = this.safeValue2(this.options, optionName, defaultOptionName);
            }
            // if it's still undefined, use the default value
            value = ((bool) isTrue((!isEqual(value, null)))) ? value : defaultValue;
        }
        return new List<object>() {value, parameters};
    }

    public virtual object handleOption(object methodName, object optionName, object defaultValue = null)
    {
        // eslint-disable-next-line no-unused-vars
        var resultemptyVariable = this.handleOptionAndParams(new Dictionary<string, object>() {}, methodName, optionName, defaultValue);
        var result = ((List<object>) resultemptyVariable)[0];
        var empty = ((List<object>) resultemptyVariable)[1];
        return result;
    }

    public virtual object handleMarketTypeAndParams(object methodName, object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString2(this.options, "defaultType", "type", "spot");
        object methodOptions = this.safeValue(this.options, methodName);
        object methodType = defaultType;
        if (isTrue(!isEqual(methodOptions, null)))
        {
            if (isTrue(((methodOptions).GetType() == typeof(string))))
            {
                methodType = methodOptions;
            } else
            {
                methodType = this.safeString2(methodOptions, "defaultType", "type", methodType);
            }
        }
        object marketType = ((bool) isTrue((isEqual(market, null)))) ? methodType : getValue(market, "type");
        object type = this.safeString2(parameters, "defaultType", "type", marketType);
        parameters = this.omit(parameters, new List<object>() {"defaultType", "type"});
        return new List<object>() {type, parameters};
    }

    public virtual object handleSubTypeAndParams(object methodName, object market = null, object parameters = null, object defaultValue = null)
    {
        parameters ??= new Dictionary<string, object>();
        object subType = null;
        // if set in params, it takes precedence
        object subTypeInParams = this.safeString2(parameters, "subType", "defaultSubType");
        // avoid omitting if it's not present
        if (isTrue(!isEqual(subTypeInParams, null)))
        {
            subType = subTypeInParams;
            parameters = this.omit(parameters, new List<object>() {"subType", "defaultSubType"});
        } else
        {
            // at first, check from market object
            if (isTrue(!isEqual(market, null)))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    subType = "linear";
                } else if (isTrue(getValue(market, "inverse")))
                {
                    subType = "inverse";
                }
            }
            // if it was not defined in market object
            if (isTrue(isEqual(subType, null)))
            {
                object values = this.handleOptionAndParams(null, methodName, "subType", defaultValue); // no need to re-test params here
                subType = getValue(values, 0);
            }
        }
        return new List<object>() {subType, parameters};
    }

    public virtual object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
        */
        parameters ??= new Dictionary<string, object>();
        return this.handleOptionAndParams(parameters, methodName, "marginMode", defaultValue);
    }

    public virtual void throwExactlyMatchedException(object exact, object str, object message)
    {
        if (isTrue(isEqual(str, null)))
        {
            return;
        }
        if (isTrue(inOp(exact, str)))
        {
            throwDynamicException(getValue(exact, str), message);
        }
    }

    public virtual void throwBroadlyMatchedException(object broad, object str, object message)
    {
        object broadKey = this.findBroadlyMatchedKey(broad, str);
        if (isTrue(!isEqual(broadKey, null)))
        {
            throwDynamicException(getValue(broad, broadKey), message);
        }
    }

    public virtual object findBroadlyMatchedKey(object broad, object str)
    {
        // a helper for matching error strings exactly vs broadly
        object keys = new List<object>(((Dictionary<string,object>)broad).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(!isEqual(str, null)))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(str, key), 0)))
                {
                    return key;
                }
            }
        }
        return null;
    }

    public virtual object handleErrors(object statusCode, object statusText, object url, object method, object responseHeaders, object responseBody, object response, object requestHeaders, object requestBody)
    {
        // it is a stub method that must be overrided in the derived exchange classes
        // throw new NotSupported (this.id + ' handleErrors() not implemented yet');
        return null;
    }

    public virtual object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        return this.safeValue(config, "cost", 1);
    }

    public async virtual Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTickers")))
        {
            await this.loadMarkets();
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            object tickers = await this.fetchTickers(new List<object>() {symbol}, parameters);
            object ticker = this.safeValue(tickers, symbol);
            if (isTrue(isEqual(ticker, null)))
            {
                throw new NullResponse ((string)add(add(this.id, " fetchTickers() could not find a ticker for "), symbol)) ;
            } else
            {
                return ticker;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTicker() is not supported yet")) ;
        }
    }

    public async virtual Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTicker() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTickers() is not supported yet")) ;
    }

    public async virtual Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTickers() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrder() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderStatus(object id, object symbol = null, object parameters = null)
    {
        // TODO: TypeScript: change method signature by replacing
        // Promise<string> with Promise<Order['status']>.
        parameters ??= new Dictionary<string, object>();
        object order = await this.fetchOrder(id, symbol, parameters);
        return getValue(order, "status");
    }

    public async virtual Task<object> fetchUnifiedOrder(object order, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrder(this.safeValue(order, "id"), this.safeValue(order, "symbol"), parameters);
    }

    public async virtual Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " createOrder() is not supported yet")) ;
    }

    public async virtual Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelOrder() is not supported yet")) ;
    }

    public async virtual Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelAllOrders() is not supported yet")) ;
    }

    public async virtual Task<object> cancelUnifiedOrder(object order, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return this.cancelOrder(this.safeValue(order, "id"), this.safeValue(order, "symbol"), parameters);
    }

    public async virtual Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderTrades() is not supported yet")) ;
    }

    public async virtual Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchClosedOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchMyTrades() is not supported yet")) ;
    }

    public async virtual Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchMyTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTransactions(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTransactions() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDeposits(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDeposits() is not supported yet")) ;
    }

    public async virtual Task<object> fetchWithdrawals(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchWithdrawals() is not supported yet")) ;
    }

    public virtual object parseLastPrice(object price, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseLastPrice() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchDepositAddresses")))
        {
            object depositAddresses = await this.fetchDepositAddresses(new List<object>() {code}, parameters);
            object depositAddress = this.safeValue(depositAddresses, code);
            if (isTrue(isEqual(depositAddress, null)))
            {
                throw new InvalidAddress ((string)add(add(add(this.id, " fetchDepositAddress() could not find a deposit address for "), code), ", make sure you have created a corresponding deposit address in your wallet on the exchange website")) ;
            } else
            {
                return depositAddress;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchDepositAddress() is not supported yet")) ;
        }
    }

    public virtual object account()
    {
        return new Dictionary<string, object>() {
            { "free", null },
            { "used", null },
            { "total", null },
        };
    }

    public virtual object commonCurrencyCode(object currency)
    {
        if (!isTrue(this.substituteCommonCurrencyCodes))
        {
            return currency;
        }
        return this.safeString(this.commonCurrencies, currency, currency);
    }

    public virtual object currency(object code)
    {
        if (isTrue(isEqual(this.currencies, null)))
        {
            throw new ExchangeError ((string)add(this.id, " currencies not loaded")) ;
        }
        if (isTrue(((code).GetType() == typeof(string))))
        {
            if (isTrue(inOp(this.currencies, code)))
            {
                return getValue(this.currencies, code);
            } else if (isTrue(inOp(this.currencies_by_id, code)))
            {
                return getValue(this.currencies_by_id, code);
            }
        }
        throw new ExchangeError ((string)add(add(this.id, " does not have currency code "), code)) ;
    }

    public virtual object market(object symbol)
    {
        if (isTrue(isEqual(this.markets, null)))
        {
            throw new ExchangeError ((string)add(this.id, " markets not loaded")) ;
        }
        if (isTrue(((symbol).GetType() == typeof(string))))
        {
            if (isTrue(inOp(this.markets, symbol)))
            {
                return getValue(this.markets, symbol);
            } else if (isTrue(inOp(this.markets_by_id, symbol)))
            {
                object markets = getValue(this.markets_by_id, symbol);
                object defaultType = this.safeString2(this.options, "defaultType", "defaultSubType", "spot");
                for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
                {
                    object market = getValue(markets, i);
                    if (isTrue(getValue(market, defaultType)))
                    {
                        return market;
                    }
                }
                return getValue(markets, 0);
            }
        }
        throw new BadSymbol ((string)add(add(this.id, " does not have market symbol "), symbol)) ;
    }

    public virtual object handleWithdrawTagAndParams(object tag, object parameters)
    {
        if (isTrue(((tag).GetType() == typeof(Dictionary<string, object>))))
        {
            parameters = this.extend(tag, parameters);
            tag = null;
        }
        if (isTrue(isEqual(tag, null)))
        {
            tag = this.safeString(parameters, "tag");
            if (isTrue(!isEqual(tag, null)))
            {
                parameters = this.omit(parameters, "tag");
            }
        }
        return new List<object>() {tag, parameters};
    }

    public async virtual Task<object> createLimitOrder(object symbol, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", side, amount, price, parameters);
    }

    public async virtual Task<object> createMarketOrder(object symbol, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", side, amount, price, parameters);
    }

    public async virtual Task<object> createLimitBuyOrder(object symbol, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", "buy", amount, price, parameters);
    }

    public async virtual Task<object> createLimitSellOrder(object symbol, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", "sell", amount, price, parameters);
    }

    public async virtual Task<object> createMarketBuyOrder(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", "buy", amount, null, parameters);
    }

    public async virtual Task<object> createMarketSellOrder(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", "sell", amount, null, parameters);
    }

    public virtual object costToPrecision(object symbol, object cost)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
    }

    public virtual object priceToPrecision(object symbol, object price)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(price, ROUND, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new ArgumentsRequired ((string)add(add(add(add(this.id, " price of "), getValue(market, "symbol")), " must be greater than minimum price precision of "), this.numberToString(getValue(getValue(market, "precision"), "price")))) ;
        }
        return result;
    }

    public virtual object amountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(amount, TRUNCATE, getValue(getValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new ArgumentsRequired ((string)add(add(add(add(this.id, " amount of "), getValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(getValue(getValue(market, "precision"), "amount")))) ;
        }
        return result;
    }

    public virtual object feeToPrecision(object symbol, object fee)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(fee, ROUND, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
    }

    public virtual object currencyToPrecision(object code, object fee, object networkCode = null)
    {
        object currency = getValue(this.currencies, code);
        object precision = this.safeValue(currency, "precision");
        if (isTrue(!isEqual(networkCode, null)))
        {
            object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
            object networkItem = this.safeValue(networks, networkCode, new Dictionary<string, object>() {});
            precision = this.safeValue(networkItem, "precision", precision);
        }
        if (isTrue(isEqual(precision, null)))
        {
            return fee;
        } else
        {
            return this.decimalToPrecision(fee, ROUND, precision, this.precisionMode, this.paddingMode);
        }
    }

    public virtual object safeNumber(object obj, object key, object defaultNumber = null)
    {
        object value = this.safeString(obj, key);
        return this.parseNumber(value, defaultNumber);
    }

    public virtual object safeNumberN(object obj, object arr, object defaultNumber = null)
    {
        object value = this.safeStringN(obj, arr);
        return this.parseNumber(value, defaultNumber);
    }

    public virtual object parsePrecision(object precision)
    {
        /**
         * @ignore
         * @method
         * @param {string} precision The number of digits to the right of the decimal
         * @returns {string} a string number equal to 1e-precision
         */
        if (isTrue(isEqual(precision, null)))
        {
            return null;
        }
        object precisionNumber = parseInt(precision);
        if (isTrue(isEqual(precisionNumber, 0)))
        {
            return "1";
        }
        object parsedPrecision = "0.";
        for (object i = 0; isLessThan(i, subtract(precisionNumber, 1)); postFixIncrement(ref i))
        {
            parsedPrecision = add(parsedPrecision, "0");
        }
        return add(parsedPrecision, "1");
    }

    public async virtual Task<object> loadTimeDifference(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object serverTime = await this.fetchTime(parameters);
        object after = this.milliseconds();
        ((Dictionary<string, object>)this.options)["timeDifference"] = subtract(after, serverTime);
        return getValue(this.options, "timeDifference");
    }

    public virtual object implodeHostname(object url)
    {
        return this.implodeParams(url, new Dictionary<string, object>() {
            { "hostname", this.hostname },
        });
    }

    public async virtual Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchLeverageTiers")))
        {
            object market = this.market(symbol);
            if (!isTrue(getValue(market, "contract")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchMarketLeverageTiers() supports contract markets only")) ;
            }
            object tiers = await this.fetchLeverageTiers(new List<object>() {symbol});
            return this.safeValue(tiers, symbol);
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchMarketLeverageTiers() is not supported yet")) ;
        }
    }

    public async virtual Task<object> createPostOnlyOrder(object symbol, object type, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createPostOnlyOrder")))
        {
            throw new NotSupported ((string)add(this.id, "createPostOnlyOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "postOnly", true },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createReduceOnlyOrder(object symbol, object type, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createReduceOnlyOrder")))
        {
            throw new NotSupported ((string)add(this.id, "createReduceOnlyOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "reduceOnly", true },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createStopOrder(object symbol, object type, object side, object amount, object price = null, object stopPrice = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopOrder() is not supported yet")) ;
        }
        if (isTrue(isEqual(stopPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " create_stop_order() requires a stopPrice argument")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createStopLimitOrder(object symbol, object side, object amount, object price, object stopPrice, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopLimitOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopLimitOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, "limit", side, amount, price, query);
    }

    public async virtual Task<object> createStopMarketOrder(object symbol, object side, object amount, object stopPrice, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopMarketOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopMarketOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, "market", side, amount, null, query);
    }

    public virtual object safeCurrencyCode(object currencyId, object currency = null)
    {
        currency = this.safeCurrency(currencyId, currency);
        return getValue(currency, "code");
    }

    public virtual object filterBySymbolSinceLimit(object array, object symbol = null, object since = null, object limit = null)
    {
        return this.filterByValueSinceLimit(array, "symbol", symbol, since, limit, "timestamp");
    }

    public virtual object filterByCurrencySinceLimit(object array, object code = null, object since = null, object limit = null)
    {
        return this.filterByValueSinceLimit(array, "currency", code, since, limit, "timestamp");
    }

    public virtual object parseLastPrices(object pricesData, object symbols = null, object parameters = null)
    {
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((pricesData.GetType().IsGenericType && pricesData.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(pricesData)); postFixIncrement(ref i))
            {
                object priceData = this.extend(this.parseLastPrice(getValue(pricesData, i)), parameters);
                ((List<object>)results).Add(priceData);
            }
        } else
        {
            object marketIds = new List<object>(((Dictionary<string,object>)pricesData).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object market = this.safeMarket(marketId);
                object priceData = this.extend(this.parseLastPrice(getValue(pricesData, marketId), market), parameters);
                ((List<object>)results).Add(priceData);
            }
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object parseTickers(object tickers, object symbols = null, object parameters = null)
    {
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((tickers.GetType().IsGenericType && tickers.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
            {
                object ticker = this.extend(this.parseTicker(getValue(tickers, i)), parameters);
                ((List<object>)results).Add(ticker);
            }
        } else
        {
            object marketIds = new List<object>(((Dictionary<string,object>)tickers).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object market = this.safeMarket(marketId);
                object ticker = this.extend(this.parseTicker(getValue(tickers, marketId), market), parameters);
                ((List<object>)results).Add(ticker);
            }
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object parseDepositAddresses(object addresses, object codes = null, object indexed = null, object parameters = null)
    {
        indexed ??= true;
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(addresses)); postFixIncrement(ref i))
        {
            object address = this.extend(this.parseDepositAddress(getValue(addresses, i)), parameters);
            ((List<object>)result).Add(address);
        }
        if (isTrue(!isEqual(codes, null)))
        {
            result = this.filterByArray(result, "currency", codes, false);
        }
        if (isTrue(indexed))
        {
            return this.indexBy(result, "currency");
        }
        return result;
    }

    public virtual object parseBorrowInterests(object response, object market = null)
    {
        object interests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object row = getValue(response, i);
            ((List<object>)interests).Add(this.parseBorrowInterest(row, market));
        }
        return interests;
    }

    public virtual object parseFundingRateHistories(object response, object market = null, object since = null, object limit = null)
    {
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            ((List<object>)rates).Add(this.parseFundingRateHistory(entry, market));
        }
        object sorted = this.sortBy(rates, "timestamp");
        object symbol = ((bool) isTrue((isEqual(market, null)))) ? null : getValue(market, "symbol");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object safeSymbol(object marketId, object market = null, object delimiter = null, object marketType = null)
    {
        market = this.safeMarket(marketId, market, delimiter, marketType);
        return getValue(market, "symbol");
    }

    public virtual object parseFundingRate(object contract, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseFundingRate() is not supported yet")) ;
    }

    public virtual object parseFundingRates(object response, object market = null)
    {
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object parsed = this.parseFundingRate(getValue(response, i), market);
            ((Dictionary<string, object>)result)[(string)getValue(parsed, "symbol")] = parsed;
        }
        return result;
    }

    public virtual object isTriggerOrder(object parameters)
    {
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        if (isTrue(isTrigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        }
        return new List<object>() {isTrigger, parameters};
    }

    public virtual object isPostOnly(object isMarketOrder, object exchangeSpecificParam, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} type Order type
        * @param {boolean} exchangeSpecificParam exchange specific postOnly
        * @param {object} params exchange specific params
        * @returns {boolean} true if a post only order, false otherwise
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.safeValue2(parameters, "postOnly", "post_only", false);
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        object ioc = isEqual(timeInForce, "IOC");
        object fok = isEqual(timeInForce, "FOK");
        object timeInForcePostOnly = isEqual(timeInForce, "PO");
        postOnly = isTrue(isTrue(postOnly) || isTrue(timeInForcePostOnly)) || isTrue(exchangeSpecificParam);
        if (isTrue(postOnly))
        {
            if (isTrue(isTrue(ioc) || isTrue(fok)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) ;
            } else if (isTrue(isMarketOrder))
            {
                throw new InvalidOrder ((string)add(this.id, " market orders cannot be postOnly")) ;
            } else
            {
                return true;
            }
        } else
        {
            return false;
        }
    }

    public virtual object handlePostOnly(object isMarketOrder, object exchangeSpecificPostOnlyOption, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} type Order type
        * @param {boolean} exchangeSpecificBoolean exchange specific postOnly
        * @param {object} params exchange specific params
        * @returns {[boolean, params]}
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.safeValue(parameters, "postOnly", false);
        object ioc = isEqual(timeInForce, "IOC");
        object fok = isEqual(timeInForce, "FOK");
        object po = isEqual(timeInForce, "PO");
        postOnly = isTrue(isTrue(postOnly) || isTrue(po)) || isTrue(exchangeSpecificPostOnlyOption);
        if (isTrue(postOnly))
        {
            if (isTrue(isTrue(ioc) || isTrue(fok)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) ;
            } else if (isTrue(isMarketOrder))
            {
                throw new InvalidOrder ((string)add(this.id, " market orders cannot be postOnly")) ;
            } else
            {
                if (isTrue(po))
                {
                    parameters = this.omit(parameters, "timeInForce");
                }
                parameters = this.omit(parameters, "postOnly");
                return new List<object>() {true, parameters};
            }
        }
        return new List<object>() {false, parameters};
    }

    public async virtual Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLastPrices() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTradingFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTradingFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFee() is not supported yet")) ;
        }
        return await this.fetchTradingFees(parameters);
    }

    public virtual object parseOpenInterest(object interest, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseOpenInterest () is not supported yet")) ;
    }

    public virtual object parseOpenInterests(object response, object market = null, object since = null, object limit = null)
    {
        object interests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object interest = this.parseOpenInterest(entry, market);
            ((List<object>)interests).Add(interest);
        }
        object sorted = this.sortBy(interests, "timestamp");
        object symbol = this.safeString(market, "symbol");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async virtual Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchFundingRates")))
        {
            await this.loadMarkets();
            object market = this.market(symbol);
            if (!isTrue(getValue(market, "contract")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports contract markets only")) ;
            }
            object rates = await this.fetchFundingRates(new List<object>() {symbol}, parameters);
            object rate = this.safeValue(rates, symbol);
            if (isTrue(isEqual(rate, null)))
            {
                throw new NullResponse ((string)add(add(this.id, " fetchFundingRate () returned no data for "), symbol)) ;
            } else
            {
                return rate;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRate () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchMarkOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchMarkOHLCV
        * @description fetches historical mark price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[[int|float]]} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchMarkOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "mark" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchMarkOHLCV () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchIndexOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchIndexOHLCV
        * @description fetches historical index price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[[int|float]]} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchIndexOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "index" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchIndexOHLCV () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchPremiumIndexOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchPremiumIndexOHLCV
        * @description fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[[int|float]]} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchPremiumIndexOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "premiumIndex" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchPremiumIndexOHLCV () is not supported yet")) ;
        }
    }

    public virtual object handleTimeInForce(object parameters = null)
    {
        /**
        * @ignore
        * @method
        * * Must add timeInForce to this.options to use this method
        * @return {string} returns the exchange specific value for timeInForce
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce"); // supported values GTC, IOC, PO
        if (isTrue(!isEqual(timeInForce, null)))
        {
            object exchangeValue = this.safeString(getValue(this.options, "timeInForce"), timeInForce);
            if (isTrue(isEqual(exchangeValue, null)))
            {
                throw new ExchangeError ((string)add(add(add(this.id, " does not support timeInForce \""), timeInForce), "\"")) ;
            }
            return exchangeValue;
        }
        return null;
    }

    public virtual object convertTypeToAccount(object account)
    {
        /**
         * @ignore
         * @method
         * * Must add accountsByType to this.options to use this method
         * @param {string} account key for account name in this.options['accountsByType']
         * @returns the exchange specific account name or the isolated margin id for transfers
         */
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object lowercaseAccount = ((string)account).ToLower();
        if (isTrue(inOp(accountsByType, lowercaseAccount)))
        {
            return getValue(accountsByType, lowercaseAccount);
        } else if (isTrue(isTrue((inOp(this.markets, account))) || isTrue((inOp(this.markets_by_id, account)))))
        {
            object market = this.market(account);
            return getValue(market, "id");
        } else
        {
            return account;
        }
    }

    public virtual void checkRequiredArgument(object methodName, object argument, object argumentName, object options = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} argument the argument to check
        * @param {string} argumentName the name of the argument to check
        * @param {string} methodName the name of the method that the argument is being checked for
        * @param {[string]} options a list of options that the argument can be
        * @returns {undefined}
        */
        options ??= new List<object>();
        object optionsLength = getArrayLength(options);
        if (isTrue(isTrue((isEqual(argument, null))) || isTrue((isTrue((isGreaterThan(optionsLength, 0))) && isTrue((!isTrue((this.inArray(argument, options)))))))))
        {
            object messageOptions = String.Join(", ", ((List<object>)options).ToArray());
            object message = add(add(add(add(add(this.id, " "), methodName), "() requires a "), argumentName), " argument");
            if (isTrue(!isEqual(messageOptions, "")))
            {
                message = add(message, add(add(add(", one of ", "("), messageOptions), ")"));
            }
            throw new ArgumentsRequired ((string)message) ;
        }
    }

    public virtual void checkRequiredMarginArgument(object methodName, object symbol, object marginMode)
    {
        /**
         * @ignore
         * @method
         * @param {string} symbol unified symbol of the market
         * @param {string} methodName name of the method that requires a symbol
         * @param {string} marginMode is either 'isolated' or 'cross'
         */
        if (isTrue(isTrue((isEqual(marginMode, "isolated"))) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for isolated margin")) ;
        } else if (isTrue(isTrue((isEqual(marginMode, "cross"))) && isTrue((!isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() cannot have a symbol argument for cross margin")) ;
        }
    }

    public virtual void checkRequiredSymbol(object methodName, object symbol)
    {
        /**
         * @ignore
         * @method
         * @param {string} symbol unified symbol of the market
         * @param {string} methodName name of the method that requires a symbol
         */
        this.checkRequiredArgument(methodName, symbol, "symbol");
    }

    public virtual object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        /**
         * @ignore
         * @method
         * @param {[object]|object} response unparsed response from the exchange
         * @param {[string]|undefined} codes the unified currency codes to fetch transactions fees for, returns all currencies when undefined
         * @param {str|undefined} currencyIdKey *should only be undefined when response is a dictionary* the object key that corresponds to the currency id
         * @returns {object} objects with withdraw and deposit fees, indexed by currency codes
         */
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        object isArray = (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)));
        object responseKeys = response;
        if (!isTrue(isArray))
        {
            responseKeys = new List<object>(((Dictionary<string,object>)response).Keys);
        }
        for (object i = 0; isLessThan(i, getArrayLength(responseKeys)); postFixIncrement(ref i))
        {
            object entry = getValue(responseKeys, i);
            object dictionary = ((bool) isTrue(isArray)) ? entry : getValue(response, entry);
            object currencyId = ((bool) isTrue(isArray)) ? this.safeString(dictionary, currencyIdKey) : entry;
            object currency = this.safeValue(this.currencies_by_id, currencyId);
            object code = this.safeString(currency, "code", currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.parseDepositWithdrawFee(dictionary, currency);
            }
        }
        return depositWithdrawFees;
    }

    public virtual object parseDepositWithdrawFee(object fee, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseDepositWithdrawFee() is not supported yet")) ;
    }

    public virtual object depositWithdrawFee(object info)
    {
        return new Dictionary<string, object>() {
            { "info", info },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public virtual object assignDefaultDepositWithdrawFees(object fee, object currency = null)
    {
        /**
         * @ignore
         * @method
         * @description Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
         * @param {object} fee A deposit withdraw fee structure
         * @param {object} currency A currency structure, the response from this.currency ()
         * @returns {object} A deposit withdraw fee structure
         */
        object networkKeys = new List<object>(((Dictionary<string,object>)getValue(fee, "networks")).Keys);
        object numNetworks = getArrayLength(networkKeys);
        if (isTrue(isEqual(numNetworks, 1)))
        {
            ((Dictionary<string, object>)fee)["withdraw"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, 0)), "withdraw");
            ((Dictionary<string, object>)fee)["deposit"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, 0)), "deposit");
            return fee;
        }
        object currencyCode = this.safeString(currency, "code");
        for (object i = 0; isLessThan(i, numNetworks); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, currencyCode)))
            {
                ((Dictionary<string, object>)fee)["withdraw"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, i)), "withdraw");
                ((Dictionary<string, object>)fee)["deposit"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, i)), "deposit");
            }
        }
        return fee;
    }

    public virtual object parseIncome(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseIncome () is not supported yet")) ;
    }

    public virtual object parseIncomes(object incomes, object market = null, object since = null, object limit = null)
    {
        /**
         * @ignore
         * @method
         * @description parses funding fee info from exchange response
         * @param {[object]} incomes each item describes once instance of currency being received or paid
         * @param {object|undefined} market ccxt market
         * @param {int|undefined} since when defined, the response items are filtered to only include items after this timestamp
         * @param {int|undefined} limit limits the number of items in the response
         * @returns {[object]} an array of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
         */
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(incomes)); postFixIncrement(ref i))
        {
            object entry = getValue(incomes, i);
            object parsed = this.parseIncome(entry, market);
            ((List<object>)result).Add(parsed);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public virtual object getMarketFromSymbols(object symbols = null)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return null;
        }
        object firstMarket = this.safeString(symbols, 0);
        object market = this.market(firstMarket);
        return market;
    }
}

