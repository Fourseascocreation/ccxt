using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public partial class SharedMethods
    {
        public object logTemplate(Exchange exchange, object method, object entry)
        {
            return add(add(add(add(add(add(" <<< ", exchange.id), " "), method), " ::: "), exchange.json(entry)), " >>> ");
        }
        public object assertType(Exchange exchange, object entry, object key, object format)
        {
            // because "typeof" string is not transpilable without === 'name', we list them manually at this moment
            object entryKeyVal = exchange.safeValue(entry, key);
            if (isTrue(isTrue(!isEqual(entryKeyVal, null)) && isTrue(!isEqual(format, null))))
            {
                object formatKeyVal = exchange.safeValue(format, key);
                if (isTrue(!isEqual(formatKeyVal, null)))
                {
                    object same_string = isTrue((((entryKeyVal).GetType() == typeof(string)))) && isTrue((((formatKeyVal).GetType() == typeof(string))));
                    object same_numeric = isTrue((((entryKeyVal).GetType() == typeof(Int64)) || ((entryKeyVal).GetType() == typeof(int) || (entryKeyVal).GetType() == typeof(float) || (entryKeyVal).GetType() == typeof(double)))) && isTrue((((formatKeyVal).GetType() == typeof(Int64)) || ((formatKeyVal).GetType() == typeof(int) || (formatKeyVal).GetType() == typeof(float) || (formatKeyVal).GetType() == typeof(double))));
                    // todo: the below is correct, but is not being transpiled into python correctly: (x == False) instead of (x is False)
                    // const same_boolean = ((entryKeyVal === true) || (entryKeyVal === false)) && ((formatKeyVal === true) || (formatKeyVal === false));
                    object same_boolean = (isTrue((isTrue(entryKeyVal) || !isTrue(entryKeyVal))) && isTrue((isTrue(formatKeyVal) || !isTrue(formatKeyVal))));
                    object same_array = isTrue((entryKeyVal.GetType().IsGenericType && entryKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))) && isTrue((formatKeyVal.GetType().IsGenericType && formatKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
                    object same_object = isTrue((((entryKeyVal).GetType() == typeof(Dictionary<string, object>)))) && isTrue((((formatKeyVal).GetType() == typeof(Dictionary<string, object>))));
                    object result = isTrue(isTrue(isTrue(isTrue(same_string) || isTrue(same_numeric)) || isTrue(same_boolean)) || isTrue(same_array)) || isTrue(same_object);
                    return result;
                }
            }
            return true;
        }
        public void assertStructure(Exchange exchange, object method, object entry, object format, object emptyNotAllowedFor = null)
        {
            emptyNotAllowedFor ??= new List<object>();
            object logText = logTemplate(exchange, method, entry);
            assert(entry, add("item is null/undefined", logText));
            // get all expected & predefined keys for this specific item and ensure thos ekeys exist in parsed structure
            if (isTrue((format.GetType().IsGenericType && format.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                assert((entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))), add("entry is not an array", logText));
                object realLength = getArrayLength(entry);
                object expectedLength = getArrayLength(format);
                assert(isEqual(realLength, expectedLength), add(add("entry length is not equal to expected length of ", ((object)expectedLength).ToString()), logText));
                for (object i = 0; isLessThan(i, getArrayLength(format)); postFixIncrement(ref i))
                {
                    object is_in_array = exchange.inArray(i, emptyNotAllowedFor);
                    if (isTrue(is_in_array))
                    {
                        assert((!isEqual(getValue(entry, i), null)), add(add(((object)i).ToString(), " index is undefined, but is is was expected to be set"), logText));
                    }
                    // because of other langs, this is needed for arrays
                    assert(assertType(exchange, entry, i, format), add(add(((object)i).ToString(), " index does not have an expected type "), logText));
                }
            } else
            {
                assert(((entry).GetType() == typeof(Dictionary<string, object>)), add("entry is not an object", logText));
                object keys = new List<object>(((Dictionary<string,object>)format).Keys);
                for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                {
                    object key = getValue(keys, i);
                    object keyStr = ((object)key).ToString();
                    assert((((Dictionary<string,object>)entry).ContainsKey(toStringOrNull(key))), add(add(keyStr, " key is missing from structure"), logText));
                    if (isTrue(exchange.inArray(key, emptyNotAllowedFor)))
                    {
                        // if it was in needed keys, then it should have value.
                        assert(!isEqual(getValue(entry, key), null), add(add(key, " key has an null value, but is expected to have a value"), logText));
                    }
                    assert(assertType(exchange, entry, key, format), add(add(key, " key is neither undefined, neither of expected type"), logText));
                }
            }
        }
        public void assertTimestamp(Exchange exchange, object method, object entry, object nowToCheck = null, object keyName = null)
        {
            keyName ??= "timestamp";
            object logText = logTemplate(exchange, method, entry);
            object isDateTimeObject = ((keyName).GetType() == typeof(string));
            if (isTrue(isDateTimeObject))
            {
                assert((((Dictionary<string,object>)entry).ContainsKey(toStringOrNull(keyName))), add(add(add("timestamp key ", keyName), " is missing from structure"), logText));
            } else
            {
                // if index was provided (mostly from fetchOHLCV) then we check if it exists, as mandatory
                assert(!isTrue((isEqual(getValue(entry, keyName), null))), add(add(add("timestamp index ", ((object)keyName).ToString()), " is undefined"), logText));
            }
            object ts = getValue(entry, keyName);
            if (isTrue(!isEqual(ts, null)))
            {
                // todo: add transpilable is_integer
                assert(((ts).GetType() == typeof(Int64)) || ((ts).GetType() == typeof(int) || (ts).GetType() == typeof(float) || (ts).GetType() == typeof(double)), add("timestamp is not numeric", logText));
                assert(isGreaterThan(ts, 1230940800000), add("timestamp is impossible to be before 1230940800000 / 03.01.2009", logText)); // 03 Jan 2009 - first block
                assert(isLessThan(ts, 2147483648000), add("timestamp more than 2147483648000 / 19.01.2038", logText)); // 19 Jan 2038 - int32 overflows // 7258118400000  -> Jan 1 2200
                if (isTrue(!isEqual(nowToCheck, null)))
                {
                    assert(isLessThan(ts, add(nowToCheck, 60000)), add(add(add(add("trade timestamp is not below current time. Returned datetime: ", exchange.iso8601(ts)), ", now: "), exchange.iso8601(nowToCheck)), logText));
                }
            }
            // only in case if the entry is a dictionary, thus it must have 'timestamp' & 'datetime' string keys
            if (isTrue(isDateTimeObject))
            {
                // we also test 'datetime' here because it's certain sibling of 'timestamp'
                assert((((Dictionary<string,object>)entry).ContainsKey(toStringOrNull("datetime"))), add("datetime is missing from structure", logText));
                object dt = getValue(entry, "datetime");
                if (isTrue(!isEqual(dt, null)))
                {
                    assert(((dt).GetType() == typeof(string)), add("datetime is not a string", logText));
                    assert(isEqual(dt, exchange.iso8601(getValue(entry, "timestamp"))), add("datetime is not iso8601 of timestamp", logText));
                }
            }
        }
        public void assertCurrencyCode(Exchange exchange, object method, object entry, object actualCode, object expectedCode = null)
        {
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(actualCode, null)))
            {
                assert(((actualCode).GetType() == typeof(string)), add("currency code should be either undefined or a string", logText));
                assert((((Dictionary<string,object>)exchange.currencies).ContainsKey(toStringOrNull(actualCode))), add("currency code should be present in exchange.currencies", logText));
                if (isTrue(!isEqual(expectedCode, null)))
                {
                    assert(isEqual(actualCode, expectedCode), add(add(add(add(add("currency code in response (", actualCode), ") should be equal to expected code ("), expectedCode), ")"), logText));
                }
            }
        }
        public void assertSymbol(Exchange exchange, object method, object entry, object key, object expectedSymbol = null)
        {
            object logText = logTemplate(exchange, method, entry);
            object actualSymbol = exchange.safeString(entry, key);
            if (isTrue(!isEqual(actualSymbol, null)))
            {
                assert(((actualSymbol).GetType() == typeof(string)), add("symbol should be either undefined or a string", logText));
                assert((((Dictionary<string,object>)exchange.markets).ContainsKey(toStringOrNull(actualSymbol))), add("symbol should be present in exchange.symbols", logText));
            }
            if (isTrue(!isEqual(expectedSymbol, null)))
            {
                assert(isEqual(actualSymbol, expectedSymbol), add(add(add(add(add("symbol in response (", actualSymbol), ") should be equal to expected symbol ("), expectedSymbol), ")"), logText));
            }
        }
        public void assertGreater(Exchange exchange, object method, object entry, object key, object compareTo)
        {
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                object keyStr = null;
                if (isTrue(((key).GetType() == typeof(string))))
                {
                    keyStr = key;
                } else
                {
                    keyStr = ((object)key).ToString();
                }
                object compareToStr = null;
                if (isTrue(((compareTo).GetType() == typeof(string))))
                {
                    compareToStr = compareTo;
                } else
                {
                    compareToStr = ((object)compareTo).ToString();
                }
                assert(Precise.stringGt(value, compareTo), add(add(add(add(add(keyStr, " key (with a value of "), value), ") was expected to be > "), compareToStr), logText));
            }
        }
        public void assertGreaterOrEqual(Exchange exchange, object method, object entry, object key, object compareTo)
        {
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                object keyStr = null;
                if (isTrue(((key).GetType() == typeof(string))))
                {
                    keyStr = key;
                } else
                {
                    keyStr = ((object)key).ToString();
                }
                object compareToStr = null;
                if (isTrue(((compareTo).GetType() == typeof(string))))
                {
                    compareToStr = compareTo;
                } else
                {
                    compareToStr = ((object)compareTo).ToString();
                }
                assert(Precise.stringGe(value, compareTo), add(add(add(add(add(keyStr, " key (with a value of "), value), ") was expected to be >= "), compareToStr), logText));
            }
        }
        public void assertLess(Exchange exchange, object method, object entry, object key, object compareTo)
        {
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                object keyStr = null;
                if (isTrue(((key).GetType() == typeof(string))))
                {
                    keyStr = key;
                } else
                {
                    keyStr = ((object)key).ToString();
                }
                object compareToStr = null;
                if (isTrue(((compareTo).GetType() == typeof(string))))
                {
                    compareToStr = compareTo;
                } else
                {
                    compareToStr = ((object)compareTo).ToString();
                }
                assert(Precise.stringLt(value, compareTo), add(add(add(add(add(keyStr, " key (with a value of "), value), ") was expected to be < "), compareToStr), logText));
            }
        }
        public void assertLessOrEqual(Exchange exchange, object method, object entry, object key, object compareTo)
        {
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                object keyStr = null;
                if (isTrue(((key).GetType() == typeof(string))))
                {
                    keyStr = key;
                } else
                {
                    keyStr = ((object)key).ToString();
                }
                object compareToStr = null;
                if (isTrue(((compareTo).GetType() == typeof(string))))
                {
                    compareToStr = compareTo;
                } else
                {
                    compareToStr = ((object)compareTo).ToString();
                }
                assert(Precise.stringLe(value, compareTo), add(add(add(add(add(keyStr, " key (with a value of "), value), ") was expected to be <= "), compareToStr), logText));
            }
        }
        public void assertInArray(Exchange exchange, object method, object entry, object key, object expectedArray)
        {
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeValue(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                object keyStr = null;
                if (isTrue(((key).GetType() == typeof(string))))
                {
                    keyStr = key;
                } else
                {
                    keyStr = ((object)key).ToString();
                }
                assert(exchange.inArray(value, expectedArray), add(add(add(add(add(add(keyStr, " key (with a value of "), value), ") was expected to be one from: ["), String.Join(",", ((List<object>)expectedArray).ToArray())), "]"), logText));
            }
        }
        public void assertFee(Exchange exchange, object method, object entry)
        {
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(entry, null)))
            {
                assert((((Dictionary<string,object>)entry).ContainsKey(toStringOrNull("cost"))), add("\"fee\" should contain a \"cost\" key", logText));
                assertGreaterOrEqual(exchange, method, entry, "cost", "0");
                assert((((Dictionary<string,object>)entry).ContainsKey(toStringOrNull("currency"))), add("\"fee\" should contain a \"currency\" key", logText));
                assertCurrencyCode(exchange, method, entry, getValue(entry, "currency"));
            }
        }
        public void assertFees(Exchange exchange, object method, object entry)
        {
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(entry, null)))
            {
                assert((entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))), add("\"fees\" is not an array", logText));
                for (object i = 0; isLessThan(i, getArrayLength(entry)); postFixIncrement(ref i))
                {
                    assertFee(exchange, method, getValue(entry, i));
                }
            }
        }
        public void assertTimestampOrder(Exchange exchange, object method, object codeOrSymbol, object items, object ascending = null)
        {
            ascending ??= false;
            for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
            {
                if (isTrue(isGreaterThan(i, 0)))
                {
                    object ascendingOrDescending = ((bool) isTrue(ascending)) ? "ascending" : "descending";
                    object firstIndex = ((bool) isTrue(ascending)) ? subtract(i, 1) : i;
                    object secondIndex = ((bool) isTrue(ascending)) ? i : subtract(i, 1);
                    assert(isGreaterThanOrEqual(getValue(getValue(items, firstIndex), "timestamp"), getValue(getValue(items, secondIndex), "timestamp")), add(add(add(add(add(add(add(add(exchange.id, " "), method), " "), codeOrSymbol), " must return a "), ascendingOrDescending), " sorted array of items by timestamp. "), exchange.json(items)));
                }
            }
        }

    }
}