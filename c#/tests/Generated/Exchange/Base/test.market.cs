using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public static void testMarket(Exchange exchange, object method, object market)
    {
        object format = new Dictionary<string, object>() {
            { "id", "btcusd" },
            { "symbol", "BTC/USD" },
            { "base", "BTC" },
            { "quote", "USD" },
            { "taker", exchange.parseNumber("0.0011") },
            { "maker", exchange.parseNumber("0.0009") },
            { "baseId", "btc" },
            { "quoteId", "usd" },
            { "active", true },
            { "type", "spot" },
            { "linear", false },
            { "inverse", false },
            { "spot", true },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "margin", false },
            { "contract", false },
            { "contractSize", exchange.parseNumber("0.001") },
            { "expiry", 1656057600000 },
            { "expiryDatetime", "2022-06-24T08:00:00.000Z" },
            { "optionType", "put" },
            { "strike", exchange.parseNumber("56000") },
            { "settle", "XYZ" },
            { "settleId", "Xyz" },
            { "precision", new Dictionary<string, object>() {
                { "price", exchange.parseNumber("8") },
                { "amount", exchange.parseNumber("8") },
                { "cost", exchange.parseNumber("8") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
            } },
            { "info", new Dictionary<string, object>() {} },
        };
        object emptyNotAllowedFor = new List<object>() {"id", "symbol", "base", "quote", "baseId", "quoteId", "precision", "limits", "type", "spot", "swap", "future", "contract"};
        testSharedMethods.assertStructure(exchange, method, market, format, emptyNotAllowedFor);
        testSharedMethods.assertSymbol(exchange, method, market, "symbol");
        object logText = testSharedMethods.logTemplate(exchange, method, market);
        //
        testSharedMethods.assertGreater(exchange, method, market, "contractSize", "0");
        testSharedMethods.assertGreater(exchange, method, market, "expiry", "0");
        testSharedMethods.assertGreater(exchange, method, market, "strike", "0");
        testSharedMethods.assertInArray(exchange, method, market, "optionType", new List<object>() {"put", "call"});
        testSharedMethods.assertGreater(exchange, method, market, "taker", "-100");
        testSharedMethods.assertGreater(exchange, method, market, "maker", "-100");
        if (isTrue(getValue(market, "contract")))
        {
            assert(!isEqual(getValue(market, "linear"), getValue(market, "inverse")), add("market linear and inverse must not be the same", logText));
        } else
        {
            assert(isTrue((isEqual(getValue(market, "linear"), null))) && isTrue((isEqual(getValue(market, "inverse"), null))), add("market linear and inverse must be undefined when \"contract\" is true", logText));
        }
        if (isTrue(getValue(market, "option")))
        {
            assert(!isEqual(getValue(market, "strike"), null), add("\"strike\" must be defined when \"option\" is true", logText));
            assert(!isEqual(getValue(market, "optionType"), null), add("\"optionType\" must be defined when \"option\" is true", logText));
        }
        object validTypes = new List<object>() {"spot", "margin", "swap", "future", "option"};
        testSharedMethods.assertInArray(exchange, method, market, "type", validTypes);
        object types = validTypes;
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            testSharedMethods.assertInArray(exchange, method, market, getValue(types, i), new List<object>() {true, false, null});
        }
        if (isTrue(getValue(market, "future")))
        {
            assert(!isTrue(getValue(market, "swap")) && !isTrue(getValue(market, "option")), add("market swap and option must be false when \"future\" is true", logText));
        } else if (isTrue(getValue(market, "swap")))
        {
            assert(!isTrue(getValue(market, "future")) && !isTrue(getValue(market, "option")), add("market future and option must be false when \"swap\" is true", logText));
        } else if (isTrue(getValue(market, "option")))
        {
            assert(!isTrue(getValue(market, "future")) && !isTrue(getValue(market, "swap")), add("market future and swap must be false when \"option\" is true", logText));
        }
        if (isTrue(getValue(market, "linear")))
        {
            assert(!isTrue(getValue(market, "inverse")), add("market inverse must be false when \"linear\" is true", logText));
        } else if (isTrue(getValue(market, "inverse")))
        {
            assert(!isTrue(getValue(market, "linear")), add("market linear must be false when \"inverse\" is true", logText));
        }
        if (isTrue(getValue(market, "future")))
        {
            assert(!isEqual(getValue(market, "expiry"), null), add("\"expiry\" must be defined when \"future\" is true", logText));
            assert(!isEqual(getValue(market, "expiryDatetime"), null), add("\"expiryDatetime\" must be defined when \"future\" is true", logText));
        }
        if (isTrue(!isEqual(getValue(market, "expiry"), null)))
        {
            assert(isEqual(getValue(market, "expiryDatetime"), exchange.iso8601(getValue(market, "expiry"))), add("expiryDatetime must be equal to expiry in iso8601 format", logText));
        }
        object targetKeys = new List<object>() {"cost", "amount", "price"};
        // check precisions
        for (object i = 0; isLessThan(i, getArrayLength(targetKeys)); postFixIncrement(ref i))
        {
            object key = getValue(targetKeys, i);
            // todo: should be migrated into assertGreater after TickSize handling is implemented
            testSharedMethods.assertGreaterOrEqual(exchange, method, getValue(market, "precision"), key, "0");
        }
        // check limits
        for (object i = 0; isLessThan(i, getArrayLength(targetKeys)); postFixIncrement(ref i))
        {
            object key = getValue(targetKeys, i);
            object limitEntry = getValue(getValue(market, "limits"), key);
            testSharedMethods.assertGreaterOrEqual(exchange, method, limitEntry, "min", "0");
            testSharedMethods.assertGreater(exchange, method, limitEntry, "max", "0");
        }
    }

}