using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class testMainClass : BaseTest
{
    public virtual void parseCliArgs()
    {
        this.info = getCliArgValue("--info");
        this.verbose = getCliArgValue("--verbose");
        this.debug = getCliArgValue("--debug");
        this.privateTest = getCliArgValue("--private");
        this.privateTestOnly = getCliArgValue("--privateOnly");
        this.sandbox = getCliArgValue("--sandbox");
    }

    public async virtual Task init(object exchangeId, object symbol)
    {
        this.parseCliArgs();
        object symbolStr = ((bool) isTrue(!isEqual(symbol, null))) ? symbol : "all";
        Console.WriteLine("\nTESTING ", ext, new Dictionary<string, object>() {
            { "exchange", exchangeId },
            { "symbol", symbolStr },
        }, "\n");
        object exchangeArgs = new Dictionary<string, object>() {
            { "verbose", this.verbose },
            { "debug", this.debug },
            { "httpsAgent", httpsAgent },
            { "enableRateLimit", true },
            { "timeout", 20000 },
        };
        Exchange exchange = initExchange(exchangeId, exchangeArgs);
        await this.importFiles(exchange);
        this.expandSettings(exchange, symbol);
        await this.startTest(exchange, symbol);
        await close(exchange);
    }

    public async virtual Task importFiles(Exchange exchange)
    {
        // exchange tests
        this.testFiles = new Dictionary<string, object>() {};
        object properties = new List<object>(((Dictionary<string,object>)exchange.has).Keys);
        ((List<object>)properties).Add("loadMarkets");
        await setTestFiles(this, properties);
    }

    public virtual void expandSettings(Exchange exchange, object symbol)
    {
        object exchangeId = exchange.id;
        object keysGlobal = add(rootDir, "keys.json");
        object keysLocal = add(rootDir, "keys.local.json");
        object keysGlobalExists = ioFileExists(keysGlobal);
        object keysLocalExists = ioFileExists(keysLocal);
        object globalSettings = ((bool) isTrue(keysGlobalExists)) ? ioFileRead(keysGlobal) : new Dictionary<string, object>() {};
        object localSettings = ((bool) isTrue(keysLocalExists)) ? ioFileRead(keysLocal) : new Dictionary<string, object>() {};
        object allSettings = exchange.deepExtend(globalSettings, localSettings);
        object exchangeSettings = exchange.safeValue(allSettings, exchangeId, new Dictionary<string, object>() {});
        if (isTrue(exchangeSettings))
        {
            object settingKeys = new List<object>(((Dictionary<string,object>)exchangeSettings).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(settingKeys)); postFixIncrement(ref i))
            {
                object key = getValue(settingKeys, i);
                if (isTrue(getValue(exchangeSettings, key)))
                {
                    // const existing = getExchangeProp (exchange, key, {});
                    setExchangeProp(exchange, key, getValue(exchangeSettings, key));
                }
            }
            // support simple proxy
            object proxy = getExchangeProp(exchange, "httpProxy");
            if (isTrue(proxy))
            {
                addProxy(exchange, proxy);
            }
        }
        // credentials
        object reqCreds = getExchangeProp(exchange, add("re", "quiredCredentials")); // dont glue the r-e-q-u-i-r-e phrase, because leads to messed up transpilation
        object objkeys = new List<object>(((Dictionary<string,object>)reqCreds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(objkeys)); postFixIncrement(ref i))
        {
            object credential = getValue(objkeys, i);
            object isRequired = getValue(reqCreds, credential);
            if (isTrue(isTrue(isRequired) && isTrue(isEqual(getExchangeProp(exchange, credential), null))))
            {
                object fullKey = add(add(exchangeId, "_"), credential);
                object credentialEnvName = ((string)fullKey).ToUpper(); // example: KRAKEN_APIKEY
                object credentialValue = ((bool) isTrue((((Dictionary<string,object>)envVars).ContainsKey(toStringOrNull(credentialEnvName))))) ? getValue(envVars, credentialEnvName) : null;
                if (isTrue(credentialValue))
                {
                    setExchangeProp(exchange, credential, credentialValue);
                }
            }
        }
        // skipped tests
        object skippedFile = add(rootDir, "skip-tests.json");
        object skippedSettings = ioFileRead(skippedFile);
        object skippedSettingsForExchange = exchange.safeValue(skippedSettings, exchangeId, new Dictionary<string, object>() {});
        // others
        object skipReason = exchange.safeValue(skippedSettingsForExchange, "skip");
        if (isTrue(!isEqual(skipReason, null)))
        {
            dump("[SKIPPED] exchange", exchangeId, skipReason);
            exitScript();
        }
        if (isTrue(exchange.alias))
        {
            dump("[SKIPPED] Alias exchange. ", "exchange", exchangeId, "symbol", symbol);
            exitScript();
        }
        //
        this.skippedMethods = exchange.safeValue(skippedSettingsForExchange, "skipMethods", new Dictionary<string, object>() {});
        this.checkedPublicTests = new Dictionary<string, object>() {};
    }

    public virtual object addPadding(object message, object size)
    {
        // has to be transpilable
        object res = "";
        object missingSpace = subtract(subtract(size, ((string)message).Length), 0); // - 0 is added just to trick transpile to treat the .length as a string for php
        if (isTrue(isGreaterThan(missingSpace, 0)))
        {
            for (object i = 0; isLessThan(i, missingSpace); postFixIncrement(ref i))
            {
                res = add(res, " ");
            }
        }
        return add(message, res);
    }

    public async virtual Task<object> testMethod(object methodName, Exchange exchange, object args, object isPublic)
    {
        object methodNameInTest = getTestName(methodName);
        // if this is a private test, and the implementation was already tested in public, then no need to re-test it in private test (exception is fetchCurrencies, because our approach in exchange)
        if (isTrue(isTrue(!isTrue(isPublic) && isTrue((((Dictionary<string,object>)this.checkedPublicTests).ContainsKey(toStringOrNull(methodNameInTest))))) && isTrue((!isEqual(methodName, "fetchCurrencies")))))
        {
            return null;
        }
        object skipMessage = null;
        object isFetchOhlcvEmulated = (isTrue(isEqual(methodName, "fetchOHLCV")) && isTrue(isEqual(getValue(exchange.has, "fetchOHLCV"), "emulated"))); // todo: remove emulation from base
        if (isTrue(isTrue(isTrue((!isEqual(methodName, "loadMarkets"))) && isTrue((!isTrue((((Dictionary<string,object>)exchange.has).ContainsKey(toStringOrNull(methodName)))) || !isTrue(getValue(exchange.has, methodName))))) || isTrue(isFetchOhlcvEmulated)))
        {
            skipMessage = "[INFO:UNSUPPORTED_TEST]"; // keep it aligned with the longest message
        } else if (isTrue(((Dictionary<string,object>)this.skippedMethods).ContainsKey(toStringOrNull(methodName))))
        {
            skipMessage = "[INFO:SKIPPED_TEST]";
        } else if (!isTrue((((Dictionary<string,object>)this.testFiles).ContainsKey(toStringOrNull(methodNameInTest)))))
        {
            skipMessage = "[INFO:UNIMPLEMENTED_TEST]";
        }
        if (isTrue(skipMessage))
        {
            if (isTrue(this.info))
            {
                dump(this.addPadding(skipMessage, 25), exchange.id, methodNameInTest);
            }
            return null;
        }
        object argsStringified = add(add("(", String.Join(",", ((List<object>)args).ToArray())), ")");
        if (isTrue(this.info))
        {
            dump(this.addPadding("[INFO:TESTING]", 25), exchange.id, methodNameInTest, argsStringified);
        }
        object result = null;
        try
        {
            result = await callMethod(this.testFiles, methodNameInTest, exchange, args);
            if (isTrue(isPublic))
            {
                ((Dictionary<string, object>)this.checkedPublicTests)[(string)methodNameInTest] = true;
            }
        } catch(Exception e)
        {
            object isAuthError = (e is AuthenticationError);
            if (!isTrue((isTrue(isPublic) && isTrue(isAuthError))))
            {
                dump("ERROR:", exceptionMessage(e), " | Exception from: ", exchange.id, methodNameInTest, argsStringified);
                throw e;
            }
        }
        return result;
    }

    public async virtual Task<object> testSafe(object methodName, Exchange exchange, object args, object isPublic)
    {
        try
        {
            await this.testMethod(methodName, exchange, args, isPublic);
            return true;
        } catch(Exception e)
        {
            return false;
        }
    }

    public async virtual Task runPublicTests(Exchange exchange, object symbol)
    {
        object tests = new Dictionary<string, object>() {
            { "loadMarkets", new List<object>() {} },
            { "fetchCurrencies", new List<object>() {} },
            { "fetchTicker", new List<object>() {symbol} },
            { "fetchTickers", new List<object>() {symbol} },
            { "fetchOHLCV", new List<object>() {symbol} },
            { "fetchTrades", new List<object>() {symbol} },
            { "fetchOrderBook", new List<object>() {symbol} },
            { "fetchL2OrderBook", new List<object>() {symbol} },
            { "fetchOrderBooks", new List<object>() {} },
            { "fetchBidsAsks", new List<object>() {} },
            { "fetchStatus", new List<object>() {} },
            { "fetchTime", new List<object>() {} },
        };
        object market = exchange.market(symbol);
        object isSpot = getValue(market, "spot");
        if (isTrue(isSpot))
        {
            ((Dictionary<string, object>)tests)["fetchCurrencies"] = new List<object>() {};
        } else
        {
            ((Dictionary<string, object>)tests)["fetchFundingRates"] = new List<object>() {symbol};
            ((Dictionary<string, object>)tests)["fetchFundingRate"] = new List<object>() {symbol};
            ((Dictionary<string, object>)tests)["fetchFundingRateHistory"] = new List<object>() {symbol};
            ((Dictionary<string, object>)tests)["fetchIndexOHLCV"] = new List<object>() {symbol};
            ((Dictionary<string, object>)tests)["fetchMarkOHLCV"] = new List<object>() {symbol};
            ((Dictionary<string, object>)tests)["fetchPremiumIndexOHLCV"] = new List<object>() {symbol};
        }
        this.publicTests = tests;
        object testNames = new List<object>(((Dictionary<string,object>)tests).Keys);
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(testNames)); postFixIncrement(ref i))
        {
            object testName = getValue(testNames, i);
            object testArgs = getValue(tests, testName);
            ((List<object>)promises).Add(this.testSafe(testName, exchange, testArgs, true));
        }
        // todo - not yet ready in other langs too
        // promises.push (testThrottle ());
        await promiseAll(promises);
        if (isTrue(this.info))
        {
            dump(this.addPadding("[INFO:PUBLIC_TESTS_DONE]", 25), exchange.id);
        }
    }

    public async virtual Task loadExchange(Exchange exchange)
    {
        await exchange.loadMarkets();
        assert(((exchange.markets).GetType() == typeof(Dictionary<string, object>)), ".markets is not an object");
        assert((exchange.symbols.GetType().IsGenericType && exchange.symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))), ".symbols is not an array");
        object symbolsLength = getArrayLength(exchange.symbols);
        object marketKeys = new List<object>(((Dictionary<string,object>)exchange.markets).Keys);
        object marketKeysLength = getArrayLength(marketKeys);
        assert(isGreaterThan(symbolsLength, 0), ".symbols count <= 0 (less than or equal to zero)");
        assert(isGreaterThan(marketKeysLength, 0), ".markets objects keys length <= 0 (less than or equal to zero)");
        assert(isEqual(symbolsLength, marketKeysLength), "number of .symbols is not equal to the number of .markets");
        object symbols = new List<object>() {"BTC/CNY", "BTC/USD", "BTC/USDT", "BTC/EUR", "BTC/ETH", "ETH/BTC", "BTC/JPY", "ETH/EUR", "ETH/JPY", "ETH/CNY", "ETH/USD", "LTC/CNY", "DASH/BTC", "DOGE/BTC", "BTC/AUD", "BTC/PLN", "USD/SLL", "BTC/RUB", "BTC/UAH", "LTC/BTC", "EUR/USD"};
        object resultSymbols = new List<object>() {};
        object exchangeSpecificSymbols = exchange.symbols;
        for (object i = 0; isLessThan(i, getArrayLength(exchangeSpecificSymbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(exchangeSpecificSymbols, i);
            if (isTrue(exchange.inArray(symbol, symbols)))
            {
                ((List<object>)resultSymbols).Add(symbol);
            }
        }
        object resultMsg = "";
        object resultLength = getArrayLength(resultSymbols);
        object exchangeSymbolsLength = getArrayLength(exchange.symbols);
        if (isTrue(isGreaterThan(resultLength, 0)))
        {
            if (isTrue(isGreaterThan(exchangeSymbolsLength, resultLength)))
            {
                resultMsg = add(String.Join(", ", ((List<object>)resultSymbols).ToArray()), " + more...");
            } else
            {
                resultMsg = String.Join(", ", ((List<object>)resultSymbols).ToArray());
            }
        }
        dump("Exchange loaded", exchangeSymbolsLength, "symbols", resultMsg);
    }

    public virtual object getTestSymbol(Exchange exchange, object isSpot, object symbols)
    {
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object s = getValue(symbols, i);
            object market = exchange.safeValue(exchange.markets, s);
            if (isTrue(!isEqual(market, null)))
            {
                object active = exchange.safeValue(market, "active");
                if (isTrue(isTrue(active) || isTrue((isEqual(active, null)))))
                {
                    symbol = s;
                    break;
                }
            }
        }
        return symbol;
    }

    public virtual object getExchangeCode(Exchange exchange, object codes = null)
    {
        if (isTrue(isEqual(codes, null)))
        {
            codes = new List<object>() {"BTC", "ETH", "XRP", "LTC", "BCH", "EOS", "BNB", "BSV", "USDT"};
        }
        object code = getValue(codes, 0);
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            if (isTrue(((Dictionary<string,object>)exchange.currencies).ContainsKey(toStringOrNull(getValue(codes, i)))))
            {
                return getValue(codes, i);
            }
        }
        return code;
    }

    public virtual object getMarketsFromExchange(Exchange exchange, object spot = null)
    {
        spot ??= true;
        object res = new Dictionary<string, object>() {};
        object markets = exchange.markets;
        object keys = new List<object>(((Dictionary<string,object>)markets).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object market = getValue(markets, key);
            if (isTrue(isTrue(spot) && isTrue(getValue(market, "spot"))))
            {
                ((Dictionary<string, object>)res)[(string)getValue(market, "symbol")] = market;
            } else if (isTrue(!isTrue(spot) && !isTrue(getValue(market, "spot"))))
            {
                ((Dictionary<string, object>)res)[(string)getValue(market, "symbol")] = market;
            }
        }
        return res;
    }

    public virtual object getValidSymbol(Exchange exchange, object spot = null)
    {
        spot ??= true;
        object currentTypeMarkets = this.getMarketsFromExchange(exchange, spot);
        object codes = new List<object>() {"BTC", "ETH", "XRP", "LTC", "BCH", "EOS", "BNB", "BSV", "USDT", "ATOM", "BAT", "BTG", "DASH", "DOGE", "ETC", "IOTA", "LSK", "MKR", "NEO", "PAX", "QTUM", "TRX", "TUSD", "USD", "USDC", "WAVES", "XEM", "XMR", "ZEC", "ZRX"};
        object spotSymbols = new List<object>() {"BTC/USD", "BTC/USDT", "BTC/CNY", "BTC/EUR", "BTC/ETH", "ETH/BTC", "ETH/USD", "ETH/USDT", "BTC/JPY", "LTC/BTC", "ZRX/WETH", "EUR/USD"};
        object swapSymbols = new List<object>() {"BTC/USDT:USDT", "BTC/USD:USD", "ETH/USDT:USDT", "ETH/USD:USD", "LTC/USDT:USDT", "DOGE/USDT:USDT", "ADA/USDT:USDT", "BTC/USD:BTC", "ETH/USD:ETH"};
        object targetSymbols = ((bool) isTrue(spot)) ? spotSymbols : swapSymbols;
        object symbol = this.getTestSymbol(exchange, spot, targetSymbols);
        // if symbols wasn't found from above hardcoded list, then try to locate any symbol which has our target hardcoded 'base' code
        if (isTrue(isEqual(symbol, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
            {
                object currentCode = getValue(codes, i);
                object marketsArrayForCurrentCode = exchange.filterBy(currentTypeMarkets, "base", currentCode);
                object indexedMkts = exchange.indexBy(marketsArrayForCurrentCode, "symbol");
                object symbolsArrayForCurrentCode = new List<object>(((Dictionary<string,object>)indexedMkts).Keys);
                object symbolsLength = getArrayLength(symbolsArrayForCurrentCode);
                if (isTrue(symbolsLength))
                {
                    symbol = this.getTestSymbol(exchange, spot, symbolsArrayForCurrentCode);
                    break;
                }
            }
        }
        // if there wasn't found any symbol with our hardcoded 'base' code, then just try to find symbols that are 'active'
        if (isTrue(isEqual(symbol, null)))
        {
            object activeMarkets = exchange.filterBy(currentTypeMarkets, "active", true);
            object activeSymbols = new List<object>(((Dictionary<string,object>)activeMarkets).Keys);
            symbol = this.getTestSymbol(exchange, spot, activeSymbols);
        }
        if (isTrue(isEqual(symbol, null)))
        {
            object values = new List<object>(((Dictionary<string,object>)currentTypeMarkets).Values);
            object first = getValue(values, 0);
            if (isTrue(!isEqual(first, null)))
            {
                symbol = getValue(first, "symbol");
            }
        }
        return symbol;
    }

    public async virtual Task testExchange(Exchange exchange, object providedSymbol = null)
    {
        object spotSymbol = null;
        object swapSymbol = null;
        if (isTrue(!isEqual(providedSymbol, null)))
        {
            object market = exchange.market(providedSymbol);
            if (isTrue(getValue(market, "spot")))
            {
                spotSymbol = providedSymbol;
            } else
            {
                swapSymbol = providedSymbol;
            }
        } else
        {
            if (isTrue(getValue(exchange.has, "spot")))
            {
                spotSymbol = this.getValidSymbol(exchange, true);
            }
            if (isTrue(getValue(exchange.has, "swap")))
            {
                swapSymbol = this.getValidSymbol(exchange, false);
            }
        }
        if (isTrue(!isEqual(spotSymbol, null)))
        {
            dump("Selected SPOT SYMBOL:", spotSymbol);
        }
        if (isTrue(!isEqual(swapSymbol, null)))
        {
            dump("Selected SWAP SYMBOL:", swapSymbol);
        }
        if (!isTrue(this.privateTestOnly))
        {
            if (isTrue(isTrue(getValue(exchange.has, "spot")) && isTrue(!isEqual(spotSymbol, null))))
            {
                if (isTrue(this.info))
                {
                    dump("[INFO:SPOT TESTS]");
                }
                ((Dictionary<string, object>)exchange.options)["type"] = "spot";
                await this.runPublicTests(exchange, spotSymbol);
            }
            if (isTrue(isTrue(getValue(exchange.has, "swap")) && isTrue(!isEqual(swapSymbol, null))))
            {
                if (isTrue(this.info))
                {
                    dump("[INFO:SWAP TESTS]");
                }
                ((Dictionary<string, object>)exchange.options)["type"] = "swap";
                await this.runPublicTests(exchange, swapSymbol);
            }
        }
        if (isTrue(isTrue(this.privateTest) || isTrue(this.privateTestOnly)))
        {
            if (isTrue(isTrue(getValue(exchange.has, "spot")) && isTrue(!isEqual(spotSymbol, null))))
            {
                ((Dictionary<string, object>)exchange.options)["defaultType"] = "spot";
                await this.runPrivateTests(exchange, spotSymbol);
            }
            if (isTrue(isTrue(getValue(exchange.has, "swap")) && isTrue(!isEqual(swapSymbol, null))))
            {
                ((Dictionary<string, object>)exchange.options)["defaultType"] = "swap";
                await this.runPrivateTests(exchange, swapSymbol);
            }
        }
    }

    public async virtual Task runPrivateTests(Exchange exchange, object symbol)
    {
        if (!isTrue(exchange.checkRequiredCredentials(false)))
        {
            dump("[Skipping private tests]", "Keys not found");
            return;
        }
        object code = this.getExchangeCode(exchange);
        // if (exchange.extendedTest) {
        //     await test ('InvalidNonce', exchange, symbol);
        //     await test ('OrderNotFound', exchange, symbol);
        //     await test ('InvalidOrder', exchange, symbol);
        //     await test ('InsufficientFunds', exchange, symbol, balance); // danger zone - won't execute with non-empty balance
        // }
        object tests = new Dictionary<string, object>() {
            { "signIn", new List<object>() {exchange} },
            { "fetchBalance", new List<object>() {exchange} },
            { "fetchAccounts", new List<object>() {exchange} },
            { "fetchTransactionFees", new List<object>() {exchange} },
            { "fetchTradingFees", new List<object>() {exchange} },
            { "fetchStatus", new List<object>() {exchange} },
            { "fetchOrders", new List<object>() {exchange, symbol} },
            { "fetchOpenOrders", new List<object>() {exchange, symbol} },
            { "fetchClosedOrders", new List<object>() {exchange, symbol} },
            { "fetchMyTrades", new List<object>() {exchange, symbol} },
            { "fetchLeverageTiers", new List<object>() {exchange, symbol} },
            { "fetchLedger", new List<object>() {exchange, code} },
            { "fetchTransactions", new List<object>() {exchange, code} },
            { "fetchDeposits", new List<object>() {exchange, code} },
            { "fetchWithdrawals", new List<object>() {exchange, code} },
            { "fetchBorrowRates", new List<object>() {exchange, code} },
            { "fetchBorrowRate", new List<object>() {exchange, code} },
            { "fetchBorrowInterest", new List<object>() {exchange, code, symbol} },
            { "addMargin", new List<object>() {exchange, symbol} },
            { "reduceMargin", new List<object>() {exchange, symbol} },
            { "setMargin", new List<object>() {exchange, symbol} },
            { "setMarginMode", new List<object>() {exchange, symbol} },
            { "setLeverage", new List<object>() {exchange, symbol} },
            { "cancelAllOrders", new List<object>() {exchange, symbol} },
            { "cancelOrder", new List<object>() {exchange, symbol} },
            { "cancelOrders", new List<object>() {exchange, symbol} },
            { "fetchCanceledOrders", new List<object>() {exchange, symbol} },
            { "fetchClosedOrder", new List<object>() {exchange, symbol} },
            { "fetchOpenOrder", new List<object>() {exchange, symbol} },
            { "fetchOrder", new List<object>() {exchange, symbol} },
            { "fetchOrderTrades", new List<object>() {exchange, symbol} },
            { "fetchPosition", new List<object>() {exchange, symbol} },
            { "fetchDeposit", new List<object>() {exchange, code} },
            { "createDepositAddress", new List<object>() {exchange, code} },
            { "fetchDepositAddress", new List<object>() {exchange, code} },
            { "fetchDepositAddresses", new List<object>() {exchange, code} },
            { "fetchDepositAddressesByNetwork", new List<object>() {exchange, code} },
            { "editOrder", new List<object>() {exchange, symbol} },
            { "fetchBorrowRateHistory", new List<object>() {exchange, symbol} },
            { "fetchBorrowRatesPerSymbol", new List<object>() {exchange, symbol} },
            { "fetchLedgerEntry", new List<object>() {exchange, code} },
            { "fetchWithdrawal", new List<object>() {exchange, code} },
            { "transfer", new List<object>() {exchange, code} },
            { "withdraw", new List<object>() {exchange, code} },
        };
        object market = exchange.market(symbol);
        object isSpot = getValue(market, "spot");
        if (isTrue(isSpot))
        {
            ((Dictionary<string, object>)tests)["fetchCurrencies"] = new List<object>() {exchange, symbol};
        } else
        {
            // derivatives only
            ((Dictionary<string, object>)tests)["fetchPositions"] = new List<object>() {exchange, new List<object>() {symbol}};
            ((Dictionary<string, object>)tests)["fetchPosition"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["fetchPositionRisk"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["setPositionMode"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["setMarginMode"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["fetchOpenInterestHistory"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["fetchFundingRateHistory"] = new List<object>() {exchange, symbol};
            ((Dictionary<string, object>)tests)["fetchFundingHistory"] = new List<object>() {exchange, symbol};
        }
        object combinedPublicPrivateTests = exchange.deepExtend(this.publicTests, tests);
        object testNames = new List<object>(((Dictionary<string,object>)combinedPublicPrivateTests).Keys);
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(testNames)); postFixIncrement(ref i))
        {
            object testName = getValue(testNames, i);
            object testArgs = getValue(combinedPublicPrivateTests, testName);
            ((List<object>)promises).Add(this.testSafe(testName, exchange, testArgs, false));
        }
        object results = await promiseAll(promises);
        object errors = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(testNames)); postFixIncrement(ref i))
        {
            object testName = getValue(testNames, i);
            object success = getValue(results, i);
            if (!isTrue(success))
            {
                ((List<object>)errors).Add(testName);
            }
        }
        if (isTrue(isGreaterThan(getArrayLength(errors), 0)))
        {
            throw new Exception ((string)add(add(add("Failed private tests [", getValue(market, "type")), "]: "), String.Join(", ", ((List<object>)errors).ToArray()))) ;
        } else
        {
            if (isTrue(this.info))
            {
                dump(this.addPadding("[INFO:PRIVATE_TESTS_DONE]", 25), exchange.id);
            }
        }
    }

    public async virtual Task startTest(Exchange exchange, object symbol)
    {
        // we don't need to test aliases
        if (isTrue(exchange.alias))
        {
            return;
        }
        if (isTrue(isTrue(this.sandbox) || isTrue(getExchangeProp(exchange, "sandbox"))))
        {
            exchange.setSandboxMode(true);
        }
        await this.loadExchange(exchange);
        await this.testExchange(exchange, symbol);
    }
}
