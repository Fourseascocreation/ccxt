# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
import hashlib
import datetime
import hmac
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import ROUND
import sys

reload(sys)
sys.setdefaultencoding('utf8')


class dragonex(Exchange):

    def describe(self):
        return self.deep_extend(super(dragonex, self).describe(), {
            'id': 'dragonex',
            'name': 'DragonEx',
            'countries': ['CN'],
            'rateLimit': 500,
            'certified': True,
            # new metainfo interface
            'has': {
                'fetchDepositAddress': True,
                'CORS': False,
                'fetchBidsAsks': True,
                'fetchTickers': True,
                'fetchOHLCV': True,
                'fetchMyTrades': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'withdraw': True,
                'fetchFundingFees': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
                'fetchTransactions': False,
            },
            'timeframes': {
                '1m': 1,
                '5m': 2,
                '15m': 3,
                '30m': 4,
                '1h': 5,
                '1d': 6,
            },
            'urls': {
                'logo': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAAwCAMAAACPMqDOAAAC6FBMVEUAAAD////////////////////////////////////////////8/Pz6xbH////////////////////////////////////////////////////369L/////////S0b/S0b/////S0b0ymr/S0b////////////vyWr/////////S0b54Iv81nL////////xyGn/S0btxm//S0bw0X/52X//6IL0w1b9/f3/S0b/////43/////83X3////30G//3nf////////844T////////////////83ID/S0b/S0btxmn+3nn/S0b/S0b/////S0b/////S0b84ojvxmv/S0buwF3jslTz0nXMnUr03Yj////z2YL////62n3ctmP/////S0bvz3r/S0b////////yznP82HP/5IT/64j52n7ouVn10XLMplT52nn////213fQpE//////S0b/S0b855Tak1zfxHOIWR3/S0bOmkP53oLu0H+cZyj+3Xz/S0bwzXO0fjT/S0b/S0bvx2mhbCz/S0b/S0bpu1j/S0bqxGn/S0b////22Ii1h0T/8JbyxV7yz3T71Wrjr03btl3JoVSrfDPasmbesFTht2Cyh0f545u2iEO+ml/mumb52XobICb74o3/S0a0gTr/S0b/S0b71HXqu1jcwID/9rXt0pLdpkj////NrnO7gjcbICbz3pHirk/44pKQZSnz5ZobICZ5WB//+7DouFaseDh4Vij//72vlFDSq2kbICb/////S0b/2nj/4oX/5In+1nH802//2HT/3nruwVjntlT/4oDyxWPsvVr/33/5z2vwxV3su1T/3Xb8zV/4yV66iDr/4nr2zWTRqVb/6Iv+2W3dq07SoUj/32/+0Wjwv1uebC3p0YP/6Hn01HLsym3pwGPiuWDjtVnOoEzHmEjEk0L/7Yr/1mbdslnOmkCtejSjciv64Ij71YLouXDksU+1gjWWZin/9aT31o4bICbNHC3fAAAAvnRSTlMAKZONDLBFwu1A9i2HBLT9MRwHvJZSIxTnTRcC3MC7k3dO/vnx2MvGnpCLd2dmXzsyIRwZDv7+/Ofi1sbFuK2qopqKbUg8NS0pD/r02tLQxaqoo6KgmJeRjIN7X1hRTz44KBQSEP7s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',
                'api': {
                    'public': 'https://openapi.dragonex.co/api/v1',
                    'private': 'https://openapi.dragonex.co',
                    'v1': 'https://openapi.dragonex.co/api/v1',
                    'aicoin': 'https://openapi.dragonex.co/api/aicoin',
                    'pal': 'https://openapi.dragonex.co/api/aicoin',
                },
                'www': 'https://dragonex.co',
                'referral': 'https://dragonex.co/account/register?inviteId=1248302',
                'doc': 'https://github.com/Dragonexio/OpenApi/blob/master/docs/English/1.interface_document_v1.md',
                'fees': 'https://dragonex.zendesk.com/hc/en-us/articles/115002431171-Fee',
            },
            'api': {
                'v1': {
                    'get': [
                        'market/kline/',  # 获取K线数据
                        'market/buy/',  # 获取买盘
                        'market/sell/',  # 获取卖盘
                        'market/real/',  # 获取实时行情
                        'market/depth/',  # 获取market depth数据
                    ],
                },
                'aicoin': {
                    'get': [
                        'market/real/',  # 获取实时行情
                        'market/all_trade/',  # 获取某币种的交易记录
                        'market/buy_sell/',  # 获取买卖盘
                    ]
                },
                'pal': {
                    'get': '/coin/',  # 获取某币种平均价格信息
                },
                'public': {
                    'get': [
                        'symbol/all/',  # 查询系统支持的所有交易对
                        'symbol/all2/',
                        'symbol/all3/',
                        'coin/all/',  # 查询系统支持的所有币种
                    ],
                },
                'private': {
                    'get': [
                        'user/own/',
                    ],
                    'post': [
                        'api/v1/token/new/',
                        'api/v1/token/status/',
                        'api/v1/user/own/',
                        'api/v1/user/fee/',
                        'api/v1/order/buy/',
                        'api/v1/order/sell/',
                        'api/v1/order/cancel/',
                        'api/v1/order/add/',
                        'api/v1/order/detail/',
                        'api/v1/order/detail2/',
                        'api/v1/order/history/',
                        'api/v1/order/history2/',
                        'api/v1/deal/history/',
                        'api/v1/user/detail/',
                        'api/pal/coin/withdraw/',
                        'api/v1/coin/withdraw/new/',
                        'api/v1/coin/prepay/history/',
                        'api/v1/coin/prepay/addr/',
                        'api/v1/coin/withdraw/history/'
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.002,
                    'taker': 0.002,
                },
            },
            'exceptions': {
                # English
                # see https://github.com/Dragonexio/OpenApi/blob/master/docs/English/2.%20error_codes.md
                # Chinese
                # https://github.com/Dragonexio/OpenApi/blob/master/docs/%E4%B8%AD%E6%96%87/2.%20error_codes.md
                "1": "ok",
                "2": "Time Out",
                "3": "Network Error",
                "4": "Database Error",
                "5": "Cache Error",
                "6": "Server Error",
                "7": "No Content",
                "8": "Parameter Error",
                "5001": "PriceLessThanLimit",
                "5002": "VolumeLessThanLimit",
                "5003": "MakeOrderIDFailed",
                "5004": "DuplicateOrder",
                "5005": "SellLessThanBuy",
                "5006": "BuyGreaterThanSell",
                "5007": "NotFindOrder",
                "5008": "OrderCanceled",
                "5009": "WriteTradeFailed",
                "5010": "WrongPrice",
                "5011": "WrongAmount",
                "5012": "WrongUserID",
                "5013": "OrderDone",
                "5014": "OrderFailed",
                "5015": "OrderNonTradable",
                "5016": "AmountLessThanLimit",
                "5017": "NewOrderDisabled",
                "5018": "CancelOrderDisabled",
                "5019": "TriggerPriceEqualClosePrice",
                "5020": "OrderCountGreaterThanLimit",
                "9001": "Key Already Exists",
                "9002": "Key Not Exists",
                "9003": "Invalid key",
                "9004": "Signature Error",
                "9005": "Invalid Token",
                "9006": "Token Expires",
                "9007": "Invalid User Credential",
                "9008": "Frequent Operations",
                "9009": "IP Disabled",
                "9010": "Key Creation Fails",
                "9011": "Unauthorized",
                "9014": "Frequent Operations",
                "9015": "Not in Binded IP",
                "9016": "Exceed Maximum Times of Request Allowed in A Single Day",
                "9017": "Fail to Obtain New Token",
                "9018": "Key Expires",
                "9019": "Date Field not Found in Headers",
                "9020": "Improper Date Field Found in Headers",
                "9021": "Incoming Time not within 15 Minutes",
                "9022": "Token Kicked Off",
            },
            'options': {
                'change_quote': {
                    "USDT": "USD"
                },
                'order_type': {
                    "0": "_",
                    "1": "Buy",
                    "2": "Sell"
                }
            },
        })

    def fetch_markets(self, params={}):
        respon = self.publicGetSymbolAll2()
        markets_dict = self.safe_value(respon, "data", {})
        markets = self.safe_value(markets_dict, "list", [])
        data = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = market[1]
            parts = id.split("_")
            baseId = parts[0]
            quoteId = parts[1]
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            precision = {
                'amount': market[7],
                'price': market[5],
            }
            taker = self.fees['trading']['taker']
            symbol = base + '/' + quote
            data_dict = {
                "id": id,
                "symbol": symbol,
                "symbol_id": market[0],
                "base": base,
                "quote": quote,
                "baseId": baseId,
                "quoteId": quoteId,
                "active": True,
                "precision": precision,
                "taker": taker,
                "limits": {
                    "amount": {
                        "min": market[4],
                        "max": None
                    },
                    "price": {
                        "min": market[2],
                        "max": None
                    },
                    "cost": {
                        "min": float(market[4]) * float(market[2]),
                        "max": None
                    }
                }

            }
            data.append(data_dict)
        return data

    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        market = self.markets[symbol]
        key = 'quote'
        rate = market[takerOrMaker]
        cost = amount * rate
        precision = market['precision']['price']
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
            precision = market['precision']['amount']
        cost = self.decimal_to_precision(cost, ROUND, precision, self.precisionMode)
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': float(cost),
        }

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privatePostUserOwn(params)
        result = {'info': response}
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = balance['coin_id']
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_float(balance, 'volume') - self.safe_float(balance, 'frozen')
            account['used'] = self.safe_float(balance, 'frozen')
            account['total'] = self.safe_float(balance, 'volume')
            result[code] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market['symbol_id'],
        }
        if limit is not None:
            request['limit'] = limit  # default = maximum = 100
        response = self.v1GetMarketDepth(self.extend(request, params))
        orderbook = self.parse_order_book(response)
        orderbook['bids'] = [[i.get("price", 0), i.get("volume", 0)] for i in
                             self.safe_value(response, "data", {}).get("buys", [])]
        orderbook['asks'] = [[i.get("price", 0), i.get("volume", 0)] for i in
                             self.safe_value(response, "data", {}).get("sells", [])]
        return orderbook

    def parse_ticker(self, ticker, market=None):
        ticker = self.safe_value(ticker, "data", {}).get("list", [])[0]
        timestamp = ticker[-1]
        last = float(ticker[3])
        return {
            'symbol': market.get("symbol", ""),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': ticker[4],
            'low': ticker[5],
            'bid': ticker[6],
            'bidVolume': None,
            'ask': ticker[7],
            'askVolume': None,
            'vwap': None,
            'open': ticker[2],
            'close': last,
            'last': last,
            'previousClose': None,  # previous day close
            'change': ticker[8],
            'percentage': ticker[9],
            'average': (last + float(ticker[2])) / 2,
            'baseVolume': ticker[-4],
            'quoteVolume': None,
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_ids': market['symbol_id'],
        }
        response = self.aicoinGetMarketReal(self.extend(request, params))
        return self.parse_ticker(response, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        symbol_list = symbols.split(",")
        symbol_id_list = []
        for symbol in symbol_list:
            symbol_id_list.append(str(self.market(symbol.replace(" ", "")).get("symbol_id", "")))
        symbol_id_str = ','.join(symbol_id_list)
        request = {
            "symbol_ids": symbol_id_str
        }
        response = self.aicoinGetMarketReal(self.extend(request, params))
        return response

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            ohlcv[-3],
            float(ohlcv[4]),
            float(ohlcv[2]),
            float(ohlcv[3]),
            float(ohlcv[1]),
            float(ohlcv[-1]),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market['symbol_id'],
            'kline_type': self.timeframes[timeframe],
        }
        if since is not None:
            request['st'] = since
        if limit is not None:
            request['count'] = limit  # default == max == 500
        response = self.v1GetMarketKline(self.extend(request, params))
        return self.parse_ohlcvs(self.safe_value(response, "data").get("lists", []), market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_string(trade, 'timestamp')
        order = None
        side = None
        type = self.safe_string(trade, 'order_type')
        if type is not None:
            type = self.options["order_type"][type]
        price = self.safe_float(trade, 'deal_price')
        amount = self.safe_float(trade, 'deal_volume')
        cost = None
        if price is not None:
            if amount is not None:
                cost = amount * price
        fee = None
        feeCost = self.safe_float(trade, 'charge')
        feeCurrency = None
        if feeCost is not None:
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        id = self.safe_string(trade, 'id')
        return {
            'id': id,
            'info': trade,
            'order': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market['symbol_id'],
        }
        if limit is not None:
            request['count'] = limit
        response = self.aicoinGetMarketAllTrade(self.extend(request, params))
        data = self.safe_value(response, 'data').get("list", [])
        result = []
        for trades in data:
            data_dict = {
                "symbol_id": trades[0],
                "order_type": trades[1],
                "deal_type": trades[2],
                "deal_price": trades[3],
                "deal_volume": trades[4],
                "charge": trades[5],
                "price_base": trades[6],
                "usdt_amount": trades[7],
                "timestamp": trades[8]
            }
            trade = self.parse_trade(data_dict, market)
            result.append(trade)
        result = self.sort_by(result, 'timestamp')
        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    def parse_order_status(self, status):
        statuses = {
            '0': 'Any',
            '1': 'Waiting',  # 等待成交
            '2': 'Done',  # 完成， 完全提交
            '3': 'Canceled',  # 取消+没有成交量
            '4': 'Failed',  # 失败
            '5': 'Cancelling',  # 正在取消订单
            '6': 'Partially_Filled',  # 部分成交+等待成交
            '7': 'Partially_Canceled'  # 部分成交+已撤销
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        status = self.parse_order_status(self.safe_value(order, 'status'))
        symbol = market["symbol"]
        timestamp = self.safe_value(order, "timestamp") / 1000000
        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'volume')
        filled = self.safe_float(order, 'trade_volume', 0)
        remaining = None
        average = None
        cost = self.safe_float(order, 'actual_amount', 0)
        if filled is not None:
            if amount is not None:
                remaining = amount - filled
                remaining = max(remaining, 0.0)
            if price is not None:
                if cost is None:
                    cost = price * filled
            if (cost is not None) and (filled > 0):
                average = cost / filled
        id = self.safe_string(order, 'order_id')
        side = self.safe_value(order, 'order_type', "0")
        side = self.options.get("order_type", {}).get(side, "")
        feeCost = self.safe_float(order, 'actual_fee', 0)  # typo in their API, filled fees
        fee = None
        if feeCost is not None:
            feeCurrency = None
            if market is not None:
                feeCurrency = market['quote'] if (side == 'sell') else market['base']
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': "market",
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market["symbol_id"],
            'volume': self.amount_to_precision(symbol, amount),
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        if side == "buy":
            response = self.privatePostApiV1OrderBuy(self.extend(request, params))
        if side == "sell":
            response = self.privatePostApiV1OrderSell(self.extend(request, params))
        timestamp = self.milliseconds()
        print self.safe_value(response, "msg"), self.safe_value(response, "code")
        data = self.safe_value(response, 'data', {})
        print data
        return {
            'info': response,
            'id': data.get("order_id", ""),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
        }

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market['symbol_id'],
            "order_id": id,
        }
        response = self.privatePostApiV1OrderDetail(self.extend(request, params))
        response_dict = self.safe_value(response, "data", {})
        return self.parse_order(response_dict, market)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrders requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        print params
        request = {
            'symbol_id': market['symbol_id'],
            'statuses': params.get("statuses", "")
        }
        if since is not None:
            request['start'] = since
        if limit is not None:
            request['count'] = limit
        response = self.privatePostApiV1OrderHistory2(self.extend(request, params))
        print response
        data = self.safe_value(response, "data", {}).get("list", [])
        return self.parse_orders(data, market=market, since=since, limit=limit, params=params)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        request = {
            'statuses': "2",
        }
        return self.fetch_orders(symbol, since, limit, self.extend(request, params))

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        request = {
            'statuses': "3",
        }
        return self.fetch_orders(symbol, since, limit, self.extend(request, params))

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol_id': market['symbol_id'],
            'order_id': id,
        }
        response = self.privatePostApiV1OrderCancel(self.extend(request, params))
        response = self.safe_value(response, "data")
        if not response:
            raise OrderNotFound(self.id + ' cancelOrder() error ' + self.last_http_response)
        return self.parse_order(response, market)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        request = {}
        coin_res = self.publicGetCoinAll()
        coin_list = self.safe_value(coin_res, "data", [])
        coin_dict = {}
        coin_id_to_coin_code = {}
        for i in coin_list:
            coin_dict[i.get("code", "")] = i.get("coin_id", 0)
            coin_id_to_coin_code[i.get("coin_id", 0)] = i.get("code", 0)
        if code is not None:
            coin_id = coin_dict[code]
            request['coin_id'] = coin_id
        response = self.privatePostApiV1CoinPrepayHistory(self.extend(request, params))
        return self.parseTransactions(response.get('data', {}).get('list', []), currency, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        request = {}
        coin_res = self.publicGetCoinAll()
        coin_list = self.safe_value(coin_res, "data", [])
        coin_dict = {}
        coin_id_to_coin_code = {}
        for i in coin_list:
            coin_dict[i.get("code", "")] = i.get("coin_id", 0)
            coin_id_to_coin_code[i.get("coin_id", 0)] = i.get("code", 0)
        if code is not None:
            coin_id = coin_dict[code]
            request['coin_id'] = coin_id
        response = self.privatePostApiV1CoinWithdrawHistory(self.extend(request, params))
        return self.parseTransactions(response.get('data', {}).get('list', []), currency, since, limit)

    def parse_transaction_status_by_type(self, status, type=None):
        if type is None:
            return status
        statuses = {
            'deposit': {
                '1': 'pending',
                '2': 'entering',
                '3': 'ok',
                '4': 'failed',
            },
            'withdrawal': {
                '1': 'pending',
                '2': 'entering',
                '3': 'ok',
                '4': 'failed',
                '5': 'not approved',
            },
        }
        return statuses[type][status] if (status in list(statuses[type].keys())) else status

    def parse_transaction(self, transaction, currency=None):
        prepay_id = self.safe_string(transaction, 'prepay_id')
        withdraw_id = self.safe_string(transaction, 'withdraw_id')
        if prepay_id:
            id = prepay_id
        else:
            id = withdraw_id
        address = self.safe_string(transaction, 'addr')
        tag = self.safe_string(transaction, 'tag')  # set but unused
        if tag is not None:
            if len(tag) < 1:
                tag = None
        txid = self.safe_value(transaction, 'tx_id')
        currencyId = self.safe_string(transaction, 'coin_id')
        coin_res = self.publicGetCoinAll()
        coin_list = self.safe_value(coin_res, "data", [])
        coin_dict = {}
        for i in coin_list:
            coin_dict[i.get("coin_id", 0)] = i.get("code", '')
        code = coin_dict[int(currencyId)]
        timestamp = None
        insertTime = None
        applyTime = None
        if prepay_id:
            insertTime = self.safe_integer(transaction, 'arrive_time')
        if withdraw_id:
            applyTime = self.safe_integer(transaction, 'arrive_time')
        type = self.safe_string(transaction, 'type')
        if type is None:
            if (insertTime is not None) and (applyTime is None):
                type = 'deposit'
                timestamp = insertTime
            elif (insertTime is None) and (applyTime is not None):
                type = 'withdrawal'
                timestamp = applyTime
        status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'), type)
        amount = self.safe_float(transaction, 'volume')
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': None,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        coin_res = self.publicGetCoinAll()
        coin_list = self.safe_value(coin_res, "data", [])
        coin_dict = {}
        request = {}
        for i in coin_list:
            coin_dict[i.get("code", "")] = i.get("coin_id", 0)
        if code is not None:
            coin_id = coin_dict[code]
            request['coin_id'] = coin_id
        response = self.privatePostApiV1CoinPrepayAddr(self.extend(request, params))
        success = self.safe_value(response, 'ok')
        if (success is None) or not success:
            raise InvalidAddress(
                self.id + ' fetchDepositAddress returned an empty response – create the deposit address in the user settings first.')
        address = self.safe_string(response.get('data', {}), 'addr')
        tag = self.safe_string(response.get('data', {}), 'tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': self.check_address(address),
            'tag': tag,
            'info': response,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        coin_res = self.publicGetCoinAll()
        coin_list = self.safe_value(coin_res, "data", [])
        coin_dict = {}
        for i in coin_list:
            coin_dict[i.get("code", "")] = i.get("coin_id", 0)
        request = {
            'coin_id': coin_dict.get(code, 0),
            'addr': address,
            'volume': float(amount),
        }
        if tag is not None:
            request['addressTag'] = tag
        print request
        response = self.privatePostApiV1CoinWithdrawNew(self.extend(request, params))
        print response
        print self.safe_value(response, "msg", "")
        response = self.safe_value(response, "data", {})
        return {
            'info': response,
            'id': self.safe_string(response, 'withdraw_id'),
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        request = '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if method == 'GET':
            if query:
                request += '?' + self.urlencode(query)
        url = self.urls['api'][api] + request
        body = json.dumps({})
        if api == 'private':
            self.check_required_credentials()
            if method != 'GET':
                if query:
                    body = self.json(query)
            gmt_format = '%a, %d %b %Y %H:%M:%S GMT'
            date = datetime.datetime.utcnow().strftime(gmt_format)
            content_md5 = ""
            content_type = "application/json"
            canonicalized_headers = ""
            ip = params.get("bind_ip", "0.0.0.0")
            if headers:
                date = headers.get("date", datetime.datetime.utcnow().strftime(gmt_format))
                content_md5 = headers.get("content-md5", "")
                content_type = headers.get("content-type", "")
                dragonex_headers = ['{}:{}'.format(k, v) for k, v in headers.items() if k.startswith('dragonex-')]
                dragonex_headers.sort()
                canonicalized_headers = '' if not dragonex_headers else '\n'.join(dragonex_headers) + '\n'
            str_to_sign = '\n'.join([method.upper(), content_md5, content_type, date, canonicalized_headers])
            str_to_sign += request
            h = hmac.new(bytes(self.secret), bytes(str_to_sign), digestmod=hashlib.sha1).digest()
            signature = base64.b64encode(h).decode('utf-8')
            auth = '{}:{}'.format(self.apiKey, signature)
            headers = {
                "Content-Sha1": content_md5,
                "Date": date,
                'Content-Type': content_type,
                "X-Real-IP-Proxy": ip,
                "Auth": auth,
            }
            str_to_token_sign = '\n'.join(
                [method.upper(), content_md5, content_type, date, canonicalized_headers]) + "/api/v1/token/new/"
            h_token = hmac.new(bytes(self.secret), bytes(str_to_token_sign), digestmod=hashlib.sha1).digest()
            token_sign = base64.b64encode(h_token).decode('utf-8')
            auth_token = '{}:{}'.format(self.apiKey, token_sign)
            token_header = {
                "Content-Sha1": content_md5,
                "Date": date,
                'Content-Type': content_type,
                "X-Real-IP-Proxy": ip,
                "Auth": auth_token,
            }
            res = self.fetch("https://openapi.dragonex.co/api/v1/token/new/", method="POST", headers=token_header)
            token = self.safe_value(res, "data", {}).get("token", "")
            headers.update({"token": token})
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if 'msg' in response:
            msg = self.safe_string(response, 'msg')
            if msg:
                raise ExchangeError(msg)
