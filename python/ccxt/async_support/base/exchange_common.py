# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import NullResponse
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported


def handle_market_type_and_params(self, methodName, market=None, params={}):
    defaultType = self.safe_string_2(self.options, 'defaultType', 'type', 'spot')
    methodOptions = self.safe_value(self.options, methodName)
    methodType = defaultType
    if methodOptions is not None:
        if isinstance(methodOptions, str):
            methodType = methodOptions
        else:
            methodType = self.safe_string_2(methodOptions, 'defaultType', 'type', methodType)
    marketType = methodType if (market is None) else market['type']
    type = self.safe_string_2(params, 'defaultType', 'type', marketType)
    params = self.omit(params, ['defaultType', 'type'])
    return [type, params]


def handle_withdraw_tag_and_params(self, tag, params):
    if isinstance(tag, dict):
        params = self.extend(tag, params)
        tag = None
    if tag is None:
        tag = self.safe_string(params, 'tag')
        if tag is not None:
            params = self.omit(params, 'tag')
    return [tag, params]


async def fetch_funding_rate(self, symbol, params={}):
    if self.has['fetchFundingRates']:
        market = await self.market(symbol)
        if not market['contract']:
            raise BadSymbol(self.id + ' fetchFundingRate() supports contract markets only')
        rates = await self.fetchFundingRates([symbol], params)
        rate = self.safe_value(rates, symbol)
        if rate is None:
            raise NullResponse(self.id + ' fetchFundingRate() returned no data for ' + symbol)
        else:
            return rate
    else:
        raise NotSupported(self.id + ' fetchFundingRate() is not supported yet')


async def fetch_mark_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :returns [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchMarkOHLCV']:
        request = {
            'price': 'mark',
        }
        return await self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchMarkOHLCV() is not supported yet')


async def fetch_index_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical index price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :returns [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchIndexOHLCV']:
        request = {
            'price': 'index',
        }
        return await self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchIndexOHLCV() is not supported yet')


async def fetch_premium_index_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :return [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchPremiumIndexOHLCV']:
        request = {
            'price': 'premiumIndex',
        }
        return await self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchPremiumIndexOHLCV() is not supported yet')


def is_post_only(self, isMarketOrder, exchangeSpecificParam, params={}):
    """
     * @ignore
    :param string type: Order type
    :param boolean exchangeSpecificParam: exchange specific postOnly
    :param dict params: exchange specific params
    :returns boolean: True if a post only order, False otherwise
    """
    timeInForce = self.safe_string_upper(params, 'timeInForce')
    postOnly = self.safe_value_2(params, 'postOnly', 'post_only', False)
    # we assume timeInForce is uppercase from safeStringUpper(params, 'timeInForce')
    ioc = timeInForce == 'IOC'
    fok = timeInForce == 'FOK'
    timeInForcePostOnly = timeInForce == 'PO'
    postOnly = postOnly or timeInForcePostOnly or exchangeSpecificParam
    if postOnly:
        if ioc or fok:
            raise InvalidOrder(self.id + ' postOnly orders cannot have timeInForce equal to ' + timeInForce)
        elif isMarketOrder:
            raise InvalidOrder(self.id + ' market orders cannot be postOnly')
        else:
            return True
    else:
        return False


async def load_time_difference(self, params={}):
    serverTime = await self.fetchTime(params)
    after = self.milliseconds()
    self.options['timeDifference'] = after - serverTime
    return self.options['timeDifference']


def check_order_arguments(self, market, type, side, amount, price, params):
    if price is None:
        if type == 'limit':
            raise ArgumentsRequired(self.id + ' createOrder() requires a price argument for a limit order')
    if amount <= 0:
        raise ArgumentsRequired(self.id + ' createOrder() amount should be above 0')


def parse_borrow_interests(self, response, market=None):
    interest = []
    for i in range(0, len(response)):
        row = response[i]
        interest.append(self.parseBorrowInterest(row, market))
    return interest


def parse_funding_rate_histories(self, response, market=None, since=None, limit=None):
    rates = []
    for i in range(0, len(response)):
        entry = response[i]
        rates.append(self.parseFundingRateHistory(entry, market))
    sorted = self.sort_by(rates, 'timestamp')
    symbol = None if (market is None) else market['symbol']
    return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)


def parse_open_interests(self, response, market=None, since=None, limit=None):
    interests = []
    for i in range(0, len(response)):
        entry = response[i]
        interest = self.parseOpenInterest(entry, market)
        interests.append(interest)
    sorted = self.sort_by(interests, 'timestamp')
    symbol = self.safe_string(market, 'symbol')
    return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)
