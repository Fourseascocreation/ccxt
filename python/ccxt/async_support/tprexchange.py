# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS


class tprexchange(Exchange):

    def describe(self):
        return self.deep_extend(super(tprexchange, self).describe(), {
            'id': 'tprexchange',
            'name': 'TPR Exchange',
            # 'countries': ['US'],
            # 'rateLimit': 500,
            'version': 'v1',
            'certified': False,
            'has': {
                'loadMarkets': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'CORS': False,
                'createDepositAddress': False,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'createOrder': True,
                'deposit': False,
                'editOrder': 'emulated',
                'fetchBalance': False,
                'fetchBidsAsks': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': 'emulated',
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': False,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchOrderTrades': False,
                'fetchStatus': 'emulated',
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'privateAPI': True,
                'publicAPI': False,
                'signIn': True,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
            },
            'urls': {
                'logo': '',
                'api': '{hostname}',
                'www': '',
                'doc': '',
                'fees': '',
                'referral': '',
            },
            'api': {
                'private': {
                    'get': [
                        'detail/detail/{id}',
                        'order/history',
                        'order/add',
                    ],
                    'post': [
                        'uc/api-login',
                    ],
                    'delete': [
                        'order/cancel/{id}',
                    ],
                },
                'feed': {
                    'get': [
                    ],
                },
            },
            'fees': {
                'trading': {
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': False,
            },
            'precisionMode': SIGNIFICANT_DIGITS,
            'options': {
                'createMarketBuyOrderRequiresPrice': False,
            },
            'exceptions': {
                'exact': {
                    'Invalid cost': InvalidOrder,  # {"message":"Invalid cost","_links":{"self":{"href":"/orders","templated":false}}}
                    'Invalid order ID': InvalidOrder,  # {"message":"Invalid order ID","_links":{"self":{"href":"/orders/4a151805-d594-4a96-9d64-e3984f2441f7","templated":false}}}
                    'Invalid market !': BadSymbol,  # {"message":"Invalid market !","_links":{"self":{"href":"/markets/300/order-book","templated":false}}}
                },
                'broad': {
                    'Failed to convert argument': BadRequest,
                },
            },
        })

    async def fetch_markets(self, params={}):
        return [
            {
                'id': 'TPR',
                'symbol': 'TPR/USD',
                'base': 'TPR',
                'quote': 'USD',
                'baseId': 'TPR',
                'quoteId': 'USD',
                'type': 'spot',
                'active': True,
                'precision': {
                    'amount': None,
                    'price': None,
                },
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                },
                'taker': '0.005',
                'maker': '0.0025',
                'info': 'TPR Market',
            },
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=1000, params={}):
        return []

    async def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        # Check existance of authentication token
        # Just use empy one in case of an application is not signed in yet
        authToken = ''
        if 'token' in self.options:
            authToken = self.options['token']
        # Get URL
        url = self.implode_params(self.urls['api'], {'hostname': self.hostname}) + '/' + path
        # Calculate body and content type depending on method type: GET or POST
        keys = list(params.keys())
        keysLength = len(keys)
        # In case of body is still not assigned just make it empty string
        if body is None:
            body = ''
        # Prepare line for hashing
        # This hash sum is checked on backend side to verify API user
        # POST params should not be added as body
        query = method + ' /' + path + ' ' + self.urlencode(params) + ' ' + authToken + '\n' + body
        signed = self.hmac(self.encode(query), self.encode(self.secret))
        contentType = ''
        if method == 'POST':
            contentType = 'application/x-www-form-urlencoded'
            if keysLength > 0:
                body = self.urlencode(params)
        else:
            if keysLength > 0:
                url += '?' + self.urlencode(params)
        headers = {
            'x-auth-token': authToken,
            'x-auth-sign': signed,
            'Content-Type': contentType,
        }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def sign_in(self, params={}):
        params = {
            'key': self.key,
            'token': self.token,
        }
        response = await self.privatePostUcApiLogin(params)
        authToken = self.safe_string(response, 'message')
        self.options['token'] = authToken
        return authToken

    async def fetch_order(self, id, symbol=None, params={}):
        request = {
            'id': id,
        }
        response = await self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response)

    def parse_order(self, order, market=None):
        return {}

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        request = {}
        query = ''
        response = await self.privatePostOrders(self.extend(request, query))
        return self.parse_order(response)

    async def cancel_order(self, id, symbol=None, params={}):
        request = {
            'id': id,
        }
        return await self.privateDeleteOrdersId(self.extend(request, params))

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if httpCode == 200:
            return
        # {
        #     "message": "Error text in case when HTTP code is not 200",
        #     ...
        # }
        message = self.safe_string(response, 'message')
        if message is not None:
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
