# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS

import json
import sys
from datetime import datetime


class tprexchange(Exchange):

    def describe(self):
        return self.deep_extend(super(tprexchange, self).describe(), {
            'id': 'tprexchange',
            'name': 'TPR Exchange',
            # 'countries': ['US'],
            # 'rateLimit': 500,
            'version': 'v1',
            'certified': False,
            'has': {
                'loadMarkets': True,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'CORS': False,
                'createDepositAddress': False,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'createOrder': True,
                'deposit': False,
                'editOrder': 'emulated',
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': 'emulated',
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': False,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchOrderTrades': False,
                'fetchStatus': True,
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'privateAPI': True,
                'publicAPI': False,
                'signIn': True,
                'withdraw': False,
                'getMarketPrice': True,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
            },
            'urls': {
                'logo': '',
                'api': '{hostname}',
                'www': '',
                'doc': '',
                'fees': '',
                'referral': '',
            },
            'api': {
                'private': {
                    'get': [
                    ],
                    'post': [
                        'uc/api-login',
                        'uc/member/balance',
                        'market/symbol-thumb',
                        'market/coins-info',
                        'market/symbol-info',
                        'exchange/order/add',
                        'exchange/order/find',
                        'exchange/order/all',
                        'exchange/order/apicancel',
                        'exchange/order/trades',
                        'exchange/order/my-trades',
                        'exchange/exchange-coin/base-symbol',
                    ],
                    'delete': [
                    ],
                },
                'feed': {
                    'get': [
                    ],
                },
            },
            'fees': {
                'trading': {
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': False,
            },
            'precisionMode': SIGNIFICANT_DIGITS,
            'options': {
                'createMarketBuyOrderRequiresPrice': False,
            },
            'exceptions': {
                'exact': {
                    'Invalid cost': InvalidOrder,  # {"message":"Invalid cost","_links":{"self":{"href":"/orders","templated":false}}}
                    'Invalid order ID': InvalidOrder,  # {"message":"Invalid order ID","_links":{"self":{"href":"/orders/4a151805-d594-4a96-9d64-e3984f2441f7","templated":false}}}
                    'Invalid market !': BadSymbol,  # {"message":"Invalid market !","_links":{"self":{"href":"/markets/300/order-book","templated":false}}}
                },
                'broad': {
                    'Failed to convert argument': BadRequest,
                },
            },
        })

    def parse_markets(self, response):
        listData = []
        for value in response:
            tmp = {
            "id": value.get("coinSymbol"),
            "symbol": value.get("symbol"),
            "base": value.get("coinSymbol"),
            "quote": value.get("baseSymbol"),
            "baseId": value.get("coinSymbol"),
            "quoteId": value.get("baseSymbol"),
            "type": value.get("publishType"),
            "active": value.get("enable"),
            "precision": {
                "amount": value.get("coinScale"),
                "price": value.get("baseCoinScale"),
                },
            "limits": {
                "amount": {"min": value.get("minVolume"), "max": value.get("maxVolume")},
                "price": {"min": value.get("minSellPrice"), "max": value.get("maxBuyPrice")},
                "cost": {"min": value.get("minVolume") * value.get("minSellPrice"), "max": value.get("maxVolume") * value.get("maxBuyPrice")},
                },
            "taker": value.get("fee"),
            "maker": value.get("fee"),
            "info": value,
            }
            listData.append(tmp)
        return listData
        
    def fetch_markets(self, symbol=''):
        request = {
            'symbol': symbol,
        }
        response = self.privatePostMarketSymbolInfo(request)
        return self.parse_markets(response)
        # RETURN EXAMPLE:
        # [
        #     {
        #         'id': 'BTC', 
        #         'symbol': 'BTC/USDT', 
        #         'base': 'BTC', 
        #         'quote': 'USDT', 
        #         'baseId': 'BTC', 
        #         'quoteId': 'USDT', 
        #         'type': 'NONE', 
        #         'active': 1, 
        #         'precision': { 'amount': 2, 'price': 2 }, 
        #         'limits': 
        #         {
        #             'amount': { 'min': 0.0, 'max': 0.0 }, 
        #             'price': { 'min': 0.0, 'max': 0.0 }, 
        #             'cost': { 'min': 0.0, 'max': 0.0 }
        #         }, 
        #         'taker': 0.001, 
        #         'maker': 0.001, 
        #         'info': {backend response}
        #     },
        #     ...
        # ]

    def load_markets(self, reload=False, symbol=''):
        if not reload:
            if self.markets:
                if not self.markets_by_id:
                    return self.set_markets(self.markets)
                return self.markets
        currencies = None
        if self.has['fetchCurrencies']:
            currencies = self.fetch_currencies()
        markets = self.fetch_markets(symbol)
        return self.set_markets(markets, currencies)

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=1000, params={}):
        return []

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        # Check existance of authentication token
        # Just use empy one in case of an application is not signed in yet
        authToken = ''
        if 'token' in self.options:
            authToken = self.options['token']
        # Get URL
        url = self.implode_params(self.urls['api'], {'hostname': self.hostname}) + '/' + path
        # Calculate body and content type depending on method type: GET or POST
        keys = list(params.keys())
        keysLength = len(keys)
        # In case of body is still not assigned just make it empty string
        if body is None:
            body = ''
        # Prepare line for hashing
        # This hash sum is checked on backend side to verify API user
        # POST params should not be added as body
        query = method + ' /' + path + ' ' + self.urlencode(params) + ' ' + authToken + '\n' + body
        signed = self.hmac(self.encode(query), self.encode(self.secret))
        contentType = None
        if method == 'POST':
            contentType = 'application/x-www-form-urlencoded'
            if keysLength > 0:
                body = self.urlencode(params)
        else:
            if keysLength > 0:
                url += '?' + self.urlencode(params)
        headers = {
            'x-auth-sign': signed,
            'x-auth-token': authToken,
        }
        if authToken != '':
            headers['access-auth-token'] = authToken
        if contentType is not None:
            headers['Content-Type'] = contentType
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def sign_in(self, params={}):
        params = {
            'key': self.key,
            'token': self.token,
        }
        response = self.privatePostUcApiLogin(params)
        loginData = response['data']
        self.options['token'] = self.safe_string(loginData, 'token')
        memberId = self.safe_string(loginData, 'id')
        return memberId

    def fetch_status(self):
        # Responce examples:
        # {'status': 'ok'}
        # or
        # {'status': 'shutdown', 'reason': 'ExchangeNotAvailable'}
        # or
        # {'status': 'shutdown', 'reason': 'Unknown reason'}
        result = False
        try:
            response = self.privatePostExchangeExchangeCoinBaseSymbol()
            for field in response.items():
                if field[0] == 'message':
                    if field[1] == 'SUCCESS':
                        result = True
            if result is True:
                return {"status": "ok"}
            else:
                return {"status": "shutdown", "reason": "ExchangeNotAvailable"}
        except:
            reason = str(sys.exc_info()[0])
            if reason.find('ExchangeNotAvailable') != -1:
                return {"status": "shutdown", "reason": "ExchangeNotAvailable"}
            else:
                return {"status": "shutdown", "reason": "Unknown reason"}

    def parse_currencies(self, response):
        listData = []
        for value in response:
            tmp = {
            'id': value.get('name'),
            'code': value.get('name').upper(),
            'name': value.get('name'),
            'active': bool(value.get('status')),
            'fee': 0,
            'precision': 0,
            'limits':
            {
                'amount':
                {
                    'min': 'None',
                    'max': 'None',
                },
                'price':    
                {
                    'min': 'None',
                    'max': 'None',
                }, 
                'cost':     
                {
                    'min': 'None',
                    'max': 'None',
                },
                'withdraw':
                {
                    'min': value.get('minWithdrawAmount'),
                    'max': value.get('maxWithdrawAmount'),
                },
            },
            'info': value
            }
            listData.append(tmp)
        return listData

    def fetch_currencies(self):
        # Responce example
        #[
        #    {
        #        'id': 'BTC', 
        #        'code': 'BTC', 
        #        'name': 'BTC', 
        #        'active': True, 
        #        'fee': '?', 
        #        'precision': '?', 
        #        'limits': // TPR exchange has no restrictions
        #        {
        #            'amount': 
        #            {
        #                'min': 'None', 
        #                'max': 'None'
        #            }, 
        #            'price': 
        #            {
        #                'min': 'None', 
        #                'max': 'None'
        #            }, 
        #            'cost': 
        #            {
        #                'min': 'None', 
        #                'max': 'None'
        #            }, 
        #            'withdraw': 
        #            {
        #                'min': 1.0, 
        #                'max': 5000.0
        #            }
        #        }, 
        #        'info': { }, 
        #    },
        #    ...
        #]
        try:
            response = self.privatePostMarketCoinsInfo()
            return self.parse_currencies(response)
        except:
            reason = str(sys.exc_info()[0])
            if reason.find('ExchangeNotAvailable') != -1:
                return {"Error": "ExchangeNotAvailable"}
            else:
                return {"Error": "Unknown reason"}

    def fetch_order(self, id, symbol=None, params={}):
        request = {
            'orderId': id,
        }
        response = self.privatePostExchangeOrderFind(request)
        return self.parse_order(response)

    def parse_order(self, order, market=None):
        # {
        #   'orderId':'E161183624377614',
        #   'memberId':2,
        #   'type':'LIMIT_PRICE',
        #   'amount':1000.0,
        #   'symbol':'BCH/USDT',
        #   'tradedAmount':1000.0,
        #   'turnover':1080.0,
        #   'coinSymbol':'BCH',
        #   'baseSymbol':'USDT',
        #   'status':'COMPLETED',
        #   'direction':'SELL',
        #   'price':1.0,
        #   'time':1611836243776,
        #   'completedTime':1611836256242,
        # },
        type = 'market'
        if order['type'] == 'LIMIT_PRICE':
            type = 'limit'
        side = order['direction'].lower()
        remaining = order['amount'] - order['tradedAmount']
        status = order['status']
        if status == 'COMPLETED':
            status = 'closed'
        elif status == 'TRADING':
            status = 'open'
        else:
            status = 'canceled'
        cost = order['tradedAmount'] * order['price']
        result = {
            'info': order,
            'id': order['orderId'],
            'clientOrderId': order['memberId'],
            'timestamp': order['time'],
            'datetime': self.iso8601(order['time']),
            'lastTradeTimestamp': None,
            'symbol': order['symbol'],
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': order['price'],
            'stopPrice': None,
            'cost': cost,
            'average': None,
            'amount': order['amount'],
            'filled': order['tradedAmount'],
            'remaining': remaining,
            'status': status,
            'fee': None,
            'trades': None,
        }
        return result

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        params['symbol'] = symbol
        params['price'] = price
        params['amount'] = amount
        if side == 'buy':
            params['direction'] = 'BUY'
        else:
            params['direction'] = 'SELL'
        if type == 'market':
            params['type'] = 'MARKET_PRICE'
        else:
            params['type'] = 'LIMIT_PRICE'
        params['useDiscount'] = '0'
        response = self.privatePostExchangeOrderAdd(params)
        orderId = self.safe_string(response, 'data')
        return self.fetch_order(orderId)

    def cancel_order(self, id, symbol=None, params={}):
        request = {
            'orderId': id,
        }
        response = self.privatePostExchangeOrderApicancel(self.extend(request, params))
        return self.parse_order(response['data'])

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        # Request structure
        # {
        #   'symbol': Parameter from method arguments
        #   'since': Timestamp of first order in list in Unix epoch format
        #   'limit': Response list size
        #   'memberId': May be set in params. May be not set
        #   'status': one of TRADING COMPLETED CANCELED OVERTIMED. May be set in params
        #   'page': for pagination. In self case limit is size of every page. May be set in params
        # }
        limit_const = 20
        if 'page' in params:
            params['pageNo'] = self.safe_string(params, 'page')
        else:
            params['pageNo'] = 0

        if symbol is None:
            symbol = ''
        if since is None:
            since = 0
        if limit is None:
            limit = limit_const

        request = {
            'symbol': symbol,
            'since': since,
            'pageSize': limit,
        }
        fullRequest = self.extend(request, params)
        response = self.privatePostExchangeOrderAll(fullRequest)
        # {
        #     'content': [
        #         {
        #             'orderId':'E161183624377614',
        #             'memberId':2,
        #             'type':'LIMIT_PRICE',
        #             'amount':1000.0,
        #             'symbol':'BCH/USDT',
        #             'tradedAmount':1000.0,
        #             'turnover':1080.0,
        #             'coinSymbol':'BCH',
        #             'baseSymbol':'USDT',
        #             'status':'COMPLETED',
        #             'direction':'SELL',
        #             'price':1.0,
        #             'time':1611836243776,
        #             'completedTime':1611836256242,
        #         },
        #         ...
        #     ],
        #     'totalElements':41,
        #     'totalPages':3,
        #     'last':False,
        #     'size':20,
        #     'number':1,
        #     'first':False,
        #     'numberOfElements':20,
        #     'sort': [
        #         {
        #             'direction':'DESC',
        #             'property':'time',
        #             'ignoreCase':False,
        #             'nullHandling':'NATIVE',
        #             'ascending':False,
        #             'descending':True,
        #         }
        #     ]
        # }
        return self.parse_orders(response['content'])

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        # Request structure
        # {
        #   'symbol': Parameter from method arguments
        #   'since': Timestamp of first order in list in Unix epoch format
        #   'limit': Response list size
        #   'memberId': May be set in params. May be not set
        #   'status': one of TRADING COMPLETED CANCELED OVERTIMED. May be set in params
        #   'page': for pagination. In self case limit is size of every page. May be set in params
        # }
        limit_const = 20
        params['status'] = 'TRADING'
        if 'page' in params:
            params['pageNo'] = self.safe_string(params, 'page')
        else:
            params['pageNo'] = 0

        if symbol is None:
            symbol = ''
        if since is None:
            since = 0
        if limit is None:
            limit = limit_const
        
        request = {
            'symbol': symbol,
            'since': since,
            'pageSize': limit,
        }
        fullRequest = self.extend(request, params)
        response = self.privatePostExchangeOrderAll(fullRequest)
        # {
        #     'content': [
        #         {
        #             'orderId':'E161183624377614',
        #             'memberId':2,
        #             'type':'LIMIT_PRICE',
        #             'amount':1000.0,
        #             'symbol':'BCH/USDT',
        #             'tradedAmount':1000.0,
        #             'turnover':1080.0,
        #             'coinSymbol':'BCH',
        #             'baseSymbol':'USDT',
        #             'status':'COMPLETED',
        #             'direction':'SELL',
        #             'price':1.0,
        #             'time':1611836243776,
        #             'completedTime':1611836256242,
        #         },
        #         ...
        #     ],
        #     'totalElements':41,
        #     'totalPages':3,
        #     'last':False,
        #     'size':20,
        #     'number':1,
        #     'first':False,
        #     'numberOfElements':20,
        #     'sort': [
        #         {
        #             'direction':'DESC',
        #             'property':'time',
        #             'ignoreCase':False,
        #             'nullHandling':'NATIVE',
        #             'ascending':False,
        #             'descending':True,
        #         }
        #     ]
        # }
        return self.parse_orders(response['content'])

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        # Request structure
        # {
        #   'symbol': Parameter from method arguments
        #   'since': Timestamp of first order in list in Unix epoch format
        #   'limit': Response list size
        #   'memberId': May be set in params. May be not set
        #   'status': one of TRADING COMPLETED CANCELED OVERTIMED. May be set in params
        #   'page': for pagination. In self case limit is size of every page. May be set in params
        # }
        limit_const = 20
        params['status'] = 'CANCELED'
        if 'page' in params:
            params['pageNo'] = self.safe_string(params, 'page')
        else:
            params['pageNo'] = 0

        if symbol is None:
            symbol = ''
        if since is None:
            since = 0
        if limit is None:
            limit = limit_const
        
        request = {
            'symbol': symbol,
            'since': since,
            'pageSize': limit,
        }
        fullRequest = self.extend(request, params)
        response = self.privatePostExchangeOrderAll(fullRequest)
        # {
        #     'content': [
        #         {
        #             'orderId':'E161183624377614',
        #             'memberId':2,
        #             'type':'LIMIT_PRICE',
        #             'amount':1000.0,
        #             'symbol':'BCH/USDT',
        #             'tradedAmount':1000.0,
        #             'turnover':1080.0,
        #             'coinSymbol':'BCH',
        #             'baseSymbol':'USDT',
        #             'status':'COMPLETED',
        #             'direction':'SELL',
        #             'price':1.0,
        #             'time':1611836243776,
        #             'completedTime':1611836256242,
        #         },
        #         ...
        #     ],
        #     'totalElements':41,
        #     'totalPages':3,
        #     'last':False,
        #     'size':20,
        #     'number':1,
        #     'first':False,
        #     'numberOfElements':20,
        #     'sort': [
        #         {
        #             'direction':'DESC',
        #             'property':'time',
        #             'ignoreCase':False,
        #             'nullHandling':'NATIVE',
        #             'ascending':False,
        #             'descending':True,
        #         }
        #     ]
        # }
        return self.parse_orders(response['content'])

    # If call without params the function returns balance of current user
    def fetch_balance(self, uid='-1', params={}):
        params = {
            'uid': uid
        }
        try:
            response = self.privatePostUcMemberBalance(params)
        except Exception as e:
            return e
        return self.parse_balance(response)

    def parse_balance(self, response):
        data = json.loads(json.dumps(response))
        if data['message'] == 'SUCCESS':
            result = { "free":{}, "used":{}, "total":{}}
            for row in data['data']['balances']:
                result['free'].update({row['coinName']:row['free']})
                result['used'].update({row['coinName']:row['used']})
                result['total'].update({row['coinName']:row['total']})
                result.update({row['coinName']:{'free':row['free'], 'used':row['used'], 'total':row['total']}})
            return result

    # Returns int or None
    def get_market_price(self, symbol):

        response = self.privatePostMarketSymbolThumb()
        for i in response:
            if i.get('symbol') == symbol:
                return i.get('close')

    def fetch_trades(self, orderId):
        # Responce example:
        # [
        #    {
        #       'info': { backend response }, 
        #       'id': 'E161460499516968', 
        #       'timestamp': 1614605187661, 
        #       'datetime': '2021-03-01 15:26:27.661000', 
        #       'symbol': 'BTC/USDT', 
        #       'order': 'E161460499516968', 
        #       'type': 'LIMIT_PRICE', 
        #       'side': 'SELL', 
        #       'takerOrMaker': 'None', (Have no this information inside TPR exchange)
        #       'price': 1.0, 
        #       'amount': 1.0, 
        #       'cost': 1.0, 
        #       'fee': 
        #       {
        #           'cost': 0.001, 
        #           'currency': 'BTC', 
        #           'rate': 'None' (Have no this information inside TPR exchange)
        #       }
        #    }
        # ]
        request = { 'orderId': orderId }
        return self.parse_trade(self.privatePostExchangeOrderMyTrades(request))

    def parse_trade(self, response):
        listData = []
        for value in response:
            ExchangeOrder = response.get(value)
            id_ = ExchangeOrder.get('orderId')
            timestamp = ExchangeOrder.get('completedTime')
            datetime_ = str(datetime.fromtimestamp(int(timestamp) * 0.001))
            price = ExchangeOrder.get('price')
            amount = ExchangeOrder.get('amount')
            cost = price * amount

            tmp = {
                'info': response.get(value),
                'id': id_,
                'timestamp': timestamp,
                'datetime': datetime_,
                'symbol': ExchangeOrder.get('symbol'),
                'order': id_,
                'type': ExchangeOrder.get('type'),
                'side': ExchangeOrder.get('direction'),
                'takerOrMaker': 'None',
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee':
                {
                    'cost': 0.001,
                    'currency': ExchangeOrder.get('coinSymbol'),
                    'rate': 'None',
                }
                }
            listData.append(tmp)
        return listData

    def fetch_my_trades(self):
        # Responce example:
        # [
        #    {
        #       'info': { backend response }, 
        #       'id': 'E161460499516968', 
        #       'timestamp': 1614605187661, 
        #       'datetime': '2021-03-01 15:26:27.661000', 
        #       'symbol': 'BTC/USDT', 
        #       'order': 'E161460499516968', 
        #       'type': 'LIMIT_PRICE', 
        #       'side': 'SELL', 
        #       'takerOrMaker': 'None', (Have no this information inside TPR exchange)
        #       'price': 1.0, 
        #       'amount': 1.0, 
        #       'cost': 1.0, 
        #       'fee': 
        #       {
        #           'cost': 0.001, 
        #           'currency': 'BTC', 
        #           'rate': 'None'  (Have no this information inside TPR exchange)
        #       }
        #    }, 
        #    { ... },
        # ]
        request = { 'orderId': '' }
        return self.parse_trade(self.privatePostExchangeOrderMyTrades(request))

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if httpCode == 200:
            if 'code' in response:
                if response['code'] == 0:
                    return
            else:
                return
        # {
        #     "message": "Error text in case when HTTP code is not 200",
        #     ...
        # }
        message = self.safe_string(response, 'message')
        if message is not None:
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
