# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.precise import Precise


class b2c2(Exchange):

    def describe(self):
        return self.deep_extend(super(b2c2, self).describe(), {
            'id': 'b2c2',
            'name': 'B2C2',
            'countries': ['GB'],
            'rateLimit': 500,
            'has': {
                'fetchBalance': True,
                'fetchCurrencies': True,
                'fetchMarkets': True,
                'fetchOrders': True,
                'fetchLedger': True,
                'fetchMyTrades': True,
                'createOrder': True,
                'fetchOrder': True,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg',
                'api': {
                    'private': 'https://api.uat.b2c2.net',
                },
                'test': {
                    'private': 'https://api.uat.b2c2.net',
                },
                'www': 'https://b2c2.com',
                'doc': 'https://docs.b2c2.net',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': False,
            },
            'api': {
                'private': {
                    'get': [
                        'account_info',
                        'balance',
                        'currency',
                        'funding_rates',
                        'instruments',
                        'ledger',
                        'order',
                        'order/{order_id_or_client_order_id}',
                        'trade',
                        'trade/{trade_id}',
                        'withdrawal',
                        'withdrawal/{withdrawal_id}',
                    ],
                    'post': [
                        'request_for_quote/',
                        'order/',
                        'withdrawal/',
                    ],
                    'delete': [
                        'order/{order_id_or_client_order_id}',
                        'withdrawal/{withdrawal_id}',
                    ],
                },
            },
            'httpExceptions': {
                '400': BadRequest,  # Bad Request –- Incorrect parameters.
                '401': AuthenticationError,  # Unauthorized – Wrong Token.
                '404': ExchangeNotAvailable,  # Not Found – The specified endpoint could not be found.
                '405': ExchangeNotAvailable,  # Method Not Allowed – You tried to access an endpoint with an invalid method.
                '406': BadRequest,  # Not Acceptable – Incorrect request format.
                '429': RateLimitExceeded,  # Too Many Requests – Rate limited, pause requests.
                '500': ExchangeError,  # Internal Server Error – We had a problem with our server. Try again later.
                '503': OnMaintenance,  # Service unavailable
            },
            'exceptions': {
                'exact': {
                    '1000': ExchangeError,  # Generic –- Unknown error.
                    '1001': InvalidOrder,  # Instrument not allowed – Instrument does not exist or you are not authorized to trade it.
                    '1002': PermissionDenied,  # The RFQ does not belong to you.
                    '1003': InvalidOrder,  # Different instrument – You tried to post a trade with a different instrument than the related RFQ.
                    '1004': InvalidOrder,  # Different side – You tried to post a trade with a different side than the related RFQ.
                    '1005': InvalidOrder,  # Different price – You tried to post a trade with a different price than the related RFQ.
                    '1006': InvalidOrder,  # Different quantity – You tried to post a trade with a different quantity than the related RFQ.
                    '1007': InvalidOrder,  # Quote is not valid – Quote may have expired.
                    '1009': InvalidOrder,  # Price not valid – The price is not valid anymore. This error can occur during big market moves.
                    '1010': InvalidOrder,  # Quantity too big – Max quantity per trade reached.
                    '1011': InsufficientFunds,  # Not enough balance – Not enough balance.
                    '1012': InsufficientFunds,  # Max risk exposure reached – Please see our FAQ for more information about the risk exposure.
                    '1013': InsufficientFunds,  # Max credit exposure reached – Please see our FAQ for more information about the credit exposure.
                    '1014': InvalidAddress,  # No BTC address associated – You don’t have a BTC address associated to your account.
                    '1015': InvalidOrder,  # Too many decimals – We only allow four decimals in quantities.
                    '1016': OnMaintenance,  # Trading is disabled – May occur after a maintenance or under exceptional circumstances.
                    '1017': BadRequest,  # Illegal parameter – Wrong type or parameter.
                    '1018': OnMaintenance,  # Settlement is disabled at the moment.
                    '1019': InvalidOrder,  # Quantity is too small.
                    '1020': InvalidOrder,  # The field valid_until is malformed.
                    '1021': OrderNotFound,  # Your Order has expired.
                    '1022': BadSymbol,  # Currency not allowed.
                    '1023': NotSupported,  # We only support “FOK” order_type at the moment.
                    '1100': ExchangeError,  # Other error.
                    '1101': BadRequest,  # Field required – Field required.
                    '1102': BadRequest,  # Pagination offset too big – Narrow down the data space using parameters such as ‘created*gte’, ‘created*lt’, ‘since’.
                    '1200': OnMaintenance,  # API Maintenance
                },
            },
            'options': {
                'fetchMyTrades': {
                    'sort': 'timestamp,asc',
                },
                'fetchOpenOrders': {
                    'sort': 'createdAt,asc',
                },
                'fetchClosedOrders': {
                    'sort': 'createdAt,asc',
                },
                'defaultSort': 'timestamp,asc',
                'defaultSortOrders': 'createdAt,asc',
            },
            'currencies': {'ADA': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Cardano', 'ada_max_qty_per_trade': 4000000}, 'id': 'ADA', 'code': 'ADA', 'name': 'Cardano', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 4000000}}}, 'AUD': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Australian Dollar', 'aud_max_qty_per_trade': 750000}, 'id': 'AUD', 'code': 'AUD', 'name': 'Australian Dollar', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 750000}}}, 'BCH': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Bitcoin cash', 'bch_max_qty_per_trade': 500}, 'id': 'BCH', 'code': 'BCH', 'name': 'Bitcoin cash', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 500}}}, 'BNB': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Binance Coin', 'bnb_max_qty_per_trade': 1700}, 'id': 'BNB', 'code': 'BNB', 'name': 'Binance Coin', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 1700}}}, 'BTC': {'info': {'long_only': False, 'minimum_trade_size': '0.0005', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Bitcoin', 'btc_max_qty_per_trade': 100}, 'id': 'BTC', 'code': 'BTC', 'name': 'Bitcoin', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.0005, 'max': 100}}}, 'CAD': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Canadian Dollar', 'cad_max_qty_per_trade': 750000}, 'id': 'CAD', 'code': 'CAD', 'name': 'Canadian Dollar', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 750000}}}, 'CHF': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Swiss Franc', 'chf_max_qty_per_trade': 550000}, 'id': 'CHF', 'code': 'CHF', 'name': 'Swiss Franc', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 550000}}}, 'CNH': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Offshore Renminbi', 'cnh_max_qty_per_trade': 600000}, 'id': 'CNH', 'code': 'CNH', 'name': 'Offshore Renminbi', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 600000}}}, 'DOG': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Dogecoin', 'dog_max_qty_per_trade': 1800000}, 'id': 'DOG', 'code': 'DOG', 'name': 'Dogecoin', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 1800000}}}, 'DOT': {'info': {'long_only': False, 'minimum_trade_size': '0.5', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Polkadot', 'dot_max_qty_per_trade': 100000}, 'id': 'DOT', 'code': 'DOT', 'name': 'Polkadot', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.5, 'max': 100000}}}, 'EOS': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'EOS', 'eos_max_qty_per_trade': 20000}, 'id': 'EOS', 'code': 'EOS', 'name': 'EOS', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 20000}}}, 'ETH': {'info': {'long_only': False, 'minimum_trade_size': '0.005', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Ether', 'eth_max_qty_per_trade': 1000}, 'id': 'ETH', 'code': 'ETH', 'name': 'Ether', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.005, 'max': 1000}}}, 'EUR': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Euro', 'eur_max_qty_per_trade': 500000}, 'id': 'EUR', 'code': 'EUR', 'name': 'Euro', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 500000}}}, 'GBP': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Great British Pound', 'gbp_max_qty_per_trade': 450000}, 'id': 'GBP', 'code': 'GBP', 'name': 'Great British Pound', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 450000}}}, 'JPY': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Japanese Yen', 'jpy_max_qty_per_trade': 65000000}, 'id': 'JPY', 'code': 'JPY', 'name': 'Japanese Yen', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 65000000}}}, 'LNK': {'info': {'long_only': False, 'minimum_trade_size': '0.1', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Chainlink', 'lnk_max_qty_per_trade': 60000}, 'id': 'LNK', 'code': 'LNK', 'name': 'Chainlink', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.1, 'max': 60000}}}, 'LTC': {'info': {'long_only': False, 'minimum_trade_size': '0.1', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Litecoin', 'ltc_max_qty_per_trade': 4000}, 'id': 'LTC', 'code': 'LTC', 'name': 'Litecoin', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.1, 'max': 4000}}}, 'MXN': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': '', 'mxn_max_qty_per_trade': 12300000}, 'id': 'MXN', 'code': 'MXN', 'name': '', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 12300000}}}, 'NZD': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': ''}, 'id': 'NZD', 'code': 'NZD', 'name': '', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01}}}, 'SGD': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'Singapore Dollar', 'sgd_max_qty_per_trade': 800000}, 'id': 'SGD', 'code': 'SGD', 'name': 'Singapore Dollar', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 800000}}}, 'UNI': {'info': {'long_only': False, 'minimum_trade_size': '0.1', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Uniswap', 'uni_max_qty_per_trade': 25000}, 'id': 'UNI', 'code': 'UNI', 'name': 'Uniswap', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.1, 'max': 25000}}}, 'USC': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': True, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'USD Coin', 'usc_max_qty_per_trade': 600000}, 'id': 'USC', 'code': 'USC', 'name': 'USD Coin', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 600000}}}, 'USD': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'fiat', 'is_crypto': False, 'readable_name': 'US Dollar', 'usd_max_qty_per_trade': 600000}, 'id': 'USD', 'code': 'USD', 'name': 'US Dollar', 'type': 'fiat', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 600000}}}, 'UST': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': True, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Tether', 'ust_max_qty_per_trade': 600000}, 'id': 'UST', 'code': 'UST', 'name': 'Tether', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01, 'max': 600000}}}, 'XAU': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'synthetic', 'is_crypto': False, 'readable_name': 'XAU', 'xau_max_qty_per_trade': 1000}, 'id': 'XAU', 'code': 'XAU', 'name': 'XAU', 'type': 'synthetic', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 1000}}}, 'XLM': {'info': {'long_only': False, 'minimum_trade_size': '100.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Stellar', 'xlm_max_qty_per_trade': 4000000}, 'id': 'XLM', 'code': 'XLM', 'name': 'Stellar', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 100, 'max': 4000000}}}, 'XMR': {'info': {'long_only': False, 'minimum_trade_size': '0.01', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Monero'}, 'id': 'XMR', 'code': 'XMR', 'name': 'Monero', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 0.01}}}, 'XRP': {'info': {'long_only': False, 'minimum_trade_size': '20.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Ripple', 'xrp_max_qty_per_trade': 200000}, 'id': 'XRP', 'code': 'XRP', 'name': 'Ripple', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 20, 'max': 200000}}}, 'XTZ': {'info': {'long_only': False, 'minimum_trade_size': '1.0', 'stable_coin': False, 'currency_type': 'crypto', 'is_crypto': True, 'readable_name': 'Tezos', 'xtz_max_qty_per_trade': 170000}, 'id': 'XTZ', 'code': 'XTZ', 'name': 'Tezos', 'type': 'crypto', 'active': True, 'precision': 4, 'limits': {'withdraw': {}, 'amount': {'min': 1, 'max': 170000}}}},
            'markets': {'LTC/USD': {'limits': {'amount': {'min': 0.1, 'max': 4000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LTCUSD.SPOT', 'underlier': 'LTCUSD', 'type': 'SPOT'}, 'id': 'LTCUSD.SPOT', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'baseId': 'LTC', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BCH/USD': {'limits': {'amount': {'min': 0.01, 'max': 500}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BCHUSD.SPOT', 'underlier': 'BCHUSD', 'type': 'SPOT'}, 'id': 'BCHUSD.SPOT', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'baseId': 'BCH', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'EOS/AUD': {'limits': {'amount': {'min': 1, 'max': 20000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'EOSAUD.SPOT', 'underlier': 'EOSAUD', 'type': 'SPOT'}, 'id': 'EOSAUD.SPOT', 'symbol': 'EOS/AUD', 'base': 'EOS', 'quote': 'AUD', 'baseId': 'EOS', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'UST/AUD': {'limits': {'amount': {'min': 0.01, 'max': 600000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'USTAUD.SPOT', 'underlier': 'USTAUD', 'type': 'SPOT'}, 'id': 'USTAUD.SPOT', 'symbol': 'UST/AUD', 'base': 'UST', 'quote': 'AUD', 'baseId': 'UST', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LNK/ETH': {'limits': {'amount': {'min': 0.1, 'max': 60000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.005, 'max': 1000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LNKETH.SPOT', 'underlier': 'LNKETH', 'type': 'SPOT'}, 'id': 'LNKETH.SPOT', 'symbol': 'LNK/ETH', 'base': 'LNK', 'quote': 'ETH', 'baseId': 'LNK', 'quoteId': 'ETH', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BTC/USD': {'limits': {'amount': {'min': 0.0005, 'max': 100}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BTCUSD.SPOT', 'underlier': 'BTCUSD', 'type': 'SPOT'}, 'id': 'BTCUSD.SPOT', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'baseId': 'BTC', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'ETH/BTC': {'limits': {'amount': {'min': 0.005, 'max': 1000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'ETHBTC.SPOT', 'underlier': 'ETHBTC', 'type': 'SPOT'}, 'id': 'ETHBTC.SPOT', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'ETH', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'ETH/USD': {'limits': {'amount': {'min': 0.005, 'max': 1000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'ETHUSD.SPOT', 'underlier': 'ETHUSD', 'type': 'SPOT'}, 'id': 'ETHUSD.SPOT', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'baseId': 'ETH', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BCH/AUD': {'limits': {'amount': {'min': 0.01, 'max': 500}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BCHAUD.SPOT', 'underlier': 'BCHAUD', 'type': 'SPOT'}, 'id': 'BCHAUD.SPOT', 'symbol': 'BCH/AUD', 'base': 'BCH', 'quote': 'AUD', 'baseId': 'BCH', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LTC/AUD': {'limits': {'amount': {'min': 0.1, 'max': 4000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LTCAUD.SPOT', 'underlier': 'LTCAUD', 'type': 'SPOT'}, 'id': 'LTCAUD.SPOT', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD', 'baseId': 'LTC', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'DOT/BTC': {'limits': {'amount': {'min': 0.5, 'max': 100000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'DOTBTC.SPOT', 'underlier': 'DOTBTC', 'type': 'SPOT'}, 'id': 'DOTBTC.SPOT', 'symbol': 'DOT/BTC', 'base': 'DOT', 'quote': 'BTC', 'baseId': 'DOT', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'DOT/USD': {'limits': {'amount': {'min': 0.5, 'max': 100000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'DOTUSD.SPOT', 'underlier': 'DOTUSD', 'type': 'SPOT'}, 'id': 'DOTUSD.SPOT', 'symbol': 'DOT/USD', 'base': 'DOT', 'quote': 'USD', 'baseId': 'DOT', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'DOT/ETH': {'limits': {'amount': {'min': 0.5, 'max': 100000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.005, 'max': 1000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'DOTETH.SPOT', 'underlier': 'DOTETH', 'type': 'SPOT'}, 'id': 'DOTETH.SPOT', 'symbol': 'DOT/ETH', 'base': 'DOT', 'quote': 'ETH', 'baseId': 'DOT', 'quoteId': 'ETH', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'DOT/AUD': {'limits': {'amount': {'min': 0.5, 'max': 100000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'DOTAUD.SPOT', 'underlier': 'DOTAUD', 'type': 'SPOT'}, 'id': 'DOTAUD.SPOT', 'symbol': 'DOT/AUD', 'base': 'DOT', 'quote': 'AUD', 'baseId': 'DOT', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XTZ/AUD': {'limits': {'amount': {'min': 1, 'max': 170000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XTZAUD.SPOT', 'underlier': 'XTZAUD', 'type': 'SPOT'}, 'id': 'XTZAUD.SPOT', 'symbol': 'XTZ/AUD', 'base': 'XTZ', 'quote': 'AUD', 'baseId': 'XTZ', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'DOG/AUD': {'limits': {'amount': {'min': 1, 'max': 1800000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'DOGAUD.SPOT', 'underlier': 'DOGAUD', 'type': 'SPOT'}, 'id': 'DOGAUD.SPOT', 'symbol': 'DOG/AUD', 'base': 'DOG', 'quote': 'AUD', 'baseId': 'DOG', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BCH/BTC': {'limits': {'amount': {'min': 0.01, 'max': 500}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BCHBTC.SPOT', 'underlier': 'BCHBTC', 'type': 'SPOT'}, 'id': 'BCHBTC.SPOT', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'baseId': 'BCH', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XRP/BTC': {'limits': {'amount': {'min': 20, 'max': 200000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XRPBTC.SPOT', 'underlier': 'XRPBTC', 'type': 'SPOT'}, 'id': 'XRPBTC.SPOT', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'XRP', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XRP/ETH': {'limits': {'amount': {'min': 20, 'max': 200000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.005, 'max': 1000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XRPETH.SPOT', 'underlier': 'XRPETH', 'type': 'SPOT'}, 'id': 'XRPETH.SPOT', 'symbol': 'XRP/ETH', 'base': 'XRP', 'quote': 'ETH', 'baseId': 'XRP', 'quoteId': 'ETH', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LNK/AUD': {'limits': {'amount': {'min': 0.1, 'max': 60000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LNKAUD.SPOT', 'underlier': 'LNKAUD', 'type': 'SPOT'}, 'id': 'LNKAUD.SPOT', 'symbol': 'LNK/AUD', 'base': 'LNK', 'quote': 'AUD', 'baseId': 'LNK', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'USC/AUD': {'limits': {'amount': {'min': 0.01, 'max': 600000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'USCAUD.SPOT', 'underlier': 'USCAUD', 'type': 'SPOT'}, 'id': 'USCAUD.SPOT', 'symbol': 'USC/AUD', 'base': 'USC', 'quote': 'AUD', 'baseId': 'USC', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XLM/BTC': {'limits': {'amount': {'min': 100, 'max': 4000000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XLMBTC.SPOT', 'underlier': 'XLMBTC', 'type': 'SPOT'}, 'id': 'XLMBTC.SPOT', 'symbol': 'XLM/BTC', 'base': 'XLM', 'quote': 'BTC', 'baseId': 'XLM', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XLM/ETH': {'limits': {'amount': {'min': 100, 'max': 4000000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.005, 'max': 1000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XLMETH.SPOT', 'underlier': 'XLMETH', 'type': 'SPOT'}, 'id': 'XLMETH.SPOT', 'symbol': 'XLM/ETH', 'base': 'XLM', 'quote': 'ETH', 'baseId': 'XLM', 'quoteId': 'ETH', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BTC/AUD': {'limits': {'amount': {'min': 0.0005, 'max': 100}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BTCAUD.SPOT', 'underlier': 'BTCAUD', 'type': 'SPOT'}, 'id': 'BTCAUD.SPOT', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'baseId': 'BTC', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'ETH/AUD': {'limits': {'amount': {'min': 0.005, 'max': 1000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'ETHAUD.SPOT', 'underlier': 'ETHAUD', 'type': 'SPOT'}, 'id': 'ETHAUD.SPOT', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD', 'baseId': 'ETH', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LTC/BTC': {'limits': {'amount': {'min': 0.1, 'max': 4000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LTCBTC.SPOT', 'underlier': 'LTCBTC', 'type': 'SPOT'}, 'id': 'LTCBTC.SPOT', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'LTC', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XRP/USD': {'limits': {'amount': {'min': 20, 'max': 200000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XRPUSD.SPOT', 'underlier': 'XRPUSD', 'type': 'SPOT'}, 'id': 'XRPUSD.SPOT', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD', 'baseId': 'XRP', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XRP/AUD': {'limits': {'amount': {'min': 20, 'max': 200000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XRPAUD.SPOT', 'underlier': 'XRPAUD', 'type': 'SPOT'}, 'id': 'XRPAUD.SPOT', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD', 'baseId': 'XRP', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'EOS/USD': {'limits': {'amount': {'min': 1, 'max': 20000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'EOSUSD.SPOT', 'underlier': 'EOSUSD', 'type': 'SPOT'}, 'id': 'EOSUSD.SPOT', 'symbol': 'EOS/USD', 'base': 'EOS', 'quote': 'USD', 'baseId': 'EOS', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'UST/USD': {'limits': {'amount': {'min': 0.01, 'max': 600000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'USTUSD.SPOT', 'underlier': 'USTUSD', 'type': 'SPOT'}, 'id': 'USTUSD.SPOT', 'symbol': 'UST/USD', 'base': 'UST', 'quote': 'USD', 'baseId': 'UST', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LTC/ETH': {'limits': {'amount': {'min': 0.1, 'max': 4000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.005, 'max': 1000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LTCETH.SPOT', 'underlier': 'LTCETH', 'type': 'SPOT'}, 'id': 'LTCETH.SPOT', 'symbol': 'LTC/ETH', 'base': 'LTC', 'quote': 'ETH', 'baseId': 'LTC', 'quoteId': 'ETH', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LNK/USD': {'limits': {'amount': {'min': 0.1, 'max': 60000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LNKUSD.SPOT', 'underlier': 'LNKUSD', 'type': 'SPOT'}, 'id': 'LNKUSD.SPOT', 'symbol': 'LNK/USD', 'base': 'LNK', 'quote': 'USD', 'baseId': 'LNK', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'UNI/AUD': {'limits': {'amount': {'min': 0.1, 'max': 25000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'UNIAUD.SPOT', 'underlier': 'UNIAUD', 'type': 'SPOT'}, 'id': 'UNIAUD.SPOT', 'symbol': 'UNI/AUD', 'base': 'UNI', 'quote': 'AUD', 'baseId': 'UNI', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'BNB/AUD': {'limits': {'amount': {'min': 0.01, 'max': 1700}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'BNBAUD.SPOT', 'underlier': 'BNBAUD', 'type': 'SPOT'}, 'id': 'BNBAUD.SPOT', 'symbol': 'BNB/AUD', 'base': 'BNB', 'quote': 'AUD', 'baseId': 'BNB', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'ADA/AUD': {'limits': {'amount': {'min': 1, 'max': 4000000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'ADAAUD.SPOT', 'underlier': 'ADAAUD', 'type': 'SPOT'}, 'id': 'ADAAUD.SPOT', 'symbol': 'ADA/AUD', 'base': 'ADA', 'quote': 'AUD', 'baseId': 'ADA', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'EOS/BTC': {'limits': {'amount': {'min': 1, 'max': 20000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'EOSBTC.SPOT', 'underlier': 'EOSBTC', 'type': 'SPOT'}, 'id': 'EOSBTC.SPOT', 'symbol': 'EOS/BTC', 'base': 'EOS', 'quote': 'BTC', 'baseId': 'EOS', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XLM/USD': {'limits': {'amount': {'min': 100, 'max': 4000000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XLMUSD.SPOT', 'underlier': 'XLMUSD', 'type': 'SPOT'}, 'id': 'XLMUSD.SPOT', 'symbol': 'XLM/USD', 'base': 'XLM', 'quote': 'USD', 'baseId': 'XLM', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'USC/USD': {'limits': {'amount': {'min': 0.01, 'max': 600000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 600000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'USCUSD.SPOT', 'underlier': 'USCUSD', 'type': 'SPOT'}, 'id': 'USCUSD.SPOT', 'symbol': 'USC/USD', 'base': 'USC', 'quote': 'USD', 'baseId': 'USC', 'quoteId': 'USD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'XLM/AUD': {'limits': {'amount': {'min': 100, 'max': 4000000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.01, 'max': 750000}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'XLMAUD.SPOT', 'underlier': 'XLMAUD', 'type': 'SPOT'}, 'id': 'XLMAUD.SPOT', 'symbol': 'XLM/AUD', 'base': 'XLM', 'quote': 'AUD', 'baseId': 'XLM', 'quoteId': 'AUD', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}, 'LNK/BTC': {'limits': {'amount': {'min': 0.1, 'max': 60000}, 'price': {'min': 0.0001}, 'cost': {'min': 0.0005, 'max': 100}}, 'precision': {'base': 4, 'quote': 4, 'price': 4, 'amount': 4}, 'tierBased': False, 'percentage': True, 'info': {'name': 'LNKBTC.SPOT', 'underlier': 'LNKBTC', 'type': 'SPOT'}, 'id': 'LNKBTC.SPOT', 'symbol': 'LNK/BTC', 'base': 'LNK', 'quote': 'BTC', 'baseId': 'LNK', 'quoteId': 'BTC', 'type': 'SPOT', 'spot': True, 'margin': False, 'active': True}},
        })

    def fetch_currencies(self, params={}):
        ccys = self.privateGetCurrency(params)
        account_info = self.privateGetAccountInfo(params)
        #
        # currencies endpoint
        # {
        #     "AUD": {
        #       "long_only": False,
        #       "minimum_trade_size": 0.01,
        #       "stable_coin": False,
        #       "currency_type": "fiat",
        #       "is_crypto": False,
        #       "readable_name": ""
        #     },
        #     "BCH": {
        #       "long_only": False,
        #       "minimum_trade_size": 0.01,
        #       "stable_coin": False,
        #       "currency_type": "crypto",
        #       "is_crypto": True,
        #       "readable_name": "Bitcoin cash"
        #     },
        # ...
        # Account info endpoint
        # {
        #     "max_risk_exposure": "500000",
        #     "risk_exposure": "74054.96",
        #     "currency": "USD",
        #     "btc_max_qty_per_trade": "100",
        #     "ust_max_qty_per_trade": "600000",
        #     "eth_max_qty_per_trade": "1000",
        #     "ltc_max_qty_per_trade": "4000",
        #     "bch_max_qty_per_trade": "500",
        #     "xrp_max_qty_per_trade": "200000",
        #     ...
        #   }
        result = {}
        keys = list(ccys.keys())
        for i in range(0, len(keys)):
            id = keys[i]
            code = self.safe_currency_code(id)
            ccy = ccys[keys[i]]
            name = self.safe_string(ccy, 'readable_name')
            currency_type = self.safe_string(ccy, 'currency_type')
            minTradeSize = self.safe_number(ccy, 'minimum_trade_size')
            maxTradeSizeKey = id.lower() + '_max_qty_per_trade'
            maxTradeSize = self.safe_number(account_info, maxTradeSizeKey)
            ccy[maxTradeSizeKey] = maxTradeSize  # update back into the raw info for debugging
            result[code] = {
                'info': ccy,
                'id': id,
                'code': code,
                'name': name,
                'type': currency_type,
                'active': True,
                'fee': None,
                'precision': 4,
                'limits': {
                    'withdraw': {'min': None, 'max': None},
                    'amount': {'min': minTradeSize, 'max': maxTradeSize},
                },
            }
        return result

    def fetch_markets(self, params={}):
        # FIXME hack to force reload currencies
        currencies = self.fetch_currencies()
        self.currencies = self.deep_extend(currencies, self.currencies)
        response = self.privateGetInstruments(params)
        #
        # [
        #     {
        #       "name": "LTCUSD.SPOT",
        #       "underlier": "LTCUSD",
        #       "type": "SPOT"
        #     },
        #     {
        #       "name": "BCHUSD.SPOT",
        #       "underlier": "BCHUSD",
        #       "type": "SPOT"
        #     },
        #
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_market(response[i]))
        return result

    def parse_market(self, market):
        # instruments endpoint
        # [
        #     {
        #       "name": "LTCUSD.SPOT",
        #       "underlier": "LTCUSD",
        #       "type": "SPOT"
        #     },
        #     {
        #       "name": "BCHUSD.SPOT",
        #       "underlier": "BCHUSD",
        #       "type": "SPOT"
        #     },
        # ...
        #
        #
        # currency object
        #
        #     result[code] = {
        #         'info': ccy,
        #         'id': id,
        #         'code': code,
        #         'name': name,
        #         'type': currency_type,
        #         'active': True,
        #         'fee': None,
        #         'precision': 4,
        #         'limits': {
        #             'withdraw': {'min': None, 'max': None},
        #             'amount': {'min': minTradeSize, 'max': maxTradeSize},
        #         },
        #     }
        # }
        id = self.safe_string(market, 'name')
        underlier = self.safe_string(market, 'underlier')
        underlier = underlier.upper()
        baseId = underlier[0:3]  # left in underlier
        quoteId = underlier[3:6]  # right in underlier
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        symbol = base + '/' + quote
        type = self.safe_string(market, 'type')
        spot = False
        margin = False
        if type == 'SPOT':
            spot = True
        elif type == 'CFD':
            margin = True
        active = True
        ccyBase = self.currencies[base]
        ccyQuote = self.currencies[quote]
        # pricePrecision = ccyQuote['limits']['amount']['min']
        # amountPrecision = ccyBase['limits']['amount']['min']
        # precision = {
        #     'price': pricePrecision,
        #     'amount': amountPrecision,
        # }
        # FIXME - hard coded precisions
        precision = {
            'base': 4,
            'quote': 4,
            'price': 4,
            'amount': 4,
        }
        amountMin = ccyBase['limits']['amount']['min']
        amountMax = ccyBase['limits']['amount']['max']
        costMin = ccyQuote['limits']['amount']['min']
        costMax = ccyQuote['limits']['amount']['max']
        limits = {
            'amount': {'min': amountMin, 'max': amountMax},
            'price': {'min': 0.0001, 'max': None},
            'cost': {'min': costMin, 'max': costMax},
        }
        # taker = None  # no maker or taker fees for b2c2
        # maker = None  # no maker or taker fees for b2c2
        return {
            'info': market,
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'type': type,
            'spot': spot,
            'margin': margin,
            'active': active,
            'precision': precision,
            'limits': limits,
            'tierBased': False,
            'percentage': True,
        }

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetBalance(params)
        # {
        #     "USD": "0",
        #     "BTC": "0",
        #     "JPY": "0",
        #     "GBP": "0",
        #     "ETH": "0",
        #     "EUR": "0",
        #     "CAD": "0",
        #     "LTC": "0",
        #     "XRP": "0",
        #     "BCH": "0"
        # }
        now = self.milliseconds()
        result = {
            'info': response,
            'timestamp': now,
            'datetime': self.iso8601(now),
        }
        assets = response
        keys = list(assets.keys())
        for i in range(0, len(keys)):
            balance = assets[keys[i]]
            code = keys[i]
            account = self.account()
            account['free'] = balance
            account['used'] = 0
            account['total'] = balance
            result[code] = account
        return self.parse_balance(result)

    def create_quote(self, symbol, side, amount, params={}):
        self.load_markets()
        market = self.market(symbol)
        lowercaseSide = side.lower()
        request = {
            'quantity': self.amount_to_precision(symbol, amount),
            'side': lowercaseSide,
            'instrument': market['id'],
        }
        response = self.privatePostRequestForQuote(self.extend(request, params))
        return self.parse_quote(response, market)

    def parse_quote(self, quote, market=None):
        # {
        #     "created": "2021-08-23T07:20:39.670767Z",
        #     "valid_until": "2021-08-23T07:21:00.670772Z",
        #     "rfq_id": "75fdad8c-69a3-45c2-b6a8-dba3f701c759",
        #     "client_rfq_id": "43fa40fb-bfdd-4e1d-8978-d84ab103ab1f",
        #     "quantity": "1.0000000000",
        #     "side": "sell",
        #     "instrument": "BTCUSD.SPOT",
        #     "price": "50113.00000000"
        #   }
        timestamp = self.parse8601(self.safe_string(quote, 'created'))
        validUntilTimestamp = self.parse8601(self.safe_string(quote, 'valid_until'))
        rfqId = self.safe_string(quote, 'rfq_id')
        clientRfqId = self.safe_string(quote, 'client_rfq_id')
        amount = self.safe_number(quote, 'quantity')
        amountString = self.safe_string(quote, 'quantity')
        type = 'quote'
        side = self.safe_string_lower(quote, 'side')
        marketId = self.safe_string(quote, 'instrument')
        symbol = self.safe_symbol(marketId, market)
        price = self.safe_number(quote, 'price')
        priceString = self.safe_string(quote, 'price')
        cost = self.parse_number(Precise.string_mul(priceString, amountString))
        status = None
        if validUntilTimestamp > self.milliseconds():
            status = 'open'
        else:
            status = 'closed'
        fee = None
        # self.calculate_fee(symbol, type, side, amount, price, takerOrMaker)  # no fees for B2C2
        if fee is not None:
            fee.cost = self.fee_to_precision(symbol, fee.cost)
        return self.safe_order({
            'info': quote,
            'rfqId': rfqId,
            'clientRfqId': clientRfqId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'validUntilTimestamp': validUntilTimestamp,
            'timeInForce': self.iso8601(validUntilTimestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'status': status,
            'fee': fee,
        })

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        # side: 'buy' | 'sell'
        # type: 'market' | 'limit'
        self.load_markets()
        market = self.market(symbol)
        lowercaseSide = side.lower()
        lowercaseType = type.lower()
        request = {
            'quantity': self.amount_to_precision(symbol, amount),
            'side': lowercaseSide,
            'instrument': market['id'],
            'order_type': None,
        }
        if lowercaseType == 'limit':
            request['order_type'] = 'FOK'
            request['price'] = self.price_to_precision(symbol, price)
        else:
            request['order_type'] = 'MKT'
        response = self.privatePostOrder(self.extend(request, params))
        return self.parse_order(response, market)

    def fetch_order(self, id, symbol=None, params={}):
        # [
        #     {
        #         order_id: 'dbeb3cc2-68a9-4364-9d80-91de5f1f2133',
        #         client_order_id: 'eba0fc09-0f51-4298-ab88-42c70eb2ba39',
        #         instrument: 'BTCUSD.SPOT',
        #         price: '40498.00000000',
        #         executed_price: '40477.00000000',
        #         quantity: '1.0000000000',
        #         side: 'buy',
        #         order_type: 'MKT',
        #         created: '2021-05-21T06:56:31.519896Z',
        #         trades: [
        #           {
        #             trade_id: '8862acae-834c-42da-986c-b4d1618dc016',
        #             rfq_id: null,
        #             cfd_contract: null,
        #             order: 'dbeb3cc2-68a9-4364-9d80-91de5f1f2133',
        #             quantity: '1.0000000000',
        #             side: 'buy',
        #             instrument: 'BTCUSD.SPOT',
        #             price: '40477.00000000',
        #             created: '2021-05-21T06:56:31.548302Z',
        #             origin: 'screen:mobile',
        #             executing_unit: ''
        #           }
        #         ],
        #         executing_unit: ''
        #       }
        # ]
        self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request = {'order_id_or_client_order_id': id}
        response = self.privateGetOrderOrderIdOrClientOrderId(self.extend(request, params))
        return self.parse_orders(response, market)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        marketId = None
        if symbol is not None:
            marketId = self.market(symbol)['id']
        # 'created__lt': None,
        # 'client_order_id': None,
        # 'order_type': None,
        # 'executing_unit': None,
        request = {
            # 'limit': limit,
        }
        if marketId is not None:
            request['instrument'] = marketId
        if since is not None:
            request['created__gte'] = self.iso8601(since)
        response = self.privateGetOrder(self.extend(request, params))
        response_next = self.fetch_recursively()
        if response_next is not None:
            response.append(response_next)
        return self.parse_orders(response, None, since, limit)

    def fetch_recursively(self):
        links = self.safe_string(self.last_response_headers, 'Link')
        print(links)
        next = None
        if links.find('next') >= 0:
            start = links.find('//') + 2
            end = links.find('>')
            next = links.substring(start, end)
            startsub = next.find('/') + 1
            next = next.substring(startsub)
        print(next)
        if next is not None:
            response = self.request(next, 'private', 'GET')
            response_next = self.fetch_recursively()
            if response_next is not None:
                response.append(response_next)
            return response
        else:
            return None

    def parse_order(self, order, market=None):
        # From fetchOrder(s)
        # [
        #     {
        #       "order_id": "373991c8-727d-4b55-94c2-eece7b81023c",
        #       "client_order_id": "fd76dbde-fdd5-40a9-9211-19eaa19653be",
        #       "instrument": "XRPUSD.SPOT",
        #       "price": "0.59525000",
        #       "executed_price": "0.59525000",
        #       "quantity": "1000.0000000000",
        #       "side": "buy",
        #       "order_type": "MKT",
        #       "created": "2021-07-23T13:36:24.885622Z",
        #       "executing_unit": ""
        #     },
        #
        # From a successful createOrder
        # {       order_id:   "e0bc5d5d-f285-42d3-aa85-6a1b76baf74c",
        # client_order_id:   "e21732d8-c62b-4922-841e-42c9e8ffdf40",
        #      instrument:   "ETHUSD.SPOT",
        #           price:    null,
        #  executed_price:   "3278.20000000",
        #        quantity:   "1.0000000000",
        #            side:   "buy",
        #      order_type:   "MKT",
        #         created:   "2021-09-13T04:55:38.095940Z",
        #  executing_unit:   "test1",
        #          trades: [{      trade_id: "2ec7679f-8e52-4020-a1fd-44ad3b24c0b3",
        #                              rfq_id:  null,
        #                        cfd_contract:  null,
        #                               order: "e0bc5d5d-f285-42d3-aa85-6a1b76baf74c",
        #                            quantity: "1.0000000000",
        #                                side: "buy",
        #                          instrument: "ETHUSD.SPOT",
        #                               price: "3278.20000000",
        #                             created: "2021-09-13T04:55:38.101368Z",
        #                              origin: "rest",
        #                      executing_unit: "test1"                                 }]}
        #
        id = self.safe_string(order, 'order_id')
        clientOrderId = self.safe_string(order, 'client_order_id')
        customer_id = self.safe_string(order, 'executing_unit')
        marketId = self.safe_string(order, 'instrument')
        symbol = self.safe_symbol(marketId, market)
        price = self.safe_number(order, 'price')
        averagepxString = self.safe_string(order, 'executed_price')
        averagepx = self.safe_number(order, 'executed_price')
        amountString = self.safe_string(order, 'quantity')
        amount = self.safe_number(order, 'quantity')
        side = self.safe_string_lower(order, 'side')
        type = self.safe_string_upper(order, 'order_type')
        if type == 'FOK':
            type = 'limit'
        else:
            type = 'market'
        timestamp = self.parse8601(self.safe_string(order, 'created'))
        filled = None
        status = None
        cost = None
        remaining = None
        takerOrMaker = 'taker'
        fee = None
        if averagepx is not None:
            status = 'closed'
            filled = amount
            cost = self.parse_number(Precise.string_mul(averagepxString, amountString))
            # fee = self.calculate_fee(symbol, type, side, filled, averagepx, takerOrMaker)  # no fees for B2C2
            if fee is not None:
                fee.cost = self.fee_to_precision(symbol, fee.cost)
        else:
            status = 'open'
            remaining = amount
        rawTrades = self.safe_value(order, 'trades', [])
        trades = None
        tradeParams = {
            'clientOrderId': clientOrderId,
            'type': type,
            'takerOrMaker': takerOrMaker,
        }
        if rawTrades is not None:
            trades = self.parse_trades(rawTrades, market, None, None, tradeParams)
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'customer_id': customer_id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'amount': amount,
            'cost': cost,
            'average': averagepx,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': trades,
        })

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        # 'created__gte': None,
        # 'created__lt': None,
        # 'since': None,  # need to map to markets
        # 'ordering': None,  # asc or desc, default desc
        # 'executing_unit': None,
        request = {
            'limit': limit,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['instrument'] = market['id']
        if since is not None:
            request['since'] = self.iso8601(since)
        response = self.privateGetTrade(self.extend(request, params))
        response_next = self.fetch_recursively()
        if response_next is not None:
            response.append(response_next)
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # When returned as part of the order object
        # {       order_id:   "e0bc5d5d-f285-42d3-aa85-6a1b76baf74c",
        # client_order_id:   "e21732d8-c62b-4922-841e-42c9e8ffdf40",
        #      instrument:   "ETHUSD.SPOT",
        #           price:    null,
        #  executed_price:   "3278.20000000",
        #        quantity:   "1.0000000000",
        #            side:   "buy",
        #      order_type:   "MKT",
        #         created:   "2021-09-13T04:55:38.095940Z",
        #  executing_unit:   "test1",
        #          trades: [{      trade_id: "2ec7679f-8e52-4020-a1fd-44ad3b24c0b3",
        #                              rfq_id:  null,
        #                        cfd_contract:  null,
        #                               order: "e0bc5d5d-f285-42d3-aa85-6a1b76baf74c",
        #                            quantity: "1.0000000000",
        #                                side: "buy",
        #                          instrument: "ETHUSD.SPOT",
        #                               price: "3278.20000000",
        #                             created: "2021-09-13T04:55:38.101368Z",
        #                              origin: "rest",
        #                      executing_unit: "test1"                                 }]}
        #
        # When returnes from fetchmytrades
        # {"trade_id":"2ec7679f-8e52-4020-a1fd-44ad3b24c0b3",
        # "rfq_id":null,
        # "order":"e0bc5d5d-f285-42d3-aa85-6a1b76baf74c",
        # "quantity":"1.0000000000",
        # "side":"buy",
        # "instrument":"ETHUSD.SPOT",
        # "price":"3278.20000000",
        # "created":"2021-09-13T04:55:38.101368Z",
        # "end_client_id":"",
        # "client_rfq_id":null,
        # "client_order_id":"e21732d8-c62b-4922-841e-42c9e8ffdf40",
        # "user":"Demo_Leonie",
        # "origin":"rest",
        # "executing_unit":"test1"},
        #
        id = self.safe_string(trade, 'trade_id')
        amountString = self.safe_string(trade, 'quantity')
        amount = self.parse_number(amountString)
        side = self.safe_string_lower(trade, 'side')
        marketId = self.safe_string(trade, 'instrument')
        symbol = self.safe_symbol(marketId, market)
        priceString = self.safe_string(trade, 'price')
        price = self.parse_number(priceString)
        timestamp = self.parse8601(self.safe_string(trade, 'created'))
        orderId = self.safe_string(trade, 'order')
        clientOrderId = self.safe_string(trade, 'client_order_id')  # parent order must provide in params override
        customer_id = self.safe_string(trade, 'executing_unit')
        cost = self.parse_number(Precise.string_mul(priceString, amountString))
        type = self.safe_string(trade, 'type')  # parent order must provide in params override
        takerOrMaker = self.safe_string(trade, 'takerOrMaker')  # parent order must provide in params override
        fee = None
        # self.calculate_fee(symbol, type, side, amount, price, takerOrMaker)  # no fees for B2C2
        if fee is not None:
            fee.cost = self.fee_to_precision(symbol, fee.cost)
        return {
            'info': trade,
            'id': id,
            'customer_id': customer_id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': orderId,
            'clientOrderId': clientOrderId,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'takerOrMaker': takerOrMaker,
            'fee': fee,
        }

    def parse_ledger_entry_type(self, type):
        # Currently four types of ledgers are possible:
        # trade(ledger resulting of a trade, there are two ledgers per trade)
        # transfer(either you sent funds to B2C2, or B2C2 sent you funds)
        # funding(funding rate charged for your open positions if you have some, CFD only)
        # realised_pnl(Realised P&L, CFD only)
        types = {
            'transfer': 'transaction',
            'funding': 'funding',
            'realised_pnl': 'margin',
            'trade': 'trade',
        }
        return self.safe_string(types, type, type)

    def parse_ledger_entry(self, item, currency=None):
        # [
        #     {
        #       "transaction_id": "3b8c41be-1bae-45aa-a6fb-86fce3ebef85",
        #       "created": "2021-07-23T13:36:24.889949Z",
        #       "reference": "57912eaf-02dc-461f-ad0d-8c636c01c997",
        #       "currency": "USD",
        #       "amount": "-595.2500000000000000",
        #       "type": "trade",
        #       "group": "trading"
        #     },
        #     {
        #       "transaction_id": "cd92a3d5-a782-4bb2-86b2-815d76667658",
        #       "created": "2021-07-23T13:36:24.889949Z",
        #       "reference": "57912eaf-02dc-461f-ad0d-8c636c01c997",
        #       "currency": "XRP",
        #       "amount": "1000.0000000000000000",
        #       "type": "trade",
        #       "group": "trading"
        #     },
        id = self.safe_string(item, 'transaction_id')
        timestamp = self.parse8601(self.safe_string(item, 'created'))
        referenceId = self.safe_string(item, 'reference')
        currencyId = self.safe_string(item, 'currency')
        code = self.safe_currency_code(currencyId, currency)  # not sure why we need the currency param?!
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        account = self.safe_string(item, 'group')
        amount = self.safe_number(item, 'amount')
        direction = None
        if amount < 0:
            direction = 'out'
            amount = abs(amount)
        else:
            direction = 'in'
        # status = self.parseTransactionStatus(self.safe_string(item, 'transactStatus'))
        return {
            'id': id,
            'info': item,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'direction': direction,
            'account': account,
            'referenceId': referenceId,
            'referenceAccount': None,
            'type': type,
            'currency': code,
            'amount': amount,
            'before': None,
            'after': None,
            'status': 'settled',
            'fee': None,
        }

    def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        if code is not None:
            currency = self.currency(code)
        # We don't need to put these in request, python sends
        # 'created__lt': None,
        # 'type': None,
        request = {
            'limit': limit,
        }
        if since is not None:
            request['since'] = since
            request['created__gte'] = since
        if currency is not None:
            request['currency'] = currency['code']
        response = self.privateGetLedger(self.extend(request, params))
        response_next = self.fetch_recursively()
        if response_next is not None:
            response.append(response_next)
        return self.parse_ledger(response, currency, since, limit)

    def withdraw(self, code, amount, address, tag=None, params={}):
        # Request a settlement for a given amount to the given destination in a given currency.
        # Your account must exhibit a sufficient balance in the requested currency.
        # Note that for non approved addresses, the amount can only be lower than 0.1.
        # The address_protocol parameter is either “Omni” or “ERC20” and only used for UST settlement requests.
        # For other currencies, leave null. The address_suffix is the memo or the tag of the address as entered on the website.
        # post_data = {
        #     'amount': '1000',
        #     'currency': 'XRP',
        #     'destination_address': {
        #         'address_value': 'rUQngTebGgF1tCexhuPaQBr5MufweybMom',
        #         'address_suffix': 'tag0',
        #         'address_protocol': None
        #     }
        # }
        # Fiat withdrawal
        # post_data = {
        #     'amount': '1000',
        #     'currency': 'USD',
        #     'destination_bank_account': 'USD Bank Account'
        # }
        # Response:
        # {
        #     "amount": "1000.00000000",
        #     "currency": "XRP",
        #     "withdrawal_id": "5c7e90cc-a8d6-4db5-8348-44053b2dcbdf",
        #     "reference": "",
        #     "settled": False,
        #     "created": "2021-06-09T09:46:00.162599Z",
        #     "destination_address": {
        #       "address_value": "rUQngTebGgF1tCexhuPaQBr5MufweybMom",
        #       "address_suffix": "tag0",
        #       "address_protocol": null
        #     },
        #     "destination_bank_account": null
        #   }
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        request = {
            'amount': amount,
            'currency': currency['id'],
        }
        dest = {
            'address_value': address,
        }
        if tag is not None:
            request['addressTag'] = tag
        if currency == 'UST':
            request['address_protocol'] = 'ERC20'
        request['destination_address'] = dest
        response = self.privatePostWithdrawal(self.extend(request, params))
        return {
            'info': response,
            'id': self.safe_string(response, 'withdrawal_id'),
        }

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        request = {
            'limit': limit,
        }
        response = self.privateGetWithdrawal(self.extend(request, params))
        response_next = self.fetch_recursively()
        if response_next is not None:
            response.append(response_next)
        return self.parseWithdrawals(response, currency, since, limit)

    def parse_withdrawal(self, transaction, currency=None):
        # [
        #     {
        #       "amount": "2.00000000",
        #       "currency": "BTC",
        #       "destination_address": "0xC323E80eF4deC2195G239F4f1e830417D294F841",
        #       "destination_bank_account": null,
        #       "reference": "",
        #       "settled": False,
        #       "created": "2021-06-09T09:46:00.162599Z",
        #       "withdrawal_id": "ed846746-f7e0-4af9-85bb-36732e60d6d8"
        #     },
        #     {
        #       "amount": "10.00000000",
        #       "currency": "BTC",
        #       "destination_address": null,
        #       "destination_bank_account": "EUR BA",
        #       "reference": "",
        #       "settled": True,
        #       "created": "2021-06-09T09:46:00.162599Z",
        #       "withdrawal_id": "b4426ff2-19c6-48ca-8b07-2c344dc34ecb"
        #     }
        #   ]
        amount = self.safe_number(transaction, 'amount')
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        address = self.safe_string(transaction, 'destination_address')
        updated = None
        tag = self.safe_string(transaction, 'reference')  # set but unused
        if tag is not None:
            if len(tag) < 1:
                tag = None
        status = 'pending'
        if transaction['settled'] is True:
            status = 'settled'
        timestamp = self.parse8601(self.safe_string(transaction, 'applyTime'))
        id = self.safe_string(transaction, 'withdrawal_id')
        return {
            'info': transaction,
            'id': id,
            'txid': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'addressTo': address,
            'addressFrom': None,
            'tag': tag,
            'tagTo': tag,
            'tagFrom': None,
            'type': 'withdrawal',
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'internal': False,
            'fee': None,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        query = self.omit(params, self.extract_params(path))
        url = self.implode_hostname(self.urls['api'][api]) + '/'
        url += self.implode_params(path, params)
        if api == 'private':
            if method == 'GET':
                headers = {
                    'Authorization': 'Token ' + self.apiKey,
                }
                if query:
                    url += '?' + self.urlencode(query)
            elif method == 'POST':
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': 'Token ' + self.apiKey,
                }
                if params:
                    body = self.json(query)
        r = {'url': url, 'method': method, 'body': body, 'headers': headers}
        return r
