# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import time
import math
import json
from ccxt.base.errors import ExchangeError


class excraft (Exchange):

    def describe(self):
        return self.deep_extend(super(excraft, self).describe(), {
            'id': 'excraft',
            'name': 'ExCraft',
            'countries': ['HK', 'UK'],
            'has': {
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchTickers': True,
            },
            'urls': {
                'api': {
                    'rest': 'https://www.excraft.com/apis/trading/v1',
                },
                'www': 'https://www.excraft.com',
                'doc': 'https://github.com/ExCraftExchange/ExCraftExchange-REST-API',
                'fees': 'https://www.excraft.com/faq/fee',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'markets/{market}/status_today',
                        'markets/status_today',
                        'markets/{market}/trades',
                        'markets/{market}/depth',
                    ],
                },
                'private': {
                    'post': [
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
                'funding': {
                    'withdraw': {
                        "BTC": 0.0005,
                        "ETH": 0.01,
                        "BCH": 0.0001,
                        "LTC": 0.001,
                        "HSR": 0.001,
                        "EOS": 0.1,
                        "EXT": 500,
                        "OMG": 1,
                        "ZRX": 10,
                        "BAT": 20,
                        "KNC": 10,
                        "BNT": 2,
                        "MANA": 50,
                        "CTXC": 20,
                        "REP": 0.2,
                        "GNT": 20,
                        "LRC": 50,
                        "ENG": 5,
                        "NPXS": 2000,
                        "PAY": 5
                    },
                },
            },
            'exceptions': {

            },
            'errorMessages': {

            },
            'options': {
                'quoteIds': ['btc', 'eth'],
            },
            'commonCurrencies': {
                'JBC': 'JubaoCoin',
            },
        })

    async def fetch_markets(self):
        data = await self.publicGetMarkets()
        result = {}
        for item in data["markets"]:
            baseId = item["base"]
            quoteId = item["quote"]
            market = item["name"]

            base = baseId.upper()
            quote = quoteId.upper()
            symbol = base + "/" + quote

            precision = {
                'amount': 8,
                'price': 8,
            }

            result[symbol] = {
                'id': baseId + quoteId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'precision': precision,
                'limits': {
                        'amount': {
                            'min': math.pow(10, -precision['amount']),
                            'max': math.pow(10, precision['amount']),
                        },
                        'price': {
                            'min': math.pow(10, -precision['price']),
                            'max': math.pow(10, precision['price']),
                        },
                        'cost': {
                            'min': None,
                            'max': None,
                        },
                },
                'info': market,
            }
        return result

    def parse_ticker(self, ticker, symbol, market=None):
        timestamp = time.time()
        close = self.safe_float(ticker, "last")
        open = self.safe_float(ticker, "open")

        if (open is not None) and(close is not None):
            change = close - open
            average = self.sum(open, close) / 2
            if (close is not None) and(close > 0):
                percentage = (change / open) * 100
        baseVolume = self.safe_float(ticker, 'volume')

        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'last'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'last'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': self.safe_float(ticker, 'last'),
            'last': self.safe_float(ticker, 'last'),
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': baseVolume,
            'quoteVolume': None,
            'info': ticker,
        }

    async def fetch_ticker(self, symbol, params={}):
        symbol = symbol.replace("/", "").upper()
        ticker = await self.publicGetMarketsMarketStatusToday(self.extend({
            'market': symbol
        }, params))
        return self.parse_ticker(ticker, symbol)

    async def fetch_tickers(self, symbols=None, params={}):
        data = await self.publicGetMarketsStatusToday()
        result = {}
        tickers = data["markets"]
        for i in range(0, len(tickers)):
            ticker = tickers[i]
            result[ticker["name"]] = self.parse_ticker(ticker, ticker["name"])
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        symbol = symbol.replace("/", "").upper()
        orderbook = await self.publicGetMarketsMarketDepth(self.extend({
            'market': symbol
        }, params))
        return self.parse_order_book(orderbook,price_key="price", amount_key="amount")

    def parse_trade_type(self, type):
        if type == 1:
            return "sell"
        else:
            return "buy"

    def parse_trade(self, trade, market=None):
        timestamp = int(trade['timestamp']) * 1000
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        symbol = market
        cost = amount * price
        return {
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string(trade, 'id'),
            'order': None,
            'type': 'limit',
            'side': self.parse_trade_type(trade['side']),
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
            'info': trade,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        symbol = symbol.replace("/", "").upper()
        data = await self.publicGetMarketsMarketTrades(self.extend({
            'market': symbol
        }, params))

        result = []
        trades = data["trades"]
        for i in range(0, len(trades)):
            trade = trades[i]
            trade = self.parse_trade(trade, symbol)
            result.append(trade)

        result = self.sort_by(result, 'timestamp')
        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        apiType = 'rest'
        if api == 'web':
            apiType = api
        url = self.urls['api'][apiType] + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public' or api == 'web':
            if api == 'web':
                query['t'] = self.nonce()
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            query = self.urlencode(self.extend({
                'key': self.apiKey,
                'nonce': self.nonce(),
            }, query))
            secret = self.hash(self.encode(self.secret))
            signature = self.hmac(self.encode(query), self.encode(secret))
            query += '&' + 'signature=' + signature
            if method == 'GET':
                url += '?' + query
            else:
                headers = {
                    'Content-type': 'application/x-www-form-urlencoded',
                }
                body = query
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body):
        # checks against error codes
        if not isinstance(body, basestring):
            return
        if len(body) == 0:
            return
        if body[0] != '{':
            return
        response = json.loads(body)
        result = self.safe_value(response, 'result')
        if result is None:
            return
        if result is True:
            # success
            return
        errorCode = self.safe_string(response, 'code')
        errorMessages = self.errorMessages
        message = self.safe_string(errorMessages, errorCode, 'Unknown Error')
        if errorCode in self.exceptions:
            raise self.exceptions[errorCode](self.id + ' ' + message)
        else:
            raise ExchangeError(self.id + ' ' + message)
