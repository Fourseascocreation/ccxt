# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class litebitpro(Exchange):

    def describe(self):
        return self.deep_extend(super(litebitpro, self).describe(), {
            'id': 'litebitpro',
            'name': 'LiteBit Pro',
            'countries': ['NL'],  # Netherlands
            'rateLimit': 60.1,  # 1000 requests per second TODO: we don't have a global rate limit across all endpoints
            'version': 'v1',
            'certified': False,
            'pro': False,
            'has': {
                'cancelAllOrders': True,
                'cancelOrder': True,
                'CORS': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFees': True,
            },
            'timeframes': {
                '1m': '60',
                '5m': '300',
                '15m': '900',
                '1h': '3600',
                '4h': '14400',
                '1d': '86400',
            },
            'urls': {
                # TODO
                'logo': 'TODO',
                'api': {
                    'public': 'https://api.pro.liteaccept.nl',
                    'private': 'https://api.pro.liteaccept.nl',
                },
                'www': 'https://pro.litebit.com/',
                'doc': 'https://docs.pro.litebit.com/',
                # TODO
                'fees': 'TODO',
                # TODO
                'referral': 'TODO',
            },
            'api': {
                'public': {
                    'get': {
                        'time': 1,
                        'currencies': 1,
                        'markets': 1,
                        'ticker': 1,
                        'tickers': 1,
                        'book': 1,
                        'candles': 1,
                        'trades': 1,
                    },
                },
                'private': {
                    'get': {
                        'orders/open': 1,
                        'orders/closed': 1,
                        'order': 1,
                        'fills': 1,
                        'fee': 1,
                        'balances': 1,
                    },
                    'post': {
                        'order': 1,
                    },
                    'delete': {
                        'orders': 1,
                    },
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'exceptions': {
                'exact': {
                    '10000': BadRequest,  # This error code is used for validation errors. See message for more information about the validation error.
                    '10001': InvalidOrder,  # The notional value of your order is too low. Use GET /market's minimum_amount_quote to retrieve the market's minimum notional value.
                    '10002': InvalidOrder,  # Order time in force is missing.
                    '10003': OnMaintenance,  # Post-only is only allowed for limit orders.
                    '10004': InvalidOrder,  # Price must be higher than zero.
                    '10005': InvalidOrder,  # Price is required for limit orders.
                    '10006': InvalidOrder,  # Type is required for orders.
                    '10007': InvalidNonce,  # Time window cannot be smaller than 1 or larger than 60000 milliseconds.
                    '10008': AuthenticationError,  # Unauthenticated.
                    '10009': PermissionDenied,  # Unauthorized.
                    '10010': BadRequest,  # Invalid JSON.
                    '10011': BadRequest,  # Invalid event.
                    '10012': BadRequest,  # Invalid channel.
                    '10013': AuthenticationError,  # Any of: Could not derive authentication method. Invalid API key and/or signature. Invalid timestamp. Invalid API key. Invalid signature. Connection is already authenticated.
                    '20000': InsufficientFunds,  # Insufficient funds.
                    '20001': DDoSProtection,  # Maximum of open orders allowed per user per market.
                    '20002': ExchangeError,  # Insufficient liquidity.
                    '20003': RateLimitExceeded,  # Rate limit exceeded.
                    '20004': ExchangeNotAvailable,  # Transient request error without any available public information.
                    '30000': OnMaintenance,  # Exchange is in maintenance mode.
                    '30001': ExchangeError,  # An unexpected error occurred. The execution status of your request is unknown.
                    '40000': OnMaintenance,  # Only post-only orders are currently accepted by the matching engine.
                    '40001': OnMaintenance,  # Only cancel order requests are currently accepted by the matching engine.
                    '40002': ExchangeError,  # Order book limit reached, only taker orders are allowed.
                    '40003': ExchangeNotAvailable,  # Market overloaded.
                    '40004': OnMaintenance,  # Market is halted.
                    '40005': OnMaintenance,  # Market is inactive.
                    '50000': AuthenticationError,  # Your request was rejected, because it was received outside the allowed time window.
                },
                'broad': {
                },
            },
            'options': {
                'LITEBIT-WINDOW': 10000,  # default 10 sec
                'fetchCurrencies': {
                    'expires': 1000,  # 1 second
                },
            },
            'precisionMode': TICK_SIZE,
        })

    def fetch_time(self, params={}):
        response = self.publicGetTime(params)
        #
        #     {"timestamp":1641228475856}
        #
        return self.safe_integer(response, 'timestamp')

    def fetch_markets(self, params={}):
        response = self.publicGetMarkets(params)
        #
        # [
        #    {
        #       "market":"BTC-EUR",
        #       "status":"active",
        #       "step_size":"0.00000001",
        #       "tick_size":"0.01",
        #       "minimum_amount_quote":"5.00",
        #       "base_currency":"BTC",
        #       "quote_currency":"EUR"
        #    }
        # ]
        #
        result = []
        for i in range(0, len(response)):
            market = response[i]
            id = self.safe_string(market, 'market')
            baseId = self.safe_string(market, 'base_currency')
            quoteId = self.safe_string(market, 'quote_currency')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            status = self.safe_string(market, 'status')
            active = (status == 'active')
            precision = {
                'price': self.safe_number(market, 'tick_size'),
                'amount': self.safe_number(market, 'step_size'),
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'type': 'spot',
                'spot': True,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': self.safe_number(market, 'minimum_amount_quote'),
                        'max': None,
                    },
                },
            })
        return result

    def fetch_currencies_from_cache(self, params={}):
        # self method is now redundant
        # currencies are now fetched before markets
        options = self.safe_value(self.options, 'fetchCurrencies', {})
        timestamp = self.safe_integer(options, 'timestamp')
        expires = self.safe_integer(options, 'expires', 1000)
        now = self.milliseconds()
        if (timestamp is None) or ((now - timestamp) > expires):
            response = self.publicGetCurrencies(params)
            self.options['fetchCurrencies'] = self.extend(options, {
                'response': response,
                'timestamp': now,
            })
        return self.safe_value(self.options['fetchCurrencies'], 'response')

    def fetch_currencies(self, params={}):
        response = self.fetch_currencies_from_cache(params)
        #
        # [
        #    {
        #       "code":"EUR",
        #       "name":"Euro",
        #       "decimals":"2"
        #    }
        # ]
        #
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'code')
            code = self.safe_currency_code(id)
            name = self.safe_string(currency, 'name')
            precision = self.safe_integer(currency, 'decimals')
            result[code] = {
                'id': id,
                'info': currency,
                'code': code,
                'name': name,
                'active': None,
                'fee': None,
                # convert number of decimals to precision mode TICK_SIZE
                'precision': math.pow(10, -precision),
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
            }
        return result

    def fetch_trading_fees(self, params={}):
        self.load_markets()
        response = self.privateGetFee(params)
        #
        # {
        #     "maker": "0.15",
        #     "taker": "0.25",
        #     "volume": "11.70"
        # }
        #
        result = {}
        maker = self.safe_number(response, 'maker')
        if maker is not None:
            # convert to ratio
            maker = maker / 100
        taker = self.safe_number(response, 'taker')
        if taker is not None:
            # convert to ratio
            taker = taker / 100
        for i in range(0, len(self.symbols)):
            symbol = self.symbols[i]
            result[symbol] = {
                'maker': maker,
                'taker': taker,
                'info': response,
                'symbol': symbol,
            }
        return result

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        response = self.publicGetTicker(self.extend(request, params))
        # {
        #    "market":"BTC-EUR",
        #    "open":"43234.98",
        #    "last":"42213.20000000",
        #    "volume":"29981.04495099",
        #    "low":"40882.22",
        #    "high":"43986.34",
        #    "bid":"41781.32",
        #    "ask":"42213.20"
        # }
        return self.parse_ticker(response, market)

    def parse_ticker(self, ticker, market=None):
        #
        # fetchTicker
        #
        # {
        #    "market":"BTC-EUR",
        #    "open":"43234.98",
        #    "last":"42213.20000000",
        #    "volume":"29981.04495099",
        #    "low":"40882.22",
        #    "high":"43986.34",
        #    "bid":"41781.32",
        #    "ask":"42213.20"
        # }
        #
        marketId = self.safe_string(ticker, 'market')
        symbol = self.safe_symbol(marketId, market, '-')
        last = self.safe_number(ticker, 'last')
        baseVolume = self.safe_number(ticker, 'volume')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': None,
            'datetime': None,
            'high': self.safe_number(ticker, 'high'),
            'low': self.safe_number(ticker, 'low'),
            'bid': self.safe_number(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_number(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_number(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': None,
            'info': ticker,
        }, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetTickers(params)
        # [
        #    {
        #       "market":"BTC-EUR",
        #       "open":"43346.43",
        #       "last":"42046.58000000",
        #       "volume":"30006.37834551",
        #       "low":"40882.22",
        #       "high":"43986.34",
        #       "bid":"41946.08",
        #       "ask":"42046.58"
        #    }
        # ]
        return self.parse_tickers(response, symbols)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            # 'limit': 200,  # default 200, max 200
            # 'timestamp_from': since,
            # 'timestamp_to': self.milliseconds(),
        }
        if limit is not None:
            request['limit'] = limit
        if since is not None:
            request['timestamp_from'] = since
        response = self.publicGetTrades(self.extend(request, params))
        # [
        #    {
        #       "uuid":"c28a37e2-69d1-4844-ad37-b8f08311478d",
        #       "amount":"0.36636292",
        #       "price":"41551.23000000",
        #       "side":"sell",
        #       "market":"BTC-EUR",
        #       "timestamp":1640788080819
        #    }
        # ]
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        # {
        #    "uuid":"c28a37e2-69d1-4844-ad37-b8f08311478d",
        #    "amount":"0.36636292",
        #    "price":"41551.23000000",
        #    "side":"sell",
        #    "market":"BTC-EUR",
        #    "timestamp":1640788080819
        # }
        #
        # fetchMyTrades(private)
        #
        # {
        #     "uuid": "234234897234-1243-1234-qsf234",
        #     "order_uuid": "234234897234-1243-1234-qsf235",
        #     "amount": "0.00100000",
        #     "price": "42986.64",
        #     "amount_quote": "43.09410660",
        #     "side": "buy",
        #     "fee": "0.10746660",
        #     "market": "BTC-EUR",
        #     "liquidity": "taker",
        #     "timestamp": 1622123573863
        # }
        #
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string(trade, 'amount')
        timestamp = self.safe_integer(trade, 'timestamp')
        side = self.safe_string(trade, 'side')
        id = self.safe_string(trade, 'uuid')
        marketId = self.safe_string(trade, 'market')
        symbol = self.safe_symbol(marketId, market, '-')
        takerOrMaker = self.safe_string(trade, 'liquidity')
        feeCurrency = None
        if market is not None:
            feeCurrency = market['quote']
        fee = {
            'cost': self.safe_string(trade, 'fee'),
            'currency': feeCurrency,
        }
        feeString = self.safe_string(trade, 'fee')
        amountQuote = self.safe_string(trade, 'amount_quote')
        cost = None
        if amountQuote is not None and feeString is not None:
            if side == 'buy':
                cost = Precise.string_sub(amountQuote, feeString)
            else:
                cost = Precise.string_add(amountQuote, feeString)
        orderId = self.safe_string(trade, 'order_uuid')
        return self.safe_trade({
            'info': trade,
            'id': id,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'order': orderId,
            'type': None,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': priceString,
            'amount': amountString,
            'cost': cost,
            'fee': fee,
        }, market)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'market': self.market_id(symbol),
        }
        if limit is not None:
            raise NotSupported(self.id + ' fetchOrderBook() doesn\'t support the limit parameter.')
        response = self.publicGetBook(self.extend(request, params))
        #
        # {
        #     "market": "BTC-EUR",
        #     "timestamp": 1622123573863,
        #     "sequence": 1231232,
        #     "update_type": "snapshot",
        #     "bids": [
        #         ["2.0000", "201.99000000"],
        #         ...,
        #     ],
        #     "asks": [
        #         ["2.0000", "201.99000000"],
        #         ...,
        #     ]
        # }
        #
        orderbook = self.parse_order_book(
            response,
            symbol,
            self.safe_integer(response, 'timestamp')
        )
        orderbook['nonce'] = self.safe_integer(response, 'sequence')
        return orderbook

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     [
        #         1590383700000,
        #         "8088.5",
        #         "8088.5",
        #         "8088.5",
        #         "8088.5",
        #         "0.04788623"
        #     ]
        #
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 5),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'interval': self.timeframes[timeframe],
            # 'limit': 1440,  # default 500, max 500
            # 'timestamp_from': since,
            # 'timestamp_to': self.milliseconds(),
        }
        if since is not None:
            request['timestamp_from'] = since
        if limit is not None:
            request['limit'] = limit  # default 500, max 500
        response = self.publicGetCandles(self.extend(request, params))
        #
        #     [
        #         [1590383700000,"8088.5","8088.5","8088.5","8088.5","0.04788623"],
        #         [1590383580000,"8091.3","8091.5","8091.3","8091.5","0.04931221"],
        #         [1590383520000,"8090.3","8092.7","8090.3","8092.5","0.04001286"],
        #     ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetBalances(params)
        #
        # [
        #    {
        #       "available":"7716.93507952",
        #       "reserved":"2155.37500000",
        #       "total":"9872.31007952",
        #       "currency":"EUR"
        #    }
        # ]
        #
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        for i in range(0, len(response)):
            balance = response[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'reserved')
            account['total'] = self.safe_string(balance, 'total')
            result[code] = account
        return self.parse_balance(result)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'side': side,
            'type': type,  # limit, market
            # 'amount': self.amount_to_precision(symbol, amount),
            # 'amount_quote': self.cost_to_precision(symbol, cost),
            # 'price': self.price_to_precision(symbol, price),
            # 'stop': 'loss',  # "entry" = trigger when the last price is greater than or equal to stop_price. "loss" = trigger when the last price is less than or equal to stop_price.
            # 'stop_price': self.price_to_precision(symbol, price),
            # 'post_only': False,
            # 'time_in_force': 'gtc',  # gtc, ioc, fok, day, gtd
            # 'expire_at': expireAt,
            # 'client_id': clientId,
        }
        stop = self.safe_string(params, 'stop')
        if stop is not None:
            stopPrice = self.safe_number_2(params, 'stopPrice', 'stop_price')
            if stopPrice is None:
                raise ArgumentsRequired(self.id + ' createOrder requires a stopPrice parameter for a stop order')
            request['stop'] = stop
            request['stop_price'] = self.price_to_precision(symbol, stopPrice)
        postOnly = self.safe_value_2(params, 'postOnly', 'post_only', False)
        if postOnly:
            request['post_only'] = True
        timeInForce = self.safe_string_2(params, 'timeInForce', 'time_in_force')
        if timeInForce is not None:
            request['time_in_force'] = timeInForce
            if timeInForce == 'gtd':
                expireAt = self.safe_number_2(params, 'expireAt', 'expire_at')
                if expireAt is None:
                    raise ArgumentsRequired(self.id + ' createOrder requires a expireAt parameter for a ' + timeInForce + ' order')
                request['expire_at'] = expireAt
        clientId = self.safe_string_2(params, 'client_id', 'clientOrderId')
        if clientId is not None:
            request['client_id'] = clientId
        params = self.omit(params, ['stop', 'stopPrice', 'stop_price', 'postOnly', 'post_only', 'timeInForce', 'time_in_force', 'expireAt', 'expire_at', 'client_id', 'clientOrderId'])
        if type == 'market':
            cost = None
            if price is not None:
                cost = amount * price
            else:
                cost = self.safe_number_2(params, 'amountQuote', 'amount_quote')
            if cost is not None:
                precision = market['precision']['price']
                request['amount_quote'] = self.decimal_to_precision(cost, TRUNCATE, precision, self.precisionMode)
            else:
                request['amount'] = self.amount_to_precision(symbol, amount)
            params = self.omit(params, ['amountQuote', 'amount_quote'])
        elif type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
            request['amount'] = self.amount_to_precision(symbol, amount)
        response = self.privatePostOrder(self.extend(request, params))
        #
        # {
        #     "uuid": "69d353dc-a80f-491e-b5cf-d2589682664e",
        #     "amount": "0.01000000",
        #     "amount_filled": "0.00000000",
        #     "amount_quote_filled": "0.00000000",
        #     "fee": "0.00000000",
        #     "price": "1000.00",
        #     "side": "buy",
        #     "type": "limit",
        #     "status": "open",
        #     "filled_status": "not_filled",
        #     "cancel_status": null,
        #     "stop": "entry",
        #     "stop_hit": False,
        #     "stop_price": "800.00",
        #     "post_only": True,
        #     "time_in_force": "gtd",
        #     "created_at": 1637147943854,
        #     "updated_at": 1637147943854,
        #     "expire_at": 1625038240391,
        #     "market": "BTC-EUR",
        #     "client_id": "d22a7a4e-c28b-40f5-a5a4-79ca8a4fc41c"
        # }
        #
        return self.parse_order(response, market)

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'orders': [id],
            'market': market['id'],
        }
        self.privateDeleteOrders(self.extend(request, params))
        #
        # <empty response>
        #

    def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['market'] = market['id']
        self.privateDeleteOrders(self.extend(request, params))
        #
        # <empty response>
        #

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'uuid': id,
            'market': market['id'],
        }
        response = self.privateGetOrder(self.extend(request, params))
        #
        # {
        #     "uuid": "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        #     "amount": "0.49875000",
        #     "amount_filled": "0.00000000",
        #     "amount_quote_filled": "0.00000000",
        #     "fee": "0.00000000",
        #     "price": "0.0000",
        #     "side": "buy",
        #     "type": "market",
        #     "status": "open",
        #     "filled_status": "not_filled",
        #     "cancel_status": null,
        #     "stop": null,
        #     "stop_hit": null,
        #     "stop_price": null,
        #     "post_only": False,
        #     "time_in_force": "gtc",
        #     "created_at": 1620112337000,
        #     "updated_at": 1620112337000,
        #     "expire_at": null,
        #     "market": "BTC-EUR",
        #     "client_id": null
        # }
        #
        return self.parse_order(response, market)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchClosedOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            # 'limit': 200,  # default 200, max 200
            # 'created_at_from': since,
            # 'created_at_to': self.milliseconds(),
        }
        if since is not None:
            request['created_at_from'] = since
        if limit is not None:
            request['limit'] = limit  # default 200, max 200
        response = self.privateGetOrdersClosed(self.extend(request, params))
        #
        # [
        #     {
        #         "uuid": "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        #         "amount": "0.49875000",
        #         "amount_filled": "0.00000000",
        #         "amount_quote_filled": "0.00000000",
        #         "fee": "0.00000000",
        #         "price": "0.0000",
        #         "side": "buy",
        #         "type": "market",
        #         "status": "closed",
        #         "filled_status": "not_filled",
        #         "cancel_status": null,
        #         "stop": null,
        #         "stop_hit": null,
        #         "stop_price": null,
        #         "post_only": False,
        #         "time_in_force": "gtc",
        #         "created_at": 1620112337000,
        #         "updated_at": 1620112337000,
        #         "expire_at": null,
        #         "market": "BTC-EUR",
        #         "client_id": null
        #     }
        # ]
        #
        return self.parse_orders(response, market, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'market': market['id'],
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['market'] = market['id']
        response = self.privateGetOrdersOpen(self.extend(request, params))
        #
        # [
        #     {
        #         "uuid": "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        #         "amount": "0.49875000",
        #         "amount_filled": "0.00000000",
        #         "amount_quote_filled": "0.00000000",
        #         "fee": "0.00000000",
        #         "price": "0.0000",
        #         "side": "buy",
        #         "type": "market",
        #         "status": "open",
        #         "filled_status": "not_filled",
        #         "cancel_status": null,
        #         "stop": null,
        #         "stop_hit": null,
        #         "stop_price": null,
        #         "post_only": False,
        #         "time_in_force": "gtc",
        #         "created_at": 1620112337000,
        #         "updated_at": 1620112337000,
        #         "expire_at": null,
        #         "market": "BTC-EUR",
        #         "client_id": null
        #     }
        # ]
        #
        return self.parse_orders(response, market, since, limit)

    def parse_order_status(self, status, cancelStatus):
        if cancelStatus is not None:
            return 'canceled'
        statuses = {
            'created': 'open',
            'open': 'open',
            'closed': 'closed',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        # createOrder, fetchOrder, fetchOpenOrders, fetchClosedOrders
        #
        # {
        #     "uuid": "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        #     "amount": "0.49875000",
        #     "amount_filled": "0.00000000",
        #     "amount_quote_filled": "0.00000000",
        #     "fee": "0.00000000",
        #     "price": "0.0000",
        #     "side": "buy",
        #     "type": "market",
        #     "status": "open",
        #     "filled_status": "not_filled",
        #     "cancel_status": null,
        #     "stop": null,
        #     "stop_hit": null,
        #     "stop_price": null,
        #     "post_only": False,
        #     "time_in_force": "gtc",
        #     "created_at": 1620112337000,
        #     "updated_at": 1620112337000,
        #     "expire_at": null,
        #     "market": "BTC-EUR",
        #     "client_id": null
        # }
        #
        id = self.safe_string(order, 'uuid')
        clientOrderId = self.safe_string(order, 'client_id')
        timestamp = self.safe_integer(order, 'created_at')
        marketId = self.safe_string(order, 'market')
        market = self.safe_market(marketId, market, '-')
        symbol = market['symbol']
        status = self.parse_order_status(self.safe_string(order, 'status'), self.safe_string(order, 'cancel_status'))
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'type')
        price = self.safe_string(order, 'price')
        amount = self.safe_string(order, 'amount')
        filled = self.safe_string(order, 'amount_filled')
        fee = None
        feeNumber = self.safe_number(order, 'fee')
        if feeNumber is not None:
            feeCurrencyCode = None
            if market is not None:
                feeCurrencyCode = market['quote']
            fee = {
                'cost': feeNumber,
                'currency': feeCurrencyCode,
            }
        feeString = self.safe_string(order, 'fee')
        amountQuoteFilled = self.safe_string(order, 'amount_quote_filled')
        cost = None
        if amountQuoteFilled is not None and feeString is not None:
            if side == 'buy':
                cost = Precise.string_sub(amountQuoteFilled, feeString)
            else:
                cost = Precise.string_add(amountQuoteFilled, feeString)
        timeInForce = self.safe_string(order, 'time_in_force')
        postOnly = self.safe_value(order, 'post_only')
        stopPrice = self.safe_number(order, 'stop_price')
        return self.safe_order2({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'timeInForce': timeInForce,
            'postOnly': postOnly,
            'side': side,
            'price': price,
            'stopPrice': stopPrice,
            'amount': amount,
            'cost': cost,
            'average': None,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            # 'order_uuid': order_uuid,
            # 'limit': 200,  # default 200, max 200
            # 'timestamp_from': since,
            # 'timestamp_to': self.milliseconds(),
        }
        if since is not None:
            request['timestamp_from'] = since
        if limit is not None:
            request['limit'] = limit  # default 200, max 200
        response = self.privateGetFills(self.extend(request, params))
        #
        # [
        #     {
        #         "uuid": "234234897234-1243-1234-qsf234",
        #         "order_uuid": "234234897234-1243-1234-qsf235",
        #         "amount": "0.00100000",
        #         "price": "42986.64",
        #         "amount_quote": "43.09410660",
        #         "side": "buy",
        #         "fee": "0.10746660",
        #         "market": "BTC-EUR",
        #         "liquidity": "taker",
        #         "timestamp": 1622123573863
        #     }
        # ]
        #
        return self.parse_trades(response, market, since, limit)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        query = self.omit(params, self.extract_params(path))
        url = '/' + self.version + '/' + self.implode_params(path, params)
        getOrDelete = (method == 'GET') or (method == 'DELETE')
        if getOrDelete:
            if query:
                url += '?' + self.urlencode(query)
        if api == 'private':
            self.check_required_credentials()
            payload = ''
            if not getOrDelete:
                if query:
                    body = self.json(query)
                    payload = body
            timestamp = str(self.milliseconds())
            auth = timestamp + method + url + payload
            signature = self.hmac(self.encode(auth), self.encode(self.secret))
            accessWindow = self.safe_string(self.options, 'LITEBIT-WINDOW', '10000')
            headers = {
                'LITEBIT-API-KEY': self.apiKey,
                'LITEBIT-SIGNATURE': signature,
                'LITEBIT-TIMESTAMP': timestamp,
                'LITEBIT-WINDOW': accessWindow,
            }
            if not getOrDelete:
                headers['Content-Type'] = 'application/json'
        url = self.urls['api'][api] + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        #
        #     {"code": 10007,"message": "Invalid time window."}
        #
        errorCode = self.safe_string(response, 'code')
        if errorCode is not None:
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
            raise ExchangeError(feedback)  # unknown message
