# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.pro.base.exchange import Exchange
import ccxt.async_support
from ccxt.pro.base.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheByTimestamp
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import InvalidOrder


class hitbtc3(Exchange, ccxt.async_support.hitbtc3):

    def describe(self):
        return self.deep_extend(super(hitbtc3, self).describe(), {
            'has': {
                'ws': True,
                'watchTicker': True,
                'watchTickers': False,
                'watchBalance': True,
                'watchOHLCV': True,
                'watchOrderBook': True,
                'watchTrades': True,
                'watchOrders': True,
                'watchMyTrades': True,
                'watchPositions': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://api.hitbtc.com/api/3/ws/public',
                        'trading': 'wss://api.hitbtc.com/api/3/ws/trading',
                        'wallet': 'wss://api.hitbtc.com/api/3/ws/wallet',
                    },
                },
                'test': {
                    'ws': {
                        'public': 'wss://api.demo.hitbtc.com/api/3/ws/public',
                        'trading': 'wss://api.demo.hitbtc.com/api/3/ws/trading',
                        'wallet': 'wss://api.demo.hitbtc.com/api/3/ws/wallet',
                    },
                },
            },
            'methods': {
                'spot': {
                    'createOrder': 'spot_new_order',
                    'editOrder': 'spot_replace_order',
                    'cancelOrder': 'spot_cancel_order',
                    'cancelAllOrders': 'spot_cancel_orders',
                    'watchBalance': 'spot_balance_subscribe',
                    'watchOrders': 'spot_subscribe',
                    'watchMyTrades': 'spot_subscribe',
                },
                'margin': {
                    'createOrder': 'margin_new_order',
                    'editOrder': 'margin_replace_order',
                    'cancelOrder': 'margin_cancel_order',
                    'cancelAllOrders': 'margin_cancel_orders',
                    'watchPositions': 'margin_subscribe',
                    'watchOrders': 'margin_subscribe',
                    'watchMyTrades': 'margin_subscribe',
                },
                'futures': {
                    'createOrder': 'futures_new_order',
                    'editOrder': 'futures_replace_order',
                    'cancelOrder': 'futures_cancel_order',
                    'cancelAllOrders': 'futures_cancel_orders',
                    'watchPositions': 'futures_subscribe',
                    'watchOrders': 'futures_subscribe',
                    'watchMyTrades': 'futures_subscribe',
                },
            },
            'options': {
                'tradesLimit': 1000,
                'ordersLimit': 1000,
                'BasicAuth': False,                           # BASIC or HS256 authenticate
                'defaultMarketType': 'spot',                  # spot | margin | swap | futures, swap=futures
                'lastRequestId': self.milliseconds(),
            },
        })

    def get_request_id(self):
        requestId = self.sum(self.safe_integer(self.options, 'lastRequestId', 0), 1)
        self.options['lastRequestId'] = requestId
        return requestId

    def make_basic_auth(self):
        return {
            'type': 'BASIC',
            'api_key': self.apiKey,
            'secret_key': self.secret,
        }

    def make_hs256_auth(self):
        timestamp = self.nonce()
        payload = [timestamp]
        payloadString = ''.join(payload)
        signature = self.hmac(self.encode(payloadString), self.encode(self.secret), hashlib.sha256, 'hex')
        return {
            'type': 'HS256',
            'api_key': self.apiKey,
            'timestamp': timestamp,
            'signature': signature,
        }

    async def authenticate(self, url):
        messageHash = 'authenticated'
        client = self.client(url)
        future = self.safe_value(client.futures, messageHash)
        if future is None:
            future = client.future(messageHash)
            method = 'login'
            params = {}
            if self.options['BasicAuth'] is True:
                params = self.make_basic_auth()
            else:
                params = self.make_hs256_auth()
            requestId = self.get_request_id()
            request = {
                'method': method,
                'params': params,
                'id': requestId,
            }
            subscription = {
                'method': messageHash,
                'callback': self.handle_authentication_message,
            }
            self.spawn(self.watch, url, method, request, requestId, subscription)
        return future

    async def watch_private(self, access, method, params={}, messageHash=None):
        self.check_required_credentials()
        url = self.urls['api']['ws'][access]
        await self.authenticate(url)
        if messageHash is None:
            messageHash = method
        requestId = self.get_request_id()
        subscribe = {
            'method': method,
            'id': requestId,
        }
        request = self.deep_extend(subscribe, params)
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_public(self, symbol, channel, params={}):
        await self.load_markets()
        url = self.urls['api']['ws']['public']
        requestId = self.get_request_id()
        marketId = self.market_id(symbol)
        messageHash = channel + ':' + marketId
        subscribe = {
            'method': 'subscribe',
            'ch': channel,
            'params': {
                'symbols': [marketId],
            },
            'id': requestId,
        }
        request = self.deep_extend(subscribe, params)
        return await self.watch(url, messageHash, request, messageHash)

    async def execute_private(self, access, method, params, callback):
        self.check_required_credentials()
        url = self.urls['api']['ws'][access]
        await self.authenticate(url)
        requestId = self.get_request_id()
        messageHash = method + ':' + requestId
        request = {
            'method': method,
            'params': [],
            'id': requestId,
        }
        request = self.deep_extend(request, params)
        subscription = {
            'method': messageHash,
            'callback': callback,
        }
        return await self.watch(url, messageHash, request, requestId, subscription)

    def get_method(self, methodName, market, params):
        marketType = self.safe_value(self.options, 'defaultMarketType', 'spot')
        if market is not None:
            marketType = self.safe_value(market, 'type', marketType)
        marketType = self.safe_value(params, 'marketType', marketType)
        if marketType == 'swap':
            marketType = 'futures'
        methods = self.safe_value(self.methods, marketType)
        if methods is None:
            raise ExchangeError(self.id + ' market type "' + marketType + '" not found!')
        method = self.safe_value(methods, methodName)
        if method is None:
            raise ExchangeError(self.id + ' method ' + marketType + '/' + methodName + ' not found!')
        return method

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
         * create a trade order
        :param str symbol: unified $symbol of the $market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
        :param array params: extra parameters specific to the hitbtc3 api endpoint
        :return array an: {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
        """
        await self.load_markets()
        market = self.market(symbol)
        timeInForce = self.safe_string_2(params, 'timeInForce', 'time_in_force', 'GTC')
        expireTime = self.safe_string_2(params, 'expireTime', 'expire_time')
        stopPrice = self.safe_number_2(params, 'stopPrice', 'stop_price')
        # A post-only limit order is either placed in the order book or expires if matches an existing order.
        # Post-only option guarantees that you will not pay the taker fee.
        postOnly = self.safe_value_2(params, 'postOnly', 'post_only')
        reduceOnly = self.safe_value(params, 'reduceOnly')
        marketType = market['type']
        cmd = {
            'params': {
                'type': type,
                'side': side,
                'quantity': self.amount_to_precision(symbol, amount),
                'symbol': market['id'],
                'time_in_force': timeInForce,
            },
        }
        if (type == 'limit') or (type == 'stopLimit') or (type == 'takeProfitLimit'):
            if price is None:
                raise ExchangeError(self.id + ' createOrder() requires a price argument for limit orders')
            cmd['params']['price'] = self.price_to_precision(symbol, price)
        if (timeInForce == 'GTD'):
            if expireTime is None:
                raise ExchangeError(self.id + ' createOrder() requires an expireTime parameter for a GTD order')
            cmd['params']['expire_time'] = expireTime
        if (type == 'stopLimit') or (type == 'stopMarket') or (type == 'takeProfitLimit') or (type == 'takeProfitMarket'):
            if stopPrice is None:
                raise ExchangeError(self.id + ' createOrder() requires a stopPrice parameter for stop-loss and take-profit orders')
            cmd['params']['stop_price'] = self.price_to_precision(symbol, stopPrice)
        if postOnly is not None:
            cmd['params']['post_only'] = postOnly
        if reduceOnly is not None:
            if (marketType != 'margin') and (marketType != 'swap'):
                raise InvalidOrder(self.id + ' createOrder() does not support reduce_only for ' + market['type'] + ' orders, reduce_only orders are supported for swap and margin markets only')
        if reduceOnly is True:
            cmd['params']['reduce_only'] = reduceOnly
        method = self.get_method('createOrder', market, params)
        return self.execute_private('trading', method, cmd, self.handle_order_message)

    async def edit_order(self, id, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        clientOrderId = self.safe_string_2(params, 'clOrdID', 'clientOrderId', self.uuid22())
        cmd = {
            'params': {
                'client_order_id': id,
                'new_client_order_id': clientOrderId,
                'quantity': self.amount_to_precision(symbol, amount),
            },
        }
        if (type == 'limit') or (type == 'stopLimit') or (type == 'takeProfitLimit'):
            if price is None:
                raise ExchangeError(self.id + ' editOrder() limit order requires price')
            cmd['params']['price'] = self.price_to_precision(symbol, price)
        method = self.get_method('editOrder', market, params)
        return self.execute_private('trading', method, cmd, self.handle_order_message)

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        cmd = {
            'params': {
                'client_order_id': id,
            },
        }
        method = self.get_method('cancelOrder', market, params)
        return self.execute_private('trading', method, cmd, self.handle_order_message)

    async def cancel_all_orders(self, symbol=None, params={}):
        if symbol is not None:
            raise ExchangeError(self.id + ' cancelAllOrders() does not support symbol param. Symbol must be None.')
        cmd = {
            'params': {},
        }
        method = self.get_method('cancelAllOrders', None, params)
        return self.execute_private('trading', method, cmd, self.handle_orders_message)

    async def watch_balance(self, params={}):
        await self.load_markets()
        methodParams = {
            'params': {
                'mode': 'updates',
            },
        }
        method = self.get_method('watchBalance', None, params)
        return await self.watch_private('trading', method, methodParams)

    def handle_balance(self, client, message):
        #
        #     {
        #          "jsonrpc": "2.0",
        #          "method": "spot_balance",
        #          "params": [
        #              {
        #                  "currency": "BCN",
        #                  "available": "100.000000000000",
        #                  "reserved": "0",
        #                  "reserved_margin": "0"
        #              },
        #              {
        #                  "currency": "BTC",
        #                  "available": "0.013634021",
        #                  "reserved": "0",
        #                  "reserved_margin": "0"
        #              },
        #              {
        #                  "currency": "ETH",
        #                  "available": "0",
        #                  "reserved": "0.00200000",
        #                  "reserved_margin": "0"
        #              }
        #          ]
        #      }
        #
        method = self.safe_value(message, 'method') + '_subscribe'
        accountType = 'spot'
        params = self.safe_value(message, 'params', [])
        for i in range(0, len(params)):
            param = params[i]
            account = self.account()
            currencyId = self.safe_string(param, 'currency')
            code = self.safe_currency_code(currencyId)
            account['free'] = self.safe_string(param, 'available', 0)
            account['used'] = self.safe_string(param, 'reserved', 0)
            self.balance[accountType][code] = account
        self.balance[accountType] = self.safe_balance(self.balance[accountType])
        client.resolve(self.balance[accountType], method)

    async def watch_positions(self, params={}):
        await self.load_markets()
        methodParams = {
            'params': {},
        }
        method = self.get_method('watchPositions', None, params)
        return await self.watch_private('trading', method, methodParams, 'positions')

    def handle_accounts(self, client, message):
        #  {
        #      "jsonrpc": "2.0",
        #      "method": "margin_account",
        #      "params": {
        #          "symbol": "BTCUSDT",
        #          "type": "isolated",
        #          "leverage": "12.00",
        #          "created_at": "2021-07-01T21:43:19.727Z",
        #          "updated_at": "2021-07-02T00:54:28.591Z",
        #          "currencies": [
        #              {
        #                  "code": "USDT",
        #                  "margin_balance": "0.080706742356",
        #                  "reserved_orders": "0",
        #                  "reserved_positions": "0.029630234750"
        #              }
        #          ],
        #          "positions": [
        #              {
        #                  "id": 485264,
        #                  "symbol": "BTCUSDT",
        #                  "quantity": "0.00001",
        #                  "price_entry": "33386.18",
        #                  "price_margin_call": "27269.85",
        #                  "price_liquidation": "26721.57",
        #                  "pnl": "0",
        #                  "created_at": "2021-07-01T21:43:19.727Z",
        #                  "updated_at": "2021-07-02T00:54:28.591Z"
        #              }
        #          ],
        #          "report_type": "status",
        #          "report_reason": "status"
        #      }
        #  }
        method = self.safe_string(message, 'method')
        accounts = []
        if (method == 'margin_accounts') or (method == 'futures_accounts'):
            accounts = self.safe_value(message, 'params', [])
        else:
            accounts = [self.safe_value(message, 'params')]
        positions = []
        for i in range(0, len(accounts)):
            account = accounts[i]
            positions.append(self.parse_position(account))
        client.resolve(positions, 'positions')

    async def watch_ticker(self, symbol, params={}):
        """
         * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified $symbol of the market to fetch the ticker for
        :param array params: extra parameters specific to the hitbtc api endpoint
        :return array a: {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
        """
        methodParams = {
            'params': {},
        }
        return await self.watch_public(symbol, 'ticker/1s', methodParams)

    def ws_parse_ticker(self, ticker, market=None):
        #
        #     {
        #            "t": 1614815872000,             # Timestamp in milliseconds
        #            "a": "0.031175",                # Best ask
        #            "A": "0.03329",                 # Best ask quantity
        #            "b": "0.031148",                # Best bid
        #            "B": "0.10565",                 # Best bid quantity
        #            "c": "0.031210",                # Last price
        #            "o": "0.030781",                # Open price
        #            "h": "0.031788",                # High price
        #            "l": "0.030733",                # Low price
        #            "v": "62.587",                  # Base asset volume
        #            "q": "1.951420577",             # Quote asset volume
        #            "p": "0.000429",                # Price change
        #            "P": "1.39",                    # Price change percent
        #            "L": 1182694927                 # Last trade identifier
        #      }
        #
        timestamp = self.safe_integer(ticker, 't')
        symbol = self.safe_symbol(None, market)
        last = self.safe_string(ticker, 'c')
        change = self.safe_string(ticker, 'p')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'h'),
            'low': self.safe_string(ticker, 'l'),
            'bid': self.safe_string(ticker, 'b'),
            'bidVolume': self.safe_string(ticker, 'B'),
            'ask': self.safe_string(ticker, 'a'),
            'askVolume': self.safe_string(ticker, 'A'),
            'vwap': None,
            'open': self.safe_string(ticker, 'o'),
            'close': last,
            'last': last,
            'previousClose': float(last) - float(change),
            'change': change,
            'percentage': self.safe_string(ticker, 'P'),
            'average': None,
            'baseVolume': self.safe_string(ticker, 'v'),
            'quoteVolume': self.safe_string(ticker, 'q'),
            'info': ticker,
        }, market)

    def handle_ticker(self, client, message):
        #
        #     {
        #          "ch": "ticker/1s",
        #          "data": {
        #              "ETHBTC": {
        #                  "t": 1614815872000,             # Timestamp in milliseconds
        #                  "a": "0.031175",                # Best ask
        #                  "A": "0.03329",                 # Best ask quantity
        #                  "b": "0.031148",                # Best bid
        #                  "B": "0.10565",                 # Best bid quantity
        #                  "c": "0.031210",                # Last price
        #                  "o": "0.030781",                # Open price
        #                  "h": "0.031788",                # High price
        #                  "l": "0.030733",                # Low price
        #                  "v": "62.587",                  # Base asset volume
        #                  "q": "1.951420577",             # Quote asset volume
        #                  "p": "0.000429",                # Price change
        #                  "P": "1.39",                    # Price change percent
        #                  "L": 1182694927                 # Last trade identifier
        #              }
        #          }
        #      }
        #
        channel = self.safe_value(message, 'ch')
        tickers = self.safe_value(message, 'data', [])
        keys = list(tickers.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            ticker = tickers[marketId]
            market = self.safe_market(marketId)
            symbol = market['symbol']
            result = self.ws_parse_ticker(ticker, market)
            self.tickers[symbol] = result
            messageHash = channel + ':' + marketId
            client.resolve(result, messageHash)
        return message

    async def watch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        """
         * watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified $symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int|None since: timestamp in ms of the earliest candle to fetch
        :param int|None limit: the maximum amount of candles to fetch
        :param array params: extra parameters specific to the hitbtc api endpoint
        :return [[int]] A: list of candles ordered as timestamp, open, high, low, close, volume
        """
        if limit is None:
            limit = 2
        period = self.timeframes[timeframe]
        methodParams = {
            'params': {
                'limit': limit,
            },
        }
        ohlcv = await self.watch_public(symbol, 'candles/' + period, methodParams)
        if self.newUpdates:
            limit = ohlcv.getLimit(symbol, limit)
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    def ws_parse_ohlcv(self, ohlcv, market=None):
        #
        #                  "t": 1626860340000,             # Message timestamp
        #                  "o": "30881.95",                # Open price
        #                  "c": "30890.96",                # Last price
        #                  "h": "30900.8",                 # High price
        #                  "l": "30861.27",                # Low price
        #                  "v": "1.27852",                 # Base asset volume
        #                  "q": "39493.9021811"            # Quote asset volume
        #
        return [
            self.safe_integer(ohlcv, 't'),
            self.safe_number(ohlcv, 'o'),
            self.safe_number(ohlcv, 'h'),
            self.safe_number(ohlcv, 'l'),
            self.safe_number(ohlcv, 'c'),
            self.safe_number(ohlcv, 'v'),
        ]

    def handle_ohlcv(self, client, message):
        #
        #      {
        #          "ch": "candles/M1",                     # Channel
        #          "snapshot": {
        #              "BTCUSDT": [{
        #                  "t": 1626860340000,             # Message timestamp
        #                  "o": "30881.95",                # Open price
        #                  "c": "30890.96",                # Last price
        #                  "h": "30900.8",                 # High price
        #                  "l": "30861.27",                # Low price
        #                  "v": "1.27852",                 # Base asset volume
        #                  "q": "39493.9021811"            # Quote asset volume
        #              }, {
        #                  "t": 1626860460000,
        #                  "o": "30858.39",
        #                  "c": "30863.56",
        #                  "h": "30864.89",
        #                  "l": "30853.83",
        #                  "v": "53.04288",
        #                  "q": "1636858.7119248"
        #              }]
        #          }
        #      }
        #
        #      {
        #          "ch": "candles/M1",
        #          "update": {
        #              "ETHBTC": [{
        #                  "t": 1626860880000,
        #                  "o": "0.060711",
        #                  "c": "0.060749",
        #                  "h": "0.060749",
        #                  "l": "0.060711",
        #                  "v": "12.2800",
        #                  "q": "0.7455339675"
        #              }]
        #          }
        #      }
        ch = self.safe_string(message, 'ch')
        period = self.strstr(ch, '/')
        timeframe = self.find_timeframe(period)
        data = self.safe_value_2(message, 'snapshot', 'update')
        limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
        keys = list(data.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            candles = data[marketId]
            messageHash = ch + ':' + marketId
            market = self.safe_market(marketId)
            symbol = market['symbol']
            self.ohlcvs[symbol] = self.safe_value(self.ohlcvs, symbol, {})
            stored = self.safe_value(self.ohlcvs[symbol], timeframe)
            if stored is None:
                stored = ArrayCacheByTimestamp(limit)
                self.ohlcvs[symbol][timeframe] = stored
            for i in range(0, len(candles)):
                candle = candles[i]
                parsed = self.ws_parse_ohlcv(candle, market)
                stored.append(parsed)
                client.resolve(stored, messageHash)
        return message

    async def watch_order_book(self, symbol, limit=None, params={}):
        """
         * watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified $symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param array params: extra parameters specific to the hitbtc api endpoint
        :return array A: dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by market symbols
        """
        speed = self.safe_integer(params, 'speed', 1000)
        channel = ''
        if limit is None:
            channel = 'orderbook/full'
        else:
            channel = 'orderbook/D' + limit + '/' + speed + 'ms'
        methodParams = {
            'params': {},
        }
        orderbook = await self.watch_public(symbol, channel, methodParams)
        return orderbook.limit()

    def handle_orderbook(self, client, message):
        if self.safe_value_2(message, 'snapshot', 'data', None) is not None:
            self.handle_order_book_snapshot(client, message)
        elif self.safe_value(message, 'update', None) is not None:
            self.handle_order_book_update(client, message)

    def get_order_book_depth(self, ch):
        parts = ch.split('/')
        partsLen = len(parts)
        textDepth = parts[1]
        if (partsLen > 1) and (textDepth == 'full'):
            return None
        else:
            return int(textDepth[1:])

    def handle_order_book_snapshot(self, client, message):
        #
        #      {
        #          "ch": "orderbook/full",                 # Channel
        #          "snapshot": {
        #              "ETHBTC": {
        #                  "t": 1626866578796,             # Timestamp in milliseconds
        #                  "s": 27617207,                  # Sequence number
        #                  "a": [                         # Asks
        #                      ["0.060506", "0"],
        #                      ["0.060549", "12.6431"],
        #                      ["0.060570", "0"],
        #                      ["0.060612", "0"]
        #                  ],
        #                  "b": [                         # Bids
        #                      ["0.060439", "4.4095"],
        #                      ["0.060414", "0"],
        #                      ["0.060407", "7.3349"],
        #                      ["0.060390", "0"]
        #                  ]
        #              }
        #          }
        #      }
        #
        ch = self.safe_value(message, 'ch')
        snapshots = self.safe_value_2(message, 'snapshot', 'data', {})
        depth = self.get_order_book_depth(ch)
        keys = list(snapshots.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            data = snapshots[marketId]
            market = self.safe_market(marketId)
            symbol = market['symbol']
            timestamp = self.safe_integer(data, 't')
            nonce = self.safe_integer(data, 's')
            if symbol in self.orderbooks:
                del self.orderbooks[symbol]
            snapshot = self.parse_order_book(data, symbol, timestamp, 'b', 'a')
            orderbook = self.order_book(snapshot, depth)
            orderbook['nonce'] = nonce
            self.orderbooks[symbol] = orderbook
            messageHash = ch + ':' + marketId
            client.resolve(orderbook, messageHash)

    def handle_order_book_update(self, client, message):
        #
        #      {
        #          "ch": "orderbook/full",
        #          "update": {
        #              "ETHBTC": {
        #                  "t": 1626866578902,
        #                  "s": 27617208,
        #                  "a": [
        #                      ["0.060508", "0"],
        #                      ["0.060509", "2.5486"]
        #                  ],
        #                  "b": [
        #                      ["0.060501", "3.9000"],
        #                      ["0.060500", "3.0459"]
        #                  ]
        #              }
        #          }
        #      }
        #
        ch = self.safe_value(message, 'ch')
        update = self.safe_value(message, 'update', {})
        keys = list(update.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            data = update[marketId]
            market = self.safe_market(marketId)
            symbol = market['symbol']
            if symbol in self.orderbooks:
                timestamp = self.safe_integer(data, 't')
                nonce = self.safe_integer(data, 's')
                orderbook = self.orderbooks[symbol]
                asks = self.safe_value(data, 'a', [])
                bids = self.safe_value(data, 'b', [])
                self.handle_deltas(orderbook['asks'], asks)
                self.handle_deltas(orderbook['bids'], bids)
                orderbook['timestamp'] = timestamp
                orderbook['datetime'] = self.iso8601(timestamp)
                orderbook['nonce'] = nonce
                self.orderbooks[symbol] = orderbook
                messageHash = ch + ':' + marketId
                client.resolve(orderbook, messageHash)

    def handle_delta(self, bookside, delta):
        price = self.safe_float(delta, 0)
        amount = self.safe_float(delta, 1)
        bookside.store(price, amount)

    def handle_deltas(self, bookside, deltas):
        for i in range(0, len(deltas)):
            self.handle_delta(bookside, deltas[i])

    async def watch_trades(self, symbol, since=None, limit=None, params={}):
        """
         * get the list of most recent $trades for a particular $symbol
        :param str symbol: unified $symbol of the market to fetch $trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of $trades to fetch
        :param array params: extra parameters specific to the hitbtc api endpoint
        :return [array] a: list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
        """
        methodParams = {
            'params': {},
        }
        if limit is not None:
            methodParams['params']['limit'] = limit
        trades = await self.watch_public(symbol, 'trades', methodParams)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    def ws_parse_trade(self, trade, market=None):
        symbol = market['symbol']
        id = self.safe_string(trade, 'i')
        timestamp = self.safe_integer(trade, 't')
        priceString = self.safe_string(trade, 'p')
        amountString = self.safe_string(trade, 'q')
        side = self.safe_string(trade, 's')
        order = None
        type = None
        takerOrMaker = None
        return self.safe_trade({
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': order,
            'type': type,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': priceString,
            'amount': amountString,
        }, market)

    def handle_trades(self, client, message):
        #
        #      {
        #          "ch": "trades",                         # Channel
        #          "snapshot": {
        #              "BTCUSDT": [{
        #                  "t": 1626861109494,             # Timestamp in milliseconds
        #                  "i": 1555634969,                # Trade identifier
        #                  "p": "30881.96",                # Price
        #                  "q": "12.66828",                # Quantity
        #                  "s": "buy"                      # Side
        #              }]
        #          }
        #      }
        #
        #      {
        #          "ch": "trades",
        #          "update": {
        #              "BTCUSDT": [{
        #                  "t": 1626861123552,
        #                  "i": 1555634969,
        #                  "p": "30877.68",
        #                  "q": "0.00006",
        #                  "s": "sell"
        #              }]
        #          }
        #      }
        #
        tradesLimit = self.safe_integer(self.options, 'tradesLimit', 1000)
        data = self.safe_value_2(message, 'snapshot', 'update', {})
        keys = list(data.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            trades = data[marketId]
            market = self.safe_market(marketId)
            symbol = market['symbol']
            messageHash = 'trades:' + marketId
            stored = self.safe_value(self.trades, symbol)
            if stored is None:
                stored = ArrayCache(tradesLimit)
                self.trades[symbol] = stored
            for i in range(0, len(trades)):
                trade = trades[i]
                trade = self.ws_parse_trade(trade, market)
                stored.append(trade)
            client.resolve(stored, messageHash)
        return message

    async def watch_orders(self, symbol=None, since=None, limit=None, params={}):
        """
         * watches information on multiple $orders made by the user
         * @param {str|None} $symbol unified $market $symbol of the $market $orders were made in
         * @param {int|None} $since the earliest time in ms to fetch $orders for
         * @param {int|None} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the binance api endpoint
        :return [array] a: list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
        """
        await self.load_markets()
        method = self.get_method('watchOrders', None, params)
        methodParams = {
            'params': {},
        }
        orders = await self.watch_private('trading', method, methodParams, 'orders')
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    def handle_orders(self, client, message):
        #
        #      {
        #          "jsonrpc": "2.0",
        #          "method": "spot_order",
        #          "params": {
        #              "id": 584244931496,
        #              "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        #              "symbol": "BTCUSDT",
        #              "side": "buy",
        #              "status": "new",
        #              "type": "limit",
        #              "time_in_force": "GTC",
        #              "quantity": "0.01000",
        #              "quantity_cumulative": "0",
        #              "price": "0.01",
        #              "post_only": False,
        #              "display_quantity": "0",
        #              "created_at": "2021-07-02T22:52:32.864Z",
        #              "updated_at": "2021-07-02T22:52:32.864Z",
        #              "report_type": "new"
        #          }
        #      }
        #
        #      {
        #          "jsonrpc": "2.0",
        #          "method": "spot_orders",
        #          "params": [
        #              {
        #                  "id": 584244931496,
        #                  "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        #                  "symbol": "BTCUSDT",
        #                  "side": "buy",
        #                  "status": "new",
        #                  "type": "limit",
        #                  "time_in_force": "GTC",
        #                  "quantity": "0.01000",
        #                  "quantity_cumulative": "0",
        #                  "price": "0.01",
        #                  "post_only": False,
        #                  "created_at": "2021-07-02T22:52:32.864Z",
        #                  "updated_at": "2021-07-02T22:52:32.864Z",
        #                  "report_type": "status"
        #              },
        #          ]
        #      }
        #
        method = self.safe_string(message, 'method')
        orders = []
        if (method == 'spot_orders') or (method == 'margin_orders') or (method == 'futures_orders'):
            orders = self.safe_value(message, 'params', [])
        else:
            orders = [self.safe_value(message, 'params')]
        # Parse orders
        messageHash = 'orders'
        if self.orders is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            self.orders = ArrayCacheBySymbolById(limit)
        cachedOrders = self.orders
        parsedOrders = self.parse_orders(orders)
        parsedOrdersLen = len(parsedOrders)
        if parsedOrdersLen > 0:
            for i in range(0, len(parsedOrders)):
                parsedOrder = parsedOrders[i]
                cachedOrders.append(parsedOrder)
            client.resolve(self.orders, messageHash)
        # Parse trades
        messageHash = 'myTrades'
        if self.myTrades is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            self.myTrades = ArrayCacheBySymbolById(limit)
        cachedTrades = self.myTrades
        parsedTrades = self.ws_parse_my_trades(orders)
        parsedTradesLen = len(parsedTrades)
        if parsedTradesLen > 0:
            for i in range(0, len(parsedTrades)):
                parsedTrade = parsedTrades[i]
                cachedTrades.append(parsedTrade)
            client.resolve(self.myTrades, messageHash)
        return message

    def ws_parse_my_trades(self, orders):
        trades = []
        for i in range(0, len(orders)):
            order = orders[i]
            id = self.safe_string(order, 'trade_id')
            if id is not None:
                trade = self.ws_parse_my_trade(order)
                trades.append(trade)
        return trades

    def ws_parse_my_trade(self, trade):
        marketId = self.safe_string(trade, 'symbol')
        market = self.safe_market(marketId)
        symbol = market['symbol']
        id = self.safe_string(trade, 'trade_id')
        orderId = self.safe_string(trade, 'client_order_id')
        datetime = self.safe_string(trade, 'updated_at')
        timestamp = self.parse8601(datetime)
        priceString = self.safe_string(trade, 'trade_price')
        amountString = self.safe_string(trade, 'trade_quantity')
        side = self.safe_string(trade, 'side')
        takerOrMaker = self.safe_value(trade, 'trade_taker')
        type = self.safe_string(trade, 'type')
        fee = None
        feeCostString = self.safe_string(trade, 'trade_fee')
        if feeCostString is not None:
            info = self.safe_value(market, 'info', {})
            feeCurrency = self.safe_string(info, 'fee_currency')
            feeCurrencyCode = self.safe_currency_code(feeCurrency)
            fee = {
                'cost': feeCostString,
                'currency': feeCurrencyCode,
            }
        return self.safe_trade({
            'info': trade,
            'id': id,
            'order': orderId,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'type': type,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': priceString,
            'amount': amountString,
            'cost': None,
            'fee': fee,
        }, market)

    async def watch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
         * watches information on multiple $trades made by the user
        :param str symbol: unified market $symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param array params: extra parameters specific to the binance api endpoint
        :return [array] a: list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
        """
        await self.load_markets()
        method = self.get_method('watchMyTrades', None, params)
        trades = await self.watch_private('trading', method, params, 'myTrades')
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    def handle_notification(self, client, message):
        #
        #     array( jsonrpc: '2.0', result: True, id: requestId )
        #
        id = self.safe_string(message, 'id')
        if id is not None:
            subscription = self.safe_value(client.subscriptions, id)
            if subscription is not None:
                method = subscription['method']
                callback = subscription['callback']
                callback(client, message, method)
                del client.subscriptions[id]
        return message

    def handle_order_message(self, client, message, method):
        if not self.handle_error_message(client, message):
            return
        order = self.safe_value(message, 'result')
        order = self.parse_order(order)
        client.resolve(order, method)

    def handle_orders_message(self, client, message, method):
        if not self.handle_error_message(client, message):
            return
        orders = self.safe_value(message, 'result')
        orders = self.parse_orders(orders)
        client.resolve(orders, method)

    def handle_authentication_message(self, client, message, method):
        #
        #     array( jsonrpc: '2.0', result: True, id: requestId )
        #
        future = self.safe_value(client.futures, method)
        if future is not None:
            future.resolve(message)

    def handle_error_message(self, client, message):
        #
        #     {"jsonrpc":"2.0","error":{"code":1002,"message":"Authorization is required or has been failed"},"id":requestId}
        #
        error = self.safe_value(message, 'error')
        if error is not None:
            errorCode = self.safe_integer(error, 'code')
            messageString = self.safe_string(error, 'message')
            try:
                if errorCode is not None:
                    feedback = self.id + ' ' + self.json(message)
                    self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
                    if messageString is not None:
                        self.throw_broadly_matched_exception(self.exceptions['broad'], messageString, feedback)
            except Exception as e:
                if isinstance(e, AuthenticationError):
                    client.reject(e, 'authenticated')
                    method = 'login'
                    if method in client.subscriptions:
                        del client.subscriptions[method]
                    return False
                raise e
        return True

    def handle_message(self, client, message):
        if not self.handle_error_message(client, message):
            return
        event = self.safe_string_2(message, 'ch', 'method')
        if event is not None:
            event = self.strstr(event, '/', True)
            channels = {
                'ticker': self.handle_ticker,
                'candles': self.handle_ohlcv,
                'orderbook': self.handle_orderbook,
                'trades': self.handle_trades,
                'spot_balance': self.handle_balance,
                'spot_order': self.handle_orders,
                'spot_orders': self.handle_orders,
                'margin_account': self.handle_accounts,
                'margin_accounts': self.handle_accounts,
                'margin_order': self.handle_orders,
                'margin_orders': self.handle_orders,
                'futures_account': self.handle_accounts,
                'futures_accounts': self.handle_accounts,
                'futures_order': self.handle_orders,
                'futures_orders': self.handle_orders,
            }
            method = self.safe_value(channels, event)
            if method is not None:
                method(client, message)
                return
        self.handle_notification(client, message)

    def strstr(self, haystack, needle, bool=False):
        pos = haystack.find(needle)
        if (pos == -1) or (not pos):
            return haystack
        else:
            if bool:
                return haystack[0:pos]
            else:
                return haystack[pos:]
