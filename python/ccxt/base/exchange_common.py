# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import NullResponse
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported


def handle_market_type_and_params(self, methodName, market=None, params={}):
    defaultType = self.safe_string_2(self.options, 'defaultType', 'type', 'spot')
    methodOptions = self.safe_value(self.options, methodName)
    methodType = defaultType
    if methodOptions is not None:
        if isinstance(methodOptions, str):
            methodType = methodOptions
        else:
            methodType = self.safe_string_2(methodOptions, 'defaultType', 'type', methodType)
    marketType = methodType if (market is None) else market['type']
    type = self.safe_string_2(params, 'defaultType', 'type', marketType)
    params = self.omit(params, ['defaultType', 'type'])
    return [type, params]


def handle_withdraw_tag_and_params(self, tag, params):
    if isinstance(tag, dict):
        params = self.extend(tag, params)
        tag = None
    if tag is None:
        tag = self.safe_string(params, 'tag')
        if tag is not None:
            params = self.omit(params, 'tag')
    return [tag, params]


def edit_limit_buy_order(self, id, symbol, amount, price, params={}):
    return self.edit_limit_order(id, symbol, 'buy', amount, price, params)


def edit_limit_sell_order(self, id, symbol, amount, price, params={}):
    return self.edit_limit_order(id, symbol, 'sell', amount, price, params)


def edit_limit_order(self, id, symbol, amount, price, params={}):
    return self.edit_order(id, symbol, 'limit', amount, price, params)


def edit_order(self, id, symbol, type, side, amount, price, params={}):
    if not self.enableRateLimit:
        raise ExchangeError(self.id + ' editOrder() requires enableRateLimit = True')
    self.cancelOrder(id, symbol)
    return self.create_order(symbol, type, side, amount, price, params)


def create_limit_order(self, symbol, side, amount, price, params={}):
    return self.create_order(symbol, 'limit', side, amount, price, params)


def create_market_order(self, symbol, side, amount, price=None, params={}):
    return self.create_order(symbol, 'market', side, amount, price, params)


def create_limit_buy_order(self, symbol, amount, price, params={}):
    return self.create_order(symbol, 'limit', 'buy', amount, price, params)


def create_limit_sell_order(self, symbol, amount, price, params={}):
    return self.create_order(symbol, 'limit', 'sell', amount, price, params)


def create_market_buy_order(self, symbol, amount, params={}):
    return self.create_order(symbol, 'market', 'buy', amount, None, params)


def create_market_sell_order(self, symbol, amount, params={}):
    return self.create_order(symbol, 'market', 'sell', amount, None, params)


def create_post_only_order(self, symbol, type, side, amount, price, params={}):
    if not self.has['createPostOnlyOrder']:
        raise NotSupported(self.id + 'createPostOnlyOrder() is not supported yet')
    query = self.extend(params, {'postOnly': True})
    return self.create_order(symbol, type, side, amount, price, query)


def create_reduce_only_order(self, symbol, type, side, amount, price, params={}):
    if not self.has['createReduceOnlyOrder']:
        raise NotSupported(self.id + 'createReduceOnlyOrder() is not supported yet')
    query = self.extend(params, {'reduceOnly': True})
    return self.create_order(symbol, type, side, amount, price, query)


def create_stop_order(self, symbol, type, side, amount, price=None, stopPrice=None, params={}):
    if not self.has['createStopOrder']:
        raise NotSupported(self.id + ' createStopOrder() is not supported yet')
    if stopPrice is None:
        raise ArgumentsRequired(self.id + ' create_stop_order() requires a stopPrice argument')
    query = self.extend(params, {'stopPrice': stopPrice})
    return self.create_order(symbol, type, side, amount, price, query)


def create_stop_limit_order(self, symbol, side, amount, price, stopPrice, params={}):
    if not self.has['createStopLimitOrder']:
        raise NotSupported(self.id + ' createStopLimitOrder() is not supported yet')
    query = self.extend(params, {'stopPrice': stopPrice})
    return self.create_order(symbol, 'limit', side, amount, price, query)


def create_stop_market_order(self, symbol, side, amount, stopPrice, params={}):
    if not self.has['createStopMarketOrder']:
        raise NotSupported(self.id + ' createStopMarketOrder() is not supported yet')
    query = self.extend(params, {'stopPrice': stopPrice})
    return self.create_order(symbol, 'market', side, amount, None, query)


def fetch_funding_rate(self, symbol, params={}):
    if self.has['fetchFundingRates']:
        market = self.market(symbol)
        if not market['contract']:
            raise BadSymbol(self.id + ' fetchFundingRate() supports contract markets only')
        rates = self.fetchFundingRates([symbol], params)
        rate = self.safe_value(rates, symbol)
        if rate is None:
            raise NullResponse(self.id + ' fetchFundingRate() returned no data for ' + symbol)
        else:
            return rate
    else:
        raise NotSupported(self.id + ' fetchFundingRate() is not supported yet')


def fetch_mark_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :returns [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchMarkOHLCV']:
        request = {
            'price': 'mark',
        }
        return self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchMarkOHLCV() is not supported yet')


def fetch_index_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical index price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :returns [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchIndexOHLCV']:
        request = {
            'price': 'index',
        }
        return self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchIndexOHLCV() is not supported yet')


def fetch_premium_index_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
    """
    fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    :param str symbol: unified symbol of the market to fetch OHLCV data for
    :param str timeframe: the length of time each candle represents
    :param int|None since: timestamp in ms of the earliest candle to fetch
    :param int|None limit: the maximum amount of candles to fetch
    :param dict params: extra parameters specific to the exchange api endpoint
    :return [[int|float]] A: list of candles ordered as timestamp, open, high, low, close, None
    """
    if self.has['fetchPremiumIndexOHLCV']:
        request = {
            'price': 'premiumIndex',
        }
        return self.fetchOHLCV(symbol, timeframe, since, limit, self.extend(request, params))
    else:
        raise NotSupported(self.id + ' fetchPremiumIndexOHLCV() is not supported yet')


def is_post_only(self, type, timeInForce=None, exchangeSpecificOption=None, params={}):
    """
     * @ignore
    :param string type: Order type
    :param string timeInForce:
    :param boolean exchangeSpecificOption: True if the exchange specific post only setting is set
    :param dict params: Exchange specific params
    :returns boolean: True if a post only order, False otherwise
    """
    postOnly = self.safe_value_2(params, 'postOnly', 'post_only', False)
    params = self.omit(params, ['post_only', 'postOnly'])
    timeInForceUpper = timeInForce.upper() if (timeInForce is not None) else None
    typeLower = type.lower()
    ioc = timeInForceUpper == 'IOC'
    fok = timeInForceUpper == 'FOK'
    timeInForcePostOnly = timeInForceUpper == 'PO'
    isMarket = typeLower == 'market'
    postOnly = postOnly or (typeLower == 'postonly') or timeInForcePostOnly or exchangeSpecificOption
    if postOnly:
        if ioc or fok:
            raise InvalidOrder(self.id + ' postOnly orders cannot have timeInForce equal to ' + timeInForce)
        elif isMarket:
            raise InvalidOrder(self.id + ' postOnly orders cannot have type ' + type)
        else:
            timeInForce = None if timeInForcePostOnly else timeInForce
            return ['limit', True, timeInForce, params]
    else:
        return [type, False, timeInForce, params]


def load_time_difference(self, params={}):
    serverTime = self.fetchTime(params)
    after = self.milliseconds()
    self.options['timeDifference'] = after - serverTime
    return self.options['timeDifference']


def check_order_arguments(self, market, type, side, amount, price, params):
    if price is None:
        if type == 'limit':
            raise ArgumentsRequired(self.id + ' createOrder() requires a price argument for a limit order')
    if amount <= 0:
        raise ArgumentsRequired(self.id + ' createOrder() amount should be above 0')


def parse_borrow_interests(self, response, market=None):
    interest = []
    for i in range(0, len(response)):
        row = response[i]
        interest.append(self.parseBorrowInterest(row, market))
    return interest


def parse_funding_rate_histories(self, response, market=None, since=None, limit=None):
    rates = []
    for i in range(0, len(response)):
        entry = response[i]
        rates.append(self.parseFundingRateHistory(entry, market))
    sorted = self.sort_by(rates, 'timestamp')
    symbol = None if (market is None) else market['symbol']
    return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)


def parse_open_interests(self, response, market=None, since=None, limit=None):
    interests = []
    for i in range(0, len(response)):
        entry = response[i]
        interest = self.parseOpenInterest(entry, market)
        interests.append(interest)
    sorted = self.sort_by(interests, 'timestamp')
    symbol = self.safe_string(market, 'symbol')
    return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)
