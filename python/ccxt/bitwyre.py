# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import hashlib
import time

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.precise import Precise


class bitwyre(Exchange):

    def describe(self):
        return self.deep_extend(super(bitwyre, self).describe(), {
            'id': 'bitwyre',
            'name': 'BITWYRE',
            'countries': ['ID'],  # Indonesia
            'has': {
                'fetchTime': True,
            },
            'version': '1.0',
            'urls': {
                'logo': '',
                'test': {
                    'public': 'https://api.bitwyre.net/public',
                    'private': 'https://api.bitwyre.net/private',
                },
                'api': {
                    'public': 'http://0.0.0.0:3001/public',
                    'private': 'http://0.0.0.0:3002/private',
                },
                'www': 'https://www.bitwyre.com',
                'doc': 'https://docs.bitwyre.com',
                'referral': '',
            },
            'api': {
                'public': {
                    'get': [
                        'contract',
                        'depth',
                        'orderlag',
                        'ticker',
                        'time',
                        'throughput',
                    ],
                },
                'private': {
                    'delete': [
                        'orders/cancel',
                        'orders/cancel/instrument/{instrument}'
                    ],
                    'get': [
                        'account/spotbalance',
                        'account/derivativesbalance',
                        'orders/cancelled',
                        'orders/closed',
                        'orders/info/{order_id}',
                        'orders/open'
                    ],
                    'post': [
                        'orders'
                        'account/deposit/crypto'
                    ]
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0,
                    'taker': 0.003,
                },
            },
            'exceptions': {
                'exact': {
                    'invalid_pair': BadSymbol,  # {"error":"invalid_pair","error_description":"Invalid Pair"}
                    'Insufficient balance.': InsufficientFunds,
                    'invalid order.': OrderNotFound,
                    'Invalid credentials. API not found or session has expired.': AuthenticationError,
                    'Invalid credentials. Bad sign.': AuthenticationError,
                },
                'broad': {
                    'Minimum price': InvalidOrder,
                    'Minimum order': InvalidOrder,
                },
            },
            # exchange-specific options
            'options': {
                'recvWindow': 5 * 1000,  # default 5 sec
                'timeDifference': 0,  # the difference between system clock and exchange clock
                'adjustForTimeDifference': False,  # controls the adjustment logic upon instantiation
                'accountsByType': {
                    'spot': 'spot',
                    'derivatives': 'derivatives',
                },
            },
        })

    def fetch_time(self, params={}):
        response = self.publicGetTime(params)
        result = self.safe_value(response, 'result', {})
        #
        #     {
        #         "unixtime": "1637664744329847066",
        #     }
        #
        return self.safe_integer(result, 'unixtime')
    
    def load_time_difference(self):
        serverTime = self.fetch_time()
        after = self.nanoseconds()
        self.options['timeDifference'] = after - serverTime
        return self.options['timeDifference']

    @staticmethod
    def nanoseconds():
        try:
            timens = time.time_ns()
        except:
            timens = int("%d" % int(time.time() * 1_000_000_000))
        return int(timens)

    def nonce(self):
        return self.nanoseconds() - self.options['timeDifference']
    
    def fetch_markets(self, params={}):
        response = self.publicGetPairs(params)

    def fetch_orderlag(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["instrument"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadSymbol(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        instrument = self.safe_string(params, 'instrument')
        method = 'publicGetOrderlag'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if result == {} or error != []:
            raise BadSymbol(self.id + ': Invalid pairs ' + instrument + ', Error ' + error)
        elif isinstance(result, list):
            try:
                result = result[0]
            except:
                raise ExchangeError(self.id + ': Something wrong. Please contact bitwyre developer')
        #
        #     {
        #         "btc_usdt_spot": "1",
        #         "eth_usdt_spot": "0"
        #     }
        #
        return result

    def fetch_throughput(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["instrument"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadSymbol(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))

        instrument = self.safe_string(params, 'instrument')
        method = 'publicGetThroughput'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
    
        if result == {} or error != []:
            raise BadSymbol(self.id + ': Invalid pairs ' + instrument + ', Error ' + str(error))
        elif isinstance(result, list):
            try:
                result = result[0]
            except:
                raise ExchangeError(self.id + ': Something wrong. Please contact bitwyre developer')
        #
        #     {
        #       "Consumer": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #       "Matching": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #       "Producer": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #     }  
        #
        return result
    
    def fetch_contract(self, params={}):
        instrument = self.safe_string(params, 'instrument')
        if instrument is None:
            raise ArgumentsRequired(self.id + ' fetchContract() requires instrument parameter')
        method = 'publicGetContract'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != []:
            raise BadRequest(self.id + ': Bad Request with instrument ' + instrument + ', Error ' + str(error))
        #
        #   {
        #     "24h_volume": null,
        #     "24h_volume_currency": "usd",
        #     "bitwyre_index_price": null,
        #     "bitwyre_index_price_currency": null,
        #     "contract_uuid": "e0182b13-9771-43c8-999d-e8d26ff04a4e",
        #     "contract_value": "1",
        #     "current_date": "Tuesday, 09 March 2021, 00:00:00",
        #     "details": "BTC/USD Futures Contract for Expiry 30 April 2021 at strike 70,000 USD/BTC",
        #     "expiry_date": "Friday, 30 April 2021, 00:00:00",
        #     "in_the_money": null,
        #     "index_price": null,
        #     "index_price_currency": "usd",
        #     "initial_margin_base_value": null,
        #     "instrument": "btcusdx_usd_210430F70000000000",
        #     "interest_rate": null,
        #     "is_call": "0",
        #     "is_futures": "1",
        #     "is_option": "0",
        #     "is_put": "0",
        #     "is_swap": "0",
        #     "maintenance_margin_base_value": null,
        #     "open_interest": null,
        #     "pricing_source": null,
        #     "strike_price": "70000000000",
        #     "timestamp": "1615280206226789000",
        #     "volatility": null
        #   }
        #
        return result
    
    def fetch_depth(self, params={}):
        instrument = self.safe_string(params, 'instrument')
        if instrument is None:
            raise ArgumentsRequired(self.id + ' fetchOrderbook() requires instrument parameter')
        depth_num = self.safe_string(params, 'depth_num')
        if depth_num is None:
            raise ArgumentsRequired(self.id + ' fetchOrderbook() requires depth_num parameter')
        method = 'publicGetDepth'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != []:
            raise BadRequest(self.id + ': Bad Request with instrument ' + instrument + ', Error ' + str(error))
        # {
        #     "asks": [
        #         [
        #             "70000.0",
        #             "0.00001"
        #         ],
        #         [
        #             "70150.0",
        #             "0.00001"
        #         ],
        #         [
        #             "70200.0",
        #             "0.00001"
        #         ]
        #     ],
        #     "bids": [
        #         [
        #             "68250.0",
        #             "0.00008"
        #         ],
        #         [
        #             "56525.0",
        #             "0.00001"
        #         ],
        #         [
        #             "56500.0",
        #             "0.00001"
        #         ]
        #     ],
        #     "is_frozen": "0"
        # }
        return result
    
    def fetch_ticker(self, params={}):
        instrument = self.safe_string(params, 'instrument')
        if instrument is None:
            raise ArgumentsRequired(self.id + ' fetchDepth() requires instrument parameter')
        method = 'publicGetTicker'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != []:
            raise BadRequest(self.id + ': Bad Request with instrument ' + instrument + ', Error ' + str(error))
        # {
        #     "asset_base": "btc",
        #     "asset_quote": "usdt",
        #     "best_ask": "70000.0",
        #     "best_bid": "68250.0",
        #     "high": "0",
        #     "instrument": "btc_usdt_spot",
        #     "is_frozen": "0",
        #     "last": "0",
        #     "low": "0",
        #     "market": "spot",
        #     "percent_change": "0",
        #     "timestamp": "1637901492505176681",
        #     "volume_base": "0",
        #     "volume_quote": "0"
        # }
        return result
    
    def fetch_balance(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["type"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))

        type_ = self.safe_string_lower(params, 'type', 'spot')
        params = self.omit(params, 'type')
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        account = self.safe_string(accountsByType, type_)
        response = {}
        if account == 'spot':
            method = 'privateGetAccountSpotbalance'
            response = getattr(self, method)(params)
        elif account == 'derivatives':
            method = 'privateGetAccountDerivativesbalance'
            response = getattr(self, method)(params)
        else:
            keys = list(accountsByType.keys())
            raise BadRequest(self.id + ' fetchBalance() type parameter must be one of ' + ', '.join(keys))
        all_asset_balance = self.safe_value(response, 'result', {})
        result = []
        for asset_balance_dict in all_asset_balance:
            result.append(
                {
                    "asset": self.safe_string(asset_balance_dict, 'asset'),
                    "available_balance": self.safe_string(asset_balance_dict, 'available_balance'),
                    "locked_balance": self.safe_string(asset_balance_dict, 'locked_balance'),
                    "total_balance": self.safe_string(asset_balance_dict, 'total_balance'),
                }
            )
        # [
        #     {
        #         "asset": "btc",
        #         "available_balance": "0.3",
        #         "locked_balance": "0.2",
        #         "total_balance": "0.5",
        #     },
        # ]
        return result
    
    def fetch_open_orders(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["instrument", "from_time", "to_time"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        response = {}
        method = 'privateGetOrdersOpen'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_closed_orders(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["instrument", "from_time", "to_time"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        response = {}
        method = 'privateGetOrdersClosed'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_cancelled_orders(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set([])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        response = {}
        method = 'privateGetOrdersCancelled'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_orders_info(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["order_id"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        order_id = self.safe_string_lower(params, 'order_id', 'all')
        response = {}
        request = {
            'order_id': order_id,
        }
        method = 'privateGetOrdersInfoOrderId'
        params = self.omit(params, 'order_id')
        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})
        # [
        #     {
        #         "AvgPx": "0.0",
        #         "LastLiquidityInd": "0",
        #         "LastPx": "0.0",
        #         "LastQty": "0.0",
        #         "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #         "cancelondisconnect": "0",
        #         "clorderid": "",
        #         "cumqty": "0.0",
        #         "execid": "",
        #         "exectype": "0",
        #         "expiry": "0",
        #         "fill_price": "0.0",
        #         "instrument": "usdt_usd_spot",
        #         "leavesqty": "100.0",
        #         "notes": "",
        #         "orderid": "919658a3-5cbe-4dbb-987a-d945715e971e",
        #         "orderqty": "100.0",
        #         "ordrejreason": "",
        #         "ordstatus": "13",
        #         "ordstatusReqID": "a9aeadc8-69a0-4194-982d-400b14b8e709",
        #         "ordtype": "2",
        #         "origclid": "919658a3-5cbe-4dbb-987a-d945715e971e",
        #         "price": "10011.0",
        #         "side": "2",
        #         "stoppx": "0.0",
        #         "time_in_force": "0",
        #         "timestamp": "1637902223144780331",
        #         "transacttime": "1637902225247678732",
        #         "value": "1001100.0"
        #     }
        # ]
        return result
    
    def create_order(self, symbol, type, side=None, amount=None, price=None, params={}):
        if type != 'limit':
            raise ExchangeError(self.id + ' allows limit orders only')
        self.load_markets()
        market = self.market(symbol)
        print("market: ", market)
        return
    
    def cancel_order(self, id, symbol=None, quantity=-1, params={}):
        if id is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires an id argument')
        # if symbol is None:
        #     raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        # self.load_markets()
        # market = self.market(symbol)
        request = {
            'order_id': id,
            'quantity': quantity,
        }
        return self.privateDeleteOrdersCancel(self.extend(request, params))
    
    def cancel_order_per_instrument(self, id, symbol=None, quantity=-1, params={}):
        if id is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires an id argument')
        # if symbol is None:
        #     raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        # self.load_markets()
        # market = self.market(symbol)
        request = {
            'order_id': id,
            'quantity': quantity,
        }
        return self.privateDeleteOrdersCancel(self.extend(request, params))
    
    def create_crypto_deposit_address(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["asset"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))

    def nonce(self):
        return self.nanoseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        if api == 'public':
            url += '/' + self.implode_params(path, params)
            params = self.omit(params, self.extract_params(path))
            if params:
                url += '?' + self.urlencode(params)
        elif api == 'private':
            self.check_required_credentials()
            uri_path = '/' + api + '/' + self.implode_params(path, params)
            url += '/' + self.implode_params(path, params)
            params = self.omit(params, self.extract_params(path))
            print("params: ", params, type(params), "uri_path: ", uri_path)
            if params == {}:
                payload = None
                payload_json = self.json(self.json(payload))
            else:
                payload = params
                payload_json = self.json(self.json(self.json(payload)))
            nonce = self.nonce()
            checksum = self.hash(self.encode(str(payload_json)), 'sha256')
            nonce_checksum = self.hash(self.encode(str(nonce)) + self.encode(str(checksum)), 'sha256')
            signature = self.hmac(self.encode(uri_path) + self.encode(nonce_checksum), self.encode(self.secret), algorithm=hashlib.sha512)
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': self.apiKey,
                'API-Sign': signature
            }
            body = {
                'nonce': nonce,
                'checksum': checksum,
            }
            if payload is not None:
                body.update({'payload': self.json(payload)})
            body = self.urlencode(body)
            print("path: ", path)
            print(url)
        
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
