# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound


class ataix(Exchange):

    def describe(self):
        return self.deep_extend(super(ataix, self).describe(), {
            'id': 'ataix',
            'name': 'ATAIX',
            'countries': ['EE'],
            'rateLimit': 600 / 10 / 60 * 1000,
            'enableRateLimit': False,
            'verbose': False,
            'version': 'v1',
            'has': {
                'CORS': False,
                'fetchMarkets': True,
                'fetchCurrencies': True,
                'fetchOrderBook': True,
                'fetchTickers': True,
                'fetchTicker': True,
                'fetchTrades': True,
                'fetchMyTrades': True,
                'createOrder': True,
                'cancelOrder': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchClosedOrders': True,
                'fetchOpenOrders': True,
                'withdraw': True,
                'deposit': False,
                'fetchDepositAddress': True,
                'createDepositAddress': True,
                'fetchOHLCV': True,
            },
            'timeframes': {
                '1m': 'M1',
                '3m': 'M3',
                '5m': 'M5',
                '15m': 'M15',
                '30m': 'M30',
                '1h': 'H1',
                '4h': 'H4',
                '1d': 'D1',
                '1w': 'D7',
            },
            'urls': {
                'logo': 'https://ataix.com/assets/images_new/ataix_dark.svg',
                'api': 'https://api.ataix.com/api',
                'www': 'https://ataix.com',
                # 'referral': 'https://ataix.com/r/__',
                'doc': 'https://ataix.com/api-docs',
                'fees': [
                    'https://ataix.com/fees',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'symbols',
                        'currencies',
                        'prices',
                        'prices/{symbol}',
                        'trades',
                        'book/{symbol}',
                        'chart',
                    ],
                },
                'private': {
                    'get': [
                        'user/balances',
                        'user/trades',
                        'user/deposit/{currency}',
                        'orders/{orderID}',
                        'orders/history',
                        'orders',
                    ],
                    'post': [
                        'orders',
                        'user/deposit/{currency}',
                        'user/withdraw',
                    ],
                    'delete': [
                        'orders/{orderID}',
                    ],
                },
            },
            'exceptions': {
                'exact': {
                    'ORDER_NOT_FOUND': OrderNotFound,
                },
                'broad': {
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': False,
            },
            'options': {
                'defaultTimeInForce': 'IOC',
            },
        })

    def fetch_markets(self, params={}):
        response = self.publicGetSymbols(params)
        markets = self.safe_value(response, 'result', [])
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            symbol = self.safe_string(market, 'symbol')
            baseId = self.safe_string(market, 'base')
            quoteId = self.safe_string(market, 'quote')
            lot = self.safe_float(market, 'lotSize')
            pricePrecision = self.safe_float(market, 'pricePrecision')
            step = math.pow(10, -pricePrecision)
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            result.append({
                'info': market,
                'id': symbol.replace('/', '-'),
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'lot': lot,
                'step': step,
                'active': market['isActive'],
                'precision': {
                    'amount': str(self.precision_from_string(market['lotSize'])),
                    'price': pricePrecision,
                },
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'minTradeSize'),
                        'max': None,
                    },
                    'price': {
                        'min': step,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            })
        return result

    def fetch_currencies(self, params={}):
        response = self.publicGetCurrencies(params)
        currencies = self.safe_value(response, 'result', [])
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            id = self.safe_string(currency, 'symbol')
            code = self.safe_currency_code(id)
            result[code] = ({
                'info': currencies[i],
                'id': id,
                'code': code,
                'name': self.safe_string(currency, 'name'),
                'active': currency['isActive'],
                'fee': None,
                'precision': self.safe_integer(currency, 'amountPrecision'),
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
            })
        return result

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetUserBalances(params)
        balance = self.safe_value(response, 'result', [])
        return self.parse_balance(balance)

    def parse_balance(self, balance):
        result = {'info': balance, 'free': {}, 'used': {}, 'total': {}}
        currencies = list(balance.available.keys())
        for i in range(0, len(currencies)):
            code = currencies[i]
            # print(self.asFloat(balances.available[code]))
            fValue = self.asFloat(balance.available[code])
            tValue = self.asFloat(balance.total[code])
            uValue = self.asFloat(self.decimal_to_precision(self.sum(tValue, -fValue), 3, 6))
            result[code] = {
                'free': fValue,
                'used': uValue,
                'total': tValue,
            }
            result.free[code] = fValue
            result.used[code] = uValue
            result.total[code] = tValue
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        response = self.publicGetBookSymbol(self.extend({
            'symbol': self.market_id(symbol),
        }, params))
        orderbook = self.safe_value(response, 'result', [])
        # print(orderbook)
        return self.parse_order_book(orderbook, None, 'buy', 'sell', 'price', 'quantity')

    def fetch_ohlcv(self, symbol, timeframe='1d', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': symbol,
            'period': self.timeframes[timeframe],
            'limit': limit or 1000,
        }
        response = self.publicGetChart(self.extend(request, params))
        raw = self.safe_value(response, 'result', [])
        return self.parse_ohlcvs(raw, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        # print(ohlcv)
        return [
            self.parse8601(ohlcv['timestamp']),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'max'),
            self.safe_float(ohlcv, 'min'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, 'volume'),
        ]

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetPrices(params)
        tickers = self.safe_value(response, 'result', [])
        ids = list(tickers.keys())
        result = {}
        for i in range(0, len(ids)):
            id = ids[i]
            ticker = tickers[id]
            symbol = self.safe_string(ticker, 'symbol')
            market = self.markets_by_id[symbol]
            result[symbol] = self.parse_ticker(ticker, market)
        return result

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {'symbol': self.market_id(symbol)}
        response = self.publicGetPricesSymbol(self.extend(request, params))
        tickers = self.safe_value(response, 'result', [])
        return self.parse_ticker(tickers[0], market)

    def parse_ticker(self, ticker, market=None):
        datetime = self.safe_string(ticker, 'timestamp')
        last = self.safe_float(ticker, 'last')
        open = self.safe_float(ticker, 'open')
        volume = self.safe_float(ticker, 'volume')
        return {
            'symbol': self.safe_string(ticker, 'symbol'),
            'timestamp': self.parse8601(datetime),
            'datetime': datetime,
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': self.safe_float(ticker, 'priceChange'),
            'average': None,
            'baseVolume': self.safe_float(volume, 'base'),
            'quoteVolume': self.safe_float(volume, 'quote'),
            'info': ticker,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        self.omit(params, 'page')
        request = {
            'symbol': self.market_id(symbol),
            'limit': limit,
        }
        if since is not None:
            request['startDate'] = since
        response = self.publicGetTrades(self.extend(request, params))
        trades = self.safe_value(response, 'result', [])
        # return trades
        return self.parse_trades(trades, market, since, limit)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = None
        if symbol:
            market = self.market(symbol)
            symbol = self.market_id(symbol)
        else:
            symbol = 'any'
        page = self.safe_integer(params, 'page', 1)
        self.omit(params, 'page')
        request = {
            'symbol': symbol,
            'startDate': since,
            'endDate': self.milliseconds(),
            'page': page,
            'itemsPerPage': limit,
        }
        response = self.privateGetUserTrades(self.extend(request, params))
        trades = self.safe_value(self.safe_value(response, 'result'), 'trades', [])
        # return trades
        return self.parse_trades(trades, market, since, limit)

    def parse_trade(self, trade, market=None):
        datetime = self.safe_string(trade, 'created')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'quantity')
        cost = price * amount  # total cost(including fees), `price * amount`
        return {
            'info': trade,
            'id': self.safe_string(trade, 'tradeId'),
            'order': None,
            'timestamp': self.parse8601(datetime),
            'datetime': datetime,
            'symbol': self.safe_string(trade, 'symbol', self.safe_string(trade, 'pair')),
            'type': None,
            'side': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': {
                'cost': self.safe_float(trade, 'fee'),
                'currency': None,
                'rate': None,
            },
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        # market = self.market(symbol)
        amount = self.asFloat(amount)
        request = {
            'symbol': symbol,
            'side': side,
            'quantity': amount,
            'type': type,
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        else:
            request['subType'] = self.safe_string(params, 'subType', self.options['defaultTimeInForce'].lower())
            self.omit(params, 'subType')
        response = self.privatePostOrders(self.extend(request, params))
        order = self.parse_order(self.safe_value(response, 'result', []))
        if order['status'] == 'rejected':
            raise InvalidOrder(self.id + ' order was rejected by the exchange ' + self.json(order))
        return order

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'orderID': id,
        }
        response = self.privateDeleteOrdersOrderID(self.extend(request, params))
        return self.parse_order(self.safe_value(response, 'result', []))

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        response = self.privateGetOrdersOrderID({'orderID': id})
        order = self.safe_value(response, 'result', [])
        if order:
            return self.parse_order(order)
        raise OrderNotFound(self.id + ' fetchOrder() error: ' + self.response)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        market = None
        if symbol:
            market = self.market(symbol)
            symbol = self.market_id(symbol)
        else:
            symbol = 'any'
        page = self.safe_integer(params, 'page', 1)
        self.omit(params, 'page')
        request = {
            'symbol': symbol,
            'startDate': since,
            'endDate': self.milliseconds(),
            # 'side': 'any',
            # 'type': 'any',
            # 'userId': 'any',
            'page': page,
            'itemsPerPage': limit or 10,
            'hideCanceled': False,
        }
        response = self.privateGetOrdersHistory(self.extend(request, params))
        orders = self.safe_value(response, 'result', [])
        return self.parse_orders(orders, market, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        market = None
        if symbol:
            market = self.market(symbol)
            symbol = self.market_id(symbol)
        else:
            symbol = 'any'
        page = self.safe_integer(params, 'page', 1)
        self.omit(params, 'page')
        request = {
            'symbol': symbol,
            'startDate': since,
            'endDate': self.milliseconds(),
            # 'side': 'any',
            # 'type': 'any',
            # 'userId': 'any',
            'page': page,
            'itemsPerPage': limit or 10,
            'hideCanceled': True,
        }
        response = self.privateGetOrdersHistory(self.extend(request, params))
        orders = self.safe_value(response, 'result', [])
        return self.parse_orders(orders, market, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = None
        if symbol:
            market = self.market(symbol)
            symbol = self.market_id(symbol)
        else:
            symbol = 'any'
        page = self.safe_integer(params, 'page', 1)
        self.omit(params, 'page')
        request = {
            'symbol': symbol,
            # 'side': '',
            # 'type': '',
            # 'userId': '',
            'page': page,
            'itemsPerPage': limit or 10,
        }
        response = self.privateGetOrders(self.extend(request, params))
        orders = self.safe_value(response, 'result', [])
        return self.parse_orders(orders, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            # 'inactive':
            'new': 'open',
            'partial': 'closed',
            'filled': 'closed',
            'cancelled': 'canceled',
            'rejected': 'rejected',
        }
        return self.safe_string(statuses, status)

    def parse_order(self, order, market=None):
        datetime = self.safe_string(order, 'created')
        symbol = self.safe_string(order, 'symbol')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        price = self.safe_float(order, 'price')
        avgPrice = self.safe_float(order, 'averagePrice')
        price = price or avgPrice
        amount = self.safe_float(order, 'quantity')
        amountFilled = self.safe_float(order, 'cumQuantity')
        remaining = self.sum(amount, -amountFilled)
        cost = price * amountFilled
        id = self.safe_string(order, 'orderID')
        type = self.safe_string(order, 'type')
        side = self.safe_string(order, 'side')
        return {
            'id': id,
            'info': order,
            'timestamp': self.parse8601(datetime),
            'datetime': datetime,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': amountFilled,
            'remaining': remaining,
            'fee': None,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetUserDepositCurrency(self.extend(request, params))
        address = self.safe_value(response, 'result')['address']
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': None,
            'info': response,
        }

    def create_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privatePostUserDepositCurrency(self.extend(request, params))
        address = self.safe_value(response, 'result')['address']
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': None,
            'info': response,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'amount': amount,
            'address': address,
        }
        response = self.privatePostUserWithdraw(self.extend(request, params))
        return {
            'info': response,
            'id': self.safe_string(response, 'result'),
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            headers = {
                'Authorization': 'api-ax <' + self.apiKey + '>',
            }
            if method == 'GET':
                url += '?' + self.urlencode(query)
            if method == 'POST':
                if query:
                    body = self.json(query)
                    headers['Content-Type'] = 'application/json'
                    # application/x-www-form-urlencoded
                    # body = self.urlencode(query)
        url = self.urls['api'] + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def request(self, path, api='public', method='GET', params={}, headers=None, body=None):
        response = self.fetch2(path, api, method, params, headers, body)
        if 'code' in response:
            if 'ExecutionReport' in response:
                if response['ExecutionReport']['orderRejectReason'] == 'orderExceedsLimit':
                    raise InsufficientFunds(self.id + ' ' + self.json(response))
            raise ExchangeError(self.id + ' ' + self.json(response))
        return response

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        status = self.safe_value(response, 'status', False)
        if not status:
            type = response['type']
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], type, feedback)
            # self.throw_broadly_matched_exception(self.exceptions['broad'], response, feedback)
            raise ExchangeError(feedback)  # unknown error
