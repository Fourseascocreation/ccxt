# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import base64
import hashlib
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce


class hotbit (Exchange):

    def describe(self):
        return self.deep_extend(super(hotbit, self).describe(), {
            'id': 'hotbit',
            'name': 'Hotbit',
            'countries': ['CN'],
            'rateLimit': 2000,
            'userAgent': self.userAgents['chrome39'],
            'version': 'v1',
            'accounts': None,
            'accountsById': None,
            'hostname': 'api.hotbit.io/api',
            'has': {
                'CORS': False,
                'fetchDepositAddress': False,
                'fetchOHCLV': False,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchTradingLimits': False,
                'withdraw': False,
                'fetchCurrencies': False,
            },
            'timeframes': {
                '1m': '60',
                '3m': '180',
                '5m': '300',
                '15m': '900',
                '30m': '1800',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/42244210-c8c42e1e-7f1c-11e8-8710-a5fb63b165c4.jpg',
                'api': 'https://api.hotbit.io/api',
                'www': 'https://www.hotbit.io',
                'referral': 'https://www.hotbit.io/support?page=api',
                'doc': 'https://github.com/hotbitex/hotbit.io-api-docs',
                'fees': 'https://www.hotbit.io/support?page=fees',
            },
            'api': {
                'public': {
                    'get': [
                        'server.time',
                        'asset.list',
                        'order.book',
                        'order.depth',
                        'market.list',
                        'market.last',
                        'market.kline',
                        'market.status',
                        'market.status_today',
                        'market.status24h',
                        'market.summary',
                    ],
                    'post':[
                        'user_deals',#by HL：api文档可能有问题
                    ]
                },
                'private':{
                    'get':[
                        'market.deals',
                    ],
                    'post':[
                        'balance.query',
                        'order.put_limit',
                        'order.cancel',
                        'order.deals',
                        'order.finished_detail',
                        'order.pending',
                        'order.finished',
                    ]
                }
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.001,
                    'taker': 0.001,
                },
            },
            'limits': {
                'amount': {'min': 0.01, 'max': 100000},
            },
            'options': {
                'createMarketBuyOrderRequiresPrice': True,
                'limits': {
                    'ETH/USDT': {'amount': {'min': 0.001, 'max': 10000}},
                },
            },
            'exceptions': {
                '400': NotSupported,  # Bad Request
                '401': AuthenticationError,
                '405': NotSupported,
                '429': DDoSProtection,  # Too Many Requests, exceed api request limit
                '1002': ExchangeNotAvailable,  # System busy
                '1016': InsufficientFunds,
                '3008': InvalidOrder,
                '6004': InvalidNonce,
                '6005': AuthenticationError,  # Illegal API Signature
            },
            'commonCurrencies': {
                'DAG': 'DAGX',
                'PAI': 'PCHAIN',
            },
        })

    def fetch_markets(self):
        response = self.publicGetMarketList()
        result = []
        markets = response['result']
        for i in range(0, len(markets)):
            market = markets[i]
            id = market['name']
            baseId = market['stock']
            quoteId = market['money']
            base = baseId.upper()
            base = self.common_currency_code(base)
            quote = quoteId.upper()
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
            precision = {
                'base': market['stock_prec'],
                'quote': market['money_prec'],
                'price': 8,
                'amount':0,
            }
            limits = {
                'amount': {
                    'min':market['min_amount'],
                    'max':None,
                },
            }

            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    def fetch_balance(self, params={}):
        if self.markets is None:
            self.load_markets()
        if 'assets' not in params:
            params['assets']=[]
        response = self.privatePostBalanceQuery(params)
        result = {'info': response}

        balances = response['result']
        for key in balances.keys():
            currencyId = key
            code = currencyId.upper()
            if currencyId in self.currencies_by_id:
                code = self.currencies_by_id[currencyId]['code']
            else:
                code = self.common_currency_code(code)
            account = self.account()
            account['free'] = float(balances[key]['available'])
            account['total'] = float(balances[key]['available']) + float(balances[key]['freeze'])
            account['used'] = float(balances[key]['freeze'])
            result[code] = account
        return self.parse_balance(result)

    # def parse_bids_asks(self, orders, priceKey=0, amountKey=1):
    #     result = []
    #     length = len(orders)
    #     halfLength = int(length / 2)
    #     # += 2 in the for loop below won't transpile
    #     for i in range(0, halfLength):
    #         index = i * 2
    #         priceField = self.sum(index, priceKey)
    #         amountField = self.sum(index, amountKey)
    #         result.append([
    #             orders[priceField],
    #             orders[amountField],
    #         ])
    #     return result
    #
    def fetch_order_book(self, symbol=None, limit=10, params={}):
        if self.markets is None:
            self.load_markets()
        request = self.extend({
            'market': self.market(symbol)['symbol'],
            'limit': str(limit),  # L20, L100, full
            'interval':'1e-8',
        }, params)
        response = self.publicGetOrderDepth(request)
        orderbook = response['result']
        return self.parse_order_book(orderbook, None, 'bids', 'asks', 0, 1)

    def fetch_ticker(self, symbol, params={}):
        if self.markets is None:
            self.load_markets()
        market = self.market(symbol)
        ticker = self.publicGetMarketStatus(self.extend({
            'market': market['symbol'],
            'period': 60,  # 获取最近60s的交易信息 by HL
        }, params))
        od=self.fetch_order_book(market['symbol'],2)
        ticker['result']['bid']= od['bids'][0][0]
        ticker['result']['bidVolume']= od['bids'][0][1]
        ticker['result']['ask']= od['asks'][0][0]
        ticker['result']['askVolume']= od['asks'][0][1]
        ticker['result']['symbol']=market['symbol']

        return self.parse_ticker(ticker['result'], market)

    def parse_ticker(self, ticker, market=None):
        timestamp = None
        symbol = market
        return {
            'symbol': ticker['symbol'],
            'timestamp': None,
            'datetime': self.iso8601(timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['bid'],
            'bidVolume': ticker['bidVolume'],
            'ask': ticker['ask'],
            'askVolume': ticker['askVolume'],
            'vwap': None,
            'open': ticker['open'],
            'close': ticker['close'],
            'last': float(ticker['last']),
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_trade(self, trade, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = int(trade['ts'])
        side = trade['side'].lower()
        orderId = self.safe_string(trade, 'id')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        cost = price * amount
        fee = None
        return {
            'id': orderId,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'order': orderId,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=100, params={}):
        if self.markets is None:
            self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['symbol'],
            'offset':0,
            'limit': limit,
        }
        response = self.privatePostOrderFinished(self.extend(request, params))

        return self.parse_trades(response['data'], market, since, limit)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if self.markets is None:
            self.load_markets()
        market = self.market(symbol)
        orderType = 'limit'
        if side == 'sell':
            sideInt = 1
        elif side == 'buy':
            sideInt = 2
        request = {
            'market': self.market(symbol)['symbol'],
            'amount': self.amount_to_precision(market['symbol'], amount),
            'side': sideInt,
            'price': self.price_to_precision(market['symbol'], price),
        }
        result = self.privatePostOrderPutLimit(self.extend(request, params))

        return {
            'info': result,
            'id': result['result']['id'],
        }

    def cancel_order(self, id, symbol=None, params={}):
        if self.markets is None:
            self.load_markets()
        response = self.privatePostOrderCancel(self.extend({
            'market':self.market(symbol)['symbol'],
            'order_id': id,
        }, params))

        order = self.parse_order(response)
        return self.extend(order, {
            'id': id,
            'status': 'canceled',
        })

    def parse_order_status(self, order):
        # statuses = {
        #     'submitted': 'open',
        #     'canceled': 'canceled',
        #     'partial_filled': 'open',
        #     'partial_canceled': 'canceled',
        #     'filled': 'closed',
        #     'pending_cancel': 'canceled',
        # }
        if self.safe_integer(order, 'amount')>=self.safe_integer(order, 'left') and\
            self.safe_integer(order, 'left')>0:
            return 'open'
        elif self.safe_integer(order, 'left')==0 :
            return 'finished'

    def parse_order(self, order, market=None):
        id = self.safe_string(order, 'id')
        side = 'buy' if self.safe_integer(order, 'side')==2 else 'sell'
        status = self.parse_order_status(order)
        symbol = None
        if market is None:
            marketId = self.safe_string(order, 'market')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
        orderType = 'limit'
        timestamp = self.safe_integer(order, 'ctime')
        amount = self.safe_float(order, 'amount')
        filled = self.safe_float(order, 'amount') - self.safe_float(order, 'left')
        remaining = self.safe_float(order, 'left')
        price = self.safe_float(order, 'price')
        cost = self.safe_float(order, 'market_fee')
        if filled is not None:
            if amount is not None:
                remaining = amount - filled
            if cost is None:
                if price is not None:
                    cost = price * filled
            elif (cost > 0) and(filled > 0):
                price = cost / filled
        feeCurrency = None
        if market is not None:
            symbol = market['symbol']
            feeCurrency = market['base'] if (side == 'buy') else market['quote']
        feeCost = self.safe_float(order, 'fill_fees')
        result = {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': orderType,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'remaining': remaining,
            'filled': filled,
            'average': None,
            'status': status,
            'source':self.safe_string(order, 'source'),
            'fee': {
                'cost': feeCost,
                'currency': feeCurrency,
            },
            'trades': None,
        }
        return result

    def fetch_order(self, id, symbol=None, params={}):
        if self.markets is None:
            self.load_markets()
        # request = self.extend({
        #     'order_id': id,
        #     'offset':0,
        # }, params)
        # response = self.privatePostOrderDeals(request)
        market=self.market(symbol)
        request = self.extend({
            'market': market['symbol'],
            'offset':0,
            'limit':100,
        }, params)
        response = self.privatePostOrderPending(request)
        for order in response['result'][market['id']]['records']:
            if self.safe_string(order,'id')==id:
                return self.parse_order(order,self.market(symbol))
        return None

    # def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
    #     result = self.fetch_orders(symbol, since, limit, {'states': 'submitted'})
    #     return result
    #
    # def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
    #     result = self.fetch_orders(symbol, since, limit, {'states': 'filled'})
    #     return result
    #
    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if self.markets is None:
            self.load_markets()
        market=self.market(symbol)
        request = self.extend({
            'market': market['symbol'],
            'offset':0,
            'limit':100,
        }, params)
        response = self.privatePostOrderPending(request)
        return self.parse_orders(response['result'][market['id']]['records'], market, since, limit)

        #the api document hasn't be refined more, some details are missing
    # def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
    #     return [
    #         ohlcv['id'] * 1000,
    #         ohlcv['open'],
    #         ohlcv['high'],
    #         ohlcv['low'],
    #         ohlcv['close'],
    #         ohlcv['base_vol'],
    #     ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=100, params={}):
        if self.markets is None:
            self.load_markets()
        if limit is None:
            raise ExchangeError(self.id + ' fetchOHLCV requires a limit argument')
        market = self.market(symbol)
        request = self.extend({
            'symbol': market['symbol'],
            'Interval': self.timeframes[timeframe],
        }, params)
        response = self.publicGetMarketKline(request)
        return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)

    def nonce(self):
        return self.milliseconds()

    def concatParam(self,query):
        resList=[]
        for key in query.keys():
            if isinstance(query[key],list):
                query[key]='[]'
            resList.append('='.join([key,str(query[key])]))
        return '&'.join(resList)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        request = '/' + self.version + '/'
        request += path
        url = self.urls['api'] + request
        if api == 'public':
            url = '?'.join([url,self.concatParam(params)])
        else:
            # secret key must be appended to the query before signing
            query = self.keysort(self.extend({
                'api_key': self.apiKey,
            }, params))
            query['secret_key']= self.secret
            queryString = self.concatParam(query)
            query['sign'] = self.hash(self.encode(queryString)).upper()
            query.pop('secret_key')
            body = self.concatParam(query)

        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body):
        if not isinstance(body, basestring):
            return  # fallback to default error handler
        if len(body) < 2:
            return  # fallback to default error handler
        if (body[0] == '{') or (body[0] == '['):
            response = json.loads(body)
            error = self.safe_string(response, 'error')
            if error is not None:
                feedback = self.id + ' ' + body
                if error in self.exceptions:
                    exceptions = self.exceptions
                    raise exceptions[error](feedback)
                raise ExchangeError(feedback)
