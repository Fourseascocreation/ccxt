// ---------------------------------------------------------------------------
// Usage: npm run transpileWs
// ---------------------------------------------------------------------------

import fs from 'fs';
import log from 'ololog';
import ccxt from '../js/ccxt.js';
import ansi  from 'ansicolor'
import {
    replaceInFile,
    copyFile,
    overwriteFile,
    createFolder,
    createFolderRecursively,
} from './fsLocal.js';
import Exchange from '../js/src/base/Exchange.js';
import {  Transpiler, parallelizeTranspiling, isMainEntry } from './transpile.js';

const exchanges = JSON.parse (fs.readFileSync("./exchanges.json", "utf8"));
const wsExchangeIds = exchanges.ws;

const { unCamelCase, precisionConstants, safeString, unique } = ccxt;

ansi.nice
// ============================================================================

class CCXTProTranspiler extends Transpiler {

    getBaseClass () {
        return new Exchange ()
    }

    createPythonClassDeclaration (className, baseClass) {
        const baseClasses = (baseClass.indexOf ('Rest') >= 0) ?
            [ 'ccxt.async_support.' + baseClass.replace('Rest', '') ] :
            [ baseClass ]
        return 'class ' + className + '(' +  baseClasses.join (', ') + '):'
    }

    createPythonClassImports (baseClass, async = false) {

        const baseClasses = {
            'Exchange': 'base.exchange',
        }

        async = (async ? '.async_support' : '')

        if (baseClass.indexOf ('Rest') >= 0) {
            return [
                // 'from ccxt.async_support' + ' import ' + baseClass,
                "import ccxt.async_support"
            ]
        } else {
            return [
                'from ccxt.pro.' + baseClass + ' import ' + baseClass // on the JS side we add to append `Rest` to the base class name
            ]
        }
        // return [
        //     (baseClass.indexOf ('ccxt.') === 0) ?
        //         ('import ccxt' + async + ' as ccxt') :
        //         ('from ccxtpro.' + safeString (baseClasses, baseClass, baseClass) + ' import ' + baseClass)
        // ]
    }

    createPythonClassHeader (ccxtImports, bodyAsString) {
        const imports = [
            ... ccxtImports,
        ]
        const arrayCacheClasses = bodyAsString.match (/\bArrayCache(?:[A-Z][A-Za-z]+)?\b/g)
        if (arrayCacheClasses) {
            const uniqueArrayCacheClasses = unique (arrayCacheClasses).sort ()
            const arrayCacheImport = 'from ccxt.async_support.base.ws.cache import ' + uniqueArrayCacheClasses.join (', ')
            imports.push (arrayCacheImport)
        }
        return [
            "# -*- coding: utf-8 -*-",
            "",
            "# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            "",
            ... imports,
        ]
    }

    createPHPClassDeclaration (className, baseClass) {
        let lines = []
        if (baseClass.indexOf ('Rest') >= 0) {
            //     lines = lines.concat ([
            //         '',
            //         // '    use ClientTrait;'
            //     ])
            lines.push('class ' + className + ' extends ' + '\\ccxt\\async\\' +  baseClass.replace ('Rest', '') + ' {')
        } else {
            lines.push('class ' + className + ' extends ' + '\\ccxt\\pro\\' +  baseClass + ' {')
        }
        return lines.join ("\n")
    }

    createPHPClassHeader (className, baseClass, bodyAsString) {
        return [
            "<?php",
            "",
            "namespace ccxt\\pro;",
            "",
            "// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            "",
            "use Exception; // a common import",
        ]
    }

    sortExchangeCapabilities (code) {
        return false
    }

    exportTypeScriptClassNames (file, classes) {

        log.bright.cyan ('Exporting WS TypeScript class names â†’', file.yellow)

        const commonImports = [
            '        export const exchanges: string[]',
            '        class Exchange  extends ExchangePro {}'
        ]

        const replacements = [
            {
                file:file,
                regex: /\n\n\s+export\snamespace\spro\s{\n\s+[\s\S]+}/,
                replacement: "\n\n    export namespace pro {\n" + commonImports.join('\n') + '\n' + Object.keys (classes).map (className => {
                    return '        class ' + className + ' extends Exchange {}'
                }).join ("\n") + "\n    }\n}"
            }
        ]

        replacements.forEach (({ file, regex, replacement }) => {
            replaceInFile (file, regex, replacement)
        })

    }

    // -----------------------------------------------------------------------

    async transpileEverything (force = false, child = false) {

        // default pattern is '.js'
        // const [ /* node */, /* script */, pattern ] = process.argv.filter (x => !x.startsWith ('--'))
        const exchanges = process.argv.slice (2).filter (x => !x.startsWith ('--'))
            // , python2Folder = './python/ccxtpro/', // CCXT Pro does not support Python 2
            , python3Folder = './python/ccxt/pro/'
            , phpAsyncFolder = './php/pro/'
            , jsFolder = './js/src/pro/'
            , tsFolder = './ts/src/pro/'
            , options = { /* python2Folder, */ python3Folder, phpAsyncFolder, jsFolder, exchanges }

        // createFolderRecursively (python2Folder)
        createFolderRecursively (python3Folder)
        createFolderRecursively (phpAsyncFolder)

        const classes = this.transpileDerivedExchangeFiles (tsFolder, options, '.ts', force, child || exchanges.length)

        this.transpileWsTests ()

        if (child) {
            return
        }

        if (classes === null) {
            log.bright.yellow ('0 files transpiled.')
            return;
        }

        //*/

        // this.transpileErrorHierarchy ({ tsFilename })

        log.bright.green ('Transpiled successfully.')
    }

    
    transpileWsTests (){
        const baseWsFolders = {
            ts: './ts/src/',
            py: './python/ccxt/',
            php: './php/',
        };
        const wsFolder = 'pro/test/';

        const wsCollectedTests = [];
        for (const currentFolder of ['', 'base/']) {
            const subDirectory = wsFolder + currentFolder;
            const fileNames = this.readTsFileNames(baseWsFolders.ts + subDirectory);
            for (const testName of fileNames) {
                const testNameUncameled = this.uncamelcaseName(testName);
                const isBaseTestFile = subDirectory.includes('test/base/');
                const test = {
                    base: isBaseTestFile,
                    name: testName,
                    tsFile: baseWsFolders.ts + subDirectory + testName + '.ts',
                };
                const pyKey = isBaseTestFile ? 'pyFileSync': 'pyFileAsync';
                const phpKey = isBaseTestFile ? 'phpFileSync': 'phpFileAsync';
                test[pyKey] = baseWsFolders.py + subDirectory + testNameUncameled + '.py';
                test[phpKey] = baseWsFolders.php + subDirectory + testNameUncameled + '.php';
                wsCollectedTests.push(test);
            }
        }
        this.transpileAndSaveExchangeTests (wsCollectedTests);
    }


    modifyCustomFiles (test) {
        const isWsCache = test.tsFile.includes('pro/test/base/test.Cache.ts');
        const isWsOrderBook = test.tsFile.includes('pro/test/base/test.OrderBook.ts');
        if (isWsCache){
            // py head
            test.pythonPreambleSync = test.pythonPreambleSync + '\n' + 'from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheByTimestamp, ArrayCacheBySymbolById, ArrayCacheBySymbolBySide  # noqa: F402' + '\n' + '\n';
            // php head
            test.phpPreambleSync = this.getPHPPreamble(true, 4, true);
        }
        if (isWsOrderBook){
            // py head
            test.pythonPreambleSync = test.pythonPreambleSync + '\n' + 'from ccxt.async_support.base.ws.order_book import OrderBook, IndexedOrderBook, CountedOrderBook  # noqa: F402' + '\n' + '\n';
            // php head
            test.phpPreambleSync = this.getPHPPreamble(true, 4, true);
        }
    }
}

// ============================================================================
// main entry point
if (isMainEntry(import.meta.url)) { // called directly like `node module`
    const transpiler = new CCXTProTranspiler ()
    const test = process.argv.includes ('--test') || process.argv.includes ('--tests');
    const force = process.argv.includes ('--force')
    const multiprocess = process.argv.includes ('--multiprocess') || process.argv.includes ('--multi')
    const child = process.argv.includes ('--child')
    if (!child && !multiprocess) {
        log.bright.green ({ force })
    }
    if (test) {
        transpiler.transpileWsTests ()
    } 
    else if (multiprocess) {
        parallelizeTranspiling (exchanges.ws)
    } else {
        (async () => {
            await transpiler.transpileEverything (force, child)
        })()
    }

} else {

    // do nothing if required as a module
}

// ============================================================================

export default CCXTProTranspiler
