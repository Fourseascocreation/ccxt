import Transpiler from "ast-transpiler";
import ts from "typescript";

import errors from "../js/src/base/errors.js"
import { basename, join } from 'path'
import { createFolderRecursively, replaceInFile, overwriteFile } from './fsLocal.js'
import {unCamelCase, precisionConstants, safeString, unique} from "../js/src/base/functions.js"
import { platform } from 'process'
import { pathToFileURL } from 'url'
import fs from 'fs'
import log from 'ololog'
import ansi from 'ansicolor'
import {Transpiler as OldTranspiler} from "./transpile.js";
import errorHierarchy from '../js/src/base/errorHierarchy.js'

const tsFilename = './ccxt.d.ts'
const pythonCodingUtf8 = '# -*- coding: utf-8 -*-'
const baseExchangeJsFile = './ts/src/base/Exchange.ts'

let exchanges = JSON.parse (fs.readFileSync("./exchanges.json", "utf8"));

// import errorHierarchy from '../js/src/base/errorHierarchy.js'

// helper

let __dirname = new URL('.', import.meta.url).pathname;

// this is necessary because for some reason
// pathname keeps the first '/' for windows paths
// making them invalid
// example: /C:Users/user/Desktop/
if (platform === 'win32') {
    if (__dirname[0] === '/') {
        __dirname = __dirname.substring(1)
    }
}

class NewTranspiler {

    transpiler;
    pythonStandardLibraries;
    oldTranspiler = new OldTranspiler();

    constructor() {

        this.setupTranspiler()

        this.pythonStandardLibraries = {
            'hashlib': 'hashlib',
            'math': 'math',
            'json.loads': 'json',
            'json.dumps': 'json',
            'sys': 'sys',
        }
    }

    // c# custom method
    customCSharpPropAssignment(node, identation) {
        const stringValue = node.getFullText().trim();
        if (Object.keys(errors).includes(stringValue)) {
            return `typeof(${stringValue})`;
        }
        return undefined;
    }

    // a helper to apply an array of regexes and substitutions to text
    // accepts an array like [ [ regex, substitution ], ... ]

    regexAll (text, array) {
        for (const i in array) {
            let regex = array[i][0]
            const flags = (typeof regex === 'string') ? 'g' : undefined
            regex = new RegExp (regex, flags)
            text = text.replace (regex, array[i][1])
        }
        return text
    }


    setupTranspiler() {
        this.transpiler = new Transpiler ({
            "csharp": {
                "parser": {
                    "ELEMENT_ACCESS_WRAPPER_OPEN": "getValue(",
                    "ELEMENT_ACCESS_WRAPPER_CLOSE": ")"
                }
            },
            "php": {
                "uncamelcaseIdentifiers": true,
                "ScopeResolutionProps": ["super", "Precise"]
            },
            "python": {
                "uncamelcaseIdentifiers": true,
            }
        })
        this.transpiler.setVerboseMode(false);
        // this.transpiler.csharpTranspiler.printCustomRightSidePropertyAssignment = this.customCSharpPropAssignment;

    }

    createGeneratedHeader() {
        return [
            "// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            ""
        ]
    }

    getCsharpImports(file) {
        return [
            "using Main;",
            "namespace Main;"
        ]
    }

    isObject(type: string) {
        return (type === 'any') || (type === 'unknown');
    }

    isDictionary(type: string): boolean {
        return (type === 'Object') || (type === 'Dictionary<any>') || (type === 'unknown') || ((type.startsWith('{')) && (type.endsWith('}')))
    }

    isStringType(type: string) {
        return (type === 'string') || (type === 'StringLiteral') || (type === 'StringLiteralType') || (type.startsWith('"') && type.endsWith('"')) || (type.startsWith("'") && type.endsWith("'"))
    }

    isNumberType(type: string) {
        return (type === 'number') || (type === 'NumericLiteral') || (type === 'NumericLiteralType')
    }

    isIntegerType(type: string) {
        return type !== undefined && type.toLowerCase().includes('int');
    }

    isBooleanType(type: string) {
        return (type === 'boolean') || (type === 'BooleanLiteral') || (type === 'BooleanLiteralType')
    }

    convertJavascriptTypeToCsharpType(type: string): string | undefined {
        const isPromise = type.startsWith('Promise<') && type.endsWith('>');
        let wrappedType = isPromise ? type.substring(8, type.length - 1) : type;
        let isList = false;

        function addTaskIfNeeded(type) {
            if (type == 'void') {
                return isPromise ? `Task` : 'void';
            } else if (isList) {
                return isPromise ? `Task<List<${type}>>` : `List<${type}>`;
            }
            return isPromise ? `Task<${type}>` : type;
        }

        const csharpReplacements = {
            'OrderType': 'string',
            'OrderSide': 'string', // tmp
        }

        if (wrappedType === undefined || wrappedType === 'Undefined') {
            return addTaskIfNeeded('object'); // default if type is unknown;
        }

        // check if returns a list
        if (wrappedType.endsWith('[]')) {
            isList = true;
            wrappedType = wrappedType.substring(0, wrappedType.length - 2);
        }

        if (this.isObject(wrappedType)) {
            return addTaskIfNeeded('object');
        }
        if (this.isDictionary(wrappedType)) {
            return addTaskIfNeeded('Dictionary<string, object>');
        }
        if (this.isStringType(wrappedType)) {
            return addTaskIfNeeded('string');
        }
        if (this.isNumberType(wrappedType)) {
            return addTaskIfNeeded('float');
        }
        if (this.isBooleanType(wrappedType)) {
            return addTaskIfNeeded('bool');
        }
        if (this.isIntegerType(wrappedType)) {
            return addTaskIfNeeded('Int64');
        }
        if (csharpReplacements[wrappedType] !== undefined) {
            return addTaskIfNeeded(csharpReplacements[wrappedType]);
        }

        return addTaskIfNeeded(wrappedType);
    }

    safeCsharpName(name: string): string {
        const csharpReservedWordsReplacement = {
            'params': 'parameters',
            'base': 'baseArg',
        }
        return csharpReservedWordsReplacement[name] || name;
    }

    convertJavascriptParamToCsharpParam(param): string | undefined {
        const name = param.name;
        const safeName = this.safeCsharpName(name);
        const isOptional =  param.optional || param.initializer !== undefined;
        const op = isOptional ? '?' : '';
        let paramType: any = undefined;
        if (param.type == undefined) {
            paramType = 'object';
        } else {
            paramType = this.convertJavascriptTypeToCsharpType(param.type);
        }
        const isNonNullableType = this.isNumberType(param.type) || this.isBooleanType(param.type) || this.isIntegerType(param.type);
        if (isNonNullableType) {
            if (isOptional) {
                if (param.initializer !== undefined && param.initializer !== 'undefined') {
                    return `${paramType} ${safeName} = ${param.initializer}`
                } else {
                    return `${paramType}? ${safeName}`
                }
            }
        } else {
            if (isOptional) {
                if (param.initializer !== undefined) {
                          return `${paramType}? ${safeName}`
                }
            } else {
                return `${paramType} ${safeName}`
            }
        }
        return `${paramType}${op} ${safeName}`
    }

    shouldCreateWrapper(methodName: string): boolean {
        const allowedPrefixes = [
            'fetch',
            'create',
            'edit',
            'cancel',
            'setP',
            'setM',
            'setL',
            // 'load',
        ];
        const blacklistMethods = [
            'fetch',
            'setSandBoxMode',
            'loadOrderBook',
            'fetchCurrencies',
            'loadMarketsHelper',
        ] // improve this later
        const isBlackListed = blacklistMethods.includes(methodName);
        const startsWithAllowedPrefix = allowedPrefixes.some(prefix => methodName.startsWith(prefix));
        return !isBlackListed && startsWithAllowedPrefix;
    }

    unwrapTaskIfNeeded(type: string): string {
        return type.startsWith('Task<') && type.endsWith('>') ? type.substring(5, type.length - 1) : type;
    }

    unwrapListIfNeeded(type: string): string {
        return type.startsWith('List<') && type.endsWith('>') ? type.substring(5, type.length - 1) : type;
    }

    createReturnStatement( unwrappedType:string ) {
        const needsToInstantiate = !unwrappedType.startsWith('List<') && !unwrappedType.startsWith('Dictionary<') && unwrappedType !== 'object' && unwrappedType !== 'string' && unwrappedType !== 'float' && unwrappedType !== 'bool' && unwrappedType !== 'Int64';
        let returnStatement = "";
        if (unwrappedType.startsWith('List<')) {
            returnStatement = `return ((List<object>)res).Select(item => new ${this.unwrapListIfNeeded(unwrappedType)}(item)).ToList<${this.unwrapListIfNeeded(unwrappedType)}>();`
        } else {
            returnStatement =  needsToInstantiate ? `return new ${unwrappedType}(res);` :  `return ((${unwrappedType})res);`;            ;
        }
        return returnStatement;
    }

    createWrapper (methodWrapper) {
        const isAsync = methodWrapper.async;
        const methodName = methodWrapper.name;
        if (!this.shouldCreateWrapper(methodName)) {
            return ''; // skip aux methods like encodeUrl, parseOrder, etc
        }
        const methodNameCapitalized = methodName.charAt(0).toUpperCase() + methodName.slice(1);
        const returnType = this.convertJavascriptTypeToCsharpType(methodWrapper.returnType);
        const unwrappedType = this.unwrapTaskIfNeeded(returnType as string);
        const args = methodWrapper.parameters.map(param => this.convertJavascriptParamToCsharpParam(param)).join(', ');
        const params = methodWrapper.parameters.map(param => this.safeCsharpName(param.name)).join(', ');

        const method = [
            `public ${isAsync ? 'async ' : ''}${returnType} ${methodNameCapitalized}(${args})`,
            '{',
            `    var res = ${isAsync ? 'await ' : ''}this.${methodName}(${params});`,
            `    ${this.createReturnStatement(unwrappedType)}`,
            '}'
        ].map(line => '    ' + line);
        return method.join('\n')
    }

    createMethodsWrappers(wrappers) {
        const wrapperFile = "./c#/src/base/Exchange.Wrappers.cs";
        // wrappers = wrappers.filter(wrapper => wrapper.name == 'createOrder'); // debug only
        const wrappersIndented = wrappers.map(wrapper => this.createWrapper(wrapper)).filter(wrapper => wrapper !== '').join('\n');
        const file = [
            'namespace Main;',
            '',
            this.createGeneratedHeader().join('\n'),
            'public partial class Exchange',
            '{',
            wrappersIndented,
            '}',
        ].join('\n')
        log.magenta ('→', (wrapperFile as any).yellow)

        overwriteFile (wrapperFile, file);
    }

    transpileErrorHierarchy ({ tsFilename }) {

        const errorHierarchyFilename = './js/src/base/errorHierarchy.js'
        const errorHierarchyPath = __dirname + '/.' + errorHierarchyFilename

        let js = fs.readFileSync (errorHierarchyPath, 'utf8')

        js = this.regexAll (js, [
            // [ /export { [^\;]+\s*\}\n/s, '' ], // new esm
            [ /\s*export default[^\n]+;\n/g, '' ],
            // [ /module\.exports = [^\;]+\;\n/s, '' ], // old commonjs
        ]).trim ()

        const message = 'Transpiling error hierachy →'
        const root = errorHierarchy['BaseError']
        // const root = undefined;

        const { python3Body } =  this.oldTranspiler.transpileJavaScriptToPythonAndPHP ({ js })

        // a helper to generate a list of exception class declarations
        // properly derived from corresponding parent classes according
        // to the error hierarchy

        function intellisense (map, parent, generate, classes) {
            function* generator(map, parent, generate, classes) {
                for (const key in map) {
                    yield generate (key, parent, classes)
                    yield* generator (map[key], key, generate, classes)
                }
            }
            return Array.from (generator (map, parent, generate, classes))
        }


        // CSHARP ----------------------------------------------------------------

        // ---------------------------------------------------------------------

        function csharpMakeErrorClassFile (name, parent) {
            const exception =
`   public class ${name} : ${parent}
    {
        public ${name}() : base() { }
        public ${name}(string message) : base(message) { }
        public ${name}(string message, ${parent} inner) : base(message, inner) { }
    }`;
            return exception
        }

        const csharpFilename ='./c#/base/Exchange.Errors.cs'

            const csharpBaseError =
`   public class BaseError : Exception
    {
        public BaseError() : base() { }
        public BaseError(string message) : base(message) { }
        public BaseError(string message, Exception inner) : base(message, inner) { }
    }`;

        // const pythonExports = [ 'error_hierarchy', 'BaseError' ]
        const csharpBody = undefined;
        const csharpErrors = intellisense (root as any, 'BaseError', csharpMakeErrorClassFile, undefined)
        const csharpBodyIntellisense = '\n' + this.createGeneratedHeader().join('\n') + '\n' + csharpBaseError + '\n' + csharpErrors.join ('\n') + '\n'
        const csharpFile = ""
        if (fs.existsSync (csharpFilename)) {
            log.bright.cyan (message, (csharpFilename as any).yellow)
            const csharpRegex = /(?<=public partial class Exchange\n{)((.|\n)+)(?=})/g
            replaceInFile (csharpFilename, csharpRegex, csharpBodyIntellisense)
        }

        log.bright.cyan (message, (csharpFilename as any).yellow)

        // TypeScript ---------------------------------------------------------

        // function declareTsErrorClass (name, parent) {
        //     return 'export class ' + name + ' extends ' + parent + ' {}'
        // }

        // const tsBaseError = [
        //     'export class BaseError extends Error {',
        //     '    constructor(message: string);',
        //     '}',
        // ].join ('\n    ')

        // const tsErrors = intellisense (root, 'BaseError', declareTsErrorClass, undefined)

        // const tsBodyIntellisense = csharpBaseError + '\n\n    ' + tsErrors.join ('\n    ') + '\n\n'

        // log.bright.cyan (message, (tsFilename as any).yellow)
        // const regex = /export class BaseError[^}]+\}[\n][\n](?:\s+export class [a-zA-Z]+ extends [a-zA-Z]+ \{\}[\n])+[\n]/m
        // replaceInFile (tsFilename, regex, tsBodyIntellisense)
    }

    transpileBaseMethods(baseExchangeFile) {
        const csharpExchangeBase = "./c#/src/base/Exchange.BaseMethods.cs";
        const delimiter = 'METHODS BELOW THIS LINE ARE TRANSPILED FROM JAVASCRIPT TO PYTHON AND PHP'

        // to c#
        const baseFile = this.transpiler.transpileCSharpByPath(baseExchangeFile);
        let baseClass = baseFile.content;

        // create wrappers with specific types
        // this.createMethodsWrappers(baseFile.methodsTypes)


        // custom transformations needed for c#
        baseClass = baseClass.replace("((object)this).number = String;", "this.number = typeof(String);"); // tmp fix for c#
        baseClass = baseClass.replace("((object)this).number = float;", "this.number = typeof(float);"); // tmp fix for c#
        // baseClass = baseClass.replace("= new List<Task<List<object>>> {", "= new List<Task<object>> {");
        // baseClass = baseClass.replace("this.number = Number;", "this.number = typeof(float);"); // tmp fix for c#
        baseClass = baseClass.replace("throw new getValue(broad, broadKey)(((string)message));", "this.throwDynamicException(broad, broadKey, message);"); // tmp fix for c#
        baseClass = baseClass.replace("throw new getValue(exact, str)(((string)message));", "this.throwDynamicException(exact, str, message);"); // tmp fix for c#
        // baseClass = baseClass.replace("throw new getValue(exact, str)(message);", "throw new Exception ((string) message);"); // tmp fix for c#

        const jsDelimiter = '// ' + delimiter
        const parts = baseClass.split (jsDelimiter)
        if (parts.length > 1) {
            const baseMethods = parts[1]
            const fileHeader = this.getCsharpImports(undefined).concat([
                "public partial class Exchange\n{\n\n"
            ]).join("\n");

            const file = fileHeader + baseMethods + "\n";
            fs.writeFileSync (csharpExchangeBase, file);
        }
    }

    transpileEverything (force = false, child = false) {

        // default pattern is '.js'
        const exchanges = process.argv.slice (2).filter (x => !x.startsWith ('--'))
            , python2Folder  = './new/python/ccxt/'
            , python3Folder  = './new/python/ccxt/async_support/'
            , phpFolder      = './new/php/'
            , phpAsyncFolder = './new/php/async/'
            , csharpFolder = './c#/src/exchanges/'
            , tsFolder = './ts/src/'
            , exchangeBase = './ts/src/base/Exchange.ts'
            , options = { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder ,exchanges }

        if (!child) {
            createFolderRecursively (python2Folder)
            createFolderRecursively (python3Folder)
            createFolderRecursively (phpFolder)
            createFolderRecursively (phpAsyncFolder)
            createFolderRecursively (csharpFolder)
        }

        const classes = this.transpileDerivedExchangeFiles (tsFolder, options, '.ts', force, !!(child || exchanges.length))

        if (child) {
            return
        }

        // encapsulate inside transpileTests
        this.transpilePrecisionTestsToCSharp();

        this.transpileBaseMethods (exchangeBase)

        //*/

        this.transpileErrorHierarchy ({ tsFilename })

        // this.transpileTests ()

        // this.transpilePythonAsyncToSync ()

        // this.transpilePhpAsyncToSync ()

        // this.transpilePhpBaseClassMethods ()

        // this.addGeneratedHeaderToJs ('./js/')

        log.bright.green ('Transpiled successfully.')
    }

    transpileDerivedExchangeFiles (jsFolder, options, pattern = '.ts', force = false, child = false) {

        // todo normalize jsFolder and other arguments

        const { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder } = options

        // exchanges.json accounts for ids included in exchanges.cfg
        let ids: string[] = []
        try {
            ids = (exchanges as any).ids
        } catch (e) {
        }

        const regex = new RegExp (pattern.replace (/[.*+?^${}()|[\]\\]/g, '\\$&'))

        // let exchanges
        if (options.exchanges && options.exchanges.length) {
            exchanges = options.exchanges.map (x => x + pattern)
        } else {
            exchanges = fs.readdirSync (jsFolder).filter (file => file.match (regex) && (!ids || ids.includes (basename (file, '.ts'))))
        }
        const classNames = exchanges.map (file => this.transpileDerivedExchangeFile (jsFolder, file, options, force))

        const classes = {}

        // if (classNames.length === 0) {
        //     return null
        // }

        // classNames.forEach (({ className, baseClass }) => {
        //     classes[className] = baseClass
        // })

        // if (!child && classNames.length > 1) {
        //     function deleteOldTranspiledFiles (folder, pattern) {
        //         fs.readdirSync (folder)
        //             .filter (file =>
        //                 !fs.lstatSync (folder + file).isDirectory () &&
        //                 !(file.replace (pattern, '') in classes) &&
        //                 !file.match (/^[A-Z_]/))
        //             .map (file => folder + file)
        //             .forEach (file => log.red ('Deleting ' + (file as any).yellow) && fs.unlinkSync (file))
        //     }

        //     [
        //         [ python2Folder, /\.pyc?$/ ],
        //         [ python3Folder, /\.pyc?$/ ],
        //         [ phpFolder, /\.php$/ ],
        //         [ phpAsyncFolder, /\.php$/ ],
        //     ].forEach (([ folder, pattern ]) => {
        //         if (folder) {
        //             deleteOldTranspiledFiles (folder, pattern)
        //         }
        //     })

        // }

        return classes
    }

    createCSharpClass(path) {
        this.transpiler.set
        const csharpVersion = this.transpiler.transpileCSharpByPath(path);
        const csharpImports = this.getCsharpImports(csharpVersion).join("\n") + "\n\n";
        let content = csharpVersion.content;
        content = content.replace(/class\s(\w+)\s:\s(\w+)/gm, "partial class $1 : $2");
        content = this.createGeneratedHeader().join('\n') + '\n' + content;
        return csharpImports + content;
    }

    transpileClass(path) {

        // handle imports
        // handle exports
        // handle generated header
        // const pythonVersion = this.createPythonClass(path)
        const pythonVersion = {}

        // const phpVersion = this.createPHPClass(path);
        const phpVersion = {}
        const csharpVersion = this.createCSharpClass(path);

        return {
            python2: pythonVersion,
            python3: pythonVersion,
            php: phpVersion,
            phpAsync: phpVersion,
            csharp: csharpVersion
        }

    }

    transpileDerivedExchangeFile (tsFolder, filename, options, force = false) {
        console.log("Transpiling", tsFolder, filename);

        const tsPath = tsFolder + filename

        const { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder } = options

        const pythonFilename = filename.replace ('.ts', '.py')
        const phpFilename = filename.replace ('.ts', '.php')
        const csharpFilename = filename.replace ('.ts', '.cs')

        const tsMtime = fs.statSync (tsPath).mtime.getTime ()

        const { python2, python3, php, phpAsync, csharp } = this.transpileClass (tsPath)

        ;[
            // [ python2Folder, pythonFilename, python2 ],
            // [ python3Folder, pythonFilename, python3 ],
            // [ phpFolder, phpFilename, php ],
            // [ phpAsyncFolder, phpFilename, phpAsync ],
            [ csharpFolder, csharpFilename, csharp ],
        ].forEach (([ folder, filename, code ]) => {
            if (folder) {
                overwriteFile (folder + filename, code)
                fs.utimesSync (folder + filename, new Date (), new Date (tsMtime))
            }
        })

        return []
    }

    transpilePrecisionTestsToCSharp () {

        const jsFile = './ts/src/test/base/functions/test.number.ts';
        const csharpFile = './c#/Tests/Generated/Precision.cs';

        log.magenta ('Transpiling from', (jsFile as any).yellow)

        const csharp = this.transpiler.transpileCSharpByPath(jsFile);
        let content = csharp.content;
        content = this.regexAll (content, [
            [ /object  = functions;/g, '' ], // tmp fix
            [/assert/g, 'Assert.True'],
        ]).trim ()

        const contentLines = content.split ('\n');
        const contentIdented = contentLines.map (line => '        ' + line).join ('\n');

        const file = [
            'using Main;',
            'namespace Tests;',
            '',
            this.createGeneratedHeader().join('\n'),
            'public class PrecisionTests : BaseTest',
            '{',
            '    [Fact]',
            '    public void TestPrecision()',
            '    {',
            contentIdented,
            '    }',
            '}',
        ].join('\n')

        log.magenta ('→', (csharpFile as any).yellow)

        overwriteFile (csharpFile, file);
    }
}

const metaUrlRaw = import.meta.url
const metaUrl = metaUrlRaw.substring(0, metaUrlRaw.lastIndexOf(".")) // remove extension
const url = pathToFileURL(process.argv[1]);
if (metaUrl === url.href || url.href === metaUrlRaw) { // called directly like `node module`

    const transpiler = new NewTranspiler ()
    transpiler.transpileEverything ();

} else { // if required as a module

    // do nothing
}