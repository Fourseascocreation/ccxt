import Transpiler from "ast-transpiler";
import ts from "typescript";

import errors from "../js/src/base/errors.js"
import { basename, join } from 'path'
import { createFolderRecursively, replaceInFile, overwriteFile } from './fsLocal.js'
import {unCamelCase, precisionConstants, safeString, unique} from "../js/src/base/functions.js"
import { platform } from 'process'
import { pathToFileURL } from 'url'
import fs from 'fs'
import log from 'ololog'
import ansi from 'ansicolor'
import {Transpiler as OldTranspiler} from "./transpile.js";
import errorHierarchy from '../js/src/base/errorHierarchy.js'

const tsFilename = './ccxt.d.ts'
const pythonCodingUtf8 = '# -*- coding: utf-8 -*-'
const baseExchangeJsFile = './ts/src/base/Exchange.ts'

let exchanges = JSON.parse (fs.readFileSync("./exchanges.json", "utf8"));

// import errorHierarchy from '../js/src/base/errorHierarchy.js'

// helper

let __dirname = new URL('.', import.meta.url).pathname;

// this is necessary because for some reason
// pathname keeps the first '/' for windows paths
// making them invalid
// example: /C:Users/user/Desktop/
if (platform === 'win32') {
    if (__dirname[0] === '/') {
        __dirname = __dirname.substring(1)
    }
}

class NewTranspiler {

    transpiler;
    pythonStandardLibraries;
    oldTranspiler = new OldTranspiler();

    constructor() {

        this.setupTranspiler()

        this.pythonStandardLibraries = {
            'hashlib': 'hashlib',
            'math': 'math',
            'json.loads': 'json',
            'json.dumps': 'json',
            'sys': 'sys',
        }
    }

    // c# custom method
    customCSharpPropAssignment(node, identation) {
        const stringValue = node.getFullText().trim();
        if (Object.keys(errors).includes(stringValue)) {
            return `typeof(${stringValue})`;
        }
        return undefined;
    }

    // a helper to apply an array of regexes and substitutions to text
    // accepts an array like [ [ regex, substitution ], ... ]

    regexAll (text, array) {
        for (const i in array) {
            let regex = array[i][0]
            const flags = (typeof regex === 'string') ? 'g' : undefined
            regex = new RegExp (regex, flags)
            text = text.replace (regex, array[i][1])
        }
        return text
    }


    setupTranspiler() {
        this.transpiler = new Transpiler ({
            "csharp": {
                "parser": {
                    "ELEMENT_ACCESS_WRAPPER_OPEN": "getValue(",
                    "ELEMENT_ACCESS_WRAPPER_CLOSE": ")"
                }
            },
            "php": {
                "uncamelcaseIdentifiers": true,
                "ScopeResolutionProps": ["super", "Precise"]
            },
            "python": {
                "uncamelcaseIdentifiers": true,
            }
        })
        this.transpiler.setVerboseMode(false);
        // this.transpiler.csharpTranspiler.printCustomRightSidePropertyAssignment = this.customCSharpPropAssignment;

    }

    createGeneratedHeader() {
        return [
            "// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            ""
        ]
    }

    createPythonHeader () {
        return [
            pythonCodingUtf8,
            "",
            "# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            "",
        ]
    }


    createPHPClassHeader (className, baseClass, bodyAsString, namespace) {
        return [
            "<?php",
            "",
            "namespace " + namespace + ";",
            "",
            "// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:",
            "// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code",
            "",
            "use Exception; // a common import",
        ]
    }

    getCsharpImports(file) {
        return [
            "using Main;",
            "namespace Main;"
        ]
    }

    transpileErrorHierarchy ({ tsFilename }) {

        const errorHierarchyFilename = './js/src/base/errorHierarchy.js'
        const errorHierarchyPath = __dirname + '/.' + errorHierarchyFilename

        let js = fs.readFileSync (errorHierarchyPath, 'utf8')

        js = this.regexAll (js, [
            // [ /export { [^\;]+\s*\}\n/s, '' ], // new esm
            [ /\s*export default[^\n]+;\n/g, '' ],
            // [ /module\.exports = [^\;]+\;\n/s, '' ], // old commonjs
        ]).trim ()

        const message = 'Transpiling error hierachy â†’'
        const root = errorHierarchy['BaseError']
        // const root = undefined;

        const { python3Body } =  this.oldTranspiler.transpileJavaScriptToPythonAndPHP ({ js })

        // a helper to generate a list of exception class declarations
        // properly derived from corresponding parent classes according
        // to the error hierarchy

        function intellisense (map, parent, generate, classes) {
            function* generator(map, parent, generate, classes) {
                for (const key in map) {
                    yield generate (key, parent, classes)
                    yield* generator (map[key], key, generate, classes)
                }
            }
            return Array.from (generator (map, parent, generate, classes))
        }

        // Python -------------------------------------------------------------

        function pythonDeclareErrorClass (name, parent, classes) {
            classes.push (name)
            return [
                'class ' + name + '(' + parent + '):',
                '    pass',
                '',
                '',
            ].join ('\n');
        }

        const pythonBaseError = [
            'class BaseError(Exception):',
            '    pass',
            '',
            '',
        ].join ('\n');

        const quote = (s) => "'" + s + "'" // helper to add quotes around class names
        const pythonExports = [ 'error_hierarchy', 'BaseError' ]
        const pythonErrors = intellisense (root as any, 'BaseError', pythonDeclareErrorClass, pythonExports)
        const pythonAll = '__all__ = [\n    ' + pythonExports.map (quote).join (',\n    ') + '\n]'
        const python3BodyIntellisense = python3Body + '\n\n\n' + pythonBaseError + '\n' + pythonErrors.join ('\n') + '\n' + pythonAll + '\n'

        const pythonFilename = './python/ccxt/base/errors.py'
        if (fs.existsSync (pythonFilename)) {
            log.bright.cyan (message, (pythonFilename as any).yellow)
            fs.writeFileSync (pythonFilename, python3BodyIntellisense)
        }

        // PHP ----------------------------------------------------------------

        function phpMakeErrorClassFile (name, parent) {

            const useClause = "\nuse " + parent + ";\n"
            const requireClause = "\nrequire_once PATH_TO_CCXT . '" + parent + ".php';\n"

            const phpBody = [
                '<?php',
                '',
                'namespace ccxt;',
                (parent === 'Exception') ? useClause : requireClause,
                'class ' + name + ' extends ' + parent + ' {};',
                '',
            ].join ("\n")
            const phpFilename = './php/' + name + '.php'
            log.bright.cyan (message, (phpFilename as any).yellow)
            fs.writeFileSync (phpFilename, phpBody)
            return "require_once PATH_TO_CCXT . '" + name + ".php';"
        }

        const phpFilename ='./ccxt.php'

        if (fs.existsSync (phpFilename)) {
            const phpErrors = intellisense (errorHierarchy, 'Exception', phpMakeErrorClassFile, undefined) as any
            const phpBodyIntellisense = phpErrors.join ("\n") + "\n\n"
            log.bright.cyan (message, (phpFilename as any).yellow)
            const phpRegex = /require_once PATH_TO_CCXT \. \'BaseError\.php\'\;\n(?:require_once PATH_TO_CCXT[^\n]+\n)+\n/m
            replaceInFile (phpFilename, phpRegex, phpBodyIntellisense)
        }


        // CSHARP ----------------------------------------------------------------

        // ---------------------------------------------------------------------

        function csharpMakeErrorClassFile (name, parent) {
            const exception =
`   public class ${name} : ${parent}
    {
        public ${name}() : base() { }
        public ${name}(string message) : base(message) { }
        public ${name}(string message, ${parent} inner) : base(message, inner) { }
    }`;
            return exception
        }

        const csharpFilename ='./c#/base/Exchange.Errors.cs'

            const csharpBaseError =
`   public class BaseError : Exception
    {
        public BaseError() : base() { }
        public BaseError(string message) : base(message) { }
        public BaseError(string message, Exception inner) : base(message, inner) { }
    }`;

        // const pythonExports = [ 'error_hierarchy', 'BaseError' ]
        const csharpBody = undefined;
        const csharpErrors = intellisense (root as any, 'BaseError', csharpMakeErrorClassFile, undefined)
        const csharpBodyIntellisense = '\n' + this.createGeneratedHeader().join('\n') + '\n' + csharpBaseError + '\n' + csharpErrors.join ('\n') + '\n'
        const csharpFile = ""
        if (fs.existsSync (csharpFilename)) {
            log.bright.cyan (message, (csharpFilename as any).yellow)
            const csharpRegex = /(?<=public partial class Exchange\n{)((.|\n)+)(?=})/g
            replaceInFile (csharpFilename, csharpRegex, csharpBodyIntellisense)
        }

        log.bright.cyan (message, (csharpFilename as any).yellow)

        // TypeScript ---------------------------------------------------------

        function declareTsErrorClass (name, parent) {
            return 'export class ' + name + ' extends ' + parent + ' {}'
        }

        const tsBaseError = [
            'export class BaseError extends Error {',
            '    constructor(message: string);',
            '}',
        ].join ('\n    ')

        const tsErrors = intellisense (root, 'BaseError', declareTsErrorClass, undefined)

        const tsBodyIntellisense = csharpBaseError + '\n\n    ' + tsErrors.join ('\n    ') + '\n\n'

        log.bright.cyan (message, (tsFilename as any).yellow)
        const regex = /export class BaseError[^}]+\}[\n][\n](?:\s+export class [a-zA-Z]+ extends [a-zA-Z]+ \{\}[\n])+[\n]/m
        replaceInFile (tsFilename, regex, tsBodyIntellisense)
    }

    transpileBaseMethods(baseExchangeFile) {
        const csharpExchangeBase = "./c#/base/Exchange.BaseMethods.cs";
        const delimiter = 'METHODS BELOW THIS LINE ARE TRANSPILED FROM JAVASCRIPT TO PYTHON AND PHP'

        // to c#
        const baseFile = this.transpiler.transpileCSharpByPath(baseExchangeFile);
        let baseClass = baseFile.content;

        // custom transformations needed for c#
        baseClass = baseClass.replace("((object)this).number = String;", "this.number = typeof(String);"); // tmp fix for c#
        baseClass = baseClass.replace("((object)this).number = float;", "this.number = typeof(float);"); // tmp fix for c#
        baseClass = baseClass.replace("= new List<Task<List<object>>> {", "= new List<Task<object>> {");
        // baseClass = baseClass.replace("this.number = Number;", "this.number = typeof(float);"); // tmp fix for c#
        baseClass = baseClass.replace("throw new getValue(broad, broadKey)(((string)message));", "this.throwDynamicException(broad, broadKey, message);"); // tmp fix for c#
        baseClass = baseClass.replace("throw new getValue(exact, str)(((string)message));", "this.throwDynamicException(exact, str, message);"); // tmp fix for c#
        // baseClass = baseClass.replace("throw new getValue(exact, str)(message);", "throw new Exception ((string) message);"); // tmp fix for c#

        const jsDelimiter = '// ' + delimiter
        const parts = baseClass.split (jsDelimiter)
        if (parts.length > 1) {
            const baseMethods = parts[1]
            const fileHeader = this.getCsharpImports(undefined).concat([
                "public partial class Exchange\n{\n\n"
            ]).join("\n");

            const file = fileHeader + baseMethods + "\n";
            fs.writeFileSync (csharpExchangeBase, file);
        }
    }

    transpileEverything (force = false, child = false) {

        // default pattern is '.js'
        const exchanges = process.argv.slice (2).filter (x => !x.startsWith ('--'))
            , python2Folder  = './new/python/ccxt/'
            , python3Folder  = './new/python/ccxt/async_support/'
            , phpFolder      = './new/php/'
            , phpAsyncFolder = './new/php/async/'
            , csharpFolder = './c#/exchanges/'
            , tsFolder = './ts/src/'
            , exchangeBase = './ts/src/base/Exchange.ts'
            , options = { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder ,exchanges }

        if (!child) {
            createFolderRecursively (python2Folder)
            createFolderRecursively (python3Folder)
            createFolderRecursively (phpFolder)
            createFolderRecursively (phpAsyncFolder)
            createFolderRecursively (csharpFolder)
        }

        // const classes = this.transpileDerivedExchangeFiles (tsFolder, options, pattern, force)
        // const classes = this.transpileDerivedExchangeFiles (tsFolder, options, '.ts', force, !!(child || exchanges.length))

        if (child) {
            return
        }

        // this.transpileBaseMethods (exchangeBase)

        //*/

        this.transpileErrorHierarchy ({ tsFilename })

        // this.transpileTests ()

        // this.transpilePythonAsyncToSync ()

        // this.transpilePhpAsyncToSync ()

        // this.transpilePhpBaseClassMethods ()

        // this.addGeneratedHeaderToJs ('./js/')

        log.bright.green ('Transpiled successfully.')
    }

    transpileDerivedExchangeFiles (jsFolder, options, pattern = '.ts', force = false, child = false) {

        // todo normalize jsFolder and other arguments

        const { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder } = options

        // exchanges.json accounts for ids included in exchanges.cfg
        let ids: string[] = []
        try {
            ids = (exchanges as any).ids
        } catch (e) {
        }

        const regex = new RegExp (pattern.replace (/[.*+?^${}()|[\]\\]/g, '\\$&'))

        // let exchanges
        if (options.exchanges && options.exchanges.length) {
            exchanges = options.exchanges.map (x => x + pattern)
        } else {
            exchanges = fs.readdirSync (jsFolder).filter (file => file.match (regex) && (!ids || ids.includes (basename (file, '.ts'))))
        }
        // // exchanges = ["binance.ts", "wazirx.ts", "whitebit.ts", "alpaca.ts"]
        // exchanges = ["binance.ts", "bybit.ts", "whitebit.ts"]
        // exchanges = exchanges.slice(0, 25)
        // exchanges = ['bitopro.ts', 'bitget.ts', 'bithumb.ts']
        const classNames = exchanges.map (file => this.transpileDerivedExchangeFile (jsFolder, file, options, force))

        const classes = {}

        // if (classNames.length === 0) {
        //     return null
        // }

        // classNames.forEach (({ className, baseClass }) => {
        //     classes[className] = baseClass
        // })

        // if (!child && classNames.length > 1) {
        //     function deleteOldTranspiledFiles (folder, pattern) {
        //         fs.readdirSync (folder)
        //             .filter (file =>
        //                 !fs.lstatSync (folder + file).isDirectory () &&
        //                 !(file.replace (pattern, '') in classes) &&
        //                 !file.match (/^[A-Z_]/))
        //             .map (file => folder + file)
        //             .forEach (file => log.red ('Deleting ' + (file as any).yellow) && fs.unlinkSync (file))
        //     }

        //     [
        //         [ python2Folder, /\.pyc?$/ ],
        //         [ python3Folder, /\.pyc?$/ ],
        //         [ phpFolder, /\.php$/ ],
        //         [ phpAsyncFolder, /\.php$/ ],
        //     ].forEach (([ folder, pattern ]) => {
        //         if (folder) {
        //             deleteOldTranspiledFiles (folder, pattern)
        //         }
        //     })

        // }

        return classes
    }


    createPHPClass (file, async = false) {

        const phpFile = this.transpiler.transpilePhpByPath(file);

        const heritage = phpFile.imports.filter(imp => imp.path.indexOf("Exchange") > 0 || imp.path.match (/.\/\w+\.js/) );
        const baseClass = heritage[0].name;

        const bodyAsString = phpFile.content;
        let header = this.createPHPClassHeader (undefined, undefined, undefined, async ? 'ccxt\\async' : 'ccxt')

        const errorImports: string[] = []

        if (async) {
            for (let error in errors) {
                const regex = new RegExp ("[^'\"]" + error + "[^'\"]")
                if (bodyAsString.match (regex)) {
                    errorImports.push ('use ccxt\\' + error + ';')
                }
            }
        }

        const precisionImports: string[] = []
        const libraryImports: string[] = []

        if (async) {
            if (bodyAsString.match (/[\s(]Precise/)) {
                precisionImports.push ('use ccxt\\Precise;')
            }
            if (bodyAsString.match (/Async\\await/)) {
                libraryImports.push ('use React\\Async;')
            }
            if (bodyAsString.match (/Promise\\all/)) {
                libraryImports.push ('use React\\Promise;')
            }
        }

        header = header.concat (errorImports).concat (precisionImports).concat (libraryImports)

        const result = header.join ("\n") + "\n" + bodyAsString + "\n";
        return result
    }

    createPythonClassImports (baseClass, async: any = false) {
        const baseClasses = {
            'Exchange': 'base.exchange',
        }
        async = (async ? '.async_support' : '')

        return [
            (baseClass.indexOf ('ccxt.') === 0) ?
                ('import ccxt' + async + ' as ccxt') :
                ('from ccxt' + async + '.' + safeString (baseClasses, baseClass, baseClass) + ' import ' + baseClass)        ]
    }

    createPythonClass(file, async = false) {
        const pythonVersion = this.transpiler.transpilePythonByPath(file);
        const imports = this.createPythonHeader().concat(this.createPythonImports(pythonVersion)).join("\n") + "\n\n\n";
        return imports + pythonVersion.content;
    }

    createCSharpClass(path) {
        this.transpiler.set
        const csharpVersion = this.transpiler.transpileCSharpByPath(path);
        const csharpImports = this.getCsharpImports(csharpVersion).join("\n") + "\n\n";
        return csharpImports + csharpVersion.content;
    }

    createPythonImports(file) {

        const errorImports: string[] = [];
        const libraries:string[] = [];
        const asyncioImports:string[] = [];
        const precisionImports:string[] = [];

        const exceptions = file.imports.filter(imp => imp.path.indexOf("errors.js") > 0);
        const precise  = file.imports.filter(imp => imp.path.indexOf("Precise") > 0);
        const functions  = file.imports.filter(imp => imp.path.indexOf("functions") > 0);

        const heritage = file.imports.filter(imp => imp.path.indexOf("Exchange") > 0 || imp.path.match (/.\/\w+\.js/) );

        const imports = this.createPythonClassImports (heritage[0].name, true)

        for (let error in exceptions) {
            const exception = exceptions[error];
            errorImports.push(`from ccxt.base.errors import ${exception.name}`);
        }

        if (file.content.match (/numbers\.(Real|Integral)/)) {
            libraries.push ('import numbers')
        }

        if (file.content.match (/[\s(]Precise/)) {
            precisionImports.push ('from ccxt.base.precise import Precise')
        }

        for (let constant in precisionConstants) {
            if (file.content.indexOf (constant) >= 0) {
                precisionImports.push ('from ccxt.base.decimal_to_precision import ' + constant)
            }
        }

        if (file.content.match (/asyncio/)) {
            asyncioImports.push ('import asyncio')
        }

        for (let library in this.pythonStandardLibraries) {
            const regex = new RegExp ("[^\\'\\\"a-zA-Z]" + library + "[^\\'\\\"a-zA-Z]")
            if (file.content.match (regex)){
                const importStatement = 'import ' + this.pythonStandardLibraries[library];
                if (!libraries.includes(importStatement)) {
                    libraries.push (importStatement)
                }
            }
        }

        return errorImports.concat(imports, libraries, asyncioImports, precisionImports);

    }

    transpileClass(path) {

        // handle imports
        // handle exports
        // handle generated header
        // const pythonVersion = this.createPythonClass(path)
        const pythonVersion = {}

        // const phpVersion = this.createPHPClass(path);
        const phpVersion = {}
        const csharpVersion = this.createCSharpClass(path);

        return {
            python2: pythonVersion,
            python3: pythonVersion,
            php: phpVersion,
            phpAsync: phpVersion,
            csharp: csharpVersion
        }

    }

    transpileDerivedExchangeFile (tsFolder, filename, options, force = false) {
        console.log("Transpiling", tsFolder, filename);

        const tsPath = tsFolder + filename

        const { python2Folder, python3Folder, phpFolder, phpAsyncFolder, csharpFolder } = options

        const pythonFilename = filename.replace ('.ts', '.py')
        const phpFilename = filename.replace ('.ts', '.php')
        const csharpFilename = filename.replace ('.ts', '.cs')

        const tsMtime = fs.statSync (tsPath).mtime.getTime ()

        const { python2, python3, php, phpAsync, csharp } = this.transpileClass (tsPath)

        ;[
            // [ python2Folder, pythonFilename, python2 ],
            // [ python3Folder, pythonFilename, python3 ],
            // [ phpFolder, phpFilename, php ],
            // [ phpAsyncFolder, phpFilename, phpAsync ],
            [ csharpFolder, csharpFilename, csharp ],
        ].forEach (([ folder, filename, code ]) => {
            if (folder) {
                overwriteFile (folder + filename, code)
                fs.utimesSync (folder + filename, new Date (), new Date (tsMtime))
            }
        })

        return []
    }

}

const metaUrlRaw = import.meta.url
const metaUrl = metaUrlRaw.substring(0, metaUrlRaw.lastIndexOf(".")) // remove extension
const url = pathToFileURL(process.argv[1]);
if (metaUrl === url.href || url.href === metaUrlRaw) { // called directly like `node module`

    const transpiler = new NewTranspiler ()
    transpiler.transpileEverything ();

} else { // if required as a module

    // do nothing
}