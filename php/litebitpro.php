<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\NotSupported;

class litebitpro extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'litebitpro',
            'name' => 'LiteBit Pro',
            'countries' => array( 'NL' ), // Netherlands
            'rateLimit' => 60.1, // 1000 requests per second TODO => we don't have a global rate limit across all endpoints
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'CORS' => true,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFees' => true,
            ),
            'timeframes' => array(
                '1m' => '60',
                '5m' => '300',
                '15m' => '900',
                '1h' => '3600',
                '4h' => '14400',
                '1d' => '86400',
            ),
            'urls' => array(
                // TODO
                'logo' => 'TODO',
                'api' => array(
                    'public' => 'https://api.exchange.acc.litebit.cloud',
                    'private' => 'https://api.exchange.acc.litebit.cloud',
                ),
                'www' => 'https://pro.litebit.com/',
                'doc' => 'https://docs.pro.litebit.com/',
                // TODO
                'fees' => 'TODO',
                // TODO
                'referral' => 'TODO',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'time' => 1,
                        'assets' => 1,
                        'markets' => 1,
                        'ticker' => 1,
                        'tickers' => 1,
                        'book' => 1,
                        'candles' => 1,
                        'trades' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'orders/open' => 1,
                        'orders/closed' => 1,
                        'order' => 1,
                        'fills' => 1,
                        'fee' => 1,
                        'balances' => 1,
                    ),
                    'post' => array(
                        'order' => 1,
                    ),
                    'delete' => array(
                        'orders' => 1,
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'exceptions' => array(
                'exact' => array(
                    '10000' => '\\ccxt\\BadRequest', // This error code is used for validation errors. See message for more information about the validation error.
                    '10001' => '\\ccxt\\InvalidOrder', // The notional value of your order is too low. Use GET /market's minimum_amount_quote to retrieve the market's minimum notional value.
                    '10002' => '\\ccxt\\InvalidOrder', // Order time in force is missing.
                    '10003' => '\\ccxt\\OnMaintenance', // Post-only is only allowed for limit orders.
                    '10004' => '\\ccxt\\InvalidOrder', // Price must be higher than zero.
                    '10005' => '\\ccxt\\InvalidOrder', // Price is required for limit orders.
                    '10006' => '\\ccxt\\InvalidOrder', // Type is required for orders.
                    '10007' => '\\ccxt\\InvalidNonce', // Time window cannot be smaller than 1 or larger than 60000 milliseconds.
                    '10008' => '\\ccxt\\AuthenticationError', // Unauthenticated.
                    '10009' => '\\ccxt\\PermissionDenied', // Unauthorized.
                    '10010' => '\\ccxt\\BadRequest', // Invalid JSON.
                    '10011' => '\\ccxt\\BadRequest', // Invalid event.
                    '10012' => '\\ccxt\\BadRequest', // Invalid channel.
                    '10013' => '\\ccxt\\AuthenticationError', // Any of => Could not derive authentication method. Invalid API key and/or signature. Invalid timestamp. Invalid API key. Invalid signature. Connection is already authenticated.
                    '20000' => '\\ccxt\\InsufficientFunds', // Insufficient funds.
                    '20001' => '\\ccxt\\DDoSProtection', // Maximum of open orders allowed per user per market.
                    '20002' => '\\ccxt\\ExchangeError', // Insufficient liquidity.
                    '20003' => '\\ccxt\\RateLimitExceeded', // Rate limit exceeded.
                    '20004' => '\\ccxt\\ExchangeNotAvailable', // Transient request error without any available public information.
                    '30000' => '\\ccxt\\OnMaintenance', // Exchange is in maintenance mode.
                    '30001' => '\\ccxt\\ExchangeError', // An unexpected error occurred. The execution status of your request is unknown.
                    '40000' => '\\ccxt\\OnMaintenance', // Only post-only orders are currently accepted by the matching engine.
                    '40001' => '\\ccxt\\OnMaintenance', // Only cancel order requests are currently accepted by the matching engine.
                    '40002' => '\\ccxt\\ExchangeError', // Order book limit reached, only taker orders are allowed.
                    '40003' => '\\ccxt\\ExchangeNotAvailable', // Market overloaded.
                    '40004' => '\\ccxt\\OnMaintenance', // Market is halted.
                    '40005' => '\\ccxt\\OnMaintenance', // Market is inactive.
                    '50000' => '\\ccxt\\AuthenticationError', // Your request was rejected, because it was received outside the allowed time window.
                ),
                'broad' => array(
                ),
            ),
            'options' => array(
                'LITEBIT-WINDOW' => 10000, // default 10 sec
                'fetchCurrencies' => array(
                    'expires' => 1000, // 1 second
                ),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function fetch_time($params = array ()) {
        $response = $this->publicGetTime ($params);
        //
        //     array("timestamp":1641228475856)
        //
        return $this->safe_integer($response, 'timestamp');
    }

    public function fetch_markets($params = array ()) {
        $response = $this->publicGetMarkets ($params);
        //
        // array(
        //    {
        //       "market":"BTC-EUR",
        //       "status":"active",
        //       "step_size":"0.00000001",
        //       "tick_size":"0.01",
        //       "minimum_amount_quote":"5.00",
        //       "base_asset":"BTC",
        //       "quote_asset":"EUR"
        //    }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $market = $response[$i];
            $id = $this->safe_string($market, 'market');
            $baseId = $this->safe_string($market, 'base_asset');
            $quoteId = $this->safe_string($market, 'quote_asset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $status = $this->safe_string($market, 'status');
            $active = ($status === 'active');
            $precision = array(
                'price' => $this->safe_number($market, 'tick_size'),
                'amount' => $this->safe_number($market, 'step_size'),
            );
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'type' => 'spot',
                'spot' => true,
                'active' => $active,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => $this->safe_number($market, 'step_size'),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => $this->safe_number($market, 'tick_size'),
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number($market, 'minimum_amount_quote'),
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_currencies_from_cache($params = array ()) {
        // this method is $now redundant
        // currencies are $now fetched before markets
        $options = $this->safe_value($this->options, 'fetchCurrencies', array());
        $timestamp = $this->safe_integer($options, 'timestamp');
        $expires = $this->safe_integer($options, 'expires', 1000);
        $now = $this->milliseconds();
        if (($timestamp === null) || (($now - $timestamp) > $expires)) {
            $response = $this->publicGetAssets ($params);
            $this->options['fetchCurrencies'] = array_merge($options, array(
                'response' => $response,
                'timestamp' => $now,
            ));
        }
        return $this->safe_value($this->options['fetchCurrencies'], 'response');
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->fetch_currencies_from_cache($params);
        //
        // array(
        //    {
        //       "code":"EUR",
        //       "name":"Euro",
        //       "decimals":"2"
        //    }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $currency = $response[$i];
            $id = $this->safe_string($currency, 'code');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'name');
            $precision = $this->safe_integer($currency, 'decimals');
            $result[$code] = array(
                'id' => $id,
                'info' => $currency,
                'code' => $code,
                'name' => $name,
                'active' => null,
                'fee' => null,
                // convert number of decimals to $precision mode TICK_SIZE
                'precision' => pow(10, -$precision),
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetFee ($params);
        //
        // {
        //     "maker" => "0.15",
        //     "taker" => "0.25",
        //     "volume" => "11.70"
        // }
        //
        $result = array();
        $maker = $this->safe_number($response, 'maker');
        if ($maker !== null) {
            // convert to ratio
            $maker = $maker / 100;
        }
        $taker = $this->safe_number($response, 'taker');
        if ($taker !== null) {
            // convert to ratio
            $taker = $taker / 100;
        }
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'maker' => $maker,
                'taker' => $taker,
                'info' => $response,
                'symbol' => $symbol,
            );
        }
        return $result;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        $response = $this->publicGetTicker (array_merge($request, $params));
        // {
        //    "market":"BTC-EUR",
        //    "open":"43234.98",
        //    "last":"42213.20000000",
        //    "volume":"29981.04495099",
        //    "low":"40882.22",
        //    "high":"43986.34",
        //    "bid":"41781.32",
        //    "ask":"42213.20"
        // }
        return $this->parse_ticker($response, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // fetchTicker
        //
        // {
        //    "market":"BTC-EUR",
        //    "open":"43234.98",
        //    "last":"42213.20000000",
        //    "volume":"29981.04495099",
        //    "low":"40882.22",
        //    "high":"43986.34",
        //    "bid":"41781.32",
        //    "ask":"42213.20"
        // }
        //
        $marketId = $this->safe_string($ticker, 'market');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $last = $this->safe_number($ticker, 'last');
        $baseVolume = $this->safe_number($ticker, 'volume');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_number($ticker, 'high'),
            'low' => $this->safe_number($ticker, 'low'),
            'bid' => $this->safe_number($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_number($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_number($ticker, 'open'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null, // previous day close
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->publicGetTickers ($params);
        // array(
        //    {
        //       "market":"BTC-EUR",
        //       "open":"43346.43",
        //       "last":"42046.58000000",
        //       "volume":"30006.37834551",
        //       "low":"40882.22",
        //       "high":"43986.34",
        //       "bid":"41946.08",
        //       "ask":"42046.58"
        //    }
        // )
        return $this->parse_tickers($response, $symbols);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            // 'limit' => 200, // default 200, max 200
            // 'timestamp_from' => $since,
            // 'timestamp_to' => $this->milliseconds(),
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['timestamp_from'] = $since;
        }
        $response = $this->publicGetTrades (array_merge($request, $params));
        // array(
        //    {
        //       "uuid":"c28a37e2-69d1-4844-ad37-b8f08311478d",
        //       "amount":"0.36636292",
        //       "price":"41551.23000000",
        //       "side":"sell",
        //       "market":"BTC-EUR",
        //       "timestamp":1640788080819
        //    }
        // )
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (public)
        //
        // {
        //    "uuid":"c28a37e2-69d1-4844-ad37-b8f08311478d",
        //    "amount":"0.36636292",
        //    "price":"41551.23000000",
        //    "side":"sell",
        //    "market":"BTC-EUR",
        //    "timestamp":1640788080819
        // }
        //
        // fetchMyTrades (private)
        //
        // {
        //     "uuid" => "234234897234-1243-1234-qsf234",
        //     "order_uuid" => "234234897234-1243-1234-qsf235",
        //     "amount" => "0.00100000",
        //     "price" => "42986.64",
        //     "amount_quote" => "43.09410660",
        //     "side" => "buy",
        //     "fee" => "0.10746660",
        //     "market" => "BTC-EUR",
        //     "liquidity" => "taker",
        //     "timestamp" => 1622123573863
        // }
        //
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'amount');
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $side = $this->safe_string($trade, 'side');
        $id = $this->safe_string($trade, 'uuid');
        $marketId = $this->safe_string($trade, 'market');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $takerOrMaker = $this->safe_string($trade, 'liquidity');
        $feeCurrency = null;
        if ($market !== null) {
            $feeCurrency = $market['quote'];
        }
        $fee = array(
            'cost' => $this->safe_string($trade, 'fee'),
            'currency' => $feeCurrency,
        );
        $feeString = $this->safe_string($trade, 'fee');
        $amountQuote = $this->safe_string($trade, 'amount_quote');
        $cost = null;
        if ($amountQuote !== null && $feeString !== null) {
            if ($side === 'buy') {
                $cost = Precise::string_sub($amountQuote, $feeString);
            } else {
                $cost = Precise::string_add($amountQuote, $feeString);
            }
        }
        $orderId = $this->safe_string($trade, 'order_uuid');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'market' => $this->market_id($symbol),
        );
        if ($limit !== null) {
            throw new NotSupported($this->id . ' fetchOrderBook() doesn\'t support the $limit parameter.');
        }
        $response = $this->publicGetBook (array_merge($request, $params));
        //
        // {
        //     "market" => "BTC-EUR",
        //     "timestamp" => 1622123573863,
        //     "sequence" => 1231232,
        //     "update_type" => "snapshot",
        //     "bids" => [
        //         ["2.0000", "201.99000000"],
        //         ...,
        //     ],
        //     "asks" => [
        //         ["2.0000", "201.99000000"],
        //         ...,
        //     ]
        // }
        //
        $orderbook = $this->parse_order_book(
            $response,
            $symbol,
            $this->safe_integer($response, 'timestamp')
        );
        $orderbook['nonce'] = $this->safe_integer($response, 'sequence');
        return $orderbook;
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     array(
        //         1590383700000,
        //         "8088.5",
        //         "8088.5",
        //         "8088.5",
        //         "8088.5",
        //         "0.04788623"
        //     )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
            // 'limit' => 1440, // default 500, max 500
            // 'timestamp_from' => $since,
            // 'timestamp_to' => $this->milliseconds(),
        );
        if ($since !== null) {
            $request['timestamp_from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 500, max 500
        }
        $response = $this->publicGetCandles (array_merge($request, $params));
        //
        //     [
        //         [1590383700000,"8088.5","8088.5","8088.5","8088.5","0.04788623"],
        //         [1590383580000,"8091.3","8091.5","8091.3","8091.5","0.04931221"],
        //         [1590383520000,"8090.3","8092.7","8090.3","8092.5","0.04001286"],
        //     ]
        //
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetBalances ($params);
        //
        // array(
        //    {
        //       "available":"7716.93507952",
        //       "reserved":"2155.37500000",
        //       "total":"9872.31007952",
        //       "asset":"EUR"
        //    }
        // )
        //
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $currencyId = $this->safe_string($balance, 'asset');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'reserved');
            $account['total'] = $this->safe_string($balance, 'total');
            $result[$code] = $account;
        }
        return $this->parse_balance($result);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            'side' => $side,
            'type' => $type, // limit, $market
            // 'amount' => $this->amount_to_precision($symbol, $amount),
            // 'amount_quote' => $this->cost_to_precision($symbol, $cost),
            // 'price' => $this->price_to_precision($symbol, $price),
            // 'stop' => 'loss', // "entry" = trigger when the last $price is greater than or equal to stop_price. "loss" = trigger when the last $price is less than or equal to stop_price.
            // 'stop_price' => $this->price_to_precision($symbol, $price),
            // 'post_only' => false,
            // 'time_in_force' => 'gtc', // gtc, ioc, fok, day, gtd
            // 'expire_at' => $expireAt,
            // 'client_id' => $clientId,
        );
        $stop = $this->safe_string($params, 'stop');
        if ($stop !== null) {
            $stopPrice = $this->safe_number_2($params, 'stopPrice', 'stop_price');
            if ($stopPrice === null) {
                throw new ArgumentsRequired($this->id . ' createOrder requires a $stopPrice parameter for a $stop order');
            }
            $request['stop'] = $stop;
            $request['stop_price'] = $this->price_to_precision($symbol, $stopPrice);
        }
        $postOnly = $this->safe_value_2($params, 'postOnly', 'post_only', false);
        if ($postOnly) {
            $request['post_only'] = true;
        }
        $timeInForce = $this->safe_string_2($params, 'timeInForce', 'time_in_force');
        if ($timeInForce !== null) {
            $request['time_in_force'] = $timeInForce;
            if ($timeInForce === 'gtd') {
                $expireAt = $this->safe_number_2($params, 'expireAt', 'expire_at');
                if ($expireAt === null) {
                    throw new ArgumentsRequired($this->id . ' createOrder requires a $expireAt parameter for a ' . $timeInForce . ' order');
                }
                $request['expire_at'] = $expireAt;
            }
        }
        $clientId = $this->safe_string_2($params, 'client_id', 'clientOrderId');
        if ($clientId !== null) {
            $request['client_id'] = $clientId;
        }
        $params = $this->omit($params, ['stop', 'stopPrice', 'stop_price', 'postOnly', 'post_only', 'timeInForce', 'time_in_force', 'expireAt', 'expire_at', 'client_id', 'clientOrderId' ]);
        if ($type === 'market') {
            $cost = null;
            if ($price !== null) {
                $cost = $amount * $price;
            } else {
                $cost = $this->safe_number_2($params, 'amountQuote', 'amount_quote');
            }
            if ($cost !== null) {
                $precision = $market['precision']['price'];
                $request['amount_quote'] = $this->decimal_to_precision($cost, TRUNCATE, $precision, $this->precisionMode);
            } else {
                $request['amount'] = $this->amount_to_precision($symbol, $amount);
            }
            $params = $this->omit($params, array( 'amountQuote', 'amount_quote' ));
        } else if ($type === 'limit') {
            $request['price'] = $this->price_to_precision($symbol, $price);
            $request['amount'] = $this->amount_to_precision($symbol, $amount);
        }
        $response = $this->privatePostOrder (array_merge($request, $params));
        //
        // {
        //     "uuid" => "69d353dc-a80f-491e-b5cf-d2589682664e",
        //     "amount" => "0.01000000",
        //     "amount_filled" => "0.00000000",
        //     "amount_quote_filled" => "0.00000000",
        //     "fee" => "0.00000000",
        //     "price" => "1000.00",
        //     "side" => "buy",
        //     "type" => "limit",
        //     "status" => "open",
        //     "filled_status" => "not_filled",
        //     "cancel_status" => null,
        //     "stop" => "entry",
        //     "stop_hit" => false,
        //     "stop_price" => "800.00",
        //     "post_only" => true,
        //     "time_in_force" => "gtd",
        //     "created_at" => 1637147943854,
        //     "updated_at" => 1637147943854,
        //     "expire_at" => 1625038240391,
        //     "market" => "BTC-EUR",
        //     "client_id" => "d22a7a4e-c28b-40f5-a5a4-79ca8a4fc41c"
        // }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'orders' => [$id],
            'market' => $market['id'],
        );
        $this->privateDeleteOrders (array_merge($request, $params));
        //
        // <empty response>
        //
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['market'] = $market['id'];
        }
        $this->privateDeleteOrders (array_merge($request, $params));
        //
        // <empty response>
        //
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'uuid' => $id,
            'market' => $market['id'],
        );
        $response = $this->privateGetOrder (array_merge($request, $params));
        //
        // {
        //     "uuid" => "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        //     "amount" => "0.49875000",
        //     "amount_filled" => "0.00000000",
        //     "amount_quote_filled" => "0.00000000",
        //     "fee" => "0.00000000",
        //     "price" => "0.0000",
        //     "side" => "buy",
        //     "type" => "market",
        //     "status" => "open",
        //     "filled_status" => "not_filled",
        //     "cancel_status" => null,
        //     "stop" => null,
        //     "stop_hit" => null,
        //     "stop_price" => null,
        //     "post_only" => false,
        //     "time_in_force" => "gtc",
        //     "created_at" => 1620112337000,
        //     "updated_at" => 1620112337000,
        //     "expire_at" => null,
        //     "market" => "BTC-EUR",
        //     "client_id" => null
        // }
        //
        return $this->parse_order($response, $market);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            // 'limit' => 200, // default 200, max 200
            // 'created_at_from' => $since,
            // 'created_at_to' => $this->milliseconds(),
        );
        if ($since !== null) {
            $request['created_at_from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 200, max 200
        }
        $response = $this->privateGetOrdersClosed (array_merge($request, $params));
        //
        // array(
        //     {
        //         "uuid" => "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        //         "amount" => "0.49875000",
        //         "amount_filled" => "0.00000000",
        //         "amount_quote_filled" => "0.00000000",
        //         "fee" => "0.00000000",
        //         "price" => "0.0000",
        //         "side" => "buy",
        //         "type" => "market",
        //         "status" => "closed",
        //         "filled_status" => "not_filled",
        //         "cancel_status" => null,
        //         "stop" => null,
        //         "stop_hit" => null,
        //         "stop_price" => null,
        //         "post_only" => false,
        //         "time_in_force" => "gtc",
        //         "created_at" => 1620112337000,
        //         "updated_at" => 1620112337000,
        //         "expire_at" => null,
        //         "market" => "BTC-EUR",
        //         "client_id" => null
        //     }
        // )
        //
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'market' => $market['id'],
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['market'] = $market['id'];
        }
        $response = $this->privateGetOrdersOpen (array_merge($request, $params));
        //
        // array(
        //     {
        //         "uuid" => "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        //         "amount" => "0.49875000",
        //         "amount_filled" => "0.00000000",
        //         "amount_quote_filled" => "0.00000000",
        //         "fee" => "0.00000000",
        //         "price" => "0.0000",
        //         "side" => "buy",
        //         "type" => "market",
        //         "status" => "open",
        //         "filled_status" => "not_filled",
        //         "cancel_status" => null,
        //         "stop" => null,
        //         "stop_hit" => null,
        //         "stop_price" => null,
        //         "post_only" => false,
        //         "time_in_force" => "gtc",
        //         "created_at" => 1620112337000,
        //         "updated_at" => 1620112337000,
        //         "expire_at" => null,
        //         "market" => "BTC-EUR",
        //         "client_id" => null
        //     }
        // )
        //
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function parse_order_status($status, $cancelStatus) {
        if ($cancelStatus !== null) {
            return 'canceled';
        }
        $statuses = array(
            'created' => 'open',
            'open' => 'open',
            'closed' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder, fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        // {
        //     "uuid" => "4260cd4a-35ba-41af-a63d-b0f1a127f2ab",
        //     "amount" => "0.49875000",
        //     "amount_filled" => "0.00000000",
        //     "amount_quote_filled" => "0.00000000",
        //     "fee" => "0.00000000",
        //     "price" => "0.0000",
        //     "side" => "buy",
        //     "type" => "market",
        //     "status" => "open",
        //     "filled_status" => "not_filled",
        //     "cancel_status" => null,
        //     "stop" => null,
        //     "stop_hit" => null,
        //     "stop_price" => null,
        //     "post_only" => false,
        //     "time_in_force" => "gtc",
        //     "created_at" => 1620112337000,
        //     "updated_at" => 1620112337000,
        //     "expire_at" => null,
        //     "market" => "BTC-EUR",
        //     "client_id" => null
        // }
        //
        $id = $this->safe_string($order, 'uuid');
        $clientOrderId = $this->safe_string($order, 'client_id');
        $timestamp = $this->safe_integer($order, 'created_at');
        $marketId = $this->safe_string($order, 'market');
        $market = $this->safe_market($marketId, $market, '-');
        $symbol = $market['symbol'];
        $status = $this->parse_order_status($this->safe_string($order, 'status'), $this->safe_string($order, 'cancel_status'));
        $side = $this->safe_string($order, 'side');
        $type = $this->safe_string($order, 'type');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'amount');
        $filled = $this->safe_string($order, 'amount_filled');
        $fee = null;
        $feeNumber = $this->safe_number($order, 'fee');
        if ($feeNumber !== null) {
            $feeCurrencyCode = null;
            if ($market !== null) {
                $feeCurrencyCode = $market['quote'];
            }
            $fee = array(
                'cost' => $feeNumber,
                'currency' => $feeCurrencyCode,
            );
        }
        $feeString = $this->safe_string($order, 'fee');
        $amountQuoteFilled = $this->safe_string($order, 'amount_quote_filled');
        $cost = null;
        if ($amountQuoteFilled !== null && $feeString !== null) {
            if ($side === 'buy') {
                $cost = Precise::string_sub($amountQuoteFilled, $feeString);
            } else {
                $cost = Precise::string_add($amountQuoteFilled, $feeString);
            }
        }
        $timeInForce = $this->safe_string($order, 'time_in_force');
        $postOnly = $this->safe_value($order, 'post_only');
        $stopPrice = $this->safe_number($order, 'stop_price');
        return $this->safe_order2(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'amount' => $amount,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            // 'order_uuid' => order_uuid,
            // 'limit' => 200, // default 200, max 200
            // 'timestamp_from' => $since,
            // 'timestamp_to' => $this->milliseconds(),
        );
        if ($since !== null) {
            $request['timestamp_from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 200, max 200
        }
        $response = $this->privateGetFills (array_merge($request, $params));
        //
        // array(
        //     {
        //         "uuid" => "234234897234-1243-1234-qsf234",
        //         "order_uuid" => "234234897234-1243-1234-qsf235",
        //         "amount" => "0.00100000",
        //         "price" => "42986.64",
        //         "amount_quote" => "43.09410660",
        //         "side" => "buy",
        //         "fee" => "0.10746660",
        //         "market" => "BTC-EUR",
        //         "liquidity" => "taker",
        //         "timestamp" => 1622123573863
        //     }
        // )
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $this->omit($params, $this->extract_params($path));
        $url = '/' . $this->version . '/' . $this->implode_params($path, $params);
        $getOrDelete = ($method === 'GET') || ($method === 'DELETE');
        if ($getOrDelete) {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $payload = '';
            if (!$getOrDelete) {
                if ($query) {
                    $body = $this->json($query);
                    $payload = $body;
                }
            }
            $timestamp = (string) $this->milliseconds();
            $auth = $timestamp . $method . $url . $payload;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret));
            $accessWindow = $this->safe_string($this->options, 'LITEBIT-WINDOW', '10000');
            $headers = array(
                'LITEBIT-API-KEY' => $this->apiKey,
                'LITEBIT-SIGNATURE' => $signature,
                'LITEBIT-TIMESTAMP' => $timestamp,
                'LITEBIT-WINDOW' => $accessWindow,
            );
            if (!$getOrDelete) {
                $headers['Content-Type'] = 'application/json';
            }
        }
        $url = $this->urls['api'][$api] . $url;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        //
        //     array("code" => 10007,"message" => "Invalid time window.")
        //
        $errorCode = $this->safe_string($response, 'code');
        if ($errorCode !== null) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            throw new ExchangeError($feedback); // unknown message
        }
    }
}
