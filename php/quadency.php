<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;

class quadency extends Exchange {

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'id' => 'quadency',
            'name' => 'quadency',
            'countries' => array(),
            'rateLimit' => 1000,
            'has' => array(
                'fetchMarkets' => true,
                'fetchOrderBook' => true,
                'fetchOHLCV' => true,
                'fetchTrades' => true,
                'fetchTicker' => true,
            ),
            'timeframes' => array(
                '1m' => '1', // default
                '5m' => '5',
                '15m' => '15',
                '30m' => '30',
                '1h' => '60',
                '1d' => '1440',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg',
                'api' => array(
                    'public' => 'https://b2t-api-b2bx.flexprotect.org',
                    'private' => 'https://b2t-api-b2bx.flexprotect.org',
                    'publicbase2' => 'https://b2t-api-cmc-b2bx.flexprotect.org/marketdata/cmc/v1',
                ),
                'www' => 'https://b2t-api-b2bx.flexprotect.org',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'frontoffice/api/info',
                        'marketdata/instruments/{id}/depth',
                        'marketdata/instruments/{id}/history',
                    ),
                ),
                'publicbase2' => array(
                    'get' => array(
                        'trades/{id}',
                        'summary',
                    ),
                ),
            ),
            'exceptions' => array(
                '400' => '\\ccxt\\BadRequest',
                '401' => '\\ccxt\\AuthenticationError',
                '403' => '\\ccxt\\AuthenticationError',
                '429' => '\\ccxt\\PermissionDenied',
            ),
            'errorMessages' => array(
                '400' => 'Incorrect parameters',
                '401' => 'Incorrect keys or ts value differs from the current time by more than 5 seconds',
                '404' => 'Not Found',
                '429' => 'Too Many Requests => API Rate Limits violated',
                '500' => 'Internal Server Error',
                '503' => 'System is currently overloaded.',
            ),
        ));
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'][$api];
        $url .= '/' . $this->implode_params($path, $params);
        $query = $this->omit ($params, $this->extract_params($path));
        if ($query) {
            if ($api === 'public') {
                $url .= '?';
                $keys = is_array($query) ? array_keys($query) : array();
                for ($i = 0; $i < count($keys); $i++) {
                    $url .= $keys[$i];
                    $url .= '=';
                    $url .= $query[$keys[$i]];
                    if ($i < strlen($keys) - 1) {
                        $url .= '&';
                    }
                }
            } else {
                $url .= '?' . $this->urlencode ($query);
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->publicGetFrontofficeApiInfo ();
        // Response
        // {
        //     "serverTime" => 636880696809972288,
        //     "pairs" => {
        //         "btc_usdt" => array(
        //             "baseAsset" => "btc",
        //             "quoteAsset" => "usdt",
        //             "status" => "Open",
        //             "hidden" => 0,
        //             "makerFee" => 0,
        //             "makerFeeLimit" => 0,
        //             "takerFee" => 0.001,
        //             "takerFeeLimit" => 0,
        //             "priceScale" => 6,
        //             "amountScale" => 6,
        //             "createdAt" => "2019-11-14T16:18:49.253354",
        //             "updatedAt" => "2019-11-14T16:18:49.253354"
        //         ),
        //     }
        // }
        $markets = $this->safe_value($response, 'pairs');
        $keys = is_array($markets) ? array_keys($markets) : array();
        $result = array();
        for ($i = 0; $i < count($keys); $i++) {
            $id = $keys[$i];
            $market = $markets[$id];
            $baseId = $this->safe_string($market, 'baseAsset');
            $quoteId = $this->safe_string($market, 'quoteAsset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $isFrozen = $this->safe_string($market, 'hidden');
            $active = ($isFrozen !== '1');
            $entry = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => array(
                    'amount' => $this->safe_value($market, 'amountScale'),
                    'price' => $this->safe_value($market, 'priceScale'),
                ),
                'taker' => $this->safe_float($market, 'takerFee'),
                'maker' => $this->safe_float($market, 'makerFee'),
                'limits' => array(
                    'amount' => array(
                        'min' => pow(10, -$this->safe_float($market, 'amountScale')),
                    ),
                    'price' => array(
                        'min' => pow(10, -$this->safe_float($market, 'priceScale')),
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_order_book ($symbol = 'BTC/USDT', $limit = 50, $params = array ()) {
        // Respoonse
        // {
        //     "instrument" => "eth_btc",
        //     "bids" => array(
        //         array(
        //             "amount" => 0.3092258,
        //             "price" => 0.01734264
        //         ),
        //         {
        //             "amount" => 51.61494099,
        //             "price" => 0.01734363
        //         }
        //     ),
        //     "asks" => array(
        //         array(
        //             "amount" => 133.52370356,
        //             "price" => 0.01739337
        //         ),
        //         {
        //             "amount" => 9.16854518,
        //             "price" => 0.01739838
        //         }
        //     ),
        //     "version" => 1891724,
        //     "askTotalAmount" => 1849.11363582,
        //     "bidTotalAmount" => 809.23878372,
        //     "snapshot" => true
        // }
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'id' => $market['id'],
        );
        $response = $this->publicGetMarketdataInstrumentsIdDepth (array_merge($request, $params));
        return $this->parse_order_book($response, null, 'bids', 'asks', 'price', 'amount');
    }

    public function parse_ohlcv ($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        // {
        //     instrument => 'btc_usdt',
        //     start => '2022-01-03T12:00:00Z',
        //     end => '2022-01-03T13:00:00Z',
        //     low => 47288.9442022,
        //     high => 47426.3285076,
        //     volume => 0.21555747,
        //     quoteVolume => 10211.36844364,
        //     open => 47426.3285076,
        //     close => 47288.9442022
        //   }
        return array(
            $this->parse8601 ($this->safe_value($ohlcv, 'start')),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_ohlcv ($symbol, $timeframe = '1h', $since = null, $limit = 1000, $params = array ()) {
        // Response
        // {
        //     "success" => true,
        //     "instrument" => "btc_usdt",
        //     "data" => array(
        //         array(
        //             "instrument" => "btc_usdt",
        //             "start" => "2019-03-13T09:00:00Z",
        //             "end" => "2019-03-13T10:00:00Z",
        //             "low" => 3842.855,
        //             "high" => 3855.445,
        //             "volume" => 4,
        //             "quoteVolume" => 0,
        //             "open" => 3855.105,
        //             "close" => 3842.855
        //         ),
        //         {
        //             "instrument" => "btc_usdt",
        //             "start" => "2019-03-13T10:00:00Z",
        //             "end" => "2019-03-13T11:00:00Z",
        //             "low" => 3834.355,
        //             "high" => 3848.855,
        //             "volume" => 26,
        //             "quoteVolume" => 0,
        //             "open" => 3842.865,
        //             "close" => 3835.655
        //         }
        //     ),
        //     "startDateTime" => "2019-03-13T09:00:00Z",
        //     "endDateTime" => "2019-03-13T11:00:00Z"
        // }
        $this->load_markets();
        $market = $this->market ($symbol);
        $marketId = $market['id'];
        $request = array(
            'id' => $marketId,
        );
        $duration = $this->parse_timeframe($timeframe);
        if ($since === null) {
            $since = $this->milliseconds () - $limit * $duration * 1000;
        }
        $enddate = $since . $limit * $duration * 100;
        $params = array_merge($params, array( 'type' => $timeframe, 'startDate' => $this->ymdhms ($since, 'T'), 'endDate' => $this->ymdhms ($enddate, 'T') ));
        $response = $this->publicGetMarketdataInstrumentsIdHistory (array_merge($request, $params));
        $responseData = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($responseData);
    }

    public function fetch_trades ($symbol = 'BTC/USDT', $since = null, $limit = null, $params = array ()) {
        // Response
        // array(
        //     array(
        //         "tradeID" => "1247307",
        //         "price" => "10093.92246491",
        //         "base_volume" => "0.0259",
        //         "quote_volume" => "261.432591841169",
        //         "trade_timestamp" => "1599577070",
        //         "type" => "buy"
        //     ),
        //     {
        //         "tradeID" => "1247309",
        //         "price" => "10091.69185435",
        //         "base_volume" => "0.0754",
        //         "quote_volume" => "760.913565817990",
        //         "trade_timestamp" => "1599577128",
        //         "type" => "sell"
        //     }
        // )
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'id' => $market['id'],
        );
        $response = $this->publicbase2GetTradesId (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade ($trade, $market = null) {
        $timestamp = $this->safe_string($trade, 'trade_timestamp');
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'base_volume');
        $symbol = null;
        if ($market === null) {
            $market = $this->safe_value($trade, 'market');
        }
        if ($market !== null) {
            $symbol = $this->safe_string($market, 'symbol');
        }
        $cost = null;
        if ($price !== null) {
            if ($amount !== null) {
                if ($symbol !== null) {
                    $cost = floatval ($this->cost_to_precision($symbol, $price * $amount));
                }
            }
        }
        $transactionId = $this->safe_string($trade, 'tradeID');
        $side = $this->safe_string($trade, 'type');
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => $transactionId,
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        );
    }

    public function parse_ticker ($symbol, $ticker, $market = null, $time = null) {
        $symbol = str_replace('/', '_', $symbol);
        if ($ticker[$symbol]) {
            $timestamp = $time;
            $last = $this->safe_float($ticker[$symbol], 'last');
            $percentage = $this->safe_float($ticker[$symbol], 'percentChange');
            return array(
                'symbol' => $symbol,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601 ($timestamp),
                'high' => $this->safe_float($ticker[$symbol], 'high24hr'),
                'low' => $this->safe_float($ticker[$symbol], 'low24hr'),
                'bid' => $this->safe_float($ticker[$symbol], 'highestBid'),
                'bidVolume' => null,
                'ask' => $this->safe_float($ticker[$symbol], 'lowestAsk'),
                'askVolume' => null,
                'vwap' => null,
                'open' => null,
                'close' => $last,
                'last' => $last,
                'previousClose' => null,
                'change' => null,
                'percentage' => $percentage,
                'average' => null,
                'baseVolume' => $this->safe_float($ticker[$symbol], 'baseVolume'),
                'quoteVolume' => $this->safe_float($ticker[$symbol], 'quoteVolume'),
                'info' => $ticker[$symbol],
            );
        }
        return null;
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        // Response
        // {
        //     "BTC_USDT" => array(
        //         "id" => "btc_usdt",
        //         "last" => "10978.93578",
        //         "lowestAsk" => "10979.0",
        //         "highestBid" => "10978.71",
        //         "percentChange" => "0.0813730364297798727996051454",
        //         "baseVolume" => "6.47119743",
        //         "quoteVolume" => "70829.9781692126756",
        //         "isFrozen" => "0",
        //         "high24hr" => "10985.0049",
        //         "low24hr" => "10857.95376"
        //     ),
        //     "BTC_USD" => {
        //         "id" => "btc_usd",
        //         "last" => "0",
        //         "lowestAsk" => "0",
        //         "highestBid" => "0",
        //         "percentChange" => "0",
        //         "baseVolume" => "0",
        //         "quoteVolume" => "0",
        //         "isFrozen" => "0",
        //         "high24hr" => "0",
        //         "low24hr" => "0"
        //     }
        // }
        $this->load_markets();
        $response = $this->publicbase2GetSummary ($params);
        return $this->parse_ticker($symbol, $response);
    }

    public function handle_errors ($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        $error = $this->safe_string($response, 'errors');
        if ($error === null) {
            // success
            return;
        }
        $errorMessages = $this->errorMessages;
        $message = null;
        $message = $this->safe_string($error[0], 'message');
        if ($message === null) {
            $message = $this->safe_string($errorMessages, $code, 'Unknown Error');
        }
        $feedback = $this->id . ' ' . $message;
        $this->throw_exactly_matched_exception($this->exceptions, $code, $feedback);
        throw new ExchangeError($feedback);
    }
}
