<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;

class tprexchange extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'tprexchange',
            'name' => 'TPR Exchange',
            // 'countries' => array( 'US' ),
            // 'rateLimit' => 500,
            'version' => 'v1',
            'certified' => false,
            'has' => array(
                'loadMarkets' => false,
                'cancelAllOrders' => false,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'CORS' => false,
                'createDepositAddress' => false,
                'createLimitOrder' => false,
                'createMarketOrder' => false,
                'createOrder' => true,
                'deposit' => false,
                'editOrder' => 'emulated',
                'fetchBalance' => true,
                'fetchBidsAsks' => false,
                'fetchClosedOrders' => false,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchFundingFees' => false,
                'fetchL2OrderBook' => false,
                'fetchLedger' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => 'emulated',
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => false,
                'fetchOrderBooks' => false,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchStatus' => 'emulated',
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTradingLimits' => false,
                'fetchTransactions' => false,
                'fetchWithdrawals' => false,
                'privateAPI' => true,
                'publicAPI' => false,
                'signIn' => true,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1',
                '5m' => '5',
                '15m' => '15',
                '1h' => '60',
                '4h' => '240',
                '1d' => '1440',
                '1w' => '10080',
            ),
            'urls' => array(
                'logo' => '',
                'api' => '{hostname}',
                'www' => '',
                'doc' => '',
                'fees' => '',
                'referral' => '',
            ),
            'api' => array(
                'private' => array(
                    'get' => array(
                    ),
                    'post' => array(
                        'uc/api-login',
                        'uc/balance',
                        'exchange/order/add',
                        'exchange/order/find',
                        'exchange/order/all',
                        'exchange/order/apicancel',
                    ),
                    'delete' => array(
                    ),
                ),
                'feed' => array(
                    'get' => array(
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'uid' => false,
            ),
            'precisionMode' => SIGNIFICANT_DIGITS,
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => false,
            ),
            'exceptions' => array(
                'exact' => array(
                    'Invalid cost' => '\\ccxt\\InvalidOrder', // array("message":"Invalid cost","_links":array("self":array("href":"/orders","templated":false)))
                    'Invalid order ID' => '\\ccxt\\InvalidOrder', // array("message":"Invalid order ID","_links":array("self":array("href":"/orders/4a151805-d594-4a96-9d64-e3984f2441f7","templated":false)))
                    'Invalid market !' => '\\ccxt\\BadSymbol', // array("message":"Invalid market !","_links":array("self":array("href":"/markets/300/order-book","templated":false)))
                ),
                'broad' => array(
                    'Failed to convert argument' => '\\ccxt\\BadRequest',
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        return array(
            array(
                'id' => 'TPR',
                'symbol' => 'TPR/USD',
                'base' => 'TPR',
                'quote' => 'USD',
                'baseId' => 'TPR',
                'quoteId' => 'USD',
                'type' => 'spot',
                'active' => true,
                'precision' => array(
                    'amount' => null,
                    'price' => null,
                ),
                'limits' => array(
                    'amount' => array( 'min' => null, 'max' => null ),
                    'price' => array( 'min' => null, 'max' => null ),
                    'cost' => array( 'min' => null, 'max' => null ),
                ),
                'taker' => '0.005',
                'maker' => '0.0025',
                'info' => 'TPR Market',
            ),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = 1000, $params = array ()) {
        return array();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        // Check existance of authentication token
        // Just use empy one in case of an application is not $signed in yet
        $authToken = '';
        if (is_array($this->options) && array_key_exists('token', $this->options)) {
            $authToken = $this->options['token'];
        }
        // Get URL
        $url = $this->implode_params($this->urls['api'], array( 'hostname' => $this->hostname )) . '/' . $path;
        // Calculate $body and content type depending on $method type => GET or POST
        $keys = is_array($params) ? array_keys($params) : array();
        $keysLength = is_array($keys) ? count($keys) : 0;
        // In case of $body is still not assigned just make it empty string
        if ($body === null) {
            $body = '';
        }
        // Prepare line for hashing
        // This hash sum is checked on backend side to verify API user
        // POST $params should not be added as $body
        $query = $method . ' /' . $path . ' ' . $this->urlencode($params) . ' ' . $authToken . '\n' . $body;
        $signed = $this->hmac($this->encode($query), $this->encode($this->secret));
        $contentType = null;
        if ($method === 'POST') {
            $contentType = 'application/x-www-form-urlencoded';
            if ($keysLength > 0) {
                $body = $this->urlencode($params);
            }
        } else {
            if ($keysLength > 0) {
                $url .= '?' . $this->urlencode($params);
            }
        }
        $headers = array(
            'x-auth-sign' => $signed,
            'x-auth-token' => $authToken,
        );
        if ($authToken !== '') {
            $headers['access-auth-token'] = $authToken;
        }
        if ($contentType !== null) {
            $headers['Content-Type'] = $contentType;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function sign_in($params = array ()) {
        $params = array(
            'key' => $this->key,
            'token' => $this->token,
        );
        $response = $this->privatePostUcApiLogin ($params);
        $loginData = $response['data'];
        $this->options['token'] = $this->safe_string($loginData, 'token');
        $memberId = $this->safe_string($loginData, 'id');
        return $memberId;
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $request = array(
            'orderId' => $id,
        );
        $response = $this->privatePostExchangeOrderFind ($request);
        return $this->parse_order($response);
    }

    public function parse_order($order, $market = null) {
        // array(
        //   'orderId':'E161183624377614',
        //   'memberId':2,
        //   'type':'LIMIT_PRICE',
        //   'amount':1000.0,
        //   'symbol':'BCH/USDT',
        //   'tradedAmount':1000.0,
        //   'turnover':1080.0,
        //   'coinSymbol':'BCH',
        //   'baseSymbol':'USDT',
        //   'status':'COMPLETED',
        //   'direction':'SELL',
        //   'price':1.0,
        //   'time':1611836243776,
        //   'completedTime':1611836256242,
        // ),
        $type = 'market';
        if ($order['type'] === 'LIMIT_PRICE') {
            $type = 'limit';
        }
        $side = strtolower($order['direction']);
        $remaining = $order['amount'] - $order['tradedAmount'];
        $status = $order['status'];
        if ($status === 'COMPLETED') {
            $status = 'closed';
        } else if ($status === 'TRADING') {
            $status = 'open';
        } else {
            $status = 'canceled';
        }
        $cost = $order['tradedAmount'] * $order['price'];
        $result = array(
            'info' => $order,
            'id' => $order['orderId'],
            'clientOrderId' => $order['memberId'],
            'timestamp' => $order['time'],
            'datetime' => $this->iso8601($order['time']),
            'lastTradeTimestamp' => null,
            'symbol' => $order['symbol'],
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $order['price'],
            'stopPrice' => null,
            'cost' => $cost,
            'average' => null,
            'amount' => $order['amount'],
            'filled' => $order['tradedAmount'],
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        );
        return $result;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $params['symbol'] = $symbol;
        $params['price'] = $price;
        $params['amount'] = $amount;
        if ($side === 'buy') {
            $params['direction'] = 'BUY';
        } else {
            $params['direction'] = 'SELL';
        }
        if ($type === 'market') {
            $params['type'] = 'MARKET_PRICE';
        } else {
            $params['type'] = 'LIMIT_PRICE';
        }
        $params['useDiscount'] = '0';
        $response = $this->privatePostExchangeOrderAdd ($params);
        $orderId = $this->safe_string($response, 'data');
        return $this->fetch_order($orderId);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $request = array(
            'orderId' => $id,
        );
        $response = $this->privatePostExchangeOrderApicancel (array_merge($request, $params));
        return $this->parse_order($response['data']);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        // Request structure
        // {
        //   'symbol' => Parameter from method arguments
        //   'since' => Timestamp of first order in list in Unix epoch format
        //   'limit' => Response list size
        //   'memberId' => May be set in $params-> May be not set
        //   'status' => one of TRADING COMPLETED CANCELED OVERTIMED. May be set in $params
        //   'page' => for pagination. In this case $limit is size of every page. May be set in $params
        // }
        if (is_array($params) && array_key_exists('page', $params)) {
            $params['pageNo'] = $this->safe_string($params, 'page');
        } else {
            $params['pageNo'] = 1;
        }
        $request = array(
            'symbol' => $symbol,
            'since' => $since,
            'pageSize' => $limit,
        );
        $fullRequest = array_merge($request, $params);
        $response = $this->privatePostExchangeOrderAll ($fullRequest);
        // {
        //     'content' => array(
        //         array(
        //             'orderId':'E161183624377614',
        //             'memberId':2,
        //             'type':'LIMIT_PRICE',
        //             'amount':1000.0,
        //             'symbol':'BCH/USDT',
        //             'tradedAmount':1000.0,
        //             'turnover':1080.0,
        //             'coinSymbol':'BCH',
        //             'baseSymbol':'USDT',
        //             'status':'COMPLETED',
        //             'direction':'SELL',
        //             'price':1.0,
        //             'time':1611836243776,
        //             'completedTime':1611836256242,
        //         ),
        //         ...
        //     ),
        //     'totalElements':41,
        //     'totalPages':3,
        //     'last':False,
        //     'size':20,
        //     'number':1,
        //     'first':False,
        //     'numberOfElements':20,
        //     'sort' => array(
        //         {
        //             'direction':'DESC',
        //             'property':'time',
        //             'ignoreCase':False,
        //             'nullHandling':'NATIVE',
        //             'ascending':False,
        //             'descending':True,
        //         }
        //     )
        // }
        return $this->parse_orders($response['content']);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        // Request structure
        // {
        //   'symbol' => Parameter from method arguments
        //   'since' => Timestamp of first order in list in Unix epoch format
        //   'limit' => Response list size
        //   'memberId' => May be set in $params-> May be not set
        //   'status' => one of TRADING COMPLETED CANCELED OVERTIMED. May be set in $params
        //   'page' => for pagination. In this case $limit is size of every page. May be set in $params
        // }
        $params['status'] = 'TRADING';
        if (is_array($params) && array_key_exists('page', $params)) {
            $params['pageNo'] = $this->safe_string($params, 'page');
        } else {
            $params['pageNo'] = 1;
        }
        $request = array(
            'symbol' => $symbol,
            'since' => $since,
            'pageSize' => $limit,
        );
        $fullRequest = array_merge($request, $params);
        $response = $this->privatePostExchangeOrderAll ($fullRequest);
        // {
        //     'content' => array(
        //         array(
        //             'orderId':'E161183624377614',
        //             'memberId':2,
        //             'type':'LIMIT_PRICE',
        //             'amount':1000.0,
        //             'symbol':'BCH/USDT',
        //             'tradedAmount':1000.0,
        //             'turnover':1080.0,
        //             'coinSymbol':'BCH',
        //             'baseSymbol':'USDT',
        //             'status':'COMPLETED',
        //             'direction':'SELL',
        //             'price':1.0,
        //             'time':1611836243776,
        //             'completedTime':1611836256242,
        //         ),
        //         ...
        //     ),
        //     'totalElements':41,
        //     'totalPages':3,
        //     'last':False,
        //     'size':20,
        //     'number':1,
        //     'first':False,
        //     'numberOfElements':20,
        //     'sort' => array(
        //         {
        //             'direction':'DESC',
        //             'property':'time',
        //             'ignoreCase':False,
        //             'nullHandling':'NATIVE',
        //             'ascending':False,
        //             'descending':True,
        //         }
        //     )
        // }
        return $this->parse_orders($response['content']);
    }

    public function parse_balance($balance) {
        return array(
            'info' => $balance,
        );
    }

    public function fetch_balance($params = array ()) {
        $response = $this->privatePostUcBalance ($params);
        return $this->parse_balance($response);
    }

    public function parse_trade($trade, $market = null) {
        $timestamp = 0;
        $fee = array(
            'cost' => null,
            'currency' => null,
        );
        return array(
            'info' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => null,
            'id' => null,
            'order' => null,
            'type' => null,
            'side' => null,
            'takerOrMaker' => null,
            'price' => null,
            'amount' => null,
            'cost' => null,
            'fee' => $fee,
        );
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $market = null;
        $trades = $this->privatePostExchangeTrades ($params);
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $market = null;
        $trades = $this->privatePostExchangeTrades ($params);
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        if ($httpCode === 200) {
            if (is_array($response) && array_key_exists('code', $response)) {
                if ($response['code'] === 0) {
                    return;
                }
            } else {
                return;
            }
        }
        // {
        //     "$message" => "Error text in case when HTTP code is not 200",
        //     ...
        // }
        $message = $this->safe_string($response, 'message');
        if ($message !== null) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
