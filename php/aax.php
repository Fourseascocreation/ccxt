<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class aax extends Exchange {

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'id' => 'aax',
            'name' => 'aax',
            'rateLimit' => 500,
            'has' => array(
                'fetchMarkets' => true,
                'fetchOHLCV' => true,
                'fetchOrderBook' => true,
                'fetchTrades' => true,
            ),
            'timeframes' => array(
                '1m' => 1,
                '3m' => 3,
                '5m' => 5,
                '15m' => 15,
                '30m' => 30,
                '1h' => 60,
                '2h' => 120,
                '3h' => 180,
                '4h' => 240,
                '8h' => 480,
                '1d' => 1440,
            ),
            'urls' => array(
                'api' => 'https://api.aax.com',
                'www' => 'https://www.aax.com/',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v2/instruments',
                        'v2/market/orderbook',
                        'marketdata/v1/getHistMarketData',
                        'v2/market/trades',
                    ),
                ),
            ),
            'errorMessages' => array(
                '400' => 'There is something wrong with your request',
                '401' => 'Your API key is wrong',
                '403' => 'Your API key does not have enough privileges to access this resource',
                '429' => 'You have exceeded your API key rate limits',
                '500' => 'Internal Server Error',
                '503' => 'Service is down for maintenance',
                '504' => 'Request timeout expired',
                '550' => 'You requested data that are not available at this moment',
            ),
        ));
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'];
        $url .= '/' . $path;
        $query = $this->omit ($params, $this->extract_params($path));
        if ($query) {
            $url .= '?' . $this->urlencode ($query);
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->publicGetV2Instruments ();
        // Exchange Response
        // {
        //     "$code":1,
        //     "data":array(
        //        array(
        //           "tickSize":"0.1",
        //           "lotSize":"0.0001",
        //           "$base":"BTC",
        //           "$quote":"USDT",
        //           "minQuantity":"0.0010000000",
        //           "maxQuantity":"999900.0000000000",
        //           "minPrice":"0.1000000000",
        //           "maxPrice":"10000000.0000000000",
        //           "$status":"enable",
        //           "$symbol":"BTCUSDT",
        //           "$code":null,
        //           "takerFee":"0.00000",
        //           "makerFee":"0.00000",
        //           "multiplier":"1.000000000000",
        //           "mmRate":"0.02500",
        //           "imRate":"0.05000",
        //           "type":"spot"
        //        ),
        //        ...
        //     ),
        //     "message":"success",
        //     "ts":1573561743499
        //  }
        $result = array();
        $markets = $this->safe_value($response, 'data');
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $code = $this->safe_string($market, 'code');
            if (($code && strtoupper($code) === 'FP')) {
                continue;
            }
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'base');
            $quoteId = $this->safe_string($market, 'quote');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $baseId . '/' . $quoteId;
            $status = $this->safe_string($market, 'status');
            $active = null;
            if ($status !== null) {
                $active = (strtoupper($status) === 'ENABLE' || strtoupper($status) === 'READONLY');
            }
            $precision = array(
                'price' => $this->precision_from_string($market['tickSize']),
                'amount' => $this->precision_from_string($market['lotSize']),
            );
            $entry = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => $precision,
                'type' => $this->safe_string($market, 'type'),
                'taker' => $this->safe_float($market, 'takerFee'),
                'maker' => $this->safe_float($market, 'makerFee'),
                'limits' => array(
                    'amount' => array(
                        'min' => $this->safe_float($market, 'minQuantity'),
                        'max' => $this->safe_float($market, 'maxQuantity'),
                    ),
                    'price' => array(
                        'min' => $this->safe_float($market, 'minPrice'),
                        'max' => $this->safe_float($market, 'maxPrice'),
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_ohlcv ($symbol = 'BTC/USDT', $timeframe = '1m', $since = null, $limit = 30, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'date_scale' => $this->timeframes[$timeframe],
            'base' => $market['base'],
            'quote' => $market['quote'],
            'limit' => $limit,
        );
        if ($since !== null) {
            $request['from'] = $since;
        }
        if (is_array($params) && array_key_exists('to', $params)) {
            $request['to'] = $params['to'];
        }
        $response = $this->publicGetMarketdataV1GetHistMarketData (array_merge($request, $params));
        $result = array();
        if (is_array($response && $response['s'] === 'ok') && array_key_exists('s', $response && $response['s'] === 'ok')) {
            $timeArr = $response['t'];
            $openArr = $response['o'];
            $highArr = $response['h'];
            $lowArr = $response['l'];
            $closeArr = $response['c'];
            $volumeArr = $response['v'];
            for ($i = 0; $i < count($timeArr); $i++) {
                $ohlcvArr = array();
                $ohlcvArr[] = intval ($timeArr[$i]) * 1000;
                $ohlcvArr[] = $openArr[$i];
                $ohlcvArr[] = $highArr[$i];
                $ohlcvArr[] = $lowArr[$i];
                $ohlcvArr[] = $closeArr[$i];
                $ohlcvArr[] = $volumeArr[$i];
                $result[] = $ohlcvArr;
            }
        }
        return $this->parse_ohlcvs($result, $market, $timeframe, $since, $limit);
    }

    public function fetch_order_book ($symbol = 'BTC/USDT', $limit = 50, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'symbol' => $market['id'],
            'level' => $limit,
        );
        $response = $this->publicGetV2MarketOrderbook (array_merge($request, $params));
        // Response Format
        // {
        //     "asks":array(
        //        array(
        //           "10823.00000000", #price
        //           "0.004000"  #size
        //        ),
        //        array(
        //           "10823.10000000",
        //           "0.100000"
        //        ),
        //        array(
        //           "10823.20000000",
        //           "0.010000"
        //        )
        //     ),
        //     "bids":array(
        //        array(
        //           "10821.20000000",
        //           "0.002000"
        //        ),
        //        array(
        //           "10821.10000000",
        //           "0.005000"
        //        ),
        //        array(
        //           "10820.40000000",
        //           "0.013000"
        //        )
        //     ),
        //     "e":"BTCUSDT@book_50",
        //     "t":1561543614756
        //  }
        $timestamp = $this->safe_integer($response, (string) 't');
        return $this->parse_order_book($response, $timestamp);
    }

    public function parse_trade ($trade, $market = null) {
        // From FetchTrades
        //   {
        //     "e":"BTCUSDFP@trades",
        //     "trades":
        //         [ array( "p":"9395.50000000",
        //            "q":"50.000000",
        //            "t":1592563996718
        //          ),
        //         array(  "p":"9395.50000000",
        //            "q":"50.000000",
        //            "t":1592563993577
        //         )]
        //   }
        $timestamp = $this->safe_integer($trade, (string) 't');
        $symbol = null;
        if ($market !== null) {
            $symbol = $this->safe_string($market, 'symbol');
        }
        $price = $this->safe_float($trade, 'p');
        $amount = $this->safe_float($trade, 'q');
        $side = 'BUY';
        $cost = null;
        if ($price !== null) {
            if ($price < 0) {
                $side = 'SELL';
            }
            $price = abs($price);
            if ($amount !== null) {
                if ($symbol !== null) {
                    $cost = floatval ($this->cost_to_precision($symbol, $price * $amount));
                }
            }
        }
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => null,
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        );
    }

    public function fetch_trades ($symbol, $since = null, $limit = 2000, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'symbol' => $market['id'],
            'limit' => $limit,
        );
        $response = $this->publicGetV2MarketTrades (array_merge($request, $params));
        // Response Received
        // {
        //     "e":"BTCUSDFP@trades",
        //     "trades":
        //         [ array( "p":"9395.50000000",
        //            "q":"50.000000",
        //            "t":1592563996718
        //          ),
        //         array(  "p":"9395.50000000",
        //            "q":"50.000000",
        //            "t":1592563993577
        //         )]
        //   }
        return $this->parse_trades($this->safe_value($response, 'trades'), $market, $since, $limit);
    }
}
