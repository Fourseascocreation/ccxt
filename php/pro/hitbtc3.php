<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\InvalidOrder;
use React\Async;

class hitbtc3 extends \ccxt\async\hitbtc3 {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchBalance' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchTrades' => true,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchPositions' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://api.hitbtc.com/api/3/ws/public',
                        'trading' => 'wss://api.hitbtc.com/api/3/ws/trading',
                        'wallet' => 'wss://api.hitbtc.com/api/3/ws/wallet',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://api.demo.hitbtc.com/api/3/ws/public',
                        'trading' => 'wss://api.demo.hitbtc.com/api/3/ws/trading',
                        'wallet' => 'wss://api.demo.hitbtc.com/api/3/ws/wallet',
                    ),
                ),
            ),
            'methods' => array(
                'spot' => array(
                    'createOrder' => 'spot_new_order',
                    'editOrder' => 'spot_replace_order',
                    'cancelOrder' => 'spot_cancel_order',
                    'cancelAllOrders' => 'spot_cancel_orders',
                    'watchBalance' => 'spot_balance_subscribe',
                    'watchOrders' => 'spot_subscribe',
                    'watchMyTrades' => 'spot_subscribe',
                ),
                'margin' => array(
                    'createOrder' => 'margin_new_order',
                    'editOrder' => 'margin_replace_order',
                    'cancelOrder' => 'margin_cancel_order',
                    'cancelAllOrders' => 'margin_cancel_orders',
                    'watchPositions' => 'margin_subscribe',
                    'watchOrders' => 'margin_subscribe',
                    'watchMyTrades' => 'margin_subscribe',
                ),
                'futures' => array(
                    'createOrder' => 'futures_new_order',
                    'editOrder' => 'futures_replace_order',
                    'cancelOrder' => 'futures_cancel_order',
                    'cancelAllOrders' => 'futures_cancel_orders',
                    'watchPositions' => 'futures_subscribe',
                    'watchOrders' => 'futures_subscribe',
                    'watchMyTrades' => 'futures_subscribe',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'BasicAuth' => false,                           // BASIC or HS256 authenticate
                'defaultMarketType' => 'spot',                  // spot | margin | swap | futures, swap=futures
                'lastRequestId' => $this->milliseconds(),
            ),
        ));
    }

    public function get_request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'lastRequestId', 0), 1);
        $this->options['lastRequestId'] = $requestId;
        return $requestId;
    }

    public function make_basic_auth() {
        return array(
            'type' => 'BASIC',
            'api_key' => $this->apiKey,
            'secret_key' => $this->secret,
        );
    }

    public function make_hs256_auth() {
        $timestamp = $this->nonce();
        $payload = array( $timestamp );
        $payloadString = implode('', $payload);
        $signature = $this->hmac($this->encode($payloadString), $this->encode($this->secret), 'sha256', 'hex');
        return array(
            'type' => 'HS256',
            'api_key' => $this->apiKey,
            'timestamp' => $timestamp,
            'signature' => $signature,
        );
    }

    public function authenticate($url) {
        $messageHash = 'authenticated';
        $client = $this->client($url);
        $future = $this->safe_value($client->futures, $messageHash);
        if ($future === null) {
            $future = $client->future ($messageHash);
            $method = 'login';
            $params = array();
            if ($this->options['BasicAuth'] === true) {
                $params = $this->make_basic_auth();
            } else {
                $params = $this->make_hs256_auth();
            }
            $requestId = $this->get_request_id();
            $request = array(
                'method' => $method,
                'params' => $params,
                'id' => $requestId,
            );
            $subscription = array(
                'method' => $messageHash,
                'callback' => array($this, 'handle_authentication_message'),
            );
            $this->spawn(array($this, 'watch'), $url, $method, $request, $requestId, $subscription);
        }
        return $future;
    }

    public function watch_private($access, $method, $params = array (), $messageHash = null) {
        return Async\async(function () use ($access, $method, $params, $messageHash) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws'][$access];
            Async\await($this->authenticate($url));
            if ($messageHash === null) {
                $messageHash = $method;
            }
            $requestId = $this->get_request_id();
            $subscribe = array(
                'method' => $method,
                'id' => $requestId,
            );
            $request = $this->deep_extend($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function watch_public($symbol, $channel, $params = array ()) {
        return Async\async(function () use ($symbol, $channel, $params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['public'];
            $requestId = $this->get_request_id();
            $marketId = $this->market_id($symbol);
            $messageHash = $channel . ':' . $marketId;
            $subscribe = array(
                'method' => 'subscribe',
                'ch' => $channel,
                'params' => array(
                    'symbols' => array( $marketId ),
                ),
                'id' => $requestId,
            );
            $request = $this->deep_extend($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function execute_private($access, $method, $params, $callback) {
        return Async\async(function () use ($access, $method, $params, $callback) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws'][$access];
            Async\await($this->authenticate($url));
            $requestId = $this->get_request_id();
            $messageHash = $method . ':' . $requestId;
            $request = array(
                'method' => $method,
                'params' => array(),
                'id' => $requestId,
            );
            $request = $this->deep_extend($request, $params);
            $subscription = array(
                'method' => $messageHash,
                'callback' => $callback,
            );
            return Async\await($this->watch($url, $messageHash, $request, $requestId, $subscription));
        }) ();
    }

    public function get_method($methodName, $market, $params) {
        $marketType = $this->safe_value($this->options, 'defaultMarketType', 'spot');
        if ($market !== null) {
            $marketType = $this->safe_value($market, 'type', $marketType);
        }
        $marketType = $this->safe_value($params, 'marketType', $marketType);
        if ($marketType === 'swap') {
            $marketType = 'futures';
        }
        $methods = $this->safe_value($this->methods, $marketType);
        if ($methods === null) {
            throw new ExchangeError($this->id . ' $market type "' . $marketType . '" not found!');
        }
        $method = $this->safe_value($methods, $methodName);
        if ($method === null) {
            throw new ExchangeError($this->id . ' $method ' . $marketType . '/' . $methodName . ' not found!');
        }
        return $method;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the hitbtc3 api endpoint
             * @return {array} an array(@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure)
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $timeInForce = $this->safe_string_2($params, 'timeInForce', 'time_in_force', 'GTC');
            $expireTime = $this->safe_string_2($params, 'expireTime', 'expire_time');
            $stopPrice = $this->safe_number_2($params, 'stopPrice', 'stop_price');
            // A post-only limit order is either placed in the order book or expires if matches an existing order.
            // Post-only option guarantees that you will not pay the taker fee.
            $postOnly = $this->safe_value_2($params, 'postOnly', 'post_only');
            $reduceOnly = $this->safe_value($params, 'reduceOnly');
            $marketType = $market['type'];
            $cmd = array(
                'params' => array(
                    'type' => $type,
                    'side' => $side,
                    'quantity' => $this->amount_to_precision($symbol, $amount),
                    'symbol' => $market['id'],
                    'time_in_force' => $timeInForce,
                ),
            );
            if (($type === 'limit') || ($type === 'stopLimit') || ($type === 'takeProfitLimit')) {
                if ($price === null) {
                    throw new ExchangeError($this->id . ' createOrder() requires a $price argument for limit orders');
                }
                $cmd['params']['price'] = $this->price_to_precision($symbol, $price);
            }
            if (($timeInForce === 'GTD')) {
                if ($expireTime === null) {
                    throw new ExchangeError($this->id . ' createOrder() requires an $expireTime parameter for a GTD order');
                }
                $cmd['params']['expire_time'] = $expireTime;
            }
            if (($type === 'stopLimit') || ($type === 'stopMarket') || ($type === 'takeProfitLimit') || ($type === 'takeProfitMarket')) {
                if ($stopPrice === null) {
                    throw new ExchangeError($this->id . ' createOrder() requires a $stopPrice parameter for stop-loss and take-profit orders');
                }
                $cmd['params']['stop_price'] = $this->price_to_precision($symbol, $stopPrice);
            }
            if ($postOnly !== null) {
                $cmd['params']['post_only'] = $postOnly;
            }
            if ($reduceOnly !== null) {
                if (($marketType !== 'margin') && ($marketType !== 'swap')) {
                    throw new InvalidOrder($this->id . ' createOrder() does not support reduce_only for ' . $market['type'] . ' orders, reduce_only orders are supported for swap and margin markets only');
                }
            }
            if ($reduceOnly === true) {
                $cmd['params']['reduce_only'] = $reduceOnly;
            }
            $method = $this->get_method('createOrder', $market, $params);
            return $this->execute_private('trading', $method, $cmd, array($this, 'handle_order_message'));
        }) ();
    }

    public function edit_order($id, $symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $clientOrderId = $this->safe_string_2($params, 'clOrdID', 'clientOrderId', $this->uuid22());
            $cmd = array(
                'params' => array(
                    'client_order_id' => $id,
                    'new_client_order_id' => $clientOrderId,
                    'quantity' => $this->amount_to_precision($symbol, $amount),
                ),
            );
            if (($type === 'limit') || ($type === 'stopLimit') || ($type === 'takeProfitLimit')) {
                if ($price === null) {
                    throw new ExchangeError($this->id . ' editOrder() limit order requires price');
                }
                $cmd['params']['price'] = $this->price_to_precision($symbol, $price);
            }
            $method = $this->get_method('editOrder', $market, $params);
            return $this->execute_private('trading', $method, $cmd, array($this, 'handle_order_message'));
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $cmd = array(
                'params' => array(
                    'client_order_id' => $id,
                ),
            );
            $method = $this->get_method('cancelOrder', $market, $params);
            return $this->execute_private('trading', $method, $cmd, array($this, 'handle_order_message'));
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        if ($symbol !== null) {
            throw new ExchangeError($this->id . ' cancelAllOrders() does not support $symbol param. Symbol must be null.');
        }
        $cmd = array(
            'params' => array(),
        );
        $method = $this->get_method('cancelAllOrders', null, $params);
        return $this->execute_private('trading', $method, $cmd, array($this, 'handle_orders_message'));
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $methodParams = array(
                'params' => array(
                    'mode' => 'updates',
                ),
            );
            $method = $this->get_method('watchBalance', null, $params);
            return Async\await($this->watch_private('trading', $method, $methodParams));
        }) ();
    }

    public function handle_balance($client, $message) {
        //
        //     {
        //          "jsonrpc" => "2.0",
        //          "method" => "spot_balance",
        //          "params" => array(
        //              array(
        //                  "currency" => "BCN",
        //                  "available" => "100.000000000000",
        //                  "reserved" => "0",
        //                  "reserved_margin" => "0"
        //              ),
        //              array(
        //                  "currency" => "BTC",
        //                  "available" => "0.013634021",
        //                  "reserved" => "0",
        //                  "reserved_margin" => "0"
        //              ),
        //              {
        //                  "currency" => "ETH",
        //                  "available" => "0",
        //                  "reserved" => "0.00200000",
        //                  "reserved_margin" => "0"
        //              }
        //          )
        //      }
        //
        $method = $this->safe_value($message, 'method') . '_subscribe';
        $accountType = 'spot';
        $params = $this->safe_value($message, 'params', array());
        for ($i = 0; $i < count($params); $i++) {
            $param = $params[$i];
            $account = $this->account();
            $currencyId = $this->safe_string($param, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($param, 'available', 0);
            $account['used'] = $this->safe_string($param, 'reserved', 0);
            $this->balance[$accountType][$code] = $account;
        }
        $this->balance[$accountType] = $this->safe_balance($this->balance[$accountType]);
        $client->resolve ($this->balance[$accountType], $method);
    }

    public function watch_positions($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $methodParams = array(
                'params' => array(),
            );
            $method = $this->get_method('watchPositions', null, $params);
            return Async\await($this->watch_private('trading', $method, $methodParams, 'positions'));
        }) ();
    }

    public function handle_accounts($client, $message) {
        //  {
        //      "jsonrpc" => "2.0",
        //      "method" => "margin_account",
        //      "params" => {
        //          "symbol" => "BTCUSDT",
        //          "type" => "isolated",
        //          "leverage" => "12.00",
        //          "created_at" => "2021-07-01T21:43:19.727Z",
        //          "updated_at" => "2021-07-02T00:54:28.591Z",
        //          "currencies" => array(
        //              {
        //                  "code" => "USDT",
        //                  "margin_balance" => "0.080706742356",
        //                  "reserved_orders" => "0",
        //                  "reserved_positions" => "0.029630234750"
        //              }
        //          ),
        //          "positions" => array(
        //              {
        //                  "id" => 485264,
        //                  "symbol" => "BTCUSDT",
        //                  "quantity" => "0.00001",
        //                  "price_entry" => "33386.18",
        //                  "price_margin_call" => "27269.85",
        //                  "price_liquidation" => "26721.57",
        //                  "pnl" => "0",
        //                  "created_at" => "2021-07-01T21:43:19.727Z",
        //                  "updated_at" => "2021-07-02T00:54:28.591Z"
        //              }
        //          ),
        //          "report_type" => "status",
        //          "report_reason" => "status"
        //      }
        //  }
        $method = $this->safe_string($message, 'method');
        $accounts = array();
        if (($method === 'margin_accounts') || ($method === 'futures_accounts')) {
            $accounts = $this->safe_value($message, 'params', array());
        } else {
            $accounts = array( $this->safe_value($message, 'params') );
        }
        $positions = array();
        for ($i = 0; $i < count($accounts); $i++) {
            $account = $accounts[$i];
            $positions[] = $this->parse_position($account);
        }
        $client->resolve ($positions, 'positions');
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} $params extra parameters specific to the hitbtc api endpoint
             * @return {array} a array(@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure)
             */
            $methodParams = array(
                'params' => array(),
            );
            return Async\await($this->watch_public($symbol, 'ticker/1s', $methodParams));
        }) ();
    }

    public function ws_parse_ticker($ticker, $market = null) {
        //
        //     {
        //            "t" => 1614815872000,             // Timestamp in milliseconds
        //            "a" => "0.031175",                // Best ask
        //            "A" => "0.03329",                 // Best ask quantity
        //            "b" => "0.031148",                // Best bid
        //            "B" => "0.10565",                 // Best bid quantity
        //            "c" => "0.031210",                // Last price
        //            "o" => "0.030781",                // Open price
        //            "h" => "0.031788",                // High price
        //            "l" => "0.030733",                // Low price
        //            "v" => "62.587",                  // Base asset volume
        //            "q" => "1.951420577",             // Quote asset volume
        //            "p" => "0.000429",                // Price $change
        //            "P" => "1.39",                    // Price $change percent
        //            "L" => 1182694927                 // Last trade identifier
        //      }
        //
        $timestamp = $this->safe_integer($ticker, 't');
        $symbol = $this->safe_symbol(null, $market);
        $last = $this->safe_string($ticker, 'c');
        $change = $this->safe_string($ticker, 'p');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'h'),
            'low' => $this->safe_string($ticker, 'l'),
            'bid' => $this->safe_string($ticker, 'b'),
            'bidVolume' => $this->safe_string($ticker, 'B'),
            'ask' => $this->safe_string($ticker, 'a'),
            'askVolume' => $this->safe_string($ticker, 'A'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => floatval($last) - floatval($change),
            'change' => $change,
            'percentage' => $this->safe_string($ticker, 'P'),
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'v'),
            'quoteVolume' => $this->safe_string($ticker, 'q'),
            'info' => $ticker,
        ), $market);
    }

    public function handle_ticker($client, $message) {
        //
        //     {
        //          "ch" => "ticker/1s",
        //          "data" => {
        //              "ETHBTC" => {
        //                  "t" => 1614815872000,             // Timestamp in milliseconds
        //                  "a" => "0.031175",                // Best ask
        //                  "A" => "0.03329",                 // Best ask quantity
        //                  "b" => "0.031148",                // Best bid
        //                  "B" => "0.10565",                 // Best bid quantity
        //                  "c" => "0.031210",                // Last price
        //                  "o" => "0.030781",                // Open price
        //                  "h" => "0.031788",                // High price
        //                  "l" => "0.030733",                // Low price
        //                  "v" => "62.587",                  // Base asset volume
        //                  "q" => "1.951420577",             // Quote asset volume
        //                  "p" => "0.000429",                // Price change
        //                  "P" => "1.39",                    // Price change percent
        //                  "L" => 1182694927                 // Last trade identifier
        //              }
        //          }
        //      }
        //
        $channel = $this->safe_value($message, 'ch');
        $tickers = $this->safe_value($message, 'data', array());
        $keys = is_array($tickers) ? array_keys($tickers) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $ticker = $tickers[$marketId];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $result = $this->ws_parse_ticker($ticker, $market);
            $this->tickers[$symbol] = $result;
            $messageHash = $channel . ':' . $marketId;
            $client->resolve ($result, $messageHash);
        }
        return $message;
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the hitbtc api endpoint
             * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
             */
            if ($limit === null) {
                $limit = 2;
            }
            $period = $this->timeframes[$timeframe];
            $methodParams = array(
                'params' => array(
                    'limit' => $limit,
                ),
            );
            $ohlcv = Async\await($this->watch_public($symbol, 'candles/' . $period, $methodParams));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function ws_parse_ohlcv($ohlcv, $market = null) {
        //
        //                  "t" => 1626860340000,             // Message timestamp
        //                  "o" => "30881.95",                // Open price
        //                  "c" => "30890.96",                // Last price
        //                  "h" => "30900.8",                 // High price
        //                  "l" => "30861.27",                // Low price
        //                  "v" => "1.27852",                 // Base asset volume
        //                  "q" => "39493.9021811"            // Quote asset volume
        //
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function handle_ohlcv($client, $message) {
        //
        //      {
        //          "ch" => "candles/M1",                     // Channel
        //          "snapshot" => {
        //              "BTCUSDT" => [array(
        //                  "t" => 1626860340000,             // Message timestamp
        //                  "o" => "30881.95",                // Open price
        //                  "c" => "30890.96",                // Last price
        //                  "h" => "30900.8",                 // High price
        //                  "l" => "30861.27",                // Low price
        //                  "v" => "1.27852",                 // Base asset volume
        //                  "q" => "39493.9021811"            // Quote asset volume
        //              ), array(
        //                  "t" => 1626860460000,
        //                  "o" => "30858.39",
        //                  "c" => "30863.56",
        //                  "h" => "30864.89",
        //                  "l" => "30853.83",
        //                  "v" => "53.04288",
        //                  "q" => "1636858.7119248"
        //              )]
        //          }
        //      }
        //
        //      {
        //          "ch" => "candles/M1",
        //          "update" => {
        //              "ETHBTC" => [array(
        //                  "t" => 1626860880000,
        //                  "o" => "0.060711",
        //                  "c" => "0.060749",
        //                  "h" => "0.060749",
        //                  "l" => "0.060711",
        //                  "v" => "12.2800",
        //                  "q" => "0.7455339675"
        //              )]
        //          }
        //      }
        $ch = $this->safe_string($message, 'ch');
        $period = $this->strstr($ch, '/');
        $timeframe = $this->find_timeframe($period);
        $data = $this->safe_value_2($message, 'snapshot', 'update');
        $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
        $keys = is_array($data) ? array_keys($data) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $candles = $data[$marketId];
            $messageHash = $ch . ':' . $marketId;
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            for ($i = 0; $i < count($candles); $i++) {
                $candle = $candles[$i];
                $parsed = $this->ws_parse_ohlcv($candle, $market);
                $stored->append ($parsed);
                $client->resolve ($stored, $messageHash);
            }
        }
        return $message;
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the hitbtc api endpoint
             * @return {array} A dictionary of array(@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures) indexed by market symbols
             */
            $speed = $this->safe_integer($params, 'speed', 1000);
            $channel = '';
            if ($limit === null) {
                $channel = 'orderbook/full';
            } else {
                $channel = 'orderbook/D' . $limit . '/' . $speed . 'ms';
            }
            $methodParams = array(
                'params' => array(),
            );
            $orderbook = Async\await($this->watch_public($symbol, $channel, $methodParams));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_orderbook($client, $message) {
        if ($this->safe_value_2($message, 'snapshot', 'data', null) !== null) {
            $this->handle_order_book_snapshot($client, $message);
        } elseif ($this->safe_value($message, 'update', null) !== null) {
            $this->handle_order_book_update($client, $message);
        }
    }

    public function get_order_book_depth($ch) {
        $parts = explode('/', $ch);
        $partsLen = count($parts);
        $textDepth = $parts[1];
        if (($partsLen > 1) && ($textDepth === 'full')) {
            return null;
        } else {
            return intval(mb_substr($textDepth, 1));
        }
    }

    public function handle_order_book_snapshot($client, $message) {
        //
        //      {
        //          "ch" => "orderbook/full",                 // Channel
        //          "snapshot" => {
        //              "ETHBTC" => {
        //                  "t" => 1626866578796,             // Timestamp in milliseconds
        //                  "s" => 27617207,                  // Sequence number
        //                  "a" => [                          // Asks
        //                      ["0.060506", "0"],
        //                      ["0.060549", "12.6431"],
        //                      ["0.060570", "0"],
        //                      ["0.060612", "0"]
        //                  ],
        //                  "b" => [                          // Bids
        //                      ["0.060439", "4.4095"],
        //                      ["0.060414", "0"],
        //                      ["0.060407", "7.3349"],
        //                      ["0.060390", "0"]
        //                  ]
        //              }
        //          }
        //      }
        //
        $ch = $this->safe_value($message, 'ch');
        $snapshots = $this->safe_value_2($message, 'snapshot', 'data', array());
        $depth = $this->get_order_book_depth($ch);
        $keys = is_array($snapshots) ? array_keys($snapshots) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $data = $snapshots[$marketId];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $timestamp = $this->safe_integer($data, 't');
            $nonce = $this->safe_integer($data, 's');
            if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
                unset($this->orderbooks[$symbol]);
            }
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
            $orderbook = $this->order_book($snapshot, $depth);
            $orderbook['nonce'] = $nonce;
            $this->orderbooks[$symbol] = $orderbook;
            $messageHash = $ch . ':' . $marketId;
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_order_book_update($client, $message) {
        //
        //      {
        //          "ch" => "orderbook/full",
        //          "update" => {
        //              "ETHBTC" => {
        //                  "t" => 1626866578902,
        //                  "s" => 27617208,
        //                  "a" => [
        //                      ["0.060508", "0"],
        //                      ["0.060509", "2.5486"]
        //                  ],
        //                  "b" => [
        //                      ["0.060501", "3.9000"],
        //                      ["0.060500", "3.0459"]
        //                  ]
        //              }
        //          }
        //      }
        //
        $ch = $this->safe_value($message, 'ch');
        $update = $this->safe_value($message, 'update', array());
        $keys = is_array($update) ? array_keys($update) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $data = $update[$marketId];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
                $timestamp = $this->safe_integer($data, 't');
                $nonce = $this->safe_integer($data, 's');
                $orderbook = $this->orderbooks[$symbol];
                $asks = $this->safe_value($data, 'a', array());
                $bids = $this->safe_value($data, 'b', array());
                $this->handle_deltas($orderbook['asks'], $asks);
                $this->handle_deltas($orderbook['bids'], $bids);
                $orderbook['timestamp'] = $timestamp;
                $orderbook['datetime'] = $this->iso8601($timestamp);
                $orderbook['nonce'] = $nonce;
                $this->orderbooks[$symbol] = $orderbook;
                $messageHash = $ch . ':' . $marketId;
                $client->resolve ($orderbook, $messageHash);
            }
        }
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the hitbtc api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            $methodParams = array(
                'params' => array(),
            );
            if ($limit !== null) {
                $methodParams['params']['limit'] = $limit;
            }
            $trades = Async\await($this->watch_public($symbol, 'trades', $methodParams));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function ws_parse_trade($trade, $market = null) {
        $symbol = $market['symbol'];
        $id = $this->safe_string($trade, 'i');
        $timestamp = $this->safe_integer($trade, 't');
        $priceString = $this->safe_string($trade, 'p');
        $amountString = $this->safe_string($trade, 'q');
        $side = $this->safe_string($trade, 's');
        $order = null;
        $type = null;
        $takerOrMaker = null;
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $order,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
        ), $market);
    }

    public function handle_trades($client, $message) {
        //
        //      {
        //          "ch" => "trades",                         // Channel
        //          "snapshot" => {
        //              "BTCUSDT" => [array(
        //                  "t" => 1626861109494,             // Timestamp in milliseconds
        //                  "i" => 1555634969,                // Trade identifier
        //                  "p" => "30881.96",                // Price
        //                  "q" => "12.66828",                // Quantity
        //                  "s" => "buy"                      // Side
        //              )]
        //          }
        //      }
        //
        //      {
        //          "ch" => "trades",
        //          "update" => {
        //              "BTCUSDT" => [array(
        //                  "t" => 1626861123552,
        //                  "i" => 1555634969,
        //                  "p" => "30877.68",
        //                  "q" => "0.00006",
        //                  "s" => "sell"
        //              )]
        //          }
        //      }
        //
        $tradesLimit = $this->safe_integer($this->options, 'tradesLimit', 1000);
        $data = $this->safe_value_2($message, 'snapshot', 'update', array());
        $keys = is_array($data) ? array_keys($data) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $trades = $data[$marketId];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $messageHash = 'trades:' . $marketId;
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $stored = new ArrayCache ($tradesLimit);
                $this->trades[$symbol] = $stored;
            }
            for ($i = 0; $i < count($trades); $i++) {
                $trade = $trades[$i];
                $trade = $this->ws_parse_trade($trade, $market);
                $stored->append ($trade);
            }
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[array]} a list of array(@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures)
             */
            Async\await($this->load_markets());
            $method = $this->get_method('watchOrders', null, $params);
            $methodParams = array(
                'params' => array(),
            );
            $orders = Async\await($this->watch_private ('trading', $method, $methodParams, 'orders'));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_orders($client, $message) {
        //
        //      {
        //          "jsonrpc" => "2.0",
        //          "method" => "spot_order",
        //          "params" => {
        //              "id" => 584244931496,
        //              "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //              "symbol" => "BTCUSDT",
        //              "side" => "buy",
        //              "status" => "new",
        //              "type" => "limit",
        //              "time_in_force" => "GTC",
        //              "quantity" => "0.01000",
        //              "quantity_cumulative" => "0",
        //              "price" => "0.01",
        //              "post_only" => false,
        //              "display_quantity" => "0",
        //              "created_at" => "2021-07-02T22:52:32.864Z",
        //              "updated_at" => "2021-07-02T22:52:32.864Z",
        //              "report_type" => "new"
        //          }
        //      }
        //
        //      {
        //          "jsonrpc" => "2.0",
        //          "method" => "spot_orders",
        //          "params" => array(
        //              array(
        //                  "id" => 584244931496,
        //                  "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //                  "symbol" => "BTCUSDT",
        //                  "side" => "buy",
        //                  "status" => "new",
        //                  "type" => "limit",
        //                  "time_in_force" => "GTC",
        //                  "quantity" => "0.01000",
        //                  "quantity_cumulative" => "0",
        //                  "price" => "0.01",
        //                  "post_only" => false,
        //                  "created_at" => "2021-07-02T22:52:32.864Z",
        //                  "updated_at" => "2021-07-02T22:52:32.864Z",
        //                  "report_type" => "status"
        //              ),
        //          )
        //      }
        //
        $method = $this->safe_string($message, 'method');
        $orders = array();
        if (($method === 'spot_orders') || ($method === 'margin_orders') || ($method === 'futures_orders')) {
            $orders = $this->safe_value($message, 'params', array());
        } else {
            $orders = array( $this->safe_value($message, 'params') );
        }
        // Parse $orders
        $messageHash = 'orders';
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $cachedOrders = $this->orders;
        $parsedOrders = $this->parse_orders($orders);
        $parsedOrdersLen = count($parsedOrders);
        if ($parsedOrdersLen > 0) {
            for ($i = 0; $i < count($parsedOrders); $i++) {
                $parsedOrder = $parsedOrders[$i];
                $cachedOrders->append ($parsedOrder);
            }
            $client->resolve ($this->orders, $messageHash);
        }
        // Parse trades
        $messageHash = 'myTrades';
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $cachedTrades = $this->myTrades;
        $parsedTrades = $this->ws_parse_my_trades($orders);
        $parsedTradesLen = count($parsedTrades);
        if ($parsedTradesLen > 0) {
            for ($i = 0; $i < count($parsedTrades); $i++) {
                $parsedTrade = $parsedTrades[$i];
                $cachedTrades->append ($parsedTrade);
            }
            $client->resolve ($this->myTrades, $messageHash);
        }
        return $message;
    }

    public function ws_parse_my_trades($orders) {
        $trades = array();
        for ($i = 0; $i < count($orders); $i++) {
            $order = $orders[$i];
            $id = $this->safe_string($order, 'trade_id');
            if ($id !== null) {
                $trade = $this->ws_parse_my_trade($order);
                $trades[] = $trade;
            }
        }
        return $trades;
    }

    public function ws_parse_my_trade($trade) {
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $id = $this->safe_string($trade, 'trade_id');
        $orderId = $this->safe_string($trade, 'client_order_id');
        $datetime = $this->safe_string($trade, 'updated_at');
        $timestamp = $this->parse8601($datetime);
        $priceString = $this->safe_string($trade, 'trade_price');
        $amountString = $this->safe_string($trade, 'trade_quantity');
        $side = $this->safe_string($trade, 'side');
        $takerOrMaker = $this->safe_value($trade, 'trade_taker');
        $type = $this->safe_string($trade, 'type');
        $fee = null;
        $feeCostString = $this->safe_string($trade, 'trade_fee');
        if ($feeCostString !== null) {
            $info = $this->safe_value($market, 'info', array());
            $feeCurrency = $this->safe_string($info, 'fee_currency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrency);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $method = $this->get_method('watchMyTrades', null, $params);
            $trades = Async\await($this->watch_private('trading', $method, $params, 'myTrades'));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_notification($client, $message) {
        //
        //     array( jsonrpc => '2.0', result => true, $id => requestId )
        //
        $id = $this->safe_string($message, 'id');
        if ($id !== null) {
            $subscription = $this->safe_value($client->subscriptions, $id);
            if ($subscription !== null) {
                $method = $subscription['method'];
                $callback = $subscription['callback'];
                $callback($client, $message, $method);
                unset($client->subscriptions[$id]);
            }
        }
        return $message;
    }

    public function handle_order_message($client, $message, $method) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        $order = $this->safe_value($message, 'result');
        $order = $this->parse_order($order);
        $client->resolve ($order, $method);
    }

    public function handle_orders_message($client, $message, $method) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        $orders = $this->safe_value($message, 'result');
        $orders = $this->parse_orders($orders);
        $client->resolve ($orders, $method);
    }

    public function handle_authentication_message($client, $message, $method) {
        //
        //     array( jsonrpc => '2.0', result => true, id => requestId )
        //
        $future = $this->safe_value($client->futures, $method);
        if ($future !== null) {
            $future->resolve ($message);
        }
    }

    public function handle_error_message($client, $message) {
        //
        //     array("jsonrpc":"2.0","error":array("code":1002,"message":"Authorization is required or has been failed"),"id":requestId)
        //
        $error = $this->safe_value($message, 'error');
        if ($error !== null) {
            $errorCode = $this->safe_integer($error, 'code');
            $messageString = $this->safe_string($error, 'message');
            try {
                if ($errorCode !== null) {
                    $feedback = $this->id . ' ' . $this->json($message);
                    $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
                    if ($messageString !== null) {
                        $this->throw_broadly_matched_exception($this->exceptions['broad'], $messageString, $feedback);
                    }
                }
            } catch (Exception $e) {
                if ($e instanceof AuthenticationError) {
                    $client->reject ($e, 'authenticated');
                    $method = 'login';
                    if (is_array($client->subscriptions) && array_key_exists($method, $client->subscriptions)) {
                        unset($client->subscriptions[$method]);
                    }
                    return false;
                }
                throw $e;
            }
        }
        return true;
    }

    public function handle_message($client, $message) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        $event = $this->safe_string_2($message, 'ch', 'method');
        if ($event !== null) {
            $event = $this->strstr($event, '/', true);
            $channels = array(
                'ticker' => array($this, 'handle_ticker'),
                'candles' => array($this, 'handle_ohlcv'),
                'orderbook' => array($this, 'handle_orderbook'),
                'trades' => array($this, 'handle_trades'),
                'spot_balance' => array($this, 'handle_balance'),
                'spot_order' => array($this, 'handle_orders'),
                'spot_orders' => array($this, 'handle_orders'),
                'margin_account' => array($this, 'handle_accounts'),
                'margin_accounts' => array($this, 'handle_accounts'),
                'margin_order' => array($this, 'handle_orders'),
                'margin_orders' => array($this, 'handle_orders'),
                'futures_account' => array($this, 'handle_accounts'),
                'futures_accounts' => array($this, 'handle_accounts'),
                'futures_order' => array($this, 'handle_orders'),
                'futures_orders' => array($this, 'handle_orders'),
            );
            $method = $this->safe_value($channels, $event);
            if ($method !== null) {
                $method($client, $message);
                return;
            }
        }
        $this->handle_notification($client, $message);
    }

    public function strstr($haystack, $needle, $bool = false) {
        $pos = mb_strpos($haystack, $needle);
        if (($pos === -1) || (!$pos)) {
            return $haystack;
        } else {
            if ($bool) {
                return mb_substr($haystack, 0, $pos - 0);
            } else {
                return mb_substr($haystack, $pos);
            }
        }
    }
}
