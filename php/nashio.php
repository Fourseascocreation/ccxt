<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\AuthenticationError;
use \ccxt\ExchangeNotAvailable;

class nashio extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'nashio',
            'name' => 'Nash',
            'countries' => ['US'],
            'version' => 'v1',
            'rateLimit' => 3000,
            'certified' => false,
            'pro' => false,
            'has' => array(
                'fetchMarkets' => true,
                'fetchCurrencies' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchOHLCV' => true,
                'fetchTrades' => true,
                'fetchOrderBook' => true,
                'fetchL2OrderBook' => false,
                'fetchOrderBooks' => false,
                'fetchBalance' => true,
                'fetchMyTrades' => true,
                'fetchOrder' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'fetchAllOrders' => true,
            ),
            'marketsByAltname' => array(),
            'timeframes' => array(
                '1m' => 'ONE_MINUTE',
                '15m' => 'FIFTEEN_MINUTE',
                '30m' => 'THIRTY_MINUTE',
                '1h' => 'ONE_HOUR',
                '6h' => 'SIX_HOUR',
                '12h' => 'TWELVE_HOUR',
                '1d' => 'ONE_DAY',
                '1w' => 'ONE_WEEK',
                '1M' => 'ONE_MONTH',
            ),
            'urls' => array(
                'logo' => 'https://blog.nash.io/content/images/2019/07/Nash_Logo-Lrg.png',
                'api' => array(
                    'public' => 'https://app.sandbox.nash.io/api/graphql',
                    'private' => 'https://app.sandbox.nash.io/api/graphql',
                ),
                'www' => 'https://www.nash.io',
                'docs' => 'https://api-ts-docs.nash.io/',
                'explorer' => 'https://app.nash.io/api/graphql/explore',
                'test' => array(
                    'public' => 'https://app.sandbox.nash.io/api/graphql',
                    'private' => 'https://app.sandbox.nash.io/api/graphql',
                ),
                'fees' => 'https://support.nash.io/hc/en-us/articles/360034801773-What-is-the-trading-fee-structure-on-Nash-',
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => 'true',
                    'taker' => 0.25 / 100,
                    'maker' => 0,
                    'tiers' => array(
                        'taker' => [
                            [0, 0.0025],
                            [1, 0.0022],
                            [2.5, 0.0019],
                            [5, 0.0019],
                            [10, 0.0016],
                            [20, 0.0013],
                        ],
                    ),
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(),
                    'post' => array(
                        'gql',
                    ),
                ),
                'private' => array(
                    'get' => array(),
                    'post' => array(
                        'gql',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $query = '';
        $query .= 'query ListMarkets { ';
        $query .= '  listMarkets {';
        $query .= '      aUnit aUnitPrecision bUnit bUnitPrecision minTickSize minTradeSize minTradeSizeB minTradeIncrement minTradeIncrementB name status';
        $query .= '  }';
        $query .= '}';
        $request = array(
            'query' => $query,
        );
        $response = $this->publicPostGql (array_merge($request, $params));
        // console.warn ('fetchMarkets', $response);
        $result = array();
        for ($i = 0; $i < count($response['data']['listMarkets']); $i++) {
            $market = $response['data']['listMarkets'][$i];
            // console.warn ($i, $market);
            $id = $this->safe_string($market, 'name');
            $baseId = $this->safe_string($market, 'aUnit');
            $quoteId = $this->safe_string($market, 'bUnit');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $active = $market['status'] === 'RUNNING';
            $precision = array(
                'amount' => $market['aUnitPrecision'],
                'price' => $market['bUnitPrecision'],
            );
            $limits = array(
                'amount' => array(
                    'min' => $market['minTradeSize'],
                    'max' => null,
                ),
                'price' => array(
                    'min' => $market['minTradeSizeB'],
                    'max' => null,
                ),
            );
            $row = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'active' => $active,
                'precision' => $precision,
                'limits' => $limits,
                'info' => $market,
            );
            // if ($this->verbose) {
            //     $this->print('market', $row);
            // }
            $result[] = $row;
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $query = '';
        $query .= 'query ListAssets { ';
        $query .= '  listAssets { ';
        $query .= '      blockchain hash name symbol';
        $query .= '  }';
        $query .= '}';
        $request = array(
            'query' => $query,
        );
        $response = $this->publicPostGql (array_merge($request, $params));
        $assets = $response['data']['listAssets'];
        // console.warn ('assets', $assets);
        $result = array();
        for ($i = 0; $i < count($assets); $i++) {
            $asset = $assets[$i];
            $row = array(
                'id' => $this->safe_string($asset, 'id'),
                'code' => $this->safe_string($asset, 'symbol'),
                'name' => $this->safe_string($asset, 'name'),
                'info' => $asset,
            );
            $result[] = $row;
        }
        return $result;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query GetTicker($marketName => MarketName' . '!' . ') { ';
        $query .= '  getTicker(marketName => $marketName) { ';
        $query .= '      highPrice24h array( amount currencyA currencyB )';
        $query .= '      lowPrice24h array( amount currencyA currencyB )';
        $query .= '      bestBidPrice array( amount currencyA currencyB )';
        $query .= '      bestBidSize array( amount currency )';
        $query .= '      bestAskPrice array( amount currencyA currencyB )';
        $query .= '      bestAskSize array( amount currency )';
        $query .= '      lastPrice array( amount currencyA currencyB )';
        $query .= '      priceChange24h array( amount currencyA currencyB )';
        $query .= '      priceChange24hPct';
        $query .= '  } ';
        $query .= '} ';
        $request = array(
            'query' => $query,
            'variables' => array(
                'marketName' => $market['id'],
            ),
        );
        $response = $this->publicPostGql (array_merge($request, $params));
        return $this->parse_ticker($response['data']['getTicker'], $market);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $symbols = ($symbols === null) ? $this->symbols : $symbols;
        $marketIds = array();
        // console.warn($this->markets);
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $market = $this->markets[$symbol];
            if ($market['active']) {
                $marketIds[] = $market['id'];
            }
        }
        $query = '';
        $query .= 'query Tickers { ';
        $query .= '  listTickers { ';
        $query .= '      highPrice24h array( amount currencyA currencyB )';
        $query .= '      lowPrice24h array( amount currencyA currencyB )';
        $query .= '      bestBidPrice array( amount currencyA currencyB )';
        $query .= '      bestBidSize array( amount currency )';
        $query .= '      bestAskPrice array( amount currencyA currencyB )';
        $query .= '      bestAskSize array( amount currency )';
        $query .= '      lastPrice array( amount currencyA currencyB )';
        $query .= '      priceChange24h array( amount currencyA currencyB )';
        $query .= '      priceChange24hPct';
        $query .= '      $market {';
        $query .= '          name';
        $query .= '      }';
        $query .= '  } ';
        $query .= '}';
        $request = array(
            'query' => $query,
        );
        $response = $this->publicPostGql (array_merge($request, $params));
        // console.warn ('fetchTickers', $response['data']);
        $result = array();
        for ($i = 0; $i < count($response['data']['listTickers']); $i++) {
            $ticker = $response['data']['listTickers'][$i];
            $market = $this->markets_by_id[$ticker['market']['name']];
            $symbol = $market['symbol'];
            if ($this->in_array($symbol, $symbols)) {
                $result[$symbol] = $this->parse_ticker($ticker, $market);
            }
        }
        // console.warn ('fetchTickers', $result);
        return $result;
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        // $this->verbose = true;
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query listCandles($before => DateTime, $interval => CandleInterval, $marketName => MarketName' . '!' . ', $limit => Int) { ';
        $query .= '  listCandles (before => $before, interval => $interval, marketName => $marketName, $limit => $limit) { ';
        $query .= '      candles { ';
        $query .= '          aVolume array( amount currency ) ';
        $query .= '          openPrice array( amount currencyA currencyB )';
        $query .= '          closePrice array( amount currencyA currencyB )';
        $query .= '          highPrice array( amount currencyA currencyB )';
        $query .= '          lowPrice array( amount currencyA currencyB )';
        $query .= '          interval ';
        $query .= '          intervalStartingAt ';
        $query .= '      } ';
        $query .= '  } ';
        $query .= '}';
        $request = array(
            'query' => $query,
            'variables' => array(
                'marketName' => $market['id'],
                'interval' => $this->timeframes[$timeframe],
                'limit' => $limit,
            ),
        );
        if ($since !== null) {
            $request['variables']['before'] = $this->iso8601($since);
        }
        $response = $this->publicPostGql (array_merge($request, $params));
        // $this->print('response', $response);
        $ohlcvs = $response['data']['listCandles']['candles'];
        // console.warn ('ohlcvs', $ohlcvs);
        return $this->parse_ohlcvs($ohlcvs, $market, $timeframe, $since, $limit);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query ListTrades($marketName => MarketName' . '!' . ', $limit => Int, $before => DateTime) { ';
        $query .= '  listTrades(marketName => $marketName, $limit => $limit, before => $before) { ';
        $query .= '      $trades { ';
        $query .= '          accountSide ';
        $query .= '          amount array( amount currency) ';
        $query .= '          cursor ';
        $query .= '          direction ';
        $query .= '          executedAt ';
        $query .= '          id ';
        $query .= '          limitPrice array( amount currencyA currencyB ) ';
        $query .= '          makerFee array( amount currency ) ';
        $query .= '          makerGave array( amount currency ) ';
        $query .= '          makerOrderId ';
        $query .= '          makerReceived array( amount currency ) ';
        // $query .= '          $market array( amount currency ) ';
        $query .= '          takerFee array( amount currency ) ';
        $query .= '          takerGave array( amount currency ) ';
        $query .= '          takerOrderId ';
        $query .= '          takerReceived array( amount currency ) ';
        $query .= '      } ';
        $query .= '      next ';
        $query .= '  } ';
        $query .= '}';
        $request = array(
            'query' => $query,
            'variables' => array(
                'marketName' => $market['id'],
            ),
        );
        $response = $this->publicPostGql (array_merge($request, $params));
        $trades = $response['data']['listTrades']['trades'];
        // $this->print('fetchTrades.trades', $trades);
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query GetOrderBook($marketName => MarketName ' . '!' . ') { ';
        $query .= '  getOrderBook(marketName => $marketName) { ';
        $query .= '      lastUpdateId ';
        $query .= '      updateId ';
        $query .= '      asks { ';
        $query .= '          amount array( amount currency ) ';
        $query .= '          price array( amount currencyA currencyB ) ';
        $query .= '      } ';
        $query .= '      bids { ';
        $query .= '          amount array( amount currency ) ';
        $query .= '          price array( amount currencyA currencyB ) ';
        $query .= '      } ';
        $query .= '  } ';
        $query .= '}';
        $request = array(
            'query' => $query,
            'variables' => array(
                'marketName' => $market['id'],
            ),
        );
        if ($limit !== null) {
            $request['count'] = $limit; // 100
        }
        $response = $this->publicPostGql (array_merge($request, $params));
        $orderbook = $response['data']['getOrderBook'];
        return $this->parse_order_book($orderbook, null, 'bids', 'asks', 0, 'amount');
    }

    public function fetch_balance($params = array ()) {
        $query = '';
        $query .= 'query ListAccountBalances($payload => ListAccountBalancesParams' . '!' . ', $signature => Signature' . '!' . ') {';
        $query .= '  listAccountBalances(payload => $payload, $signature => $signature) { ';
        $query .= '      asset array( name symbol hash ) ';
        $query .= '      available array( amount currency ) ';
        $query .= '      depositAddress ';
        $query .= '      inOrders array( amount currency ) ';
        $query .= '      pending array( amount currency ) ';
        $query .= '      personal array( amount currency ) ';
        $query .= '  }';
        $query .= '}';
        // $signature = 'TODO SIGN IT';
        $listAccountBalancesParams = array(
            'ignoreLowBalance' => false,
        );
        $signedPayload = $this->sign_payload_mpc(2, 'list_account_balances', $listAccountBalancesParams);
        $signature = $signedPayload['signature'];
        $request = array(
            'query' => $query,
            'variables' => array(
                'payload' => $signedPayload['payload'],
                'signature' => array(
                    'publicKey' => $signature['publicKey'],
                    'signedDigest' => $signature['signedDigest'],
                ),
            ),
        );
        $response = $this->privatePostGql (array_merge($request, $params));
        // $this->print('response', $response);
        $listData = $response['data']['listAccountBalances'];
        // console.warn ('response', $response['data']['listAccountBalances']);
        $result = array(
            'info' => $listData,
            'free' => array(),
            'used' => array(),
            'total' => array(),
        );
        // console.warn ($listData);
        for ($i = 0; $i < count($listData); $i++) {
            $listItem = $listData[$i];
            $listSymbol = $listItem['asset']['symbol'];
            $code = $this->safe_currency_code($listSymbol);
            // console.warn ($listSymbol, $code);
            $free = $listData[$i]['available']['amount'];
            $used = $this->sum($listData[$i]['inOrders']['amount'], $listData[$i]['pending']['amount']);
            $total = $this->sum($free, $used);
            $result['free'][$code] = $free;
            $result['used'][$code] = $used;
            $result['total'][$code] = $total;
            $result[$code] = array(
                'free' => $free,
                'used' => $used,
                'total' => $total,
            );
        }
        return $result;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query ListAccountTrades($payload => ListAccountTradesParams' . '!, $signature => Signature' . '!' . ') { ';
        $query .= '  listAccountTrades(payload => $payload, signature => $signature) { ';
        $query .= '      $trades { ';
        $query .= '          accountSide ';
        $query .= '          amount array( amount currency ) ';
        $query .= '          cursor ';
        $query .= '          direction ';
        $query .= '          executedAt ';
        $query .= '          id ';
        $query .= '          limitPrice array( amount currencyA currencyB ) ';
        $query .= '          makerFee array( amount currency ) ';
        $query .= '          makerGave array( amount currency ) ';
        $query .= '          makerOrderId ';
        $query .= '          makerReceived array( amount currency ) ';
        // $query .= '          $market array( ) ';
        $query .= '          takerFee array( amount currency ) ';
        $query .= '          takerGave array( amount currency ) ';
        $query .= '          takerOrderId ';
        $query .= '          takerReceived array( amount currency ) ';
        $query .= '          usdARate array( amount currencyA currencyB ) ';
        $query .= '          usdBRate array( amount currencyA currencyB ) ';
        $query .= '      } ';
        $query .= '      next ';
        $query .= '  } ';
        $query .= '}';
        $listAccountTradesParams = array(
            'before' => null,
            'limit' => null,
            'marketName' => $market['id'],
            'rangeStart' => null,
            'rangeStop' => null,
        );
        if ($since !== null) {
            $listAccountTradesParams['rangeStart'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $listAccountTradesParams['limit'] = $limit;
        }
        $signedPayload = $this->sign_payload_mpc(30, 'list_account_trades', $listAccountTradesParams);
        $request = array(
            'query' => $query,
            'variables' => array(
                'payload' => $signedPayload->payload,
                'signature' => array(
                    'publicKey' => $signedPayload->signature.publicKey,
                    'signedDigest' => $signedPayload->signature.signedDigest,
                ),
            ),
        );
        $response = $this->privatePostGql (array_merge($request, $params));
        // $this->print('response', $response);
        $trades = $response['data']['listAccountTrades']['trades'];
        return $this->parse_trades($trades, $market, $since, $limit);
        // structure
        // {
        //     'info' =>         array( ... ),                    // the original decoded JSON as is
        //     'id' =>           '12345-67890:09876/54321',  // string trade id
        //     'timestamp' =>    1502962946216,              // Unix timestamp in milliseconds
        //     'datetime' =>     '2017-08-17 12:42:48.000',  // ISO8601 datetime with milliseconds
        //     'symbol' =>       'ETH/BTC',                  // $symbol
        //     'order' =>        '12345-67890:09876/54321',  // string order id or null/None/null
        //     'type' =>         'limit',                    // order type, 'market', 'limit' or null/None/null
        //     'side' =>         'buy',                      // direction of the trade, 'buy' or 'sell'
        //     'takerOrMaker' => 'taker',                    // string, 'taker' or 'maker'
        //     'price' =>        0.06917684,                 // float price in quote currency
        //     'amount' =>       1.5,                        // amount of base currency
        //     'cost' =>         0.10376526,                 // total cost (including fees), `price * amount`
        //     'fee' =>          array(                           // provided by exchange or calculated by ccxt
        //         'cost' =>  0.0015,                        // float
        //         'currency' => 'ETH',                      // usually base currency for buys, quote currency for sells
        //         'rate' => 0.002,                          // the fee rate (if available)
        //     ),
        // }
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query GetAccountOrder($payload => GetAccountOrderParams' . '!, $signature => Signature' . '!' . ') { ';
        $query .= '  getAccountOrder(payload => $payload, signature => $signature) {';
        $query .= '      id';
        $query .= '      placedAt';
        $query .= '      status';
        $query .= '      type';
        $query .= '      buyOrSell';
        $query .= '      amount array( amount )';
        $query .= '      amountExecuted array( amount )';
        $query .= '      amountRemaining array( amount )';
        $query .= '      limitPrice array( amount )';
        $query .= '      stopPrice array( amount )';
        $query .= '      trades {';
        $query .= '          accountSide ';
        $query .= '          amount array( amount currency ) ';
        $query .= '          cursor ';
        $query .= '          direction ';
        $query .= '          executedAt ';
        $query .= '          $id ';
        $query .= '          limitPrice array( amount currencyA currencyB ) ';
        $query .= '          makerFee array( amount currency ) ';
        $query .= '          makerGave array( amount currency ) ';
        $query .= '          makerOrderId ';
        $query .= '          makerReceived array( amount currency ) ';
        $query .= '          takerFee array( amount currency ) ';
        $query .= '          takerGave array( amount currency ) ';
        $query .= '          takerOrderId ';
        $query .= '          takerReceived array( amount currency ) ';
        $query .= '          usdARate array( amount currencyA currencyB ) ';
        $query .= '          usdBRate array( amount currencyA currencyB ) ';
        $query .= '      }';
        $query .= '  }';
        $query .= '}';
        $getAccountOrderParams = array(
            'orderId' => $id,
        );
        $signedPayload = $this->sign_payload_mpc(8, 'get_account_order', $getAccountOrderParams);
        $request = array(
            'query' => $query,
            'variables' => array(
                'payload' => $signedPayload->payload,
                'signature' => array(
                    'publicKey' => $signedPayload->signature.publicKey,
                    'signedDigest' => $signedPayload->signature.signedDigest,
                ),
            ),
        );
        $response = $this->privatePostGql (array_merge($request, $params));
        // console.warn ('response', $response);
        return $this->parse_order($response['data']['getAccountOrder'], $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_by_status(['OPEN'], $symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_by_status(['FILLED'], $symbol, $since, $limit, $params);
    }

    public function fetch_all_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_by_status(['CANCELLED', 'FILLED', 'OPEN', 'PENDING'], $symbol, $since, $limit, $params);
    }

    public function fetch_orders_by_status($orderStatus, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $query = '';
        $query .= 'query ListAccountOrders($payload => ListAccountOrdersParams' . '!, $signature => Signature' . '!' . ') { ';
        $query .= '  listAccountOrders(payload => $payload, signature => $signature) {';
        $query .= '      next';
        $query .= '      $orders {';
        $query .= '          id';
        $query .= '          placedAt';
        $query .= '          status';
        $query .= '          type';
        $query .= '          buyOrSell';
        $query .= '          amount array( amount )';
        $query .= '          amountExecuted array( amount )';
        $query .= '          amountRemaining array( amount )';
        $query .= '          limitPrice array( amount )';
        $query .= '          stopPrice array( amount )';
        $query .= '          trades {';
        $query .= '              accountSide ';
        $query .= '              amount array( amount currency ) ';
        $query .= '              cursor ';
        $query .= '              direction ';
        $query .= '              executedAt ';
        $query .= '              id ';
        $query .= '              limitPrice array( amount currencyA currencyB ) ';
        $query .= '              makerFee array( amount currency ) ';
        $query .= '              makerGave array( amount currency ) ';
        $query .= '              makerOrderId ';
        $query .= '              makerReceived array( amount currency ) ';
        $query .= '              takerFee array( amount currency ) ';
        $query .= '              takerGave array( amount currency ) ';
        $query .= '              takerOrderId ';
        $query .= '              takerReceived array( amount currency ) ';
        $query .= '              usdARate array( amount currencyA currencyB ) ';
        $query .= '              usdBRate array( amount currencyA currencyB ) ';
        $query .= '          }';
        $query .= '      }';
        $query .= '  }';
        $query .= '}';
        $listAccountOrdersParams = array(
            'before' => null,
            'buyOrSell' => null,
            'limit' => null,
            'marketName' => $market['id'],
            'rangeStart' => null,
            'rangeStop' => null,
            'status' => $orderStatus,
            'type' => null,
        );
        if ($since !== null) {
            $listAccountOrdersParams['rangeStart'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $listAccountOrdersParams['limit'] = $limit;
        }
        $signedPayload = $this->sign_payload_mpc(0, 'list_account_orders', $listAccountOrdersParams);
        $request = array(
            'query' => $query,
            'variables' => array(
                'payload' => $signedPayload->payload,
                'signature' => array(
                    'publicKey' => $signedPayload->signature.publicKey,
                    'signedDigest' => $signedPayload->signature.signedDigest,
                ),
            ),
        );
        $response = $this->privatePostGql (array_merge($request, $params));
        $orders = $this->parse_orders($response['data']['listAccountOrders']['orders'], $market, $since, $limit, $params);
        return $orders;
    }

    public function sign_payload_mpc($kindId, $kindName, $params) {
        // kind => https://gitlab.com/nash-io-public/nash-protocol/-/blob/master/src/payload/signingPayloadID.ts
        $payload = $params;
        $payload['timestamp'] = $this->milliseconds();
        $payloadAndKind = array(
            'kind' => $kindId,
            'payload' => $payload,
        );
        $json = base64_decode($this->secret);
        $apiKey = $this->unjson($json);
        $signedPayload = $this->pre_sign_payload($apiKey, $payloadAndKind, $kindName);
        return array(
            'payload' => $signedPayload['payload'],
            'signature' => array(
                'publicKey' => $apiKey['payload_public_key'],
                'signedDigest' => $signedPayload['signature'],
            ),
            // 'blockchain_data' => $signedPayload->blockchainMovement,
            // 'blockchain_raw' => $signedPayload->blockchainRaw,
            // 'signedPayload' => $signedPayload->payload,
        );
    }

    public function pre_sign_payload($apiKey, $payloadAndKind, $kindName) {
        $message = $kindName;
        $signature = $this->ecdsa($message, $apiKey['payload_signing_key'], 'secp256k1', 'sha256', true);
        $signature = $this->signature_to_der($signature['r'], $signature['s'], 'hex');
        $this->print('nashio', 'signature', $signature);
        return array(
            'payload' => $payloadAndKind['payload'],
            'signature' => $signature,
        );
    }

    public function parse_bid_ask($bidask, $priceKey = 0, $amountKey = 1) {
        // if ($this->verbose) {
        //     $this->print('bidask', $bidask, $priceKey, $amountKey, market);
        // }
        $price = floatval ($bidask['price'][$amountKey]);
        $amount = floatval ($bidask['amount'][$amountKey]);
        return array( $price, $amount );
    }

    public function parse_ticker($ticker, $market = null) {
        // console.warn ('parseTicker', $ticker);
        $timestamp = $this->milliseconds();
        $symbol = null;
        if ($market) {
            $symbol = $market['symbol'];
        }
        $open = null;
        $tickerHighPrice24h = $this->safe_value($ticker, 'highPrice24h');
        $tickerLowPrice24h = $this->safe_value($ticker, 'lowPrice24h');
        $tickerLastPrice = $this->safe_value($ticker, 'lastPrice');
        $tickerPriceChange24h = $this->safe_value($ticker, 'priceChange24h');
        $tickerBestAskPrice = $this->safe_value($ticker, 'bestAskPrice');
        $tickerBestAskSize = $this->safe_value($ticker, 'bestAskSize');
        $tickerBestBidPrice = $this->safe_value($ticker, 'bestBidPrice');
        $tickerBestBidSize = $this->safe_value($ticker, 'bestBidSize');
        $high = $this->safe_float($tickerHighPrice24h, 'amount');
        $low = $this->safe_float($tickerLowPrice24h, 'amount');
        $last = $this->safe_float($tickerLastPrice, 'amount');
        // console.warn ('last', $symbol, $last);
        $change = $this->safe_float($tickerPriceChange24h, 'amount');
        $ask = $this->safe_float($tickerBestAskPrice, 'amount');
        $askVolume = $this->safe_float($tickerBestAskSize, 'amount');
        $bid = $this->safe_float($tickerBestBidPrice, 'amount');
        $bidVolume = $this->safe_float($tickerBestBidSize, 'amount');
        $percentage = $ticker['priceChange24hPct'];
        $average = null;
        $close = $last;
        // console.warn ('parseTicker', $last, $close);
        return array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'open' => $open,
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'close' => $close,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => $average,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function parse_ohlcv($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        $intervalStartingAt = $this->safe_string($ohlcv, 'intervalStartingAt');
        $ohlvOpenPrice = $this->safe_value($ohlcv, 'openPrice');
        $ohlvHighPrice = $this->safe_value($ohlcv, 'highPrice');
        $ohlvLowPrice = $this->safe_value($ohlcv, 'lowPrice');
        $ohlvClosePrice = $this->safe_value($ohlcv, 'closePrice');
        $ohlvVolume = $this->safe_value($ohlcv, 'aVolume');
        $data = array(
            $this->parse8601($intervalStartingAt),
            $this->safe_float($ohlvOpenPrice, 'amount'),
            $this->safe_float($ohlvHighPrice, 'amount'),
            $this->safe_float($ohlvLowPrice, 'amount'),
            $this->safe_float($ohlvClosePrice, 'amount'),
            $this->safe_float($ohlvVolume, 'amount'),
        );
        return $data;
    }

    public function parse_trade($trade, $market = null) {
        $tradeExecutedAt = $this->safe_string($trade, 'executedAt');
        $timestamp = $this->parse8601($tradeExecutedAt);
        $id = $this->safe_string($trade, 'id');
        $order = null;
        $type = null;
        $side = $this->safe_string($trade, 'direction') === 'SELL' ? 'sell' : 'buy';
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $tradeLimitPrice = $this->safe_value($trade, 'limitPrice');
        $price = $this->safe_float($tradeLimitPrice, 'amount');
        $tradeAmount = $this->safe_value($trade, 'amount');
        $amount = $this->safe_float($tradeAmount, 'amount');
        $takerOrMaker = null;
        $tradeAccountSide = $this->safe_string($trade, 'accountSide');
        if ($tradeAccountSide === 'MAKER') {
            $takerOrMaker = 'maker';
        } else if ($tradeAccountSide === 'TAKER') {
            $takerOrMaker = 'taker';
        }
        $tradeMakerGave = $this->safe_value($trade, 'makerGave');
        $tradeTakerReceived = $this->safe_value($trade, 'takerReceived');
        $tradeTakerFee = $this->safe_value($trade, 'takerFee');
        $fee = array(
            'cost' => $this->safe_float($tradeTakerFee, 'amount'),
            'currency' => $this->safe_string($tradeTakerFee, 'currency'),
            'rate' => $this->safe_float($tradeMakerGave, 'amount') / $this->safe_float($tradeTakerReceived, 'amount'),
        );
        return array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $order,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $price * $amount,
            'fee' => $fee,
        );
    }

    public function parse_order($order, $market = null) {
        // console.warn ('parseOrder', $order);
        $id = $this->safe_string($order, 'id');
        $placedAt = $this->safe_string($order, 'placedAt');
        $timestamp = $this->parse8601($placedAt);
        $status = $this->safe_string($order, 'status');
        if ($status === 'OPEN') {
            $status = 'open';
        } else if ($status === 'FILLED') {
            $status = 'closed';
        } else if ($status === 'CANCELLED') {
            $status = 'canceled';
        }
        $type = $this->safe_string($order, 'type');
        if ($type === 'MARKET') {
            $type = 'market';
        } else if ($type === 'LIMIT') {
            $type = 'limit';
        }
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $side = $this->safe_string($order, 'buyOrSell');
        if ($side === 'BUY') {
            $side = 'buy';
        } else if ($side === 'SELL') {
            $side = 'sell';
        }
        $orderAmount = $this->safe_value($order, 'amount');
        $amount = $this->safe_float($orderAmount, 'amount');
        $orderAmountExecuted = $this->safe_value($order, 'amountExecuted');
        $filled = $this->safe_float($orderAmountExecuted, 'amount');
        $orderAmountRemaining = $this->safe_value($order, 'amountRemaining');
        $remaining = $this->safe_float($orderAmountRemaining, 'amount');
        $price = null;
        $limitPrice = $this->safe_value($order, 'limitPrice');
        $stopPrice = $this->safe_value($order, 'stopPrice');
        if ($limitPrice) {
            $price = $this->safe_float($limitPrice, 'amount');
        } else if ($stopPrice) {
            $price = $this->safe_float($stopPrice, 'amount');
        }
        $orderTrades = $this->safe_value($order, 'trades');
        $trades = $this->parse_trades($orderTrades, $market);
        // console.warn ('trades', $trades);
        return array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'cost' => $filled * $price,
            'trades' => $trades,
            'info' => $order,
        );
        // ### structure
        // {
        //     'id' =>                '12345-67890:09876/54321', // string
        //     'datetime' =>          '2017-08-17 12:42:48.000', // ISO8601 datetime of 'timestamp' with milliseconds
        //     'timestamp' =>          1502962946216, // $order placing/opening Unix $timestamp in milliseconds
        //     'lastTradeTimestamp' => 1502962956216, // Unix $timestamp of the most recent trade on this $order
        //     'status' =>     'open',         // 'open', 'closed', 'canceled'
        //     'symbol' =>     'ETH/BTC',      // $symbol
        //     'type' =>       'limit',        // 'market', 'limit'
        //     'side' =>       'buy',          // 'buy', 'sell'
        //     'price' =>       0.06917684,    // float $price in quote currency
        //     'amount' =>      1.5,           // ordered $amount of base currency
        //     'filled' =>      1.1,           // $filled $amount of base currency
        //     'remaining' =>   0.4,           // $remaining $amount to fill
        //     'cost' =>        0.076094524,   // 'filled' * 'price' (filling $price used where available)
        //     'trades' =>    array( ... ),         // a list of $order trades/executions
        //     'fee' => array(                      // fee info, if available
        //         'currency' => 'BTC',        // which currency the fee is (usually quote)
        //         'cost' => 0.0009,           // the fee $amount in that currency
        //         'rate' => 0.002,            // the fee rate (if available)
        //     ),
        //     'info' => array( ... ),              // the original unparsed $order structure as is
        // }
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        // if ($this->verbose) {
        //     $this->print('sign', $path, $api, $method, $params, $headers, $body);
        // }
        $url = $this->urls['api'][$api];
        $headers = array(
            'Content-Type' => 'application/json',
        );
        $body = $this->json($params);
        // if ($this->verbose) {
        //     $this->print('sign', array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers ));
        // }
        if ($api === 'private') {
            // console.warn ('private');
            $this->check_required_credentials();
            $headers['Authorization'] = 'Token ' . $this->apiKey;
        }
        // console.warn ($url, $method, $body, $headers);
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        // console.warn ('handleErrors', $code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody);
        if ($code === 520) {
            throw new ExchangeNotAvailable($this->id . ' ' . (string) $code . ' ' . $reason);
        }
        $errors = $this->safe_value($response, 'errors');
        if ($errors) {
            for ($i = 0; $i < count($errors); $i++) {
                $error = $errors[$i];
                $code = $this->safe_float($error, 'code');
                $message = $this->safe_string($error, 'message');
                if ($code === 10) {
                    throw new AuthenticationError($message);
                } else {
                    throw new ExchangeError($message);
                }
            }
        }
    }
}
